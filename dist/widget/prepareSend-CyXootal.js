var zS = Object.defineProperty;
var UE = (t) => {
  throw TypeError(t);
};
var jS = (t, e, n) => e in t ? zS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var O = (t, e, n) => jS(t, typeof e != "symbol" ? e + "" : e, n), c0 = (t, e, n) => e.has(t) || UE("Cannot " + n);
var m = (t, e, n) => (c0(t, e, "read from private field"), n ? n.call(t) : e.get(t)), B = (t, e, n) => e.has(t) ? UE("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), x = (t, e, n, r) => (c0(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n), G = (t, e, n) => (c0(t, e, "access private method"), n);
var ra = (t, e, n, r) => ({
  set _(s) {
    x(t, e, s, n);
  },
  get _() {
    return m(t, e, r);
  }
});
import * as Ot from "react";
import { createContext as VS, useState as n6, useContext as qS, useMemo as Eo, useEffect as KS } from "react";
import { jsx as r6 } from "react/jsx-runtime";
import { parseSignature as WS, encodeFunctionData as Kt, custom as Ou, hexToBigInt as sa, createPublicClient as hn, fallback as NE, http as Ge, createWalletClient as Kd, zeroAddress as Ne, isAddressEqual as QS, getAddress as uo, erc20Abi as vl, maxUint256 as Lh, parseAbi as s6, keccak256 as ou, encodeAbiParameters as RE, concat as Wd, pad as xo, toHex as Za, encodeDeployData as JS, decodeAbiParameters as XS, decodeFunctionData as sy, parseGwei as ZS, hexToBytes as b1, bytesToHex as YS, formatUnits as sc, parseUnits as ay } from "viem";
import { SequenceAPIClient as e7 } from "@0xsequence/trails-api";
import { Config as t7, Payload as n7 } from "@0xsequence/wallet-primitives";
import { Relayer as iy } from "@0xsequence/wallet-core";
import { useReadContracts as r7 } from "wagmi";
const s7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get claimAppFees() {
    return bK;
  },
  get execute() {
    return dK;
  },
  get getAppFees() {
    return yK;
  },
  get getPrice() {
    return hK;
  },
  get getQuote() {
    return pK;
  },
  get getSolverCapacity() {
    return mK;
  }
}, Symbol.toStringTag, { value: "Module" })), a7 = {
  indexerGatewayUrl: "https://indexer.sequence.app",
  metadataUrl: "https://metadata.sequence.app",
  apiUrl: "https://api.sequence.app",
  indexerUrl: "https://indexer.sequence.app",
  imageProxyUrl: "https://imgproxy.sequence.xyz/",
  builderUrl: "https://api.sequence.build"
}, a6 = VS(null), Tne = (t) => {
  const [e, n] = n6(t.config.jwt), r = {
    ...t.config,
    env: {
      ...a7,
      ...t.config.env
    },
    jwt: e,
    setJWT: n
  };
  return r6(a6.Provider, { value: r, children: t.children });
}, i6 = () => {
  const t = qS(a6);
  if (!t)
    throw new Error("useConfig must be used within a SequenceHooksProvider");
  return t;
};
var zl = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Ao = typeof window > "u" || "Deno" in globalThis;
function on() {
}
function i7(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function oy(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function o6(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function Va(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function nr(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function DE(t, e) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: s,
    predicate: a,
    queryKey: i,
    stale: o
  } = t;
  if (i) {
    if (r) {
      if (e.queryHash !== g1(i, e.options))
        return !1;
    } else if (!ad(e.queryKey, i))
      return !1;
  }
  if (n !== "all") {
    const c = e.isActive();
    if (n === "active" && !c || n === "inactive" && c)
      return !1;
  }
  return !(typeof o == "boolean" && e.isStale() !== o || s && s !== e.state.fetchStatus || a && !a(e));
}
function FE(t, e) {
  const { exact: n, status: r, predicate: s, mutationKey: a } = t;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (n) {
      if (sd(e.options.mutationKey) !== sd(a))
        return !1;
    } else if (!ad(e.options.mutationKey, a))
      return !1;
  }
  return !(r && e.state.status !== r || s && !s(e));
}
function g1(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || sd)(t);
}
function sd(t) {
  return JSON.stringify(
    t,
    (e, n) => ly(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n
  );
}
function ad(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((n) => ad(t[n], e[n])) : !1;
}
function Dp(t, e) {
  if (t === e)
    return t;
  const n = ME(t) && ME(e);
  if (n || ly(t) && ly(e)) {
    const r = n ? t : Object.keys(t), s = r.length, a = n ? e : Object.keys(e), i = a.length, o = n ? [] : {}, c = new Set(r);
    let u = 0;
    for (let l = 0; l < i; l++) {
      const d = n ? l : a[l];
      (!n && c.has(d) || n) && t[d] === void 0 && e[d] === void 0 ? (o[d] = void 0, u++) : (o[d] = Dp(t[d], e[d]), o[d] === t[d] && t[d] !== void 0 && u++);
    }
    return s === i && u === s ? t : o;
  }
  return e;
}
function cy(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const n in t)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function ME(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function ly(t) {
  if (!LE(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const n = e.prototype;
  return !(!LE(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function LE(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function o7(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function uy(t, e, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(t, e);
  if (n.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Dp(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${n.queryHash}]: ${r}`
        ), r;
      }
    return Dp(t, e);
  }
  return e;
}
function c7(t, e, n = 0) {
  const r = [...t, e];
  return n && r.length > n ? r.slice(1) : r;
}
function l7(t, e, n = 0) {
  const r = [e, ...t];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var Fp = Symbol();
function c6(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === Fp && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === Fp ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function u7(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var Ri, ya, Cc, jA, d7 = (jA = class extends zl {
  constructor() {
    super();
    B(this, Ri);
    B(this, ya);
    B(this, Cc);
    x(this, Cc, (e) => {
      if (!Ao && window.addEventListener) {
        const n = () => e();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    m(this, ya) || this.setEventListener(m(this, Cc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = m(this, ya)) == null || e.call(this), x(this, ya, void 0));
  }
  setEventListener(e) {
    var n;
    x(this, Cc, e), (n = m(this, ya)) == null || n.call(this), x(this, ya, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    m(this, Ri) !== e && (x(this, Ri, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((n) => {
      n(e);
    });
  }
  isFocused() {
    var e;
    return typeof m(this, Ri) == "boolean" ? m(this, Ri) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, Ri = new WeakMap(), ya = new WeakMap(), Cc = new WeakMap(), jA), w1 = new d7(), Tc, ba, Sc, VA, f7 = (VA = class extends zl {
  constructor() {
    super();
    B(this, Tc, !0);
    B(this, ba);
    B(this, Sc);
    x(this, Sc, (e) => {
      if (!Ao && window.addEventListener) {
        const n = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    m(this, ba) || this.setEventListener(m(this, Sc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = m(this, ba)) == null || e.call(this), x(this, ba, void 0));
  }
  setEventListener(e) {
    var n;
    x(this, Sc, e), (n = m(this, ba)) == null || n.call(this), x(this, ba, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    m(this, Tc) !== e && (x(this, Tc, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return m(this, Tc);
  }
}, Tc = new WeakMap(), ba = new WeakMap(), Sc = new WeakMap(), VA), Mp = new f7();
function dy() {
  let t, e;
  const n = new Promise((s, a) => {
    t = s, e = a;
  });
  n.status = "pending", n.catch(() => {
  });
  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject;
  }
  return n.resolve = (s) => {
    r({
      status: "fulfilled",
      value: s
    }), t(s);
  }, n.reject = (s) => {
    r({
      status: "rejected",
      reason: s
    }), e(s);
  }, n;
}
function p7(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function l6(t) {
  return (t ?? "online") === "online" ? Mp.isOnline() : !0;
}
var u6 = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function l0(t) {
  return t instanceof u6;
}
function d6(t) {
  let e = !1, n = 0, r = !1, s;
  const a = dy(), i = (y) => {
    var g;
    r || (p(new u6(y)), (g = t.abort) == null || g.call(t));
  }, o = () => {
    e = !0;
  }, c = () => {
    e = !1;
  }, u = () => w1.isFocused() && (t.networkMode === "always" || Mp.isOnline()) && t.canRun(), l = () => l6(t.networkMode) && t.canRun(), d = (y) => {
    var g;
    r || (r = !0, (g = t.onSuccess) == null || g.call(t, y), s == null || s(), a.resolve(y));
  }, p = (y) => {
    var g;
    r || (r = !0, (g = t.onError) == null || g.call(t, y), s == null || s(), a.reject(y));
  }, f = () => new Promise((y) => {
    var g;
    s = (w) => {
      (r || u()) && y(w);
    }, (g = t.onPause) == null || g.call(t);
  }).then(() => {
    var y;
    s = void 0, r || (y = t.onContinue) == null || y.call(t);
  }), b = () => {
    if (r)
      return;
    let y;
    const g = n === 0 ? t.initialPromise : void 0;
    try {
      y = g ?? t.fn();
    } catch (w) {
      y = Promise.reject(w);
    }
    Promise.resolve(y).then(d).catch((w) => {
      var N;
      if (r)
        return;
      const k = t.retry ?? (Ao ? 0 : 3), E = t.retryDelay ?? p7, T = typeof E == "function" ? E(n, w) : E, A = k === !0 || typeof k == "number" && n < k || typeof k == "function" && k(n, w);
      if (e || !A) {
        p(w);
        return;
      }
      n++, (N = t.onFail) == null || N.call(t, n, w), o7(T).then(() => u() ? void 0 : f()).then(() => {
        e ? p(w) : b();
      });
    });
  };
  return {
    promise: a,
    cancel: i,
    continue: () => (s == null || s(), a),
    cancelRetry: o,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? b() : f().then(b), a)
  };
}
var h7 = (t) => setTimeout(t, 0);
function m7() {
  let t = [], e = 0, n = (o) => {
    o();
  }, r = (o) => {
    o();
  }, s = h7;
  const a = (o) => {
    e ? t.push(o) : s(() => {
      n(o);
    });
  }, i = () => {
    const o = t;
    t = [], o.length && s(() => {
      r(() => {
        o.forEach((c) => {
          n(c);
        });
      });
    });
  };
  return {
    batch: (o) => {
      let c;
      e++;
      try {
        c = o();
      } finally {
        e--, e || i();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (o) => (...c) => {
      a(() => {
        o(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (o) => {
      n = o;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (o) => {
      r = o;
    },
    setScheduler: (o) => {
      s = o;
    }
  };
}
var lt = m7(), Di, qA, f6 = (qA = class {
  constructor() {
    B(this, Di);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), oy(this.gcTime) && x(this, Di, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (Ao ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    m(this, Di) && (clearTimeout(m(this, Di)), x(this, Di, void 0));
  }
}, Di = new WeakMap(), qA), Ic, Fi, Wn, Mi, Ht, Id, Li, yr, bs, KA, y7 = (KA = class extends f6 {
  constructor(e) {
    super();
    B(this, yr);
    B(this, Ic);
    B(this, Fi);
    B(this, Wn);
    B(this, Mi);
    B(this, Ht);
    B(this, Id);
    B(this, Li);
    x(this, Li, !1), x(this, Id, e.defaultOptions), this.setOptions(e.options), this.observers = [], x(this, Mi, e.client), x(this, Wn, m(this, Mi).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, x(this, Ic, b7(this.options)), this.state = e.state ?? m(this, Ic), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = m(this, Ht)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...m(this, Id), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && m(this, Wn).remove(this);
  }
  setData(e, n) {
    const r = uy(this.state.data, e, this.options);
    return G(this, yr, bs).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(e, n) {
    G(this, yr, bs).call(this, { type: "setState", state: e, setStateOptions: n });
  }
  cancel(e) {
    var r, s;
    const n = (r = m(this, Ht)) == null ? void 0 : r.promise;
    return (s = m(this, Ht)) == null || s.cancel(e), n ? n.then(on).catch(on) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(m(this, Ic));
  }
  isActive() {
    return this.observers.some(
      (e) => nr(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Fp || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Va(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !o6(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = m(this, Ht)) == null || n.continue();
  }
  onOnline() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = m(this, Ht)) == null || n.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), m(this, Wn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((n) => n !== e), this.observers.length || (m(this, Ht) && (m(this, Li) ? m(this, Ht).cancel({ revert: !0 }) : m(this, Ht).cancelRetry()), this.scheduleGc()), m(this, Wn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || G(this, yr, bs).call(this, { type: "invalidate" });
  }
  fetch(e, n) {
    var u, l, d;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (m(this, Ht))
        return m(this, Ht).continueRetry(), m(this, Ht).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const p = this.observers.find((f) => f.options.queryFn);
      p && this.setOptions(p.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), s = (p) => {
      Object.defineProperty(p, "signal", {
        enumerable: !0,
        get: () => (x(this, Li, !0), r.signal)
      });
    }, a = () => {
      const p = c6(this.options, n), b = (() => {
        const y = {
          client: m(this, Mi),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(y), y;
      })();
      return x(this, Li, !1), this.options.persister ? this.options.persister(
        p,
        b,
        this
      ) : p(b);
    }, o = (() => {
      const p = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        client: m(this, Mi),
        state: this.state,
        fetchFn: a
      };
      return s(p), p;
    })();
    (u = this.options.behavior) == null || u.onFetch(o, this), x(this, Fi, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((l = o.fetchOptions) == null ? void 0 : l.meta)) && G(this, yr, bs).call(this, { type: "fetch", meta: (d = o.fetchOptions) == null ? void 0 : d.meta });
    const c = (p) => {
      var f, b, y, g;
      l0(p) && p.silent || G(this, yr, bs).call(this, {
        type: "error",
        error: p
      }), l0(p) || ((b = (f = m(this, Wn).config).onError) == null || b.call(
        f,
        p,
        this
      ), (g = (y = m(this, Wn).config).onSettled) == null || g.call(
        y,
        this.state.data,
        p,
        this
      )), this.scheduleGc();
    };
    return x(this, Ht, d6({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: o.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (p) => {
        var f, b, y, g;
        if (p === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(p);
        } catch (w) {
          c(w);
          return;
        }
        (b = (f = m(this, Wn).config).onSuccess) == null || b.call(f, p, this), (g = (y = m(this, Wn).config).onSettled) == null || g.call(
          y,
          p,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: c,
      onFail: (p, f) => {
        G(this, yr, bs).call(this, { type: "failed", failureCount: p, error: f });
      },
      onPause: () => {
        G(this, yr, bs).call(this, { type: "pause" });
      },
      onContinue: () => {
        G(this, yr, bs).call(this, { type: "continue" });
      },
      retry: o.options.retry,
      retryDelay: o.options.retryDelay,
      networkMode: o.options.networkMode,
      canRun: () => !0
    })), m(this, Ht).start();
  }
}, Ic = new WeakMap(), Fi = new WeakMap(), Wn = new WeakMap(), Mi = new WeakMap(), Ht = new WeakMap(), Id = new WeakMap(), Li = new WeakMap(), yr = new WeakSet(), bs = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...p6(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return x(this, Fi, void 0), {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const s = e.error;
        return l0(s) && s.revert && m(this, Fi) ? { ...m(this, Fi), fetchStatus: "idle" } : {
          ...r,
          error: s,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = n(this.state), lt.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), m(this, Wn).notify({ query: this, type: "updated", action: e });
  });
}, KA);
function p6(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: l6(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function b7(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var zr, WA, g7 = (WA = class extends zl {
  constructor(e = {}) {
    super();
    B(this, zr);
    this.config = e, x(this, zr, /* @__PURE__ */ new Map());
  }
  build(e, n, r) {
    const s = n.queryKey, a = n.queryHash ?? g1(s, n);
    let i = this.get(a);
    return i || (i = new y7({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(n),
      state: r,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(i)), i;
  }
  add(e) {
    m(this, zr).has(e.queryHash) || (m(this, zr).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const n = m(this, zr).get(e.queryHash);
    n && (e.destroy(), n === e && m(this, zr).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    lt.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return m(this, zr).get(e);
  }
  getAll() {
    return [...m(this, zr).values()];
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => DE(n, r)
    );
  }
  findAll(e = {}) {
    const n = this.getAll();
    return Object.keys(e).length > 0 ? n.filter((r) => DE(e, r)) : n;
  }
  notify(e) {
    lt.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  onFocus() {
    lt.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    lt.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, zr = new WeakMap(), WA), jr, nn, Hi, Vr, pa, QA, w7 = (QA = class extends f6 {
  constructor(e) {
    super();
    B(this, Vr);
    B(this, jr);
    B(this, nn);
    B(this, Hi);
    this.mutationId = e.mutationId, x(this, nn, e.mutationCache), x(this, jr, []), this.state = e.state || E7(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    m(this, jr).includes(e) || (m(this, jr).push(e), this.clearGcTimeout(), m(this, nn).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    x(this, jr, m(this, jr).filter((n) => n !== e)), this.scheduleGc(), m(this, nn).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    m(this, jr).length || (this.state.status === "pending" ? this.scheduleGc() : m(this, nn).remove(this));
  }
  continue() {
    var e;
    return ((e = m(this, Hi)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var a, i, o, c, u, l, d, p, f, b, y, g, w, k, E, T, A, N, D, P;
    const n = () => {
      G(this, Vr, pa).call(this, { type: "continue" });
    };
    x(this, Hi, d6({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (C, S) => {
        G(this, Vr, pa).call(this, { type: "failed", failureCount: C, error: S });
      },
      onPause: () => {
        G(this, Vr, pa).call(this, { type: "pause" });
      },
      onContinue: n,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => m(this, nn).canRun(this)
    }));
    const r = this.state.status === "pending", s = !m(this, Hi).canStart();
    try {
      if (r)
        n();
      else {
        G(this, Vr, pa).call(this, { type: "pending", variables: e, isPaused: s }), await ((i = (a = m(this, nn).config).onMutate) == null ? void 0 : i.call(
          a,
          e,
          this
        ));
        const S = await ((c = (o = this.options).onMutate) == null ? void 0 : c.call(o, e));
        S !== this.state.context && G(this, Vr, pa).call(this, {
          type: "pending",
          context: S,
          variables: e,
          isPaused: s
        });
      }
      const C = await m(this, Hi).start();
      return await ((l = (u = m(this, nn).config).onSuccess) == null ? void 0 : l.call(
        u,
        C,
        e,
        this.state.context,
        this
      )), await ((p = (d = this.options).onSuccess) == null ? void 0 : p.call(d, C, e, this.state.context)), await ((b = (f = m(this, nn).config).onSettled) == null ? void 0 : b.call(
        f,
        C,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((g = (y = this.options).onSettled) == null ? void 0 : g.call(y, C, null, e, this.state.context)), G(this, Vr, pa).call(this, { type: "success", data: C }), C;
    } catch (C) {
      try {
        throw await ((k = (w = m(this, nn).config).onError) == null ? void 0 : k.call(
          w,
          C,
          e,
          this.state.context,
          this
        )), await ((T = (E = this.options).onError) == null ? void 0 : T.call(
          E,
          C,
          e,
          this.state.context
        )), await ((N = (A = m(this, nn).config).onSettled) == null ? void 0 : N.call(
          A,
          void 0,
          C,
          this.state.variables,
          this.state.context,
          this
        )), await ((P = (D = this.options).onSettled) == null ? void 0 : P.call(
          D,
          void 0,
          C,
          e,
          this.state.context
        )), C;
      } finally {
        G(this, Vr, pa).call(this, { type: "error", error: C });
      }
    } finally {
      m(this, nn).runNext(this);
    }
  }
}, jr = new WeakMap(), nn = new WeakMap(), Hi = new WeakMap(), Vr = new WeakSet(), pa = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: e.error,
          failureCount: r.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), lt.batch(() => {
    m(this, jr).forEach((r) => {
      r.onMutationUpdate(e);
    }), m(this, nn).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, QA);
function E7() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var vs, br, Od, JA, x7 = (JA = class extends zl {
  constructor(e = {}) {
    super();
    B(this, vs);
    B(this, br);
    B(this, Od);
    this.config = e, x(this, vs, /* @__PURE__ */ new Set()), x(this, br, /* @__PURE__ */ new Map()), x(this, Od, 0);
  }
  build(e, n, r) {
    const s = new w7({
      mutationCache: this,
      mutationId: ++ra(this, Od)._,
      options: e.defaultMutationOptions(n),
      state: r
    });
    return this.add(s), s;
  }
  add(e) {
    m(this, vs).add(e);
    const n = Af(e);
    if (typeof n == "string") {
      const r = m(this, br).get(n);
      r ? r.push(e) : m(this, br).set(n, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (m(this, vs).delete(e)) {
      const n = Af(e);
      if (typeof n == "string") {
        const r = m(this, br).get(n);
        if (r)
          if (r.length > 1) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          } else r[0] === e && m(this, br).delete(n);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const n = Af(e);
    if (typeof n == "string") {
      const r = m(this, br).get(n), s = r == null ? void 0 : r.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var r;
    const n = Af(e);
    if (typeof n == "string") {
      const s = (r = m(this, br).get(n)) == null ? void 0 : r.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    lt.batch(() => {
      m(this, vs).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), m(this, vs).clear(), m(this, br).clear();
    });
  }
  getAll() {
    return Array.from(m(this, vs));
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => FE(n, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((n) => FE(e, n));
  }
  notify(e) {
    lt.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((n) => n.state.isPaused);
    return lt.batch(
      () => Promise.all(
        e.map((n) => n.continue().catch(on))
      )
    );
  }
}, vs = new WeakMap(), br = new WeakMap(), Od = new WeakMap(), JA);
function Af(t) {
  var e;
  return (e = t.options.scope) == null ? void 0 : e.id;
}
function HE(t) {
  return {
    onFetch: (e, n) => {
      var l, d, p, f, b;
      const r = e.options, s = (p = (d = (l = e.fetchOptions) == null ? void 0 : l.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : p.direction, a = ((f = e.state.data) == null ? void 0 : f.pages) || [], i = ((b = e.state.data) == null ? void 0 : b.pageParams) || [];
      let o = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let y = !1;
        const g = (E) => {
          Object.defineProperty(E, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? y = !0 : e.signal.addEventListener("abort", () => {
              y = !0;
            }), e.signal)
          });
        }, w = c6(e.options, e.fetchOptions), k = async (E, T, A) => {
          if (y)
            return Promise.reject();
          if (T == null && E.pages.length)
            return Promise.resolve(E);
          const D = (() => {
            const R = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: T,
              direction: A ? "backward" : "forward",
              meta: e.options.meta
            };
            return g(R), R;
          })(), P = await w(D), { maxPages: C } = e.options, S = A ? l7 : c7;
          return {
            pages: S(E.pages, P, C),
            pageParams: S(E.pageParams, T, C)
          };
        };
        if (s && a.length) {
          const E = s === "backward", T = E ? A7 : _E, A = {
            pages: a,
            pageParams: i
          }, N = T(r, A);
          o = await k(A, N, E);
        } else {
          const E = t ?? a.length;
          do {
            const T = c === 0 ? i[0] ?? r.initialPageParam : _E(r, o);
            if (c > 0 && T == null)
              break;
            o = await k(o, T), c++;
          } while (c < E);
        }
        return o;
      };
      e.options.persister ? e.fetchFn = () => {
        var y, g;
        return (g = (y = e.options).persister) == null ? void 0 : g.call(
          y,
          u,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          n
        );
      } : e.fetchFn = u;
    }
  };
}
function _E(t, { pages: e, pageParams: n }) {
  const r = e.length - 1;
  return e.length > 0 ? t.getNextPageParam(
    e[r],
    e,
    n[r],
    n
  ) : void 0;
}
function A7(t, { pages: e, pageParams: n }) {
  var r;
  return e.length > 0 ? (r = t.getPreviousPageParam) == null ? void 0 : r.call(t, e[0], e, n[0], n) : void 0;
}
var We, ga, wa, Oc, Bc, Ea, Pc, Uc, XA, E1 = (XA = class {
  constructor(t = {}) {
    B(this, We);
    B(this, ga);
    B(this, wa);
    B(this, Oc);
    B(this, Bc);
    B(this, Ea);
    B(this, Pc);
    B(this, Uc);
    x(this, We, t.queryCache || new g7()), x(this, ga, t.mutationCache || new x7()), x(this, wa, t.defaultOptions || {}), x(this, Oc, /* @__PURE__ */ new Map()), x(this, Bc, /* @__PURE__ */ new Map()), x(this, Ea, 0);
  }
  mount() {
    ra(this, Ea)._++, m(this, Ea) === 1 && (x(this, Pc, w1.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), m(this, We).onFocus());
    })), x(this, Uc, Mp.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), m(this, We).onOnline());
    })));
  }
  unmount() {
    var t, e;
    ra(this, Ea)._--, m(this, Ea) === 0 && ((t = m(this, Pc)) == null || t.call(this), x(this, Pc, void 0), (e = m(this, Uc)) == null || e.call(this), x(this, Uc, void 0));
  }
  isFetching(t) {
    return m(this, We).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return m(this, ga).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = m(this, We).get(e.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), n = m(this, We).build(this, e), r = n.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && n.isStaleByTime(Va(e.staleTime, n)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return m(this, We).findAll(t).map(({ queryKey: e, state: n }) => {
      const r = n.data;
      return [e, r];
    });
  }
  setQueryData(t, e, n) {
    const r = this.defaultQueryOptions({ queryKey: t }), s = m(this, We).get(
      r.queryHash
    ), a = s == null ? void 0 : s.state.data, i = i7(e, a);
    if (i !== void 0)
      return m(this, We).build(this, r).setData(i, { ...n, manual: !0 });
  }
  setQueriesData(t, e, n) {
    return lt.batch(
      () => m(this, We).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, n)
      ])
    );
  }
  getQueryState(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = m(this, We).get(
      e.queryHash
    )) == null ? void 0 : n.state;
  }
  removeQueries(t) {
    const e = m(this, We);
    lt.batch(() => {
      e.findAll(t).forEach((n) => {
        e.remove(n);
      });
    });
  }
  resetQueries(t, e) {
    const n = m(this, We);
    return lt.batch(() => (n.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const n = { revert: !0, ...e }, r = lt.batch(
      () => m(this, We).findAll(t).map((s) => s.cancel(n))
    );
    return Promise.all(r).then(on).catch(on);
  }
  invalidateQueries(t, e = {}) {
    return lt.batch(() => (m(this, We).findAll(t).forEach((n) => {
      n.invalidate();
    }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const n = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = lt.batch(
      () => m(this, We).findAll(t).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, n);
        return n.throwOnError || (a = a.catch(on)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(r).then(on);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const n = m(this, We).build(this, e);
    return n.isStaleByTime(
      Va(e.staleTime, n)
    ) ? n.fetch(e) : Promise.resolve(n.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(on).catch(on);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = HE(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(on).catch(on);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = HE(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Mp.isOnline() ? m(this, ga).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return m(this, We);
  }
  getMutationCache() {
    return m(this, ga);
  }
  getDefaultOptions() {
    return m(this, wa);
  }
  setDefaultOptions(t) {
    x(this, wa, t);
  }
  setQueryDefaults(t, e) {
    m(this, Oc).set(sd(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...m(this, Oc).values()], n = {};
    return e.forEach((r) => {
      ad(t, r.queryKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  setMutationDefaults(t, e) {
    m(this, Bc).set(sd(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...m(this, Bc).values()], n = {};
    return e.forEach((r) => {
      ad(t, r.mutationKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...m(this, wa).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = g1(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === Fp && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...m(this, wa).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    m(this, We).clear(), m(this, ga).clear();
  }
}, We = new WeakMap(), ga = new WeakMap(), wa = new WeakMap(), Oc = new WeakMap(), Bc = new WeakMap(), Ea = new WeakMap(), Pc = new WeakMap(), Uc = new WeakMap(), XA), bn, ve, Bd, rn, _i, Nc, xa, Aa, Pd, Rc, Dc, $i, Gi, ka, Fc, De, Bu, fy, py, hy, my, yy, by, gy, h6, ZA, x1 = (ZA = class extends zl {
  constructor(e, n) {
    super();
    B(this, De);
    B(this, bn);
    B(this, ve);
    B(this, Bd);
    B(this, rn);
    B(this, _i);
    B(this, Nc);
    B(this, xa);
    B(this, Aa);
    B(this, Pd);
    B(this, Rc);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    B(this, Dc);
    B(this, $i);
    B(this, Gi);
    B(this, ka);
    B(this, Fc, /* @__PURE__ */ new Set());
    this.options = n, x(this, bn, e), x(this, Aa, null), x(this, xa, dy()), this.options.experimental_prefetchInRender || m(this, xa).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (m(this, ve).addObserver(this), $E(m(this, ve), this.options) ? G(this, De, Bu).call(this) : this.updateResult(), G(this, De, my).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return wy(
      m(this, ve),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return wy(
      m(this, ve),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), G(this, De, yy).call(this), G(this, De, by).call(this), m(this, ve).removeObserver(this);
  }
  setOptions(e) {
    const n = this.options, r = m(this, ve);
    if (this.options = m(this, bn).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof nr(this.options.enabled, m(this, ve)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    G(this, De, gy).call(this), m(this, ve).setOptions(this.options), n._defaulted && !cy(this.options, n) && m(this, bn).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: m(this, ve),
      observer: this
    });
    const s = this.hasListeners();
    s && GE(
      m(this, ve),
      r,
      this.options,
      n
    ) && G(this, De, Bu).call(this), this.updateResult(), s && (m(this, ve) !== r || nr(this.options.enabled, m(this, ve)) !== nr(n.enabled, m(this, ve)) || Va(this.options.staleTime, m(this, ve)) !== Va(n.staleTime, m(this, ve))) && G(this, De, fy).call(this);
    const a = G(this, De, py).call(this);
    s && (m(this, ve) !== r || nr(this.options.enabled, m(this, ve)) !== nr(n.enabled, m(this, ve)) || a !== m(this, ka)) && G(this, De, hy).call(this, a);
  }
  getOptimisticResult(e) {
    const n = m(this, bn).getQueryCache().build(m(this, bn), e), r = this.createResult(n, e);
    return v7(this, r) && (x(this, rn, r), x(this, Nc, this.options), x(this, _i, m(this, ve).state)), r;
  }
  getCurrentResult() {
    return m(this, rn);
  }
  trackResult(e, n) {
    return new Proxy(e, {
      get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
    });
  }
  trackProp(e) {
    m(this, Fc).add(e);
  }
  getCurrentQuery() {
    return m(this, ve);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const n = m(this, bn).defaultQueryOptions(e), r = m(this, bn).getQueryCache().build(m(this, bn), n);
    return r.fetch().then(() => this.createResult(r, n));
  }
  fetch(e) {
    return G(this, De, Bu).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), m(this, rn)));
  }
  createResult(e, n) {
    var C;
    const r = m(this, ve), s = this.options, a = m(this, rn), i = m(this, _i), o = m(this, Nc), u = e !== r ? e.state : m(this, Bd), { state: l } = e;
    let d = { ...l }, p = !1, f;
    if (n._optimisticResults) {
      const S = this.hasListeners(), R = !S && $E(e, n), M = S && GE(e, r, n, s);
      (R || M) && (d = {
        ...d,
        ...p6(l.data, e.options)
      }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle");
    }
    let { error: b, errorUpdatedAt: y, status: g } = d;
    f = d.data;
    let w = !1;
    if (n.placeholderData !== void 0 && f === void 0 && g === "pending") {
      let S;
      a != null && a.isPlaceholderData && n.placeholderData === (o == null ? void 0 : o.placeholderData) ? (S = a.data, w = !0) : S = typeof n.placeholderData == "function" ? n.placeholderData(
        (C = m(this, Dc)) == null ? void 0 : C.state.data,
        m(this, Dc)
      ) : n.placeholderData, S !== void 0 && (g = "success", f = uy(
        a == null ? void 0 : a.data,
        S,
        n
      ), p = !0);
    }
    if (n.select && f !== void 0 && !w)
      if (a && f === (i == null ? void 0 : i.data) && n.select === m(this, Pd))
        f = m(this, Rc);
      else
        try {
          x(this, Pd, n.select), f = n.select(f), f = uy(a == null ? void 0 : a.data, f, n), x(this, Rc, f), x(this, Aa, null);
        } catch (S) {
          x(this, Aa, S);
        }
    m(this, Aa) && (b = m(this, Aa), f = m(this, Rc), y = Date.now(), g = "error");
    const k = d.fetchStatus === "fetching", E = g === "pending", T = g === "error", A = E && k, N = f !== void 0, P = {
      status: g,
      fetchStatus: d.fetchStatus,
      isPending: E,
      isSuccess: g === "success",
      isError: T,
      isInitialLoading: A,
      isLoading: A,
      data: f,
      dataUpdatedAt: d.dataUpdatedAt,
      error: b,
      errorUpdatedAt: y,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount,
      isFetching: k,
      isRefetching: k && !E,
      isLoadingError: T && !N,
      isPaused: d.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: T && N,
      isStale: A1(e, n),
      refetch: this.refetch,
      promise: m(this, xa),
      isEnabled: nr(n.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const S = (_) => {
        P.status === "error" ? _.reject(P.error) : P.data !== void 0 && _.resolve(P.data);
      }, R = () => {
        const _ = x(this, xa, P.promise = dy());
        S(_);
      }, M = m(this, xa);
      switch (M.status) {
        case "pending":
          e.queryHash === r.queryHash && S(M);
          break;
        case "fulfilled":
          (P.status === "error" || P.data !== M.value) && R();
          break;
        case "rejected":
          (P.status !== "error" || P.error !== M.reason) && R();
          break;
      }
    }
    return P;
  }
  updateResult() {
    const e = m(this, rn), n = this.createResult(m(this, ve), this.options);
    if (x(this, _i, m(this, ve).state), x(this, Nc, this.options), m(this, _i).data !== void 0 && x(this, Dc, m(this, ve)), cy(n, e))
      return;
    x(this, rn, n);
    const r = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: s } = this.options, a = typeof s == "function" ? s() : s;
      if (a === "all" || !a && !m(this, Fc).size)
        return !0;
      const i = new Set(
        a ?? m(this, Fc)
      );
      return this.options.throwOnError && i.add("error"), Object.keys(m(this, rn)).some((o) => {
        const c = o;
        return m(this, rn)[c] !== e[c] && i.has(c);
      });
    };
    G(this, De, h6).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && G(this, De, my).call(this);
  }
}, bn = new WeakMap(), ve = new WeakMap(), Bd = new WeakMap(), rn = new WeakMap(), _i = new WeakMap(), Nc = new WeakMap(), xa = new WeakMap(), Aa = new WeakMap(), Pd = new WeakMap(), Rc = new WeakMap(), Dc = new WeakMap(), $i = new WeakMap(), Gi = new WeakMap(), ka = new WeakMap(), Fc = new WeakMap(), De = new WeakSet(), Bu = function(e) {
  G(this, De, gy).call(this);
  let n = m(this, ve).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (n = n.catch(on)), n;
}, fy = function() {
  G(this, De, yy).call(this);
  const e = Va(
    this.options.staleTime,
    m(this, ve)
  );
  if (Ao || m(this, rn).isStale || !oy(e))
    return;
  const r = o6(m(this, rn).dataUpdatedAt, e) + 1;
  x(this, $i, setTimeout(() => {
    m(this, rn).isStale || this.updateResult();
  }, r));
}, py = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(m(this, ve)) : this.options.refetchInterval) ?? !1;
}, hy = function(e) {
  G(this, De, by).call(this), x(this, ka, e), !(Ao || nr(this.options.enabled, m(this, ve)) === !1 || !oy(m(this, ka)) || m(this, ka) === 0) && x(this, Gi, setInterval(() => {
    (this.options.refetchIntervalInBackground || w1.isFocused()) && G(this, De, Bu).call(this);
  }, m(this, ka)));
}, my = function() {
  G(this, De, fy).call(this), G(this, De, hy).call(this, G(this, De, py).call(this));
}, yy = function() {
  m(this, $i) && (clearTimeout(m(this, $i)), x(this, $i, void 0));
}, by = function() {
  m(this, Gi) && (clearInterval(m(this, Gi)), x(this, Gi, void 0));
}, gy = function() {
  const e = m(this, bn).getQueryCache().build(m(this, bn), this.options);
  if (e === m(this, ve))
    return;
  const n = m(this, ve);
  x(this, ve, e), x(this, Bd, e.state), this.hasListeners() && (n == null || n.removeObserver(this), e.addObserver(this));
}, h6 = function(e) {
  lt.batch(() => {
    e.listeners && this.listeners.forEach((n) => {
      n(m(this, rn));
    }), m(this, bn).getQueryCache().notify({
      query: m(this, ve),
      type: "observerResultsUpdated"
    });
  });
}, ZA);
function k7(t, e) {
  return nr(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function $E(t, e) {
  return k7(t, e) || t.state.data !== void 0 && wy(t, e, e.refetchOnMount);
}
function wy(t, e, n) {
  if (nr(e.enabled, t) !== !1 && Va(e.staleTime, t) !== "static") {
    const r = typeof n == "function" ? n(t) : n;
    return r === "always" || r !== !1 && A1(t, e);
  }
  return !1;
}
function GE(t, e, n, r) {
  return (t !== e || nr(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && A1(t, n);
}
function A1(t, e) {
  return nr(e.enabled, t) !== !1 && t.isStaleByTime(Va(e.staleTime, t));
}
function v7(t, e) {
  return !cy(t.getCurrentResult(), e);
}
function zE(t, e) {
  const n = new Set(e);
  return t.filter((r) => !n.has(r));
}
function C7(t, e, n) {
  const r = t.slice(0);
  return r[e] = n, r;
}
var zi, Qn, Mc, Lc, Jn, va, Ud, Nd, Rd, Rt, Ey, xy, Ay, ky, vy, YA, T7 = (YA = class extends zl {
  constructor(e, n, r) {
    super();
    B(this, Rt);
    B(this, zi);
    B(this, Qn);
    B(this, Mc);
    B(this, Lc);
    B(this, Jn);
    B(this, va);
    B(this, Ud);
    B(this, Nd);
    B(this, Rd, []);
    x(this, zi, e), x(this, Lc, r), x(this, Mc, []), x(this, Jn, []), x(this, Qn, []), this.setQueries(n);
  }
  onSubscribe() {
    this.listeners.size === 1 && m(this, Jn).forEach((e) => {
      e.subscribe((n) => {
        G(this, Rt, ky).call(this, e, n);
      });
    });
  }
  onUnsubscribe() {
    this.listeners.size || this.destroy();
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), m(this, Jn).forEach((e) => {
      e.destroy();
    });
  }
  setQueries(e, n) {
    if (x(this, Mc, e), x(this, Lc, n), process.env.NODE_ENV !== "production") {
      const r = e.map(
        (s) => m(this, zi).defaultQueryOptions(s).queryHash
      );
      new Set(r).size !== r.length && console.warn(
        "[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior."
      );
    }
    lt.batch(() => {
      const r = m(this, Jn), s = G(this, Rt, Ay).call(this, m(this, Mc));
      x(this, Rd, s), s.forEach(
        (c) => c.observer.setOptions(c.defaultedQueryOptions)
      );
      const a = s.map((c) => c.observer), i = a.map(
        (c) => c.getCurrentResult()
      ), o = a.some(
        (c, u) => c !== r[u]
      );
      r.length === a.length && !o || (x(this, Jn, a), x(this, Qn, i), this.hasListeners() && (zE(r, a).forEach((c) => {
        c.destroy();
      }), zE(a, r).forEach((c) => {
        c.subscribe((u) => {
          G(this, Rt, ky).call(this, c, u);
        });
      }), G(this, Rt, vy).call(this)));
    });
  }
  getCurrentResult() {
    return m(this, Qn);
  }
  getQueries() {
    return m(this, Jn).map((e) => e.getCurrentQuery());
  }
  getObservers() {
    return m(this, Jn);
  }
  getOptimisticResult(e, n) {
    const r = G(this, Rt, Ay).call(this, e), s = r.map(
      (a) => a.observer.getOptimisticResult(a.defaultedQueryOptions)
    );
    return [
      s,
      (a) => G(this, Rt, xy).call(this, a ?? s, n),
      () => G(this, Rt, Ey).call(this, s, r)
    ];
  }
}, zi = new WeakMap(), Qn = new WeakMap(), Mc = new WeakMap(), Lc = new WeakMap(), Jn = new WeakMap(), va = new WeakMap(), Ud = new WeakMap(), Nd = new WeakMap(), Rd = new WeakMap(), Rt = new WeakSet(), Ey = function(e, n) {
  return n.map((r, s) => {
    const a = e[s];
    return r.defaultedQueryOptions.notifyOnChangeProps ? a : r.observer.trackResult(a, (i) => {
      n.forEach((o) => {
        o.observer.trackProp(i);
      });
    });
  });
}, xy = function(e, n) {
  return n ? ((!m(this, va) || m(this, Qn) !== m(this, Nd) || n !== m(this, Ud)) && (x(this, Ud, n), x(this, Nd, m(this, Qn)), x(this, va, Dp(
    m(this, va),
    n(e)
  ))), m(this, va)) : e;
}, Ay = function(e) {
  const n = new Map(
    m(this, Jn).map((s) => [s.options.queryHash, s])
  ), r = [];
  return e.forEach((s) => {
    const a = m(this, zi).defaultQueryOptions(s), i = n.get(a.queryHash);
    i ? r.push({
      defaultedQueryOptions: a,
      observer: i
    }) : r.push({
      defaultedQueryOptions: a,
      observer: new x1(m(this, zi), a)
    });
  }), r;
}, ky = function(e, n) {
  const r = m(this, Jn).indexOf(e);
  r !== -1 && (x(this, Qn, C7(m(this, Qn), r, n)), G(this, Rt, vy).call(this));
}, vy = function() {
  var e;
  if (this.hasListeners()) {
    const n = m(this, va), r = G(this, Rt, Ey).call(this, m(this, Qn), m(this, Rd)), s = G(this, Rt, xy).call(this, r, (e = m(this, Lc)) == null ? void 0 : e.combine);
    n !== s && lt.batch(() => {
      this.listeners.forEach((a) => {
        a(m(this, Qn));
      });
    });
  }
}, YA), m6 = Ot.createContext(
  void 0
), y6 = (t) => {
  const e = Ot.useContext(m6);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, Sne = ({
  client: t,
  children: e
}) => (Ot.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ r6(m6.Provider, { value: t, children: e })), b6 = Ot.createContext(!1), g6 = () => Ot.useContext(b6);
b6.Provider;
function S7() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var I7 = Ot.createContext(S7()), w6 = () => Ot.useContext(I7), E6 = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, x6 = (t) => {
  Ot.useEffect(() => {
    t.clearReset();
  }, [t]);
}, A6 = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: n,
  query: r,
  suspense: s
}) => t.isError && !e.isReset() && !t.isFetching && r && (s && t.data === void 0 || u7(n, [t.error, r])), k6 = (t) => {
  if (t.suspense) {
    const e = (r) => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime;
    t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3));
  }
}, v6 = (t, e) => t.isLoading && t.isFetching && !e, Cy = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, Lp = (t, e, n) => e.fetchOptimistic(t).catch(() => {
  n.clearReset();
});
function O7({
  queries: t,
  ...e
}, n) {
  const r = y6(), s = g6(), a = w6(), i = Ot.useMemo(
    () => t.map((y) => {
      const g = r.defaultQueryOptions(
        y
      );
      return g._optimisticResults = s ? "isRestoring" : "optimistic", g;
    }),
    [t, r, s]
  );
  i.forEach((y) => {
    k6(y), E6(y, a);
  }), x6(a);
  const [o] = Ot.useState(
    () => new T7(
      r,
      i,
      e
    )
  ), [c, u, l] = o.getOptimisticResult(
    i,
    e.combine
  ), d = !s && e.subscribed !== !1;
  Ot.useSyncExternalStore(
    Ot.useCallback(
      (y) => d ? o.subscribe(lt.batchCalls(y)) : on,
      [o, d]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), Ot.useEffect(() => {
    o.setQueries(
      i,
      e
    );
  }, [i, e, o]);
  const f = c.some(
    (y, g) => Cy(i[g], y)
  ) ? c.flatMap((y, g) => {
    const w = i[g];
    if (w) {
      const k = new x1(r, w);
      if (Cy(w, y))
        return Lp(w, k, a);
      v6(y, s) && Lp(w, k, a);
    }
    return [];
  }) : [];
  if (f.length > 0)
    throw Promise.all(f);
  const b = c.find(
    (y, g) => {
      const w = i[g];
      return w && A6({
        result: y,
        errorResetBoundary: a,
        throwOnError: w.throwOnError,
        query: r.getQueryCache().get(w.queryHash),
        suspense: w.suspense
      });
    }
  );
  if (b != null && b.error)
    throw b.error;
  return u(l());
}
function B7(t, e, n) {
  var d, p, f, b, y;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = g6(), s = w6(), a = y6(), i = a.defaultQueryOptions(t);
  (p = (d = a.getDefaultOptions().queries) == null ? void 0 : d._experimental_beforeQuery) == null || p.call(
    d,
    i
  ), process.env.NODE_ENV !== "production" && (i.queryFn || console.error(
    `[${i.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), i._optimisticResults = r ? "isRestoring" : "optimistic", k6(i), E6(i, s), x6(s);
  const o = !a.getQueryCache().get(i.queryHash), [c] = Ot.useState(
    () => new e(
      a,
      i
    )
  ), u = c.getOptimisticResult(i), l = !r && t.subscribed !== !1;
  if (Ot.useSyncExternalStore(
    Ot.useCallback(
      (g) => {
        const w = l ? c.subscribe(lt.batchCalls(g)) : on;
        return c.updateResult(), w;
      },
      [c, l]
    ),
    () => c.getCurrentResult(),
    () => c.getCurrentResult()
  ), Ot.useEffect(() => {
    c.setOptions(i);
  }, [i, c]), Cy(i, u))
    throw Lp(i, c, s);
  if (A6({
    result: u,
    errorResetBoundary: s,
    throwOnError: i.throwOnError,
    query: a.getQueryCache().get(i.queryHash),
    suspense: i.suspense
  }))
    throw u.error;
  if ((b = (f = a.getDefaultOptions().queries) == null ? void 0 : f._experimental_afterQuery) == null || b.call(
    f,
    i,
    u
  ), i.experimental_prefetchInRender && !Ao && v6(u, r)) {
    const g = o ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Lp(i, c, s)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (y = a.getQueryCache().get(i.queryHash)) == null ? void 0 : y.promise
    );
    g == null || g.catch(on).finally(() => {
      c.updateResult();
    });
  }
  return i.notifyOnChangeProps ? u : c.trackResult(u);
}
function ar(t, e) {
  return B7(t, x1);
}
function Hp() {
  return Hp = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Hp.apply(null, arguments);
}
let Ine = /* @__PURE__ */ function(t) {
  return t.NOT_AVAILABLE = "NOT_AVAILABLE", t.REFRESHING = "REFRESHING", t.AVAILABLE = "AVAILABLE", t;
}({}), P7 = /* @__PURE__ */ function(t) {
  return t.VERIFIED = "VERIFIED", t.UNVERIFIED = "UNVERIFIED", t.ALL = "ALL", t;
}({});
const U7 = "Webrpc", N7 = "webrpc@v0.21.1;gen-typescript@v0.15.1;sequence-indexer@v0.4.0";
class R7 {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/IndexerGateway/", this.getNativeTokenBalance = (r, s, a) => this.fetch(this.url("GetNativeTokenBalance"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalances = (r, s, a) => this.fetch(this.url("GetTokenBalances"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesSummary = (r, s, a) => this.fetch(this.url("GetTokenBalancesSummary"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesDetails = (r, s, a) => this.fetch(this.url("GetTokenBalancesDetails"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesByContract = (r, s, a) => this.fetch(this.url("GetTokenBalancesByContract"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getBalanceUpdates = (r, s, a) => this.fetch(this.url("GetBalanceUpdates"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getChains = (r, s, a) => this.fetch(this.url("GetChains"), Dr(r, s, a)).then((i) => Fr(i).then((o) => ({
      chains: o.chains
    })), (i) => {
      throw fr.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.ping = (r, s) => this.fetch(this.url("Ping"), Dr({}, r, s)).then((a) => Fr(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw fr.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), Dr({}, r, s)).then((a) => Fr(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw fr.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), Dr({}, r, s)).then((a) => Fr(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw fr.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const Dr = (t = {}, e = {}, n = null) => {
  const r = Hp({}, e, {
    "Content-Type": "application/json"
  });
  return r[U7] = N7, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, Fr = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), P6.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (pI[r] || xe).new(n);
  }
  return n;
});
let xe = class C6 extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, C6.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, D7 = class T6 extends xe {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, T6.prototype);
  }
}, fr = class S6 extends xe {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, S6.prototype);
  }
}, F7 = class I6 extends xe {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, I6.prototype);
  }
}, M7 = class O6 extends xe {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, O6.prototype);
  }
}, L7 = class B6 extends xe {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, B6.prototype);
  }
}, P6 = class U6 extends xe {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, U6.prototype);
  }
}, H7 = class N6 extends xe {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, N6.prototype);
  }
}, _7 = class R6 extends xe {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, R6.prototype);
  }
}, $7 = class D6 extends xe {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, D6.prototype);
  }
}, G7 = class F6 extends xe {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, F6.prototype);
  }
}, z7 = class M6 extends xe {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, M6.prototype);
  }
}, j7 = class L6 extends xe {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, L6.prototype);
  }
}, V7 = class H6 extends xe {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, H6.prototype);
  }
}, q7 = class _6 extends xe {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _6.prototype);
  }
}, K7 = class $6 extends xe {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $6.prototype);
  }
}, W7 = class G6 extends xe {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, G6.prototype);
  }
}, Q7 = class z6 extends xe {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, z6.prototype);
  }
}, J7 = class j6 extends xe {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, j6.prototype);
  }
}, X7 = class V6 extends xe {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, V6.prototype);
  }
}, Z7 = class q6 extends xe {
  constructor(e = "ProjectNotFound", n = 1100, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, q6.prototype);
  }
}, Y7 = class K6 extends xe {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, K6.prototype);
  }
}, eI = class W6 extends xe {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, W6.prototype);
  }
}, tI = class Q6 extends xe {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Q6.prototype);
  }
}, nI = class J6 extends xe {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, J6.prototype);
  }
}, rI = class X6 extends xe {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, X6.prototype);
  }
}, sI = class Z6 extends xe {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Z6.prototype);
  }
};
class k1 extends xe {
  constructor(e = "RateLimit", n = 1201, r = "Rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, k1.prototype);
  }
}
let aI = class Y6 extends xe {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Y6.prototype);
  }
}, iI = class ek extends xe {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ek.prototype);
  }
}, oI = class tk extends xe {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, tk.prototype);
  }
}, cI = class nk extends xe {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, nk.prototype);
  }
}, lI = class rk extends xe {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, rk.prototype);
  }
}, uI = class sk extends xe {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, sk.prototype);
  }
}, dI = class ak extends xe {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ak.prototype);
  }
};
class v1 extends xe {
  constructor(e = "ResourceExhausted", n = 2004, r = "Resource exhausted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, v1.prototype);
  }
}
let fI = class ik extends xe {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ik.prototype);
  }
};
class C1 extends xe {
  constructor(e = "MetadataCallFailed", n = 3003, r = "Metadata service call failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, C1.prototype);
  }
}
const pI = {
  0: D7,
  [-1]: fr,
  [-2]: F7,
  [-3]: M7,
  [-4]: L7,
  [-5]: P6,
  [-6]: H7,
  [-7]: _7,
  [-8]: $7,
  [-9]: G7,
  [-10]: z7,
  1e3: j7,
  1001: V7,
  1002: q7,
  1003: K7,
  1004: W7,
  1005: Q7,
  1006: J7,
  1007: X7,
  1100: Z7,
  1101: Y7,
  1102: eI,
  1103: tI,
  1104: nI,
  1105: rI,
  1200: sI,
  1201: k1,
  1300: aI,
  1301: iI,
  1302: oI,
  1900: cI,
  2001: lI,
  2002: uI,
  2003: dI,
  2004: v1,
  3e3: fI,
  3003: C1
};
class hI extends R7 {
  constructor(e, n, r) {
    super(e.endsWith("/") ? e.slice(0, -1) : e, fetch), this.projectAccessKey = n, this.jwtAuth = r, this._fetch = (s, a) => {
      const i = {}, o = this.jwtAuth, c = this.projectAccessKey;
      return o && o.length > 0 && (i.Authorization = `BEARER ${o}`), c && c.length > 0 && (i["X-Access-Key"] = c), a.headers = Hp({}, a.headers, i), fetch(s, a);
    }, this.fetch = this._fetch;
  }
}
let ie = /* @__PURE__ */ function(t) {
  return t.MAINNET = "mainnet", t.TESTNET = "testnet", t;
}({}), v = /* @__PURE__ */ function(t) {
  return t[t.MAINNET = 1] = "MAINNET", t[t.ROPSTEN = 3] = "ROPSTEN", t[t.RINKEBY = 4] = "RINKEBY", t[t.GOERLI = 5] = "GOERLI", t[t.KOVAN = 42] = "KOVAN", t[t.SEPOLIA = 11155111] = "SEPOLIA", t[t.POLYGON = 137] = "POLYGON", t[t.POLYGON_MUMBAI = 80001] = "POLYGON_MUMBAI", t[t.POLYGON_ZKEVM = 1101] = "POLYGON_ZKEVM", t[t.POLYGON_AMOY = 80002] = "POLYGON_AMOY", t[t.BSC = 56] = "BSC", t[t.BSC_TESTNET = 97] = "BSC_TESTNET", t[t.OPTIMISM = 10] = "OPTIMISM", t[t.OPTIMISM_KOVAN = 69] = "OPTIMISM_KOVAN", t[t.OPTIMISM_GOERLI = 420] = "OPTIMISM_GOERLI", t[t.OPTIMISM_SEPOLIA = 11155420] = "OPTIMISM_SEPOLIA", t[t.ARBITRUM = 42161] = "ARBITRUM", t[t.ARBITRUM_GOERLI = 421613] = "ARBITRUM_GOERLI", t[t.ARBITRUM_SEPOLIA = 421614] = "ARBITRUM_SEPOLIA", t[t.ARBITRUM_NOVA = 42170] = "ARBITRUM_NOVA", t[t.AVALANCHE = 43114] = "AVALANCHE", t[t.AVALANCHE_TESTNET = 43113] = "AVALANCHE_TESTNET", t[t.GNOSIS = 100] = "GNOSIS", t[t.BASE = 8453] = "BASE", t[t.BASE_GOERLI = 84531] = "BASE_GOERLI", t[t.BASE_SEPOLIA = 84532] = "BASE_SEPOLIA", t[t.HOMEVERSE_TESTNET = 40875] = "HOMEVERSE_TESTNET", t[t.HOMEVERSE = 19011] = "HOMEVERSE", t[t.XAI = 660279] = "XAI", t[t.XAI_SEPOLIA = 37714555429] = "XAI_SEPOLIA", t[t.TELOS = 40] = "TELOS", t[t.TELOS_TESTNET = 41] = "TELOS_TESTNET", t[t.B3 = 8333] = "B3", t[t.B3_SEPOLIA = 1993] = "B3_SEPOLIA", t[t.APECHAIN = 33139] = "APECHAIN", t[t.APECHAIN_TESTNET = 33111] = "APECHAIN_TESTNET", t[t.BLAST = 81457] = "BLAST", t[t.BLAST_SEPOLIA = 168587773] = "BLAST_SEPOLIA", t[t.BORNE_TESTNET = 94984] = "BORNE_TESTNET", t[t.SKALE_NEBULA = 1482601649] = "SKALE_NEBULA", t[t.SKALE_NEBULA_TESTNET = 37084624] = "SKALE_NEBULA_TESTNET", t[t.SONEIUM_MINATO = 1946] = "SONEIUM_MINATO", t[t.SONEIUM = 1868] = "SONEIUM", t[t.TOY_TESTNET = 21e6] = "TOY_TESTNET", t[t.IMMUTABLE_ZKEVM = 13371] = "IMMUTABLE_ZKEVM", t[t.IMMUTABLE_ZKEVM_TESTNET = 13473] = "IMMUTABLE_ZKEVM_TESTNET", t[t.ROOT_NETWORK = 7668] = "ROOT_NETWORK", t[t.ROOT_NETWORK_PORCINI = 7672] = "ROOT_NETWORK_PORCINI", t[t.HARDHAT = 31337] = "HARDHAT", t[t.HARDHAT_2 = 31338] = "HARDHAT_2", t[t.LAOS = 6283] = "LAOS", t[t.LAOS_SIGMA_TESTNET = 62850] = "LAOS_SIGMA_TESTNET", t[t.ETHERLINK = 42793] = "ETHERLINK", t[t.ETHERLINK_TESTNET = 128123] = "ETHERLINK_TESTNET", t[t.MOONBEAM = 1284] = "MOONBEAM", t[t.MOONBASE_ALPHA = 1287] = "MOONBASE_ALPHA", t[t.MONAD_TESTNET = 10143] = "MONAD_TESTNET", t[t.SOMNIA_TESTNET = 50312] = "SOMNIA_TESTNET", t[t.SOMNIA = 5031] = "SOMNIA", t[t.INCENTIV_TESTNET = 11690] = "INCENTIV_TESTNET", t[t.SEI = 1329] = "SEI", t[t.SEI_TESTNET = 1328] = "SEI_TESTNET", t;
}({});
const Ty = {
  [v.MAINNET]: {
    chainId: v.MAINNET,
    type: ie.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [v.ROPSTEN]: {
    chainId: v.ROPSTEN,
    type: ie.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ROPSTEN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [v.RINKEBY]: {
    chainId: v.RINKEBY,
    type: ie.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.RINKEBY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [v.GOERLI]: {
    chainId: v.GOERLI,
    type: ie.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [v.KOVAN]: {
    chainId: v.KOVAN,
    type: ie.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [v.SEPOLIA]: {
    chainId: v.SEPOLIA,
    type: ie.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [v.POLYGON]: {
    chainId: v.POLYGON,
    type: ie.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "POL",
      name: "POL",
      decimals: 18
    }
  },
  [v.POLYGON_MUMBAI]: {
    chainId: v.POLYGON_MUMBAI,
    type: ie.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.POLYGON_MUMBAI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: !0
  },
  [v.POLYGON_AMOY]: {
    chainId: v.POLYGON_AMOY,
    type: ie.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.POLYGON_AMOY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aPOL",
      name: "Amoy POL",
      decimals: 18
    }
  },
  [v.POLYGON_ZKEVM]: {
    chainId: v.POLYGON_ZKEVM,
    type: ie.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.BSC]: {
    chainId: v.BSC,
    type: ie.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [v.BSC_TESTNET]: {
    chainId: v.BSC_TESTNET,
    type: ie.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BSC_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [v.OPTIMISM]: {
    chainId: v.OPTIMISM,
    type: ie.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.OPTIMISM_KOVAN]: {
    chainId: v.OPTIMISM_KOVAN,
    type: ie.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.OPTIMISM_KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [v.OPTIMISM_GOERLI]: {
    chainId: v.OPTIMISM_GOERLI,
    type: ie.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.OPTIMISM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [v.OPTIMISM_SEPOLIA]: {
    chainId: v.OPTIMISM_SEPOLIA,
    type: ie.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.OPTIMISM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [v.ARBITRUM]: {
    chainId: v.ARBITRUM,
    type: ie.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.ARBITRUM_GOERLI]: {
    chainId: v.ARBITRUM_GOERLI,
    type: ie.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ARBITRUM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [v.ARBITRUM_SEPOLIA]: {
    chainId: v.ARBITRUM_SEPOLIA,
    type: ie.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ARBITRUM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [v.ARBITRUM_NOVA]: {
    chainId: v.ARBITRUM_NOVA,
    type: ie.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.AVALANCHE]: {
    chainId: v.AVALANCHE,
    type: ie.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [v.AVALANCHE_TESTNET]: {
    chainId: v.AVALANCHE_TESTNET,
    type: ie.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.AVALANCHE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [v.GNOSIS]: {
    chainId: v.GNOSIS,
    type: ie.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [v.BASE]: {
    chainId: v.BASE,
    type: ie.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.BASE_GOERLI]: {
    chainId: v.BASE_GOERLI,
    type: ie.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BASE_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [v.BASE_SEPOLIA]: {
    chainId: v.BASE_SEPOLIA,
    type: ie.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BASE_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [v.HOMEVERSE]: {
    chainId: v.HOMEVERSE,
    type: ie.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [v.HOMEVERSE_TESTNET]: {
    chainId: v.HOMEVERSE_TESTNET,
    type: ie.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.HOMEVERSE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [v.XAI]: {
    chainId: v.XAI,
    type: ie.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [v.XAI_SEPOLIA]: {
    chainId: v.XAI_SEPOLIA,
    type: ie.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.XAI_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [v.B3]: {
    chainId: v.B3,
    type: ie.MAINNET,
    name: "b3",
    title: "B3",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.B3}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "B3 Explorer",
      rootUrl: "https://explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.B3_SEPOLIA]: {
    chainId: v.B3_SEPOLIA,
    type: ie.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.B3_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.APECHAIN]: {
    chainId: v.APECHAIN,
    type: ie.MAINNET,
    name: "apechain",
    title: "APE Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.APECHAIN}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://apechain.calderaexplorer.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [v.APECHAIN_TESTNET]: {
    chainId: v.APECHAIN_TESTNET,
    type: ie.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.APECHAIN_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [v.BLAST]: {
    chainId: v.BLAST,
    type: ie.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.BLAST_SEPOLIA]: {
    chainId: v.BLAST_SEPOLIA,
    type: ie.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BLAST_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.TELOS]: {
    chainId: v.TELOS,
    type: ie.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [v.TELOS_TESTNET]: {
    chainId: v.TELOS_TESTNET,
    type: ie.TESTNET,
    name: "telos-testnet",
    title: "Telos Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.TELOS_TESTNET}.webp`,
    blockExplorer: {
      name: "Telos Testnet Explorer",
      rootUrl: "https://explorer-test.telos.net/network"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [v.BORNE_TESTNET]: {
    chainId: v.BORNE_TESTNET,
    type: ie.TESTNET,
    name: "borne-testnet",
    title: "Borne Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.BORNE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Borne Testnet Explorer",
      rootUrl: "https://subnets-test.avax.network/bornegfdn"
    },
    nativeToken: {
      symbol: "BORNE",
      name: "BORNE",
      decimals: 18
    }
  },
  [v.SKALE_NEBULA]: {
    chainId: v.SKALE_NEBULA,
    type: ie.MAINNET,
    name: "skale-nebula",
    title: "SKALE Nebula Gaming Hub",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SKALE_NEBULA}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Explorer",
      rootUrl: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [v.SKALE_NEBULA_TESTNET]: {
    chainId: v.SKALE_NEBULA_TESTNET,
    type: ie.TESTNET,
    name: "skale-nebula-testnet",
    title: "SKALE Nebula Gaming Hub Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SKALE_NEBULA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Testnet Explorer",
      rootUrl: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [v.SONEIUM]: {
    chainId: v.SONEIUM,
    type: ie.MAINNET,
    name: "soneium",
    title: "Soneium",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SONEIUM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Soneium Explorer",
      rootUrl: "https://soneium.blockscout.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.SONEIUM_MINATO]: {
    chainId: v.SONEIUM_MINATO,
    type: ie.TESTNET,
    name: "soneium-minato",
    title: "Soneium Minato (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SONEIUM_MINATO}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Soneium Minato Explorer",
      rootUrl: "https://explorer-testnet.soneium.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.TOY_TESTNET]: {
    chainId: v.TOY_TESTNET,
    type: ie.TESTNET,
    name: "toy-testnet",
    title: "TOY (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.TOY_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "TOY Testnet Explorer",
      rootUrl: "https://toy-chain-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "TOY",
      name: "TOY",
      decimals: 18
    }
  },
  [v.IMMUTABLE_ZKEVM]: {
    chainId: v.IMMUTABLE_ZKEVM,
    type: ie.MAINNET,
    name: "immutable-zkevm",
    title: "Immutable zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.IMMUTABLE_ZKEVM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Immutable zkEVM Explorer",
      rootUrl: "https://explorer.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [v.IMMUTABLE_ZKEVM_TESTNET]: {
    chainId: v.IMMUTABLE_ZKEVM_TESTNET,
    type: ie.TESTNET,
    name: "immutable-zkevm-testnet",
    title: "Immutable zkEVM Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.IMMUTABLE_ZKEVM_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Immutable zkEVM Testnet Explorer",
      rootUrl: "https://explorer.testnet.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [v.ROOT_NETWORK]: {
    chainId: v.ROOT_NETWORK,
    type: ie.MAINNET,
    name: "rootnet",
    title: "The Root Network",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ROOT_NETWORK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "The Root Network Explorer",
      rootUrl: "https://rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [v.ROOT_NETWORK_PORCINI]: {
    chainId: v.ROOT_NETWORK_PORCINI,
    type: ie.TESTNET,
    name: "rootnet-porcini",
    title: "The Root Network Porcini Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ROOT_NETWORK_PORCINI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "The Root Network Porcini Testnet Explorer",
      rootUrl: "https://porcini.rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [v.HARDHAT]: {
    chainId: v.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.HARDHAT_2]: {
    chainId: v.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [v.LAOS]: {
    chainId: v.LAOS,
    type: ie.MAINNET,
    name: "laos",
    title: "LAOS",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.LAOS}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "LAOS Explorer",
      rootUrl: "https://blockscout.laos.laosfoundation.io/"
    },
    nativeToken: {
      symbol: "LAOS",
      name: "LAOS",
      decimals: 18
    }
  },
  [v.LAOS_SIGMA_TESTNET]: {
    chainId: v.LAOS_SIGMA_TESTNET,
    type: ie.TESTNET,
    name: "laos-sigma-testnet",
    title: "LAOS Sigma Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.LAOS_SIGMA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "LAOS Sigma Testnet Explorer",
      rootUrl: "https://sigma.explorer.laosnetwork.io/"
    },
    nativeToken: {
      symbol: "SIGMA",
      name: "SIGMA",
      decimals: 18
    }
  },
  [v.MOONBEAM]: {
    chainId: v.MOONBEAM,
    type: ie.MAINNET,
    name: "moonbeam",
    title: "Moonbeam",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.MOONBEAM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Moonscan",
      rootUrl: "https://moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [v.MOONBASE_ALPHA]: {
    chainId: v.MOONBASE_ALPHA,
    type: ie.TESTNET,
    name: "moonbase-alpha",
    title: "Moonbase Alpha",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.MOONBASE_ALPHA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Moonscan (Moonbase Alpha)",
      rootUrl: "https://moonbase.moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [v.ETHERLINK]: {
    chainId: v.ETHERLINK,
    type: ie.MAINNET,
    name: "etherlink",
    title: "Etherlink",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ETHERLINK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Etherlink Explorer",
      rootUrl: "https://explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [v.ETHERLINK_TESTNET]: {
    chainId: v.ETHERLINK_TESTNET,
    type: ie.TESTNET,
    name: "etherlink-testnet",
    title: "Etherlink Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.ETHERLINK_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherlink Testnet Explorer",
      rootUrl: "https://testnet.explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [v.MONAD_TESTNET]: {
    chainId: v.MONAD_TESTNET,
    type: ie.TESTNET,
    name: "monad-testnet",
    title: "Monad Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.MONAD_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Monad Testnet Explorer",
      rootUrl: "https://testnet.monadexplorer.com/"
    },
    nativeToken: {
      symbol: "MON",
      name: "MON",
      decimals: 18
    }
  },
  [v.SOMNIA_TESTNET]: {
    chainId: v.SOMNIA_TESTNET,
    type: ie.TESTNET,
    name: "somnia-testnet",
    title: "Somnia Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SOMNIA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Somnia Testnet Explorer",
      rootUrl: "https://somnia-testnet.socialscan.io/"
    },
    nativeToken: {
      symbol: "STT",
      name: "STT",
      decimals: 18
    }
  },
  [v.INCENTIV_TESTNET]: {
    chainId: v.INCENTIV_TESTNET,
    type: ie.TESTNET,
    name: "incentiv-testnet",
    title: "Incentiv Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.INCENTIV_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Incentiv Testnet Explorer",
      rootUrl: "https://explorer.testnet.incentiv.net/"
    },
    nativeToken: {
      symbol: "CENT",
      name: "CENT",
      decimals: 18
    }
  },
  [v.SEI]: {
    chainId: v.SEI,
    type: ie.MAINNET,
    name: "sei",
    title: "Sei",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SEI}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "SEI Explorer",
      rootUrl: "https://seitrace.com/?chain=pacific-1"
    },
    nativeToken: {
      symbol: "SEI",
      name: "SEI",
      decimals: 18
    }
  },
  [v.SEI_TESTNET]: {
    chainId: v.SEI_TESTNET,
    type: ie.TESTNET,
    name: "sei-testnet",
    title: "Sei Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SEI_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Sei Testnet Explorer",
      rootUrl: "https://seitrace.com/?chain=atlantic-2"
    },
    nativeToken: {
      symbol: "SEI",
      name: "SEI",
      decimals: 18
    }
  },
  [v.SOMNIA]: {
    chainId: v.SOMNIA,
    type: ie.MAINNET,
    name: "somnia",
    title: "Somnia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${v.SOMNIA}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Somnia Explorer",
      rootUrl: "https://mainnet.somnia.w3us.site/"
    },
    nativeToken: {
      symbol: "SOMI",
      name: "SOMI",
      decimals: 18
    }
  }
}, mI = "6.15.0";
function yI(t, e, n) {
  const r = e.split("|").map((a) => a.trim());
  for (let a = 0; a < r.length; a++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof t === e)
          return;
    }
  const s = new Error(`invalid value for type ${e}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${n}`, s.value = t, s;
}
async function Tt(t) {
  const e = Object.keys(t);
  return (await Promise.all(e.map((r) => Promise.resolve(t[r])))).reduce((r, s, a) => (r[e[a]] = s, r), {});
}
function le(t, e, n) {
  for (let r in e) {
    let s = e[r];
    const a = n ? n[r] : null;
    a && yI(s, a, r), Object.defineProperty(t, r, { enumerable: !0, value: s, writable: !1 });
  }
}
function ac(t, e) {
  if (t == null)
    return "null";
  if (e == null && (e = /* @__PURE__ */ new Set()), typeof t == "object") {
    if (e.has(t))
      return "[Circular]";
    e.add(t);
  }
  if (Array.isArray(t))
    return "[ " + t.map((n) => ac(n, e)).join(", ") + " ]";
  if (t instanceof Uint8Array) {
    const n = "0123456789abcdef";
    let r = "0x";
    for (let s = 0; s < t.length; s++)
      r += n[t[s] >> 4], r += n[t[s] & 15];
    return r;
  }
  if (typeof t == "object" && typeof t.toJSON == "function")
    return ac(t.toJSON(), e);
  switch (typeof t) {
    case "boolean":
    case "number":
    case "symbol":
      return t.toString();
    case "bigint":
      return BigInt(t).toString();
    case "string":
      return JSON.stringify(t);
    case "object": {
      const n = Object.keys(t);
      return n.sort(), "{ " + n.map((r) => `${ac(r, e)}: ${ac(t[r], e)}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function Bt(t, e) {
  return t && t.code === e;
}
function T1(t) {
  return Bt(t, "CALL_EXCEPTION");
}
function je(t, e, n) {
  let r = t;
  {
    const a = [];
    if (n) {
      if ("message" in n || "code" in n || "name" in n)
        throw new Error(`value will overwrite populated values: ${ac(n)}`);
      for (const i in n) {
        if (i === "shortMessage")
          continue;
        const o = n[i];
        a.push(i + "=" + ac(o));
      }
    }
    a.push(`code=${e}`), a.push(`version=${mI}`), a.length && (t += " (" + a.join(", ") + ")");
  }
  let s;
  switch (e) {
    case "INVALID_ARGUMENT":
      s = new TypeError(t);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(t);
      break;
    default:
      s = new Error(t);
  }
  return le(s, { code: e }), n && Object.assign(s, n), s.shortMessage == null && le(s, { shortMessage: r }), s;
}
function q(t, e, n, r) {
  if (!t)
    throw je(e, n, r);
}
function U(t, e, n, r) {
  q(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
}
function ok(t, e, n) {
  n == null && (n = ""), n && (n = ": " + n), q(t >= e, "missing argument" + n, "MISSING_ARGUMENT", {
    count: t,
    expectedCount: e
  }), q(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
    count: t,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    t.push(e);
  } catch {
  }
  return t;
}, []);
function Hh(t, e, n) {
  if (n == null && (n = ""), t !== e) {
    let r = n, s = "new";
    n && (r += ".", s += " " + n), q(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function ck(t, e, n) {
  if (t instanceof Uint8Array)
    return n ? new Uint8Array(t) : t;
  if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((t.length - 2) / 2);
    let s = 2;
    for (let a = 0; a < r.length; a++)
      r[a] = parseInt(t.substring(s, s + 2), 16), s += 2;
    return r;
  }
  U(!1, "invalid BytesLike value", e || "value", t);
}
function ee(t, e) {
  return ck(t, e, !1);
}
function ln(t, e) {
  return ck(t, e, !0);
}
function Re(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === !0 && t.length % 2 !== 0);
}
function ko(t) {
  return Re(t, !0) || t instanceof Uint8Array;
}
const jE = "0123456789abcdef";
function z(t) {
  const e = ee(t);
  let n = "0x";
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    n += jE[(s & 240) >> 4] + jE[s & 15];
  }
  return n;
}
function _e(t) {
  return "0x" + t.map((e) => z(e).substring(2)).join("");
}
function fo(t) {
  return Re(t, !0) ? (t.length - 2) / 2 : ee(t).length;
}
function Ve(t, e, n) {
  const r = ee(t);
  return n != null && n > r.length && q(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: r,
    length: r.length,
    offset: n
  }), z(r.slice(e ?? 0, n ?? r.length));
}
function lk(t, e, n) {
  const r = ee(t);
  q(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: e,
    offset: e + 1
  });
  const s = new Uint8Array(e);
  return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), z(s);
}
function Mn(t, e) {
  return lk(t, e, !0);
}
function uk(t, e) {
  return lk(t, e, !1);
}
const _h = BigInt(0), Cr = BigInt(1), ic = 9007199254740991;
function bI(t, e) {
  const n = $h(t, "value"), r = BigInt(Ee(e, "width"));
  if (q(n >> r === _h, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: t
  }), n >> r - Cr) {
    const s = (Cr << r) - Cr;
    return -((~n & s) + Cr);
  }
  return n;
}
function S1(t, e) {
  let n = re(t, "value");
  const r = BigInt(Ee(e, "width")), s = Cr << r - Cr;
  if (n < _h) {
    n = -n, q(n <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
    const a = (Cr << r) - Cr;
    return (~n & a) + Cr;
  } else
    q(n < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
  return n;
}
function Pu(t, e) {
  const n = $h(t, "value"), r = BigInt(Ee(e, "bits"));
  return n & (Cr << r) - Cr;
}
function re(t, e) {
  switch (typeof t) {
    case "bigint":
      return t;
    case "number":
      return U(Number.isInteger(t), "underflow", e || "value", t), U(t >= -ic && t <= ic, "overflow", e || "value", t), BigInt(t);
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t);
      } catch (n) {
        U(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t);
      }
  }
  U(!1, "invalid BigNumberish value", e || "value", t);
}
function $h(t, e) {
  const n = re(t, e);
  return q(n >= _h, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: t
  }), n;
}
const VE = "0123456789abcdef";
function I1(t) {
  if (t instanceof Uint8Array) {
    let e = "0x0";
    for (const n of t)
      e += VE[n >> 4], e += VE[n & 15];
    return BigInt(e);
  }
  return re(t);
}
function Ee(t, e) {
  switch (typeof t) {
    case "bigint":
      return U(t >= -ic && t <= ic, "overflow", e || "value", t), Number(t);
    case "number":
      return U(Number.isInteger(t), "underflow", e || "value", t), U(t >= -ic && t <= ic, "overflow", e || "value", t), t;
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return Ee(BigInt(t), e);
      } catch (n) {
        U(!1, `invalid numeric string: ${n.message}`, e || "value", t);
      }
  }
  U(!1, "invalid numeric value", e || "value", t);
}
function gI(t) {
  return Ee(I1(t));
}
function Ir(t, e) {
  let r = $h(t, "value").toString(16);
  if (e == null)
    r.length % 2 && (r = "0" + r);
  else {
    const s = Ee(e, "width");
    for (q(s * 2 >= r.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: t
    }); r.length < s * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function dt(t) {
  const e = $h(t, "value");
  if (e === _h)
    return new Uint8Array([]);
  let n = e.toString(16);
  n.length % 2 && (n = "0" + n);
  const r = new Uint8Array(n.length / 2);
  for (let s = 0; s < r.length; s++) {
    const a = s * 2;
    r[s] = parseInt(n.substring(a, a + 2), 16);
  }
  return r;
}
function kr(t) {
  let e = z(ko(t) ? t : dt(t)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const qE = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const KE = BigInt(58);
function wI(t) {
  const e = ee(t);
  let n = I1(e), r = "";
  for (; n; )
    r = qE[Number(n % KE)] + r, n /= KE;
  for (let s = 0; s < e.length && !e[s]; s++)
    r = qE[0] + r;
  return r;
}
function EI(t) {
  t = atob(t);
  const e = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    e[n] = t.charCodeAt(n);
  return ee(e);
}
function xI(t) {
  const e = ee(t);
  let n = "";
  for (let r = 0; r < e.length; r++)
    n += String.fromCharCode(e[r]);
  return btoa(n);
}
var Hc;
class dk {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, n, r) {
    /**
     *  The event filter.
     */
    O(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    O(this, "emitter");
    B(this, Hc);
    x(this, Hc, n), le(this, { emitter: e, filter: r });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    m(this, Hc) != null && await this.emitter.off(this.filter, m(this, Hc));
  }
}
Hc = new WeakMap();
function AI(t, e, n, r, s) {
  U(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
}
function fk(t, e, n, r, s) {
  if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
    let a = 0;
    for (let i = e + 1; i < n.length && n[i] >> 6 === 2; i++)
      a++;
    return a;
  }
  return t === "OVERRUN" ? n.length - e - 1 : 0;
}
function kI(t, e, n, r, s) {
  return t === "OVERLONG" ? (U(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), r.push(s), 0) : (r.push(65533), fk(t, e, n));
}
const vI = Object.freeze({
  error: AI,
  ignore: fk,
  replace: kI
});
function CI(t, e) {
  e == null && (e = vI.error);
  const n = ee(t, "bytes"), r = [];
  let s = 0;
  for (; s < n.length; ) {
    const a = n[s++];
    if (!(a >> 7)) {
      r.push(a);
      continue;
    }
    let i = null, o = null;
    if ((a & 224) === 192)
      i = 1, o = 127;
    else if ((a & 240) === 224)
      i = 2, o = 2047;
    else if ((a & 248) === 240)
      i = 3, o = 65535;
    else {
      (a & 192) === 128 ? s += e("UNEXPECTED_CONTINUE", s - 1, n, r) : s += e("BAD_PREFIX", s - 1, n, r);
      continue;
    }
    if (s - 1 + i >= n.length) {
      s += e("OVERRUN", s - 1, n, r);
      continue;
    }
    let c = a & (1 << 8 - i - 1) - 1;
    for (let u = 0; u < i; u++) {
      let l = n[s];
      if ((l & 192) != 128) {
        s += e("MISSING_CONTINUE", s, n, r), c = null;
        break;
      }
      c = c << 6 | l & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += e("OUT_OF_RANGE", s - 1 - i, n, r, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += e("UTF16_SURROGATE", s - 1 - i, n, r, c);
        continue;
      }
      if (c <= o) {
        s += e("OVERLONG", s - 1 - i, n, r, c);
        continue;
      }
      r.push(c);
    }
  }
  return r;
}
function kn(t, e) {
  U(typeof t == "string", "invalid string value", "str", t);
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t.charCodeAt(r);
    if (s < 128)
      n.push(s);
    else if (s < 2048)
      n.push(s >> 6 | 192), n.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      r++;
      const a = t.charCodeAt(r);
      U(r < t.length && (a & 64512) === 56320, "invalid surrogate pair", "str", t);
      const i = 65536 + ((s & 1023) << 10) + (a & 1023);
      n.push(i >> 18 | 240), n.push(i >> 12 & 63 | 128), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
    } else
      n.push(s >> 12 | 224), n.push(s >> 6 & 63 | 128), n.push(s & 63 | 128);
  }
  return new Uint8Array(n);
}
function TI(t) {
  return t.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function _p(t, e) {
  return TI(CI(t, e));
}
function pk(t) {
  async function e(n, r) {
    q(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
    const s = n.url.split(":")[0].toLowerCase();
    q(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), q(s === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let a = null;
    const i = new AbortController(), o = setTimeout(() => {
      a = je("request timeout", "TIMEOUT"), i.abort();
    }, n.timeout);
    r && r.addListener(() => {
      a = je("request cancelled", "CANCELLED"), i.abort();
    });
    const c = Object.assign({}, t, {
      method: n.method,
      headers: new Headers(Array.from(n)),
      body: n.body || void 0,
      signal: i.signal
    });
    let u;
    try {
      u = await fetch(n.url, c);
    } catch (f) {
      throw clearTimeout(o), a || f;
    }
    clearTimeout(o);
    const l = {};
    u.headers.forEach((f, b) => {
      l[b.toLowerCase()] = f;
    });
    const d = await u.arrayBuffer(), p = d == null ? null : new Uint8Array(d);
    return {
      statusCode: u.status,
      statusMessage: u.statusText,
      headers: l,
      body: p
    };
  }
  return e;
}
const SI = 12, II = 250;
let WE = pk();
const OI = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), BI = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let u0 = !1;
async function hk(t, e) {
  try {
    const n = t.match(OI);
    if (!n)
      throw new Error("invalid data");
    return new qa(200, "OK", {
      "content-type": n[1] || "text/plain"
    }, n[2] ? EI(n[3]) : UI(n[3]));
  } catch {
    return new qa(599, "BAD REQUEST (invalid data: URI)", {}, null, new as(t));
  }
}
function mk(t) {
  async function e(n, r) {
    try {
      const s = n.match(BI);
      if (!s)
        throw new Error("invalid link");
      return new as(`${t}${s[2]}`);
    } catch {
      return new qa(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new as(n));
    }
  }
  return e;
}
const kf = {
  data: hk,
  ipfs: mk("https://gateway.ipfs.io/ipfs/")
}, yk = /* @__PURE__ */ new WeakMap();
var ji, Ca;
class PI {
  constructor(e) {
    B(this, ji);
    B(this, Ca);
    x(this, ji, []), x(this, Ca, !1), yk.set(e, () => {
      if (!m(this, Ca)) {
        x(this, Ca, !0);
        for (const n of m(this, ji))
          setTimeout(() => {
            n();
          }, 0);
        x(this, ji, []);
      }
    });
  }
  addListener(e) {
    q(!m(this, Ca), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), m(this, ji).push(e);
  }
  get cancelled() {
    return m(this, Ca);
  }
  checkSignal() {
    q(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
ji = new WeakMap(), Ca = new WeakMap();
function vf(t) {
  if (t == null)
    throw new Error("missing signal; should not happen");
  return t.checkSignal(), t;
}
var _c, $c, gr, Cs, Gc, zc, gt, Nn, Ts, Vi, qi, Ki, qr, wr, Ta, Wi, Uu;
const Ph = class Ph {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    B(this, Wi);
    B(this, _c);
    B(this, $c);
    B(this, gr);
    B(this, Cs);
    B(this, Gc);
    B(this, zc);
    B(this, gt);
    B(this, Nn);
    B(this, Ts);
    // Hooks
    B(this, Vi);
    B(this, qi);
    B(this, Ki);
    B(this, qr);
    B(this, wr);
    B(this, Ta);
    x(this, zc, String(e)), x(this, _c, !1), x(this, $c, !0), x(this, gr, {}), x(this, Cs, ""), x(this, Gc, 3e5), x(this, wr, {
      slotInterval: II,
      maxAttempts: SI
    }), x(this, Ta, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return m(this, zc);
  }
  set url(e) {
    x(this, zc, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return m(this, gt) == null ? null : new Uint8Array(m(this, gt));
  }
  set body(e) {
    if (e == null)
      x(this, gt, void 0), x(this, Nn, void 0);
    else if (typeof e == "string")
      x(this, gt, kn(e)), x(this, Nn, "text/plain");
    else if (e instanceof Uint8Array)
      x(this, gt, e), x(this, Nn, "application/octet-stream");
    else if (typeof e == "object")
      x(this, gt, kn(JSON.stringify(e))), x(this, Nn, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return m(this, gt) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return m(this, Cs) ? m(this, Cs) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), x(this, Cs, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, m(this, gr));
    return m(this, Ts) && (e.authorization = `Basic ${xI(kn(m(this, Ts)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && m(this, Nn) && (e["content-type"] = m(this, Nn)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, n) {
    m(this, gr)[String(e).toLowerCase()] = String(n);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    x(this, gr, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return m(this, Ts) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, n) {
    U(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), x(this, Ts, `${e}:${n}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return m(this, $c);
  }
  set allowGzip(e) {
    x(this, $c, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!m(this, _c);
  }
  set allowInsecureAuthentication(e) {
    x(this, _c, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return m(this, Gc);
  }
  set timeout(e) {
    U(e >= 0, "timeout must be non-zero", "timeout", e), x(this, Gc, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return m(this, Vi) || null;
  }
  set preflightFunc(e) {
    x(this, Vi, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return m(this, qi) || null;
  }
  set processFunc(e) {
    x(this, qi, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return m(this, Ki) || null;
  }
  set retryFunc(e) {
    x(this, Ki, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return m(this, Ta) || WE;
  }
  set getUrlFunc(e) {
    x(this, Ta, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${m(this, gt) ? z(m(this, gt)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (m(this, wr).slotInterval = e.slotInterval), e.maxAttempts != null && (m(this, wr).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return q(m(this, qr) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), x(this, qr, new PI(this)), G(this, Wi, Uu).call(this, 0, QE() + this.timeout, 0, this, new qa(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    q(m(this, qr) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = yk.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const n = this.url.split(":")[0].toLowerCase(), r = e.split(":")[0].toLowerCase();
    q(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const s = new Ph(e);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, x(s, gr, Object.assign({}, m(this, gr))), m(this, gt) && x(s, gt, new Uint8Array(m(this, gt))), x(s, Nn, m(this, Nn)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new Ph(this.url);
    return x(e, Cs, m(this, Cs)), m(this, gt) && x(e, gt, m(this, gt)), x(e, Nn, m(this, Nn)), x(e, gr, Object.assign({}, m(this, gr))), x(e, Ts, m(this, Ts)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), x(e, Vi, m(this, Vi)), x(e, qi, m(this, qi)), x(e, Ki, m(this, Ki)), x(e, wr, Object.assign({}, m(this, wr))), x(e, Ta, m(this, Ta)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    u0 = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return kf[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, n) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (u0)
      throw new Error("gateways locked");
    kf[e] = n;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (u0)
      throw new Error("gateways locked");
    WE = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return pk(e);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return hk;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return mk(e);
  }
};
_c = new WeakMap(), $c = new WeakMap(), gr = new WeakMap(), Cs = new WeakMap(), Gc = new WeakMap(), zc = new WeakMap(), gt = new WeakMap(), Nn = new WeakMap(), Ts = new WeakMap(), Vi = new WeakMap(), qi = new WeakMap(), Ki = new WeakMap(), qr = new WeakMap(), wr = new WeakMap(), Ta = new WeakMap(), Wi = new WeakSet(), Uu = async function(e, n, r, s, a) {
  var l, d, p;
  if (e >= m(this, wr).maxAttempts)
    return a.makeServerError("exceeded maximum retry limit");
  q(QE() <= n, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), r > 0 && await NI(r);
  let i = this.clone();
  const o = (i.url.split(":")[0] || "").toLowerCase();
  if (o in kf) {
    const f = await kf[o](i.url, vf(m(s, qr)));
    if (f instanceof qa) {
      let b = f;
      if (this.processFunc) {
        vf(m(s, qr));
        try {
          b = await this.processFunc(i, b);
        } catch (y) {
          (y.throttle == null || typeof y.stall != "number") && b.makeServerError("error in post-processing function", y).assertOk();
        }
      }
      return b;
    }
    i = f;
  }
  this.preflightFunc && (i = await this.preflightFunc(i));
  const c = await this.getUrlFunc(i, vf(m(s, qr)));
  let u = new qa(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const f = u.headers.location || "";
      return G(l = i.redirect(f), Wi, Uu).call(l, e + 1, n, 0, s, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(i, u, e))) {
    const f = u.headers["retry-after"];
    let b = m(this, wr).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
    return typeof f == "string" && f.match(/^[1-9][0-9]*$/) && (b = parseInt(f)), G(d = i.clone(), Wi, Uu).call(d, e + 1, n, b, s, u);
  }
  if (this.processFunc) {
    vf(m(s, qr));
    try {
      u = await this.processFunc(i, u);
    } catch (f) {
      (f.throttle == null || typeof f.stall != "number") && u.makeServerError("error in post-processing function", f).assertOk();
      let b = m(this, wr).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return f.stall >= 0 && (b = f.stall), G(p = i.clone(), Wi, Uu).call(p, e + 1, n, b, s, u);
    }
  }
  return u;
};
let as = Ph;
var Dd, Fd, Md, Rn, jc, Qi;
const IE = class IE {
  constructor(e, n, r, s, a) {
    B(this, Dd);
    B(this, Fd);
    B(this, Md);
    B(this, Rn);
    B(this, jc);
    B(this, Qi);
    x(this, Dd, e), x(this, Fd, n), x(this, Md, Object.keys(r).reduce((i, o) => (i[o.toLowerCase()] = String(r[o]), i), {})), x(this, Rn, s == null ? null : new Uint8Array(s)), x(this, jc, a || null), x(this, Qi, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${m(this, Rn) ? z(m(this, Rn)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return m(this, Dd);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return m(this, Fd);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, m(this, Md));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return m(this, Rn) == null ? null : new Uint8Array(m(this, Rn));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return m(this, Rn) == null ? "" : _p(m(this, Rn));
    } catch {
      q(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      q(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, n) {
    let r;
    e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const s = new IE(599, r, this.headers, this.body, m(this, jc) || void 0);
    return x(s, Qi, { message: e, error: n }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, n) {
    n == null ? n = -1 : U(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
    const r = new Error(e || "throttling requests");
    throw le(r, { stall: n, throttle: !0 }), r;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return m(this, Rn) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return m(this, jc);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return m(this, Qi).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: n } = m(this, Qi);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let s = null;
    try {
      m(this, Rn) && (s = _p(m(this, Rn)));
    } catch {
    }
    q(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: n,
      info: {
        requestUrl: r,
        responseBody: s,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
Dd = new WeakMap(), Fd = new WeakMap(), Md = new WeakMap(), Rn = new WeakMap(), jc = new WeakMap(), Qi = new WeakMap();
let qa = IE;
function QE() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function UI(t) {
  return kn(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))));
}
function NI(t) {
  return new Promise((e) => setTimeout(e, t));
}
function RI(t) {
  let e = t.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function JE(t, e, n) {
  let r = 0;
  for (let s = 0; s < n; s++)
    r = r * 256 + t[e + s];
  return r;
}
function XE(t, e, n, r) {
  const s = [];
  for (; n < e + 1 + r; ) {
    const a = bk(t, n);
    s.push(a.result), n += a.consumed, q(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: r,
      offset: e
    });
  }
  return { consumed: 1 + r, result: s };
}
function bk(t, e) {
  q(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: t,
    length: 0,
    offset: 1
  });
  const n = (r) => {
    q(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: t.length,
      offset: r
    });
  };
  if (t[e] >= 248) {
    const r = t[e] - 247;
    n(e + 1 + r);
    const s = JE(t, e + 1, r);
    return n(e + 1 + r + s), XE(t, e, e + 1 + r, r + s);
  } else if (t[e] >= 192) {
    const r = t[e] - 192;
    return n(e + 1 + r), XE(t, e, e + 1, r);
  } else if (t[e] >= 184) {
    const r = t[e] - 183;
    n(e + 1 + r);
    const s = JE(t, e + 1, r);
    n(e + 1 + r + s);
    const a = z(t.slice(e + 1 + r, e + 1 + r + s));
    return { consumed: 1 + r + s, result: a };
  } else if (t[e] >= 128) {
    const r = t[e] - 128;
    n(e + 1 + r);
    const s = z(t.slice(e + 1, e + 1 + r));
    return { consumed: 1 + r, result: s };
  }
  return { consumed: 1, result: RI(t[e]) };
}
function Qd(t) {
  const e = ee(t, "data"), n = bk(e, 0);
  return U(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result;
}
function ZE(t) {
  const e = [];
  for (; t; )
    e.unshift(t & 255), t >>= 8;
  return e;
}
function gk(t) {
  if (Array.isArray(t)) {
    let r = [];
    if (t.forEach(function(a) {
      r = r.concat(gk(a));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const s = ZE(r.length);
    return s.unshift(247 + s.length), s.concat(r);
  }
  const e = Array.prototype.slice.call(ee(t, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const n = ZE(e.length);
  return n.unshift(183 + n.length), n.concat(e);
}
const YE = "0123456789abcdef";
function Ya(t) {
  let e = "0x";
  for (const n of gk(t))
    e += YE[n >> 4], e += YE[n & 15];
  return e;
}
const un = 32, Sy = new Uint8Array(un), DI = ["then"], Cf = {}, wk = /* @__PURE__ */ new WeakMap();
function yi(t) {
  return wk.get(t);
}
function ex(t, e) {
  wk.set(t, e);
}
function cu(t, e) {
  const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
  throw n.error = e, n;
}
function Iy(t, e, n) {
  return t.indexOf(null) >= 0 ? e.map((r, s) => r instanceof Cl ? Iy(yi(r), r, n) : r) : t.reduce((r, s, a) => {
    let i = e.getValue(s);
    return s in r || (n && i instanceof Cl && (i = Iy(yi(i), i, n)), r[s] = i), r;
  }, {});
}
var Vc;
const pc = class pc extends Array {
  /**
   *  @private
   */
  constructor(...n) {
    const r = n[0];
    let s = n[1], a = (n[2] || []).slice(), i = !0;
    r !== Cf && (s = n, a = [], i = !1);
    super(s.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    B(this, Vc);
    s.forEach((u, l) => {
      this[l] = u;
    });
    const o = a.reduce((u, l) => (typeof l == "string" && u.set(l, (u.get(l) || 0) + 1), u), /* @__PURE__ */ new Map());
    if (ex(this, Object.freeze(s.map((u, l) => {
      const d = a[l];
      return d != null && o.get(d) === 1 ? d : null;
    }))), x(this, Vc, []), m(this, Vc) == null && m(this, Vc), !i)
      return;
    Object.freeze(this);
    const c = new Proxy(this, {
      get: (u, l, d) => {
        if (typeof l == "string") {
          if (l.match(/^[0-9]+$/)) {
            const f = Ee(l, "%index");
            if (f < 0 || f >= this.length)
              throw new RangeError("out of result range");
            const b = u[f];
            return b instanceof Error && cu(`index ${f}`, b), b;
          }
          if (DI.indexOf(l) >= 0)
            return Reflect.get(u, l, d);
          const p = u[l];
          if (p instanceof Function)
            return function(...f) {
              return p.apply(this === d ? u : this, f);
            };
          if (!(l in u))
            return u.getValue.apply(this === d ? u : this, [l]);
        }
        return Reflect.get(u, l, d);
      }
    });
    return ex(c, yi(this)), c;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(n) {
    const r = [];
    return this.forEach((s, a) => {
      s instanceof Error && cu(`index ${a}`, s), n && s instanceof pc && (s = s.toArray(n)), r.push(s);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(n) {
    const r = yi(this);
    return r.reduce((s, a, i) => (q(a != null, `value at index ${i} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), Iy(r, this, n)), {});
  }
  /**
   *  @_ignore
   */
  slice(n, r) {
    n == null && (n = 0), n < 0 && (n += this.length, n < 0 && (n = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const s = yi(this), a = [], i = [];
    for (let o = n; o < r; o++)
      a.push(this[o]), i.push(s[o]);
    return new pc(Cf, a, i);
  }
  /**
   *  @_ignore
   */
  filter(n, r) {
    const s = yi(this), a = [], i = [];
    for (let o = 0; o < this.length; o++) {
      const c = this[o];
      c instanceof Error && cu(`index ${o}`, c), n.call(r, c, o, this) && (a.push(c), i.push(s[o]));
    }
    return new pc(Cf, a, i);
  }
  /**
   *  @_ignore
   */
  map(n, r) {
    const s = [];
    for (let a = 0; a < this.length; a++) {
      const i = this[a];
      i instanceof Error && cu(`index ${a}`, i), s.push(n.call(r, i, a, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(n) {
    const r = yi(this).indexOf(n);
    if (r === -1)
      return;
    const s = this[r];
    return s instanceof Error && cu(`property ${JSON.stringify(n)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(n, r) {
    return new pc(Cf, n, r);
  }
};
Vc = new WeakMap();
let Cl = pc;
function tx(t) {
  let e = dt(t);
  return q(e.length <= un, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: un, offset: e.length }), e.length !== un && (e = ln(_e([Sy.slice(e.length % un), e]))), e;
}
class Ws {
  constructor(e, n, r, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    O(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    O(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    O(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    O(this, "dynamic");
    le(this, { name: e, type: n, localName: r, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, n) {
    U(!1, e, this.localName, n);
  }
}
var Ss, Ji, qc, yp;
class Oy {
  constructor() {
    B(this, qc);
    // An array of WordSize lengthed objects to concatenation
    B(this, Ss);
    B(this, Ji);
    x(this, Ss, []), x(this, Ji, 0);
  }
  get data() {
    return _e(m(this, Ss));
  }
  get length() {
    return m(this, Ji);
  }
  appendWriter(e) {
    return G(this, qc, yp).call(this, ln(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let n = ln(e);
    const r = n.length % un;
    return r && (n = ln(_e([n, Sy.slice(r)]))), G(this, qc, yp).call(this, n);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return G(this, qc, yp).call(this, tx(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = m(this, Ss).length;
    return m(this, Ss).push(Sy), x(this, Ji, m(this, Ji) + un), (n) => {
      m(this, Ss)[e] = tx(n);
    };
  }
}
Ss = new WeakMap(), Ji = new WeakMap(), qc = new WeakSet(), yp = function(e) {
  return m(this, Ss).push(e), x(this, Ji, m(this, Ji) + e.length), e.length;
};
var gn, Dn, Xi, Zi, Sa, Lo, Py, Ek;
const OE = class OE {
  constructor(e, n, r) {
    B(this, Lo);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    O(this, "allowLoose");
    B(this, gn);
    B(this, Dn);
    B(this, Xi);
    B(this, Zi);
    B(this, Sa);
    le(this, { allowLoose: !!n }), x(this, gn, ln(e)), x(this, Xi, 0), x(this, Zi, null), x(this, Sa, r ?? 1024), x(this, Dn, 0);
  }
  get data() {
    return z(m(this, gn));
  }
  get dataLength() {
    return m(this, gn).length;
  }
  get consumed() {
    return m(this, Dn);
  }
  get bytes() {
    return new Uint8Array(m(this, gn));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const n = new OE(m(this, gn).slice(m(this, Dn) + e), this.allowLoose, m(this, Sa));
    return x(n, Zi, this), n;
  }
  // Read bytes
  readBytes(e, n) {
    let r = G(this, Lo, Ek).call(this, 0, e, !!n);
    return G(this, Lo, Py).call(this, e), x(this, Dn, m(this, Dn) + r.length), r.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return I1(this.readBytes(un));
  }
  readIndex() {
    return gI(this.readBytes(un));
  }
};
gn = new WeakMap(), Dn = new WeakMap(), Xi = new WeakMap(), Zi = new WeakMap(), Sa = new WeakMap(), Lo = new WeakSet(), Py = function(e) {
  var n;
  if (m(this, Zi))
    return G(n = m(this, Zi), Lo, Py).call(n, e);
  x(this, Xi, m(this, Xi) + e), q(m(this, Sa) < 1 || m(this, Xi) <= m(this, Sa) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${m(this, Sa)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: ln(m(this, gn)),
    offset: m(this, Dn),
    length: e,
    info: {
      bytesRead: m(this, Xi),
      dataLength: this.dataLength
    }
  });
}, Ek = function(e, n, r) {
  let s = Math.ceil(n / un) * un;
  return m(this, Dn) + s > m(this, gn).length && (this.allowLoose && r && m(this, Dn) + n <= m(this, gn).length ? s = n : q(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: ln(m(this, gn)),
    length: m(this, gn).length,
    offset: m(this, Dn) + s
  })), m(this, gn).slice(m(this, Dn), m(this, Dn) + s);
};
let By = OE;
function $p(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function O1(t, ...e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function FI(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  $p(t.outputLen), $p(t.blockLen);
}
function Tl(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function xk(t, e) {
  O1(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const d0 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ak = (t) => t instanceof Uint8Array, MI = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), f0 = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Mr = (t, e) => t << 32 - e | t >>> e, LI = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!LI)
  throw new Error("Non little-endian hardware is not supported");
function HI(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Gh(t) {
  if (typeof t == "string" && (t = HI(t)), !Ak(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
function _I(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!Ak(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
let B1 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function P1(t) {
  const e = (r) => t().update(Gh(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function $I(t = 32) {
  if (d0 && typeof d0.getRandomValues == "function")
    return d0.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
let kk = class extends B1 {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, FI(e);
    const r = Gh(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(e) {
    return Tl(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Tl(this), O1(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const vk = (t, e, n) => new kk(t, e).update(n).digest();
vk.create = (t, e) => new kk(t, e);
function GI(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
class Ck extends B1 {
  constructor(e, n, r, s) {
    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = f0(this.buffer);
  }
  update(e) {
    Tl(this);
    const { view: n, buffer: r, blockLen: s } = this;
    e = Gh(e);
    const a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = f0(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Tl(this), xk(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    GI(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = f0(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.length = s, e.pos = o, e.finished = a, e.destroyed = i, s % n && e.buffer.set(r), e;
  }
}
const zI = (t, e, n) => t & e ^ ~t & n, jI = (t, e, n) => t & e ^ t & n ^ e & n, VI = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), aa = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ia = /* @__PURE__ */ new Uint32Array(64);
let qI = class extends Ck {
  constructor() {
    super(64, 32, 8, !1), this.A = aa[0] | 0, this.B = aa[1] | 0, this.C = aa[2] | 0, this.D = aa[3] | 0, this.E = aa[4] | 0, this.F = aa[5] | 0, this.G = aa[6] | 0, this.H = aa[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      ia[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const p = ia[d - 15], f = ia[d - 2], b = Mr(p, 7) ^ Mr(p, 18) ^ p >>> 3, y = Mr(f, 17) ^ Mr(f, 19) ^ f >>> 10;
      ia[d] = y + ia[d - 7] + b + ia[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const p = Mr(o, 6) ^ Mr(o, 11) ^ Mr(o, 25), f = l + p + zI(o, c, u) + VI[d] + ia[d] | 0, y = (Mr(r, 2) ^ Mr(r, 13) ^ Mr(r, 22)) + jI(r, s, a) | 0;
      l = u, u = c, c = o, o = i + f | 0, i = a, a = s, s = r, r = f + y | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    ia.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const Tk = /* @__PURE__ */ P1(() => new qI()), Tf = /* @__PURE__ */ BigInt(2 ** 32 - 1), Uy = /* @__PURE__ */ BigInt(32);
function Sk(t, e = !1) {
  return e ? { h: Number(t & Tf), l: Number(t >> Uy & Tf) } : { h: Number(t >> Uy & Tf) | 0, l: Number(t & Tf) | 0 };
}
function Ik(t, e = !1) {
  let n = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: a, l: i } = Sk(t[s], e);
    [n[s], r[s]] = [a, i];
  }
  return [n, r];
}
const KI = (t, e) => BigInt(t >>> 0) << Uy | BigInt(e >>> 0), WI = (t, e, n) => t >>> n, QI = (t, e, n) => t << 32 - n | e >>> n, JI = (t, e, n) => t >>> n | e << 32 - n, XI = (t, e, n) => t << 32 - n | e >>> n, ZI = (t, e, n) => t << 64 - n | e >>> n - 32, YI = (t, e, n) => t >>> n - 32 | e << 64 - n, eO = (t, e) => e, tO = (t, e) => t, Ok = (t, e, n) => t << n | e >>> 32 - n, Bk = (t, e, n) => e << n | t >>> 32 - n, Pk = (t, e, n) => e << n - 32 | t >>> 64 - n, Uk = (t, e, n) => t << n - 32 | e >>> 64 - n;
function nO(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const rO = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), sO = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, aO = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), iO = (t, e, n, r, s) => e + n + r + s + (t / 2 ** 32 | 0) | 0, oO = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), cO = (t, e, n, r, s, a) => e + n + r + s + a + (t / 2 ** 32 | 0) | 0, ye = {
  fromBig: Sk,
  split: Ik,
  toBig: KI,
  shrSH: WI,
  shrSL: QI,
  rotrSH: JI,
  rotrSL: XI,
  rotrBH: ZI,
  rotrBL: YI,
  rotr32H: eO,
  rotr32L: tO,
  rotlSH: Ok,
  rotlSL: Bk,
  rotlBH: Pk,
  rotlBL: Uk,
  add: nO,
  add3L: rO,
  add3H: sO,
  add4L: aO,
  add4H: iO,
  add5H: cO,
  add5L: oO
}, [lO, uO] = ye.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), oa = /* @__PURE__ */ new Uint32Array(80), ca = /* @__PURE__ */ new Uint32Array(80);
let dO = class extends Ck {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: a, Cl: i, Dh: o, Dl: c, Eh: u, El: l, Fh: d, Fl: p, Gh: f, Gl: b, Hh: y, Hl: g } = this;
    return [e, n, r, s, a, i, o, c, u, l, d, p, f, b, y, g];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c, u, l, d, p, f, b, y, g) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = p | 0, this.Gh = f | 0, this.Gl = b | 0, this.Hh = y | 0, this.Hl = g | 0;
  }
  process(e, n) {
    for (let E = 0; E < 16; E++, n += 4)
      oa[E] = e.getUint32(n), ca[E] = e.getUint32(n += 4);
    for (let E = 16; E < 80; E++) {
      const T = oa[E - 15] | 0, A = ca[E - 15] | 0, N = ye.rotrSH(T, A, 1) ^ ye.rotrSH(T, A, 8) ^ ye.shrSH(T, A, 7), D = ye.rotrSL(T, A, 1) ^ ye.rotrSL(T, A, 8) ^ ye.shrSL(T, A, 7), P = oa[E - 2] | 0, C = ca[E - 2] | 0, S = ye.rotrSH(P, C, 19) ^ ye.rotrBH(P, C, 61) ^ ye.shrSH(P, C, 6), R = ye.rotrSL(P, C, 19) ^ ye.rotrBL(P, C, 61) ^ ye.shrSL(P, C, 6), M = ye.add4L(D, R, ca[E - 7], ca[E - 16]), _ = ye.add4H(M, N, S, oa[E - 7], oa[E - 16]);
      oa[E] = _ | 0, ca[E] = M | 0;
    }
    let { Ah: r, Al: s, Bh: a, Bl: i, Ch: o, Cl: c, Dh: u, Dl: l, Eh: d, El: p, Fh: f, Fl: b, Gh: y, Gl: g, Hh: w, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const T = ye.rotrSH(d, p, 14) ^ ye.rotrSH(d, p, 18) ^ ye.rotrBH(d, p, 41), A = ye.rotrSL(d, p, 14) ^ ye.rotrSL(d, p, 18) ^ ye.rotrBL(d, p, 41), N = d & f ^ ~d & y, D = p & b ^ ~p & g, P = ye.add5L(k, A, D, uO[E], ca[E]), C = ye.add5H(P, w, T, N, lO[E], oa[E]), S = P | 0, R = ye.rotrSH(r, s, 28) ^ ye.rotrBH(r, s, 34) ^ ye.rotrBH(r, s, 39), M = ye.rotrSL(r, s, 28) ^ ye.rotrBL(r, s, 34) ^ ye.rotrBL(r, s, 39), _ = r & a ^ r & o ^ a & o, j = s & i ^ s & c ^ i & c;
      w = y | 0, k = g | 0, y = f | 0, g = b | 0, f = d | 0, b = p | 0, { h: d, l: p } = ye.add(u | 0, l | 0, C | 0, S | 0), u = o | 0, l = c | 0, o = a | 0, c = i | 0, a = r | 0, i = s | 0;
      const I = ye.add3L(S, M, j);
      r = ye.add3H(I, C, R, _), s = I | 0;
    }
    ({ h: r, l: s } = ye.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: a, l: i } = ye.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: o, l: c } = ye.add(this.Ch | 0, this.Cl | 0, o | 0, c | 0), { h: u, l } = ye.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: p } = ye.add(this.Eh | 0, this.El | 0, d | 0, p | 0), { h: f, l: b } = ye.add(this.Fh | 0, this.Fl | 0, f | 0, b | 0), { h: y, l: g } = ye.add(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: w, l: k } = ye.add(this.Hh | 0, this.Hl | 0, w | 0, k | 0), this.set(r, s, a, i, o, c, u, l, d, p, f, b, y, g, w, k);
  }
  roundClean() {
    oa.fill(0), ca.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const fO = /* @__PURE__ */ P1(() => new dO());
function pO() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const nx = pO(), rx = nx.crypto || nx.msCrypto;
function hO(t) {
  switch (t) {
    case "sha256":
      return Tk.create();
    case "sha512":
      return fO.create();
  }
  U(!1, "invalid hashing algorithm name", "algorithm", t);
}
function mO(t) {
  q(rx != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  }), U(Number.isInteger(t) && t > 0 && t <= 1024, "invalid length", "length", t);
  const e = new Uint8Array(t);
  return rx.getRandomValues(e), e;
}
const [Nk, Rk, Dk] = [[], [], []], yO = /* @__PURE__ */ BigInt(0), lu = /* @__PURE__ */ BigInt(1), bO = /* @__PURE__ */ BigInt(2), gO = /* @__PURE__ */ BigInt(7), wO = /* @__PURE__ */ BigInt(256), EO = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = lu, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], Nk.push(2 * (5 * r + n)), Rk.push((t + 1) * (t + 2) / 2 % 64);
  let s = yO;
  for (let a = 0; a < 7; a++)
    e = (e << lu ^ (e >> gO) * EO) % wO, e & bO && (s ^= lu << (lu << /* @__PURE__ */ BigInt(a)) - lu);
  Dk.push(s);
}
const [xO, AO] = /* @__PURE__ */ Ik(Dk, !0), sx = (t, e, n) => n > 32 ? Pk(t, e, n) : Ok(t, e, n), ax = (t, e, n) => n > 32 ? Uk(t, e, n) : Bk(t, e, n);
function kO(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = sx(u, l, 1) ^ n[o], p = ax(u, l, 1) ^ n[o + 1];
      for (let f = 0; f < 50; f += 10)
        t[i + f] ^= d, t[i + f + 1] ^= p;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = Rk[i], c = sx(s, a, o), u = ax(s, a, o), l = Nk[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= xO[r], t[1] ^= AO[r];
  }
  n.fill(0);
}
let vO = class Fk extends B1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, $p(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = MI(this.state);
  }
  keccak() {
    kO(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Tl(this);
    const { blockLen: n, state: r } = this;
    e = Gh(e);
    const s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Tl(this, !1), O1(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return $p(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (xk(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new Fk(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
};
const CO = (t, e, n) => P1(() => new vO(e, t, n)), TO = /* @__PURE__ */ CO(1, 136, 256 / 8);
let Mk = !1;
const Lk = function(t) {
  return TO(t);
};
let Hk = Lk;
function ke(t) {
  const e = ee(t, "data");
  return z(Hk(e));
}
ke._ = Lk;
ke.lock = function() {
  Mk = !0;
};
ke.register = function(t) {
  if (Mk)
    throw new TypeError("keccak256 is locked");
  Hk = t;
};
Object.freeze(ke);
let _k = !1;
const $k = function(t) {
  return new Uint8Array(mO(t));
};
let Gk = $k;
function ei(t) {
  return Gk(t);
}
ei._ = $k;
ei.lock = function() {
  _k = !0;
};
ei.register = function(t) {
  if (_k)
    throw new Error("randomBytes is locked");
  Gk = t;
};
Object.freeze(ei);
const zk = function(t) {
  return hO("sha256").update(t).digest();
};
let jk = zk, Vk = !1;
function jl(t) {
  const e = ee(t, "data");
  return z(jk(e));
}
jl._ = zk;
jl.lock = function() {
  Vk = !0;
};
jl.register = function(t) {
  if (Vk)
    throw new Error("sha256 is locked");
  jk = t;
};
Object.freeze(jl);
Object.freeze(jl);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qk = BigInt(0), zh = BigInt(1), SO = BigInt(2), jh = (t) => t instanceof Uint8Array, IO = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Sl(t) {
  if (!jh(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += IO[t[n]];
  return e;
}
function Kk(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function U1(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function Il(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(e / 2);
  for (let r = 0; r < n.length; r++) {
    const s = r * 2, a = t.slice(s, s + 2), i = Number.parseInt(a, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    n[r] = i;
  }
  return n;
}
function po(t) {
  return U1(Sl(t));
}
function N1(t) {
  if (!jh(t))
    throw new Error("Uint8Array expected");
  return U1(Sl(Uint8Array.from(t).reverse()));
}
function Ol(t, e) {
  return Il(t.toString(16).padStart(e * 2, "0"));
}
function R1(t, e) {
  return Ol(t, e).reverse();
}
function OO(t) {
  return Il(Kk(t));
}
function mr(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = Il(e);
    } catch (a) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${a}`);
    }
  else if (jh(e))
    r = Uint8Array.from(e);
  else
    throw new Error(`${t} must be hex string or Uint8Array`);
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(`${t} expected ${n} bytes, got ${s}`);
  return r;
}
function id(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!jh(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
function BO(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function PO(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function UO(t) {
  let e;
  for (e = 0; t > qk; t >>= zh, e += 1)
    ;
  return e;
}
function NO(t, e) {
  return t >> BigInt(e) & zh;
}
const RO = (t, e, n) => t | (n ? zh : qk) << BigInt(e), D1 = (t) => (SO << BigInt(t - 1)) - zh, p0 = (t) => new Uint8Array(t), ix = (t) => Uint8Array.from(t);
function Wk(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = p0(t), s = p0(t), a = 0;
  const i = () => {
    r.fill(1), s.fill(0), a = 0;
  }, o = (...d) => n(s, r, ...d), c = (d = p0()) => {
    s = o(ix([0]), d), r = o(), d.length !== 0 && (s = o(ix([1]), d), r = o());
  }, u = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const p = [];
    for (; d < e; ) {
      r = o();
      const f = r.slice();
      p.push(f), d += r.length;
    }
    return id(...p);
  };
  return (d, p) => {
    i(), c(d);
    let f;
    for (; !(f = p(u())); )
      c();
    return i(), f;
  };
}
const DO = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  stringOrUint8Array: (t) => typeof t == "string" || t instanceof Uint8Array,
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function Jd(t, e, n = {}) {
  const r = (s, a, i) => {
    const o = DO[a];
    if (typeof o != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const c = t[s];
    if (!(i && c === void 0) && !o(c, t))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${a}`);
  };
  for (const [s, a] of Object.entries(e))
    r(s, a, !1);
  for (const [s, a] of Object.entries(n))
    r(s, a, !0);
  return t;
}
const FO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: NO,
  bitLen: UO,
  bitMask: D1,
  bitSet: RO,
  bytesToHex: Sl,
  bytesToNumberBE: po,
  bytesToNumberLE: N1,
  concatBytes: id,
  createHmacDrbg: Wk,
  ensureBytes: mr,
  equalBytes: BO,
  hexToBytes: Il,
  hexToNumber: U1,
  numberToBytesBE: Ol,
  numberToBytesLE: R1,
  numberToHexUnpadded: Kk,
  numberToVarBytesBE: OO,
  utf8ToBytes: PO,
  validateObject: Jd
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const xt = BigInt(0), st = BigInt(1), bi = BigInt(2), MO = BigInt(3), Ny = BigInt(4), ox = BigInt(5), cx = BigInt(8);
BigInt(9);
BigInt(16);
function En(t, e) {
  const n = t % e;
  return n >= xt ? n : e + n;
}
function LO(t, e, n) {
  if (n <= xt || e < xt)
    throw new Error("Expected power/modulo > 0");
  if (n === st)
    return xt;
  let r = st;
  for (; e > xt; )
    e & st && (r = r * t % n), t = t * t % n, e >>= st;
  return r;
}
function $n(t, e, n) {
  let r = t;
  for (; e-- > xt; )
    r *= r, r %= n;
  return r;
}
function Ry(t, e) {
  if (t === xt || e <= xt)
    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
  let n = En(t, e), r = e, s = xt, a = st;
  for (; n !== xt; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== st)
    throw new Error("invert: does not exist");
  return En(s, e);
}
function HO(t) {
  const e = (t - st) / bi;
  let n, r, s;
  for (n = t - st, r = 0; n % bi === xt; n /= bi, r++)
    ;
  for (s = bi; s < t && LO(s, e, t) !== t - st; s++)
    ;
  if (r === 1) {
    const i = (t + st) / Ny;
    return function(c, u) {
      const l = c.pow(u, i);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (n + st) / bi;
  return function(o, c) {
    if (o.pow(c, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let u = r, l = o.pow(o.mul(o.ONE, s), n), d = o.pow(c, a), p = o.pow(c, n);
    for (; !o.eql(p, o.ONE); ) {
      if (o.eql(p, o.ZERO))
        return o.ZERO;
      let f = 1;
      for (let y = o.sqr(p); f < u && !o.eql(y, o.ONE); f++)
        y = o.sqr(y);
      const b = o.pow(l, st << BigInt(u - f - 1));
      l = o.sqr(b), d = o.mul(d, b), p = o.mul(p, l), u = f;
    }
    return d;
  };
}
function _O(t) {
  if (t % Ny === MO) {
    const e = (t + st) / Ny;
    return function(r, s) {
      const a = r.pow(s, e);
      if (!r.eql(r.sqr(a), s))
        throw new Error("Cannot find square root");
      return a;
    };
  }
  if (t % cx === ox) {
    const e = (t - ox) / cx;
    return function(r, s) {
      const a = r.mul(s, bi), i = r.pow(a, e), o = r.mul(s, i), c = r.mul(r.mul(o, bi), i), u = r.mul(o, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return HO(t);
}
const $O = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function GO(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = $O.reduce((r, s) => (r[s] = "function", r), e);
  return Jd(t, n);
}
function zO(t, e, n) {
  if (n < xt)
    throw new Error("Expected power > 0");
  if (n === xt)
    return t.ONE;
  if (n === st)
    return e;
  let r = t.ONE, s = e;
  for (; n > xt; )
    n & st && (r = t.mul(r, s)), s = t.sqr(s), n >>= st;
  return r;
}
function jO(t, e) {
  const n = new Array(e.length), r = e.reduce((a, i, o) => t.is0(i) ? a : (n[o] = a, t.mul(a, i)), t.ONE), s = t.inv(r);
  return e.reduceRight((a, i, o) => t.is0(i) ? a : (n[o] = t.mul(a, n[o]), t.mul(a, i)), s), n;
}
function Qk(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function VO(t, e, n = !1, r = {}) {
  if (t <= xt)
    throw new Error(`Expected Field ORDER > 0, got ${t}`);
  const { nBitLength: s, nByteLength: a } = Qk(t, e);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = _O(t), o = Object.freeze({
    ORDER: t,
    BITS: s,
    BYTES: a,
    MASK: D1(s),
    ZERO: xt,
    ONE: st,
    create: (c) => En(c, t),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return xt <= c && c < t;
    },
    is0: (c) => c === xt,
    isOdd: (c) => (c & st) === st,
    neg: (c) => En(-c, t),
    eql: (c, u) => c === u,
    sqr: (c) => En(c * c, t),
    add: (c, u) => En(c + u, t),
    sub: (c, u) => En(c - u, t),
    mul: (c, u) => En(c * u, t),
    pow: (c, u) => zO(o, c, u),
    div: (c, u) => En(c * Ry(u, t), t),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => Ry(c, t),
    sqrt: r.sqrt || ((c) => i(o, c)),
    invertBatch: (c) => jO(o, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => n ? R1(c, a) : Ol(c, a),
    fromBytes: (c) => {
      if (c.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${c.length}`);
      return n ? N1(c) : po(c);
    }
  });
  return Object.freeze(o);
}
function Jk(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Xk(t) {
  const e = Jk(t);
  return e + Math.ceil(e / 2);
}
function qO(t, e, n = !1) {
  const r = t.length, s = Jk(e), a = Xk(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error(`expected ${a}-1024 bytes of input, got ${r}`);
  const i = n ? po(t) : N1(t), o = En(i, e - st) + st;
  return n ? R1(o, s) : Ol(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const KO = BigInt(0), h0 = BigInt(1);
function WO(t, e) {
  const n = (s, a) => {
    const i = a.negate();
    return s ? i : a;
  }, r = (s) => {
    const a = Math.ceil(e / s) + 1, i = 2 ** (s - 1);
    return { windows: a, windowSize: i };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(s, a) {
      let i = t.ZERO, o = s;
      for (; a > KO; )
        a & h0 && (i = i.add(o)), o = o.double(), a >>= h0;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, a) {
      const { windows: i, windowSize: o } = r(a), c = [];
      let u = s, l = u;
      for (let d = 0; d < i; d++) {
        l = u, c.push(l);
        for (let p = 1; p < o; p++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, a, i) {
      const { windows: o, windowSize: c } = r(s);
      let u = t.ZERO, l = t.BASE;
      const d = BigInt(2 ** s - 1), p = 2 ** s, f = BigInt(s);
      for (let b = 0; b < o; b++) {
        const y = b * c;
        let g = Number(i & d);
        i >>= f, g > c && (g -= p, i += h0);
        const w = y, k = y + Math.abs(g) - 1, E = b % 2 !== 0, T = g < 0;
        g === 0 ? l = l.add(n(E, a[w])) : u = u.add(n(T, a[k]));
      }
      return { p: u, f: l };
    },
    wNAFCached(s, a, i, o) {
      const c = s._WINDOW_SIZE || 1;
      let u = a.get(s);
      return u || (u = this.precomputeWindow(s, c), c !== 1 && a.set(s, o(u))), this.wNAF(c, u, i);
    }
  };
}
function Zk(t) {
  return GO(t.Fp), Jd(t, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Qk(t.n, t.nBitLength),
    ...t,
    p: t.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function QO(t) {
  const e = Zk(t);
  Jd(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: s } = e;
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: JO, hexToBytes: XO } = FO, Ai = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(t) {
    const { Err: e } = Ai;
    if (t.length < 2 || t[0] !== 2)
      throw new e("Invalid signature integer tag");
    const n = t[1], r = t.subarray(2, n + 2);
    if (!n || r.length !== n)
      throw new e("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: JO(r), l: t.subarray(n + 2) };
  },
  toSig(t) {
    const { Err: e } = Ai, n = typeof t == "string" ? XO(t) : t;
    if (!(n instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = n.length;
    if (r < 2 || n[0] != 48)
      throw new e("Invalid signature tag");
    if (n[1] !== r - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: s, l: a } = Ai._parseInt(n.subarray(2)), { d: i, l: o } = Ai._parseInt(a);
    if (o.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: s, s: i };
  },
  hexFromSig(t) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, n = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, r = e(n(t.s)), s = e(n(t.r)), a = r.length / 2, i = s.length / 2, o = n(a), c = n(i);
    return `30${n(i + a + 4)}02${c}${s}02${o}${r}`;
  }
}, Fs = BigInt(0), tr = BigInt(1);
BigInt(2);
const lx = BigInt(3);
BigInt(4);
function ZO(t) {
  const e = QO(t), { Fp: n } = e, r = e.toBytes || ((b, y, g) => {
    const w = y.toAffine();
    return id(Uint8Array.from([4]), n.toBytes(w.x), n.toBytes(w.y));
  }), s = e.fromBytes || ((b) => {
    const y = b.subarray(1), g = n.fromBytes(y.subarray(0, n.BYTES)), w = n.fromBytes(y.subarray(n.BYTES, 2 * n.BYTES));
    return { x: g, y: w };
  });
  function a(b) {
    const { a: y, b: g } = e, w = n.sqr(b), k = n.mul(w, b);
    return n.add(n.add(k, n.mul(b, y)), g);
  }
  if (!n.eql(n.sqr(e.Gy), a(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function i(b) {
    return typeof b == "bigint" && Fs < b && b < e.n;
  }
  function o(b) {
    if (!i(b))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(b) {
    const { allowedPrivateKeyLengths: y, nByteLength: g, wrapPrivateKey: w, n: k } = e;
    if (y && typeof b != "bigint") {
      if (b instanceof Uint8Array && (b = Sl(b)), typeof b != "string" || !y.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(g * 2, "0");
    }
    let E;
    try {
      E = typeof b == "bigint" ? b : po(mr("private key", b, g));
    } catch {
      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof b}`);
    }
    return w && (E = En(E, k)), o(E), E;
  }
  const u = /* @__PURE__ */ new Map();
  function l(b) {
    if (!(b instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(y, g, w) {
      if (this.px = y, this.py = g, this.pz = w, y == null || !n.isValid(y))
        throw new Error("x required");
      if (g == null || !n.isValid(g))
        throw new Error("y required");
      if (w == null || !n.isValid(w))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(y) {
      const { x: g, y: w } = y || {};
      if (!y || !n.isValid(g) || !n.isValid(w))
        throw new Error("invalid affine point");
      if (y instanceof d)
        throw new Error("projective point not allowed");
      const k = (E) => n.eql(E, n.ZERO);
      return k(g) && k(w) ? d.ZERO : new d(g, w, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(y) {
      const g = n.invertBatch(y.map((w) => w.pz));
      return y.map((w, k) => w.toAffine(g[k])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(y) {
      const g = d.fromAffine(s(mr("pointHex", y)));
      return g.assertValidity(), g;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(y) {
      return d.BASE.multiply(c(y));
    }
    // "Private method", don't use it directly
    _setWindowSize(y) {
      this._WINDOW_SIZE = y, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !n.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: y, y: g } = this.toAffine();
      if (!n.isValid(y) || !n.isValid(g))
        throw new Error("bad point: x or y not FE");
      const w = n.sqr(g), k = a(y);
      if (!n.eql(w, k))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(y) {
      l(y);
      const { px: g, py: w, pz: k } = this, { px: E, py: T, pz: A } = y, N = n.eql(n.mul(g, A), n.mul(E, k)), D = n.eql(n.mul(w, A), n.mul(T, k));
      return N && D;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: y, b: g } = e, w = n.mul(g, lx), { px: k, py: E, pz: T } = this;
      let A = n.ZERO, N = n.ZERO, D = n.ZERO, P = n.mul(k, k), C = n.mul(E, E), S = n.mul(T, T), R = n.mul(k, E);
      return R = n.add(R, R), D = n.mul(k, T), D = n.add(D, D), A = n.mul(y, D), N = n.mul(w, S), N = n.add(A, N), A = n.sub(C, N), N = n.add(C, N), N = n.mul(A, N), A = n.mul(R, A), D = n.mul(w, D), S = n.mul(y, S), R = n.sub(P, S), R = n.mul(y, R), R = n.add(R, D), D = n.add(P, P), P = n.add(D, P), P = n.add(P, S), P = n.mul(P, R), N = n.add(N, P), S = n.mul(E, T), S = n.add(S, S), P = n.mul(S, R), A = n.sub(A, P), D = n.mul(S, C), D = n.add(D, D), D = n.add(D, D), new d(A, N, D);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(y) {
      l(y);
      const { px: g, py: w, pz: k } = this, { px: E, py: T, pz: A } = y;
      let N = n.ZERO, D = n.ZERO, P = n.ZERO;
      const C = e.a, S = n.mul(e.b, lx);
      let R = n.mul(g, E), M = n.mul(w, T), _ = n.mul(k, A), j = n.add(g, w), I = n.add(E, T);
      j = n.mul(j, I), I = n.add(R, M), j = n.sub(j, I), I = n.add(g, k);
      let F = n.add(E, A);
      return I = n.mul(I, F), F = n.add(R, _), I = n.sub(I, F), F = n.add(w, k), N = n.add(T, A), F = n.mul(F, N), N = n.add(M, _), F = n.sub(F, N), P = n.mul(C, I), N = n.mul(S, _), P = n.add(N, P), N = n.sub(M, P), P = n.add(M, P), D = n.mul(N, P), M = n.add(R, R), M = n.add(M, R), _ = n.mul(C, _), I = n.mul(S, I), M = n.add(M, _), _ = n.sub(R, _), _ = n.mul(C, _), I = n.add(I, _), R = n.mul(M, I), D = n.add(D, R), R = n.mul(F, I), N = n.mul(j, N), N = n.sub(N, R), R = n.mul(j, M), P = n.mul(F, P), P = n.add(P, R), new d(N, D, P);
    }
    subtract(y) {
      return this.add(y.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(y) {
      return f.wNAFCached(this, u, y, (g) => {
        const w = n.invertBatch(g.map((k) => k.pz));
        return g.map((k, E) => k.toAffine(w[E])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(y) {
      const g = d.ZERO;
      if (y === Fs)
        return g;
      if (o(y), y === tr)
        return this;
      const { endo: w } = e;
      if (!w)
        return f.unsafeLadder(this, y);
      let { k1neg: k, k1: E, k2neg: T, k2: A } = w.splitScalar(y), N = g, D = g, P = this;
      for (; E > Fs || A > Fs; )
        E & tr && (N = N.add(P)), A & tr && (D = D.add(P)), P = P.double(), E >>= tr, A >>= tr;
      return k && (N = N.negate()), T && (D = D.negate()), D = new d(n.mul(D.px, w.beta), D.py, D.pz), N.add(D);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(y) {
      o(y);
      let g = y, w, k;
      const { endo: E } = e;
      if (E) {
        const { k1neg: T, k1: A, k2neg: N, k2: D } = E.splitScalar(g);
        let { p: P, f: C } = this.wNAF(A), { p: S, f: R } = this.wNAF(D);
        P = f.constTimeNegate(T, P), S = f.constTimeNegate(N, S), S = new d(n.mul(S.px, E.beta), S.py, S.pz), w = P.add(S), k = C.add(R);
      } else {
        const { p: T, f: A } = this.wNAF(g);
        w = T, k = A;
      }
      return d.normalizeZ([w, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(y, g, w) {
      const k = d.BASE, E = (A, N) => N === Fs || N === tr || !A.equals(k) ? A.multiplyUnsafe(N) : A.multiply(N), T = E(this, g).add(E(y, w));
      return T.is0() ? void 0 : T;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(y) {
      const { px: g, py: w, pz: k } = this, E = this.is0();
      y == null && (y = E ? n.ONE : n.inv(k));
      const T = n.mul(g, y), A = n.mul(w, y), N = n.mul(k, y);
      if (E)
        return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(N, n.ONE))
        throw new Error("invZ was invalid");
      return { x: T, y: A };
    }
    isTorsionFree() {
      const { h: y, isTorsionFree: g } = e;
      if (y === tr)
        return !0;
      if (g)
        return g(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: y, clearCofactor: g } = e;
      return y === tr ? this : g ? g(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(y = !0) {
      return this.assertValidity(), r(d, this, y);
    }
    toHex(y = !0) {
      return Sl(this.toRawBytes(y));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
  const p = e.nBitLength, f = WO(d, e.endo ? Math.ceil(p / 2) : p);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: a,
    isWithinCurveOrder: i
  };
}
function YO(t) {
  const e = Zk(t);
  return Jd(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function e9(t) {
  const e = YO(t), { Fp: n, n: r } = e, s = n.BYTES + 1, a = 2 * n.BYTES + 1;
  function i(I) {
    return Fs < I && I < n.ORDER;
  }
  function o(I) {
    return En(I, r);
  }
  function c(I) {
    return Ry(I, r);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: d, isWithinCurveOrder: p } = ZO({
    ...e,
    toBytes(I, F, $) {
      const V = F.toAffine(), X = n.toBytes(V.x), Z = id;
      return $ ? Z(Uint8Array.from([F.hasEvenY() ? 2 : 3]), X) : Z(Uint8Array.from([4]), X, n.toBytes(V.y));
    },
    fromBytes(I) {
      const F = I.length, $ = I[0], V = I.subarray(1);
      if (F === s && ($ === 2 || $ === 3)) {
        const X = po(V);
        if (!i(X))
          throw new Error("Point is not on curve");
        const Z = d(X);
        let Y = n.sqrt(Z);
        const W = (Y & tr) === tr;
        return ($ & 1) === 1 !== W && (Y = n.neg(Y)), { x: X, y: Y };
      } else if (F === a && $ === 4) {
        const X = n.fromBytes(V.subarray(0, n.BYTES)), Z = n.fromBytes(V.subarray(n.BYTES, 2 * n.BYTES));
        return { x: X, y: Z };
      } else
        throw new Error(`Point of length ${F} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`);
    }
  }), f = (I) => Sl(Ol(I, e.nByteLength));
  function b(I) {
    const F = r >> tr;
    return I > F;
  }
  function y(I) {
    return b(I) ? o(-I) : I;
  }
  const g = (I, F, $) => po(I.slice(F, $));
  class w {
    constructor(F, $, V) {
      this.r = F, this.s = $, this.recovery = V, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(F) {
      const $ = e.nByteLength;
      return F = mr("compactSignature", F, $ * 2), new w(g(F, 0, $), g(F, $, 2 * $));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(F) {
      const { r: $, s: V } = Ai.toSig(mr("DER", F));
      return new w($, V);
    }
    assertValidity() {
      if (!p(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!p(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(F) {
      return new w(this.r, this.s, F);
    }
    recoverPublicKey(F) {
      const { r: $, s: V, recovery: X } = this, Z = D(mr("msgHash", F));
      if (X == null || ![0, 1, 2, 3].includes(X))
        throw new Error("recovery id invalid");
      const Y = X === 2 || X === 3 ? $ + e.n : $;
      if (Y >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const W = X & 1 ? "03" : "02", Q = u.fromHex(W + f(Y)), oe = c(Y), te = o(-Z * oe), ae = o(V * oe), ue = u.BASE.multiplyAndAddUnsafe(Q, te, ae);
      if (!ue)
        throw new Error("point at infinify");
      return ue.assertValidity(), ue;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return b(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new w(this.r, o(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Il(this.toDERHex());
    }
    toDERHex() {
      return Ai.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Il(this.toCompactHex());
    }
    toCompactHex() {
      return f(this.r) + f(this.s);
    }
  }
  const k = {
    isValidPrivateKey(I) {
      try {
        return l(I), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const I = Xk(e.n);
      return qO(e.randomBytes(I), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(I = 8, F = u.BASE) {
      return F._setWindowSize(I), F.multiply(BigInt(3)), F;
    }
  };
  function E(I, F = !0) {
    return u.fromPrivateKey(I).toRawBytes(F);
  }
  function T(I) {
    const F = I instanceof Uint8Array, $ = typeof I == "string", V = (F || $) && I.length;
    return F ? V === s || V === a : $ ? V === 2 * s || V === 2 * a : I instanceof u;
  }
  function A(I, F, $ = !0) {
    if (T(I))
      throw new Error("first arg must be private key");
    if (!T(F))
      throw new Error("second arg must be public key");
    return u.fromHex(F).multiply(l(I)).toRawBytes($);
  }
  const N = e.bits2int || function(I) {
    const F = po(I), $ = I.length * 8 - e.nBitLength;
    return $ > 0 ? F >> BigInt($) : F;
  }, D = e.bits2int_modN || function(I) {
    return o(N(I));
  }, P = D1(e.nBitLength);
  function C(I) {
    if (typeof I != "bigint")
      throw new Error("bigint expected");
    if (!(Fs <= I && I < P))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return Ol(I, e.nByteLength);
  }
  function S(I, F, $ = R) {
    if (["recovered", "canonical"].some((Le) => Le in $))
      throw new Error("sign() legacy options not supported");
    const { hash: V, randomBytes: X } = e;
    let { lowS: Z, prehash: Y, extraEntropy: W } = $;
    Z == null && (Z = !0), I = mr("msgHash", I), Y && (I = mr("prehashed msgHash", V(I)));
    const Q = D(I), oe = l(F), te = [C(oe), C(Q)];
    if (W != null) {
      const Le = W === !0 ? X(n.BYTES) : W;
      te.push(mr("extraEntropy", Le));
    }
    const ae = id(...te), ue = Q;
    function Ie(Le) {
      const Ze = N(Le);
      if (!p(Ze))
        return;
      const vt = c(Ze), yt = u.BASE.multiply(Ze).toAffine(), Ke = o(yt.x);
      if (Ke === Fs)
        return;
      const Yt = o(vt * o(ue + Ke * oe));
      if (Yt === Fs)
        return;
      let Ys = (yt.x === Ke ? 0 : 2) | Number(yt.y & tr), ea = Yt;
      return Z && b(Yt) && (ea = y(Yt), Ys ^= 1), new w(Ke, ea, Ys);
    }
    return { seed: ae, k2sig: Ie };
  }
  const R = { lowS: e.lowS, prehash: !1 }, M = { lowS: e.lowS, prehash: !1 };
  function _(I, F, $ = R) {
    const { seed: V, k2sig: X } = S(I, F, $), Z = e;
    return Wk(Z.hash.outputLen, Z.nByteLength, Z.hmac)(V, X);
  }
  u.BASE._setWindowSize(8);
  function j(I, F, $, V = M) {
    var yt;
    const X = I;
    if (F = mr("msgHash", F), $ = mr("publicKey", $), "strict" in V)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Z, prehash: Y } = V;
    let W, Q;
    try {
      if (typeof X == "string" || X instanceof Uint8Array)
        try {
          W = w.fromDER(X);
        } catch (Ke) {
          if (!(Ke instanceof Ai.Err))
            throw Ke;
          W = w.fromCompact(X);
        }
      else if (typeof X == "object" && typeof X.r == "bigint" && typeof X.s == "bigint") {
        const { r: Ke, s: Yt } = X;
        W = new w(Ke, Yt);
      } else
        throw new Error("PARSE");
      Q = u.fromHex($);
    } catch (Ke) {
      if (Ke.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Z && W.hasHighS())
      return !1;
    Y && (F = e.hash(F));
    const { r: oe, s: te } = W, ae = D(F), ue = c(te), Ie = o(ae * ue), Le = o(oe * ue), Ze = (yt = u.BASE.multiplyAndAddUnsafe(Q, Ie, Le)) == null ? void 0 : yt.toAffine();
    return Ze ? o(Ze.x) === oe : !1;
  }
  return {
    CURVE: e,
    getPublicKey: E,
    getSharedSecret: A,
    sign: _,
    verify: j,
    ProjectivePoint: u,
    Signature: w,
    utils: k
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function t9(t) {
  return {
    hash: t,
    hmac: (e, ...n) => vk(t, e, _I(...n)),
    randomBytes: $I
  };
}
function n9(t, e) {
  const n = (r) => e9({ ...t, ...t9(r) });
  return Object.freeze({ ...n(e), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yk = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), ux = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), r9 = BigInt(1), Dy = BigInt(2), dx = (t, e) => (t + e / Dy) / e;
function s9(t) {
  const e = Yk, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = $n(l, n, e) * l % e, p = $n(d, n, e) * l % e, f = $n(p, Dy, e) * u % e, b = $n(f, s, e) * f % e, y = $n(b, a, e) * b % e, g = $n(y, o, e) * y % e, w = $n(g, c, e) * g % e, k = $n(w, o, e) * y % e, E = $n(k, n, e) * l % e, T = $n(E, i, e) * b % e, A = $n(T, r, e) * u % e, N = $n(A, Dy, e);
  if (!Fy.eql(Fy.sqr(N), t))
    throw new Error("Cannot find square root");
  return N;
}
const Fy = VO(Yk, void 0, void 0, { sqrt: s9 }), ha = n9({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fy,
  n: ux,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = ux, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -r9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = dx(a * t, e), c = dx(-r * t, e);
      let u = En(t - o * n - c * s, e), l = En(-o * r - c * a, e);
      const d = u > i, p = l > i;
      if (d && (u = e - u), p && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: p, k2: l };
    }
  }
}, Tk);
BigInt(0);
ha.ProjectivePoint;
const ti = "0x0000000000000000000000000000000000000000", Gp = "0x0000000000000000000000000000000000000000000000000000000000000000", e8 = `Ethereum Signed Message:
`, fx = BigInt(0), px = BigInt(1), hx = BigInt(2), mx = BigInt(27), yx = BigInt(28), Sf = BigInt(35), Vo = {};
function bx(t) {
  return Mn(dt(t), 32);
}
var Kc, Kr, Wc, Yi;
const hr = class hr {
  /**
   *  @private
   */
  constructor(e, n, r, s) {
    B(this, Kc);
    B(this, Kr);
    B(this, Wc);
    B(this, Yi);
    Hh(e, Vo, "Signature"), x(this, Kc, n), x(this, Kr, r), x(this, Wc, s), x(this, Yi, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return m(this, Kc);
  }
  set r(e) {
    U(fo(e) === 32, "invalid r", "value", e), x(this, Kc, z(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return U(parseInt(m(this, Kr).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", m(this, Kr)), m(this, Kr);
  }
  set s(e) {
    U(fo(e) === 32, "invalid s", "value", e), x(this, Kr, z(e));
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return m(this, Kr);
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return parseInt(m(this, Kr).substring(0, 3)) < 8;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return m(this, Wc);
  }
  set v(e) {
    const n = Ee(e, "value");
    U(n === 27 || n === 28, "invalid v", "v", e), x(this, Wc, n);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return m(this, Yi);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : hr.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = ee(this.s);
    return this.yParity && (e[0] |= 128), z(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return _e([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return _e([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new hr(Vo, this.r, this._s, this.v);
    return this.networkV && x(e, Yi, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const n = re(e, "v");
    return n == mx || n == yx ? fx : (U(n >= Sf, "invalid EIP-155 v", "v", e), (n - Sf) / hx);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, n) {
    return re(e) * hx + BigInt(35 + n - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const n = re(e);
    return n === fx || n === mx ? 27 : n === px || n === yx ? 28 : (U(n >= Sf, "invalid v", "v", e), n & px ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function n(u, l) {
      U(u, l, "signature", e);
    }
    if (e == null)
      return new hr(Vo, Gp, Gp, 27);
    if (typeof e == "string") {
      const u = ee(e, "signature");
      if (u.length === 64) {
        const l = z(u.slice(0, 32)), d = u.slice(32, 64), p = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new hr(Vo, l, z(d), p);
      }
      if (u.length === 65) {
        const l = z(u.slice(0, 32)), d = z(u.slice(32, 64)), p = hr.getNormalizedV(u[64]);
        return new hr(Vo, l, d, p);
      }
      n(!1, "invalid raw signature length");
    }
    if (e instanceof hr)
      return e.clone();
    const r = e.r;
    n(r != null, "missing r");
    const s = bx(r), a = function(u, l) {
      if (u != null)
        return bx(u);
      if (l != null) {
        n(Re(l, 32), "invalid yParityAndS");
        const d = ee(l);
        return d[0] &= 127, z(d);
      }
      n(!1, "missing s");
    }(e.s, e.yParityAndS), { networkV: i, v: o } = function(u, l, d) {
      if (u != null) {
        const p = re(u);
        return {
          networkV: p >= Sf ? p : void 0,
          v: hr.getNormalizedV(p)
        };
      }
      if (l != null)
        return n(Re(l, 32), "invalid yParityAndS"), { v: ee(l)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (Ee(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        n(!1, "invalid yParity");
      }
      n(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), c = new hr(Vo, s, a, o);
    return i && x(c, Yi, i), n(e.yParity == null || Ee(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
Kc = new WeakMap(), Kr = new WeakMap(), Wc = new WeakMap(), Yi = new WeakMap();
let vn = hr;
var Is;
const Ei = class Ei {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    B(this, Is);
    U(fo(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), x(this, Is, z(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return m(this, Is);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Ei.computePublicKey(m(this, Is));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Ei.computePublicKey(m(this, Is), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    U(fo(e) === 32, "invalid digest length", "digest", e);
    const n = ha.sign(ln(e), ln(m(this, Is)), {
      lowS: !0
    });
    return vn.from({
      r: Ir(n.r, 32),
      s: Ir(n.s, 32),
      v: n.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const n = Ei.computePublicKey(e);
    return z(ha.getSharedSecret(ln(m(this, Is)), ee(n), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, n) {
    let r = ee(e, "key");
    if (r.length === 32) {
      const a = ha.getPublicKey(r, !!n);
      return z(a);
    }
    if (r.length === 64) {
      const a = new Uint8Array(65);
      a[0] = 4, a.set(r, 1), r = a;
    }
    const s = ha.ProjectivePoint.fromHex(r);
    return z(s.toRawBytes(n));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, n) {
    U(fo(e) === 32, "invalid digest length", "digest", e);
    const r = vn.from(n);
    let s = ha.Signature.fromCompact(ln(_e([r.r, r.s])));
    s = s.addRecoveryBit(r.yParity);
    const a = s.recoverPublicKey(ln(e));
    return U(a != null, "invalid signature for digest", "signature", n), "0x" + a.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, n, r) {
    const s = ha.ProjectivePoint.fromHex(Ei.computePublicKey(e).substring(2)), a = ha.ProjectivePoint.fromHex(Ei.computePublicKey(n).substring(2));
    return "0x" + s.add(a).toHex(!!r);
  }
};
Is = new WeakMap();
let od = Ei;
const a9 = BigInt(0), i9 = BigInt(36);
function gx(t) {
  t = t.toLowerCase();
  const e = t.substring(2).split(""), n = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    n[s] = e[s].charCodeAt(0);
  const r = ee(ke(n));
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
  return "0x" + e.join("");
}
const F1 = {};
for (let t = 0; t < 10; t++)
  F1[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  F1[String.fromCharCode(65 + t)] = String(10 + t);
const wx = 15;
function o9(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((r) => F1[r]).join("");
  for (; e.length >= wx; ) {
    let r = e.substring(0, wx);
    e = parseInt(r, 10) % 97 + e.substring(r.length);
  }
  let n = String(98 - parseInt(e, 10) % 97);
  for (; n.length < 2; )
    n = "0" + n;
  return n;
}
const c9 = function() {
  const t = {};
  for (let e = 0; e < 36; e++) {
    const n = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    t[n] = BigInt(e);
  }
  return t;
}();
function l9(t) {
  t = t.toLowerCase();
  let e = a9;
  for (let n = 0; n < t.length; n++)
    e = e * i9 + c9[t[n]];
  return e;
}
function de(t) {
  if (U(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    t.startsWith("0x") || (t = "0x" + t);
    const e = gx(t);
    return U(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e;
  }
  if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    U(t.substring(2, 4) === o9(t), "bad icap checksum", "address", t);
    let e = l9(t.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return gx("0x" + e);
  }
  U(!1, "invalid address", "address", t);
}
function u9(t) {
  const e = de(t.from);
  let r = re(t.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, de(Ve(ke(Ya([e, r])), 12));
}
function t8(t) {
  return t && typeof t.getAddress == "function";
}
function Ex(t) {
  try {
    return de(t), !0;
  } catch {
  }
  return !1;
}
async function m0(t, e) {
  const n = await e;
  return (n == null || n === "0x0000000000000000000000000000000000000000") && (q(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: t }), U(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), de(n);
}
function dn(t, e) {
  if (typeof t == "string")
    return t.match(/^0x[0-9a-f]{40}$/i) ? de(t) : (q(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), m0(t, e.resolveName(t)));
  if (t8(t))
    return m0(t, t.getAddress());
  if (t && typeof t.then == "function")
    return m0(t, t);
  U(!1, "unsupported addressable value", "target", t);
}
const ws = {};
function ne(t, e) {
  let n = !1;
  return e < 0 && (n = !0, e *= -1), new Vt(ws, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e });
}
function Oe(t, e) {
  return new Vt(ws, `bytes${e || ""}`, t, { size: e });
}
const xx = Symbol.for("_ethers_typed");
var eo;
const Es = class Es {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    O(this, "type");
    /**
     *  The actual value.
     */
    O(this, "value");
    B(this, eo);
    /**
     *  @_ignore:
     */
    O(this, "_typedSymbol");
    s == null && (s = null), Hh(ws, e, "Typed"), le(this, { _typedSymbol: xx, type: n, value: r }), x(this, eo, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return m(this, eo);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return m(this, eo) === !0 ? -1 : m(this, eo) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, n) {
    return new Es(ws, e, n);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return ne(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return ne(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return ne(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return ne(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return ne(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return ne(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return ne(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return ne(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return ne(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return ne(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return ne(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return ne(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return ne(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return ne(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return ne(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return ne(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return ne(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return ne(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return ne(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return ne(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return ne(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return ne(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return ne(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return ne(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return ne(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return ne(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return ne(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return ne(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return ne(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return ne(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return ne(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return ne(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return ne(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return ne(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return ne(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return ne(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return ne(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return ne(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return ne(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return ne(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return ne(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return ne(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return ne(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return ne(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return ne(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return ne(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return ne(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return ne(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return ne(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return ne(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return ne(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return ne(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return ne(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return ne(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return ne(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return ne(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return ne(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return ne(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return ne(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return ne(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return ne(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return ne(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return ne(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return ne(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return ne(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return ne(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Oe(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Oe(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Oe(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Oe(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Oe(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Oe(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Oe(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Oe(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Oe(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Oe(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Oe(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Oe(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Oe(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Oe(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Oe(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Oe(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Oe(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Oe(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Oe(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Oe(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Oe(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Oe(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Oe(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Oe(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Oe(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Oe(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Oe(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Oe(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Oe(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Oe(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Oe(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Oe(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new Es(ws, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new Es(ws, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new Es(ws, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new Es(ws, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new Es(ws, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === xx;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, n) {
    if (Es.isTyped(e)) {
      if (e.type !== n)
        throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
eo = new WeakMap();
let Vt = Es;
class d9 extends Ws {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, n) {
    let r = Vt.dereference(n, "string");
    try {
      r = de(r);
    } catch (s) {
      return this._throwError(s.message, n);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return de(Ir(e.readValue(), 20));
  }
}
class f9 extends Ws {
  constructor(n) {
    super(n.name, n.type, "_", n.dynamic);
    O(this, "coder");
    this.coder = n;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(n, r) {
    return this.coder.encode(n, r);
  }
  decode(n) {
    return this.coder.decode(n);
  }
}
function n8(t, e, n) {
  let r = [];
  if (Array.isArray(n))
    r = n;
  else if (n && typeof n == "object") {
    let c = {};
    r = e.map((u) => {
      const l = u.localName;
      return q(l, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), q(!c[l], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), c[l] = !0, n[l];
    });
  } else
    U(!1, "invalid tuple value", "tuple", n);
  U(e.length === r.length, "types/value length mismatch", "tuple", n);
  let s = new Oy(), a = new Oy(), i = [];
  e.forEach((c, u) => {
    let l = r[u];
    if (c.dynamic) {
      let d = a.length;
      c.encode(a, l);
      let p = s.writeUpdatableValue();
      i.push((f) => {
        p(f + d);
      });
    } else
      c.encode(s, l);
  }), i.forEach((c) => {
    c(s.length);
  });
  let o = t.appendWriter(s);
  return o += t.appendWriter(a), o;
}
function r8(t, e) {
  let n = [], r = [], s = t.subReader(0);
  return e.forEach((a) => {
    let i = null;
    if (a.dynamic) {
      let o = t.readIndex(), c = s.subReader(o);
      try {
        i = a.decode(c);
      } catch (u) {
        if (Bt(u, "BUFFER_OVERRUN"))
          throw u;
        i = u, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    } else
      try {
        i = a.decode(t);
      } catch (o) {
        if (Bt(o, "BUFFER_OVERRUN"))
          throw o;
        i = o, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    if (i == null)
      throw new Error("investigate");
    n.push(i), r.push(a.localName || null);
  }), Cl.fromItems(n, r);
}
class p9 extends Ws {
  constructor(n, r, s) {
    const a = n.type + "[" + (r >= 0 ? r : "") + "]", i = r === -1 || n.dynamic;
    super("array", a, s, i);
    O(this, "coder");
    O(this, "length");
    le(this, { coder: n, length: r });
  }
  defaultValue() {
    const n = this.coder.defaultValue(), r = [];
    for (let s = 0; s < this.length; s++)
      r.push(n);
    return r;
  }
  encode(n, r) {
    const s = Vt.dereference(r, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let a = this.length;
    a === -1 && (a = s.length, n.writeValue(s.length)), ok(s.length, a, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let o = 0; o < s.length; o++)
      i.push(this.coder);
    return n8(n, i, s);
  }
  decode(n) {
    let r = this.length;
    r === -1 && (r = n.readIndex(), q(r * un <= n.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: n.bytes, offset: r * un, length: n.dataLength }));
    let s = [];
    for (let a = 0; a < r; a++)
      s.push(new f9(this.coder));
    return r8(n, s);
  }
}
class h9 extends Ws {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, n) {
    const r = Vt.dereference(n, "bool");
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class s8 extends Ws {
  constructor(e, n) {
    super(e, e, n, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, n) {
    n = ln(n);
    let r = e.writeValue(n.length);
    return r += e.writeBytes(n), r;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class m9 extends s8 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return z(super.decode(e));
  }
}
class y9 extends Ws {
  constructor(n, r) {
    let s = "bytes" + String(n);
    super(s, s, r, !1);
    O(this, "size");
    le(this, { size: n }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(n, r) {
    let s = ln(Vt.dereference(r, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", r), n.writeBytes(s);
  }
  decode(n) {
    return z(n.readBytes(this.size));
  }
}
const b9 = new Uint8Array([]);
class g9 extends Ws {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, n) {
    return n != null && this._throwError("not null", n), e.writeBytes(b9);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const w9 = BigInt(0), E9 = BigInt(1), x9 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class A9 extends Ws {
  constructor(n, r, s) {
    const a = (r ? "int" : "uint") + n * 8;
    super(a, a, s, !1);
    O(this, "size");
    O(this, "signed");
    le(this, { size: n, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(n, r) {
    let s = re(Vt.dereference(r, this.type)), a = Pu(x9, un * 8);
    if (this.signed) {
      let i = Pu(a, this.size * 8 - 1);
      (s > i || s < -(i + E9)) && this._throwError("value out-of-bounds", r), s = S1(s, 8 * un);
    } else (s < w9 || s > Pu(a, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return n.writeValue(s);
  }
  decode(n) {
    let r = Pu(n.readValue(), this.size * 8);
    return this.signed && (r = bI(r, this.size * 8)), r;
  }
}
class k9 extends s8 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, n) {
    return super.encode(e, kn(Vt.dereference(n, "string")));
  }
  decode(e) {
    return _p(super.decode(e));
  }
}
class If extends Ws {
  constructor(n, r) {
    let s = !1;
    const a = [];
    n.forEach((o) => {
      o.dynamic && (s = !0), a.push(o.type);
    });
    const i = "tuple(" + a.join(",") + ")";
    super("tuple", i, r, s);
    O(this, "coders");
    le(this, { coders: Object.freeze(n.slice()) });
  }
  defaultValue() {
    const n = [];
    this.coders.forEach((s) => {
      n.push(s.defaultValue());
    });
    const r = this.coders.reduce((s, a) => {
      const i = a.localName;
      return i && (s[i] || (s[i] = 0), s[i]++), s;
    }, {});
    return this.coders.forEach((s, a) => {
      let i = s.localName;
      !i || r[i] !== 1 || (i === "length" && (i = "_length"), n[i] == null && (n[i] = n[a]));
    }), Object.freeze(n);
  }
  encode(n, r) {
    const s = Vt.dereference(r, "tuple");
    return n8(n, this.coders, s);
  }
  decode(n) {
    return r8(n, this.coders);
  }
}
function y0(t, e) {
  return {
    address: de(t),
    storageKeys: e.map((n, r) => (U(Re(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
  };
}
function Ho(t) {
  if (Array.isArray(t))
    return t.map((n, r) => Array.isArray(n) ? (U(n.length === 2, "invalid slot set", `value[${r}]`, n), y0(n[0], n[1])) : (U(n != null && typeof n == "object", "invalid address-slot set", "value", t), y0(n.address, n.storageKeys)));
  U(t != null && typeof t == "object", "invalid access list", "value", t);
  const e = Object.keys(t).map((n) => {
    const r = t[n].reduce((s, a) => (s[a] = !0, s), {});
    return y0(n, Object.keys(r).sort());
  });
  return e.sort((n, r) => n.address.localeCompare(r.address)), e;
}
function a8(t) {
  return {
    address: de(t.address),
    nonce: re(t.nonce != null ? t.nonce : 0),
    chainId: re(t.chainId != null ? t.chainId : 0),
    signature: vn.from(t.signature)
  };
}
function v9(t) {
  let e;
  return typeof t == "string" ? e = od.computePublicKey(t, !1) : e = t.publicKey, de(ke("0x" + e.substring(4)).substring(26));
}
function My(t, e) {
  return v9(od.recoverPublicKey(t, e));
}
const wt = BigInt(0), C9 = BigInt(2), T9 = BigInt(27), S9 = BigInt(28), I9 = BigInt(35), O9 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), b0 = 4096 * 32;
function B9(t) {
  return { blobToKzgCommitment: (r) => {
    if ("computeBlobProof" in t) {
      if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
        return ee(t.blobToKzgCommitment(z(r)));
    } else if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
      return ee(t.blobToKzgCommitment(r));
    if ("blobToKZGCommitment" in t && typeof t.blobToKZGCommitment == "function")
      return ee(t.blobToKZGCommitment(z(r)));
    U(!1, "unsupported KZG library", "kzg", t);
  }, computeBlobKzgProof: (r, s) => {
    if ("computeBlobProof" in t && typeof t.computeBlobProof == "function")
      return ee(t.computeBlobProof(z(r), z(s)));
    if ("computeBlobKzgProof" in t && typeof t.computeBlobKzgProof == "function")
      return t.computeBlobKzgProof(r, s);
    if ("computeBlobKZGProof" in t && typeof t.computeBlobKZGProof == "function")
      return ee(t.computeBlobKZGProof(z(r), z(s)));
    U(!1, "unsupported KZG library", "kzg", t);
  } };
}
function Ax(t, e) {
  let n = t.toString(16);
  for (; n.length < 2; )
    n = "0" + n;
  return n += jl(e).substring(4), "0x" + n;
}
function Vl(t) {
  return t === "0x" ? null : de(t);
}
function Vh(t, e) {
  try {
    return Ho(t);
  } catch (n) {
    U(!1, n.message, e, t);
  }
}
function P9(t, e) {
  try {
    if (!Array.isArray(t))
      throw new Error("authorizationList: invalid array");
    const n = [];
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (!Array.isArray(s))
        throw new Error(`authorization[${r}]: invalid array`);
      if (s.length !== 6)
        throw new Error(`authorization[${r}]: wrong length`);
      if (!s[1])
        throw new Error(`authorization[${r}]: null address`);
      n.push({
        address: Vl(s[1]),
        nonce: He(s[2], "nonce"),
        chainId: He(s[0], "chainId"),
        signature: vn.from({
          yParity: _o(s[3], "yParity"),
          r: Mn(s[4], 32),
          s: Mn(s[5], 32)
        })
      });
    }
    return n;
  } catch (n) {
    U(!1, n.message, e, t);
  }
}
function _o(t, e) {
  return t === "0x" ? 0 : Ee(t, e);
}
function He(t, e) {
  if (t === "0x")
    return wt;
  const n = re(t, e);
  return U(n <= O9, "value exceeds uint size", e, n), n;
}
function Te(t, e) {
  const n = re(t, "value"), r = dt(n);
  return U(r.length <= 32, "value too large", `tx.${e}`, n), r;
}
function qh(t) {
  return Ho(t).map((e) => [e.address, e.storageKeys]);
}
function U9(t) {
  return t.map((e) => [
    Te(e.chainId, "chainId"),
    e.address,
    Te(e.nonce, "nonce"),
    Te(e.signature.yParity, "yParity"),
    dt(e.signature.r),
    dt(e.signature.s)
  ]);
}
function N9(t, e) {
  U(Array.isArray(t), `invalid ${e}`, "value", t);
  for (let n = 0; n < t.length; n++)
    U(Re(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
  return t;
}
function R9(t) {
  const e = Qd(t);
  U(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
  const n = {
    type: 0,
    nonce: _o(e[0], "nonce"),
    gasPrice: He(e[1], "gasPrice"),
    gasLimit: He(e[2], "gasLimit"),
    to: Vl(e[3]),
    value: He(e[4], "value"),
    data: z(e[5]),
    chainId: wt
  };
  if (e.length === 6)
    return n;
  const r = He(e[6], "v"), s = He(e[7], "r"), a = He(e[8], "s");
  if (s === wt && a === wt)
    n.chainId = r;
  else {
    let i = (r - I9) / C9;
    i < wt && (i = wt), n.chainId = i, U(i !== wt || r === T9 || r === S9, "non-canonical legacy v", "v", e[6]), n.signature = vn.from({
      r: Mn(e[7], 32),
      s: Mn(e[8], 32),
      v: r
    });
  }
  return n;
}
function D9(t, e) {
  const n = [
    Te(t.nonce, "nonce"),
    Te(t.gasPrice || 0, "gasPrice"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data
  ];
  let r = wt;
  if (t.chainId != wt)
    r = re(t.chainId, "tx.chainId"), U(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
  else if (t.signature) {
    const a = t.signature.legacyChainId;
    a != null && (r = a);
  }
  if (!e)
    return r !== wt && (n.push(dt(r)), n.push("0x"), n.push("0x")), Ya(n);
  let s = BigInt(27 + e.yParity);
  return r !== wt ? s = vn.getChainIdV(r, e.v) : BigInt(e.v) !== s && U(!1, "tx.chainId/sig.v mismatch", "sig", e), n.push(dt(s)), n.push(dt(e.r)), n.push(dt(e.s)), Ya(n);
}
function Kh(t, e) {
  let n;
  try {
    if (n = _o(e[0], "yParity"), n !== 0 && n !== 1)
      throw new Error("bad yParity");
  } catch {
    U(!1, "invalid yParity", "yParity", e[0]);
  }
  const r = Mn(e[1], 32), s = Mn(e[2], 32), a = vn.from({ r, s, yParity: n });
  t.signature = a;
}
function F9(t) {
  const e = Qd(ee(t).slice(1));
  U(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", z(t));
  const n = {
    type: 2,
    chainId: He(e[0], "chainId"),
    nonce: _o(e[1], "nonce"),
    maxPriorityFeePerGas: He(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: He(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: He(e[4], "gasLimit"),
    to: Vl(e[5]),
    value: He(e[6], "value"),
    data: z(e[7]),
    accessList: Vh(e[8], "accessList")
  };
  return e.length === 9 || Kh(n, e.slice(9)), n;
}
function M9(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    qh(t.accessList || [])
  ];
  return e && (n.push(Te(e.yParity, "yParity")), n.push(dt(e.r)), n.push(dt(e.s))), _e(["0x02", Ya(n)]);
}
function L9(t) {
  const e = Qd(ee(t).slice(1));
  U(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", z(t));
  const n = {
    type: 1,
    chainId: He(e[0], "chainId"),
    nonce: _o(e[1], "nonce"),
    gasPrice: He(e[2], "gasPrice"),
    gasLimit: He(e[3], "gasLimit"),
    to: Vl(e[4]),
    value: He(e[5], "value"),
    data: z(e[6]),
    accessList: Vh(e[7], "accessList")
  };
  return e.length === 8 || Kh(n, e.slice(8)), n;
}
function H9(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.gasPrice || 0, "gasPrice"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    qh(t.accessList || [])
  ];
  return e && (n.push(Te(e.yParity, "recoveryParam")), n.push(dt(e.r)), n.push(dt(e.s))), _e(["0x01", Ya(n)]);
}
function _9(t) {
  let e = Qd(ee(t).slice(1)), n = "3", r = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    n = "3 (network format)";
    const a = e[1], i = e[2], o = e[3];
    U(Array.isArray(a), "invalid network format: blobs not an array", "fields[1]", a), U(Array.isArray(i), "invalid network format: commitments not an array", "fields[2]", i), U(Array.isArray(o), "invalid network format: proofs not an array", "fields[3]", o), U(a.length === i.length, "invalid network format: blobs/commitments length mismatch", "fields", e), U(a.length === o.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
    for (let c = 0; c < e[1].length; c++)
      r.push({
        data: a[c],
        commitment: i[c],
        proof: o[c]
      });
    e = e[0];
  }
  U(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${n}`, "data", z(t));
  const s = {
    type: 3,
    chainId: He(e[0], "chainId"),
    nonce: _o(e[1], "nonce"),
    maxPriorityFeePerGas: He(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: He(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: He(e[4], "gasLimit"),
    to: Vl(e[5]),
    value: He(e[6], "value"),
    data: z(e[7]),
    accessList: Vh(e[8], "accessList"),
    maxFeePerBlobGas: He(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  r && (s.blobs = r), U(s.to != null, `invalid address for transaction type: ${n}`, "data", t), U(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
  for (let a = 0; a < s.blobVersionedHashes.length; a++)
    U(Re(s.blobVersionedHashes[a], 32), `invalid blobVersionedHash at index ${a}: must be length 32`, "data", t);
  return e.length === 11 || Kh(s, e.slice(11)), s;
}
function $9(t, e, n) {
  const r = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || ti,
    Te(t.value, "value"),
    t.data,
    qh(t.accessList || []),
    Te(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    N9(t.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (r.push(Te(e.yParity, "yParity")), r.push(dt(e.r)), r.push(dt(e.s)), n) ? _e([
    "0x03",
    Ya([
      r,
      n.map((s) => s.data),
      n.map((s) => s.commitment),
      n.map((s) => s.proof)
    ])
  ]) : _e(["0x03", Ya(r)]);
}
function G9(t) {
  const e = Qd(ee(t).slice(1));
  U(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", z(t));
  const n = {
    type: 4,
    chainId: He(e[0], "chainId"),
    nonce: _o(e[1], "nonce"),
    maxPriorityFeePerGas: He(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: He(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: He(e[4], "gasLimit"),
    to: Vl(e[5]),
    value: He(e[6], "value"),
    data: z(e[7]),
    accessList: Vh(e[8], "accessList"),
    authorizationList: P9(e[9], "authorizationList")
  };
  return e.length === 10 || Kh(n, e.slice(10)), n;
}
function z9(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    qh(t.accessList || []),
    U9(t.authorizationList || [])
  ];
  return e && (n.push(Te(e.yParity, "yParity")), n.push(dt(e.r)), n.push(dt(e.s))), _e(["0x04", Ya(n)]);
}
var Er, Qc, Jc, Xc, Zc, Yc, el, tl, nl, rl, sl, al, to, Ia, Wr, Oa, il, ol, bp;
const $r = class $r {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    B(this, ol);
    B(this, Er);
    B(this, Qc);
    B(this, Jc);
    B(this, Xc);
    B(this, Zc);
    B(this, Yc);
    B(this, el);
    B(this, tl);
    B(this, nl);
    B(this, rl);
    B(this, sl);
    B(this, al);
    B(this, to);
    B(this, Ia);
    B(this, Wr);
    B(this, Oa);
    B(this, il);
    x(this, Er, null), x(this, Qc, null), x(this, Xc, 0), x(this, Zc, wt), x(this, Yc, null), x(this, el, null), x(this, tl, null), x(this, Jc, "0x"), x(this, nl, wt), x(this, rl, wt), x(this, sl, null), x(this, al, null), x(this, to, null), x(this, Ia, null), x(this, Wr, null), x(this, Oa, null), x(this, il, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return m(this, Er);
  }
  set type(e) {
    switch (e) {
      case null:
        x(this, Er, null);
        break;
      case 0:
      case "legacy":
        x(this, Er, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        x(this, Er, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        x(this, Er, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        x(this, Er, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        x(this, Er, 4);
        break;
      default:
        U(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = m(this, Qc);
    return e == null && this.type === 3 ? ti : e;
  }
  set to(e) {
    x(this, Qc, e == null ? null : de(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return m(this, Xc);
  }
  set nonce(e) {
    x(this, Xc, Ee(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return m(this, Zc);
  }
  set gasLimit(e) {
    x(this, Zc, re(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = m(this, Yc);
    return e == null && (this.type === 0 || this.type === 1) ? wt : e;
  }
  set gasPrice(e) {
    x(this, Yc, e == null ? null : re(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = m(this, el);
    return e ?? (this.type === 2 || this.type === 3 ? wt : null);
  }
  set maxPriorityFeePerGas(e) {
    x(this, el, e == null ? null : re(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = m(this, tl);
    return e ?? (this.type === 2 || this.type === 3 ? wt : null);
  }
  set maxFeePerGas(e) {
    x(this, tl, e == null ? null : re(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return m(this, Jc);
  }
  set data(e) {
    x(this, Jc, z(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return m(this, nl);
  }
  set value(e) {
    x(this, nl, re(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return m(this, rl);
  }
  set chainId(e) {
    x(this, rl, re(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return m(this, sl) || null;
  }
  set signature(e) {
    x(this, sl, e == null ? null : vn.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = m(this, al) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    x(this, al, e == null ? null : Ho(e));
  }
  get authorizationList() {
    const e = m(this, il) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    x(this, il, e == null ? null : e.map((n) => a8(n)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = m(this, to);
    return e == null && this.type === 3 ? wt : e;
  }
  set maxFeePerBlobGas(e) {
    x(this, to, e == null ? null : re(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = m(this, Ia);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      U(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let n = 0; n < e.length; n++)
        U(Re(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n]);
    }
    x(this, Ia, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return m(this, Oa) == null ? null : m(this, Oa).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      x(this, Oa, null);
      return;
    }
    const n = [], r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (ko(a)) {
        q(m(this, Wr), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let i = ee(a);
        if (U(i.length <= b0, "blob is too large", `blobs[${s}]`, a), i.length !== b0) {
          const u = new Uint8Array(b0);
          u.set(i), i = u;
        }
        const o = m(this, Wr).blobToKzgCommitment(i), c = z(m(this, Wr).computeBlobKzgProof(i, o));
        n.push({
          data: z(i),
          commitment: z(o),
          proof: c
        }), r.push(Ax(1, o));
      } else {
        const i = z(a.commitment);
        n.push({
          data: z(a.data),
          commitment: i,
          proof: z(a.proof)
        }), r.push(Ax(1, i));
      }
    }
    x(this, Oa, n), x(this, Ia, r);
  }
  get kzg() {
    return m(this, Wr);
  }
  set kzg(e) {
    e == null ? x(this, Wr, null) : x(this, Wr, B9(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : ke(G(this, ol, bp).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return ke(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : My(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : od.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return G(this, ol, bp).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return G(this, ol, bp).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, s = m(this, to) != null || m(this, Ia);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && q(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), q(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), q(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const a = [];
    return this.type != null ? a.push(this.type) : this.authorizationList && this.authorizationList.length ? a.push(4) : n ? a.push(2) : e ? (a.push(1), r || a.push(0)) : r ? (a.push(1), a.push(2)) : (s && this.to || (a.push(0), a.push(1), a.push(2)), a.push(3)), a.sort(), a;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return $r.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (n) => n == null ? null : n.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new $r();
    if (typeof e == "string") {
      const r = ee(e);
      if (r[0] >= 127)
        return $r.from(R9(r));
      switch (r[0]) {
        case 1:
          return $r.from(L9(r));
        case 2:
          return $r.from(F9(r));
        case 3:
          return $r.from(_9(r));
        case 4:
          return $r.from(G9(r));
      }
      q(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const n = new $r();
    return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = vn.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.authorizationList != null && (n.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (n.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (n.kzg = e.kzg), e.blobs != null && (n.blobs = e.blobs), e.hash != null && (U(n.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), U(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (U(n.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), U(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n;
  }
};
Er = new WeakMap(), Qc = new WeakMap(), Jc = new WeakMap(), Xc = new WeakMap(), Zc = new WeakMap(), Yc = new WeakMap(), el = new WeakMap(), tl = new WeakMap(), nl = new WeakMap(), rl = new WeakMap(), sl = new WeakMap(), al = new WeakMap(), to = new WeakMap(), Ia = new WeakMap(), Wr = new WeakMap(), Oa = new WeakMap(), il = new WeakMap(), ol = new WeakSet(), bp = function(e, n) {
  q(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return D9(this, r);
    case 1:
      return H9(this, r);
    case 2:
      return M9(this, r);
    case 3:
      return $9(this, r, n ? this.blobs : null);
    case 4:
      return z9(this, r);
  }
  q(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let zp = $r;
function is(t) {
  return ke(kn(t));
}
var j9 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const kx = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), vx = 4;
function V9(t) {
  let e = 0;
  function n() {
    return t[e++] << 8 | t[e++];
  }
  let r = n(), s = 1, a = [0, 1];
  for (let A = 1; A < r; A++)
    a.push(s += n());
  let i = n(), o = e;
  e += i;
  let c = 0, u = 0;
  function l() {
    return c == 0 && (u = u << 8 | t[e++], c = 8), u >> --c & 1;
  }
  const d = 31, p = 2 ** d, f = p >>> 1, b = f >> 1, y = p - 1;
  let g = 0;
  for (let A = 0; A < d; A++) g = g << 1 | l();
  let w = [], k = 0, E = p;
  for (; ; ) {
    let A = Math.floor(((g - k + 1) * s - 1) / E), N = 0, D = r;
    for (; D - N > 1; ) {
      let S = N + D >>> 1;
      A < a[S] ? D = S : N = S;
    }
    if (N == 0) break;
    w.push(N);
    let P = k + Math.floor(E * a[N] / s), C = k + Math.floor(E * a[N + 1] / s) - 1;
    for (; !((P ^ C) & f); )
      g = g << 1 & y | l(), P = P << 1 & y, C = C << 1 & y | 1;
    for (; P & ~C & b; )
      g = g & f | g << 1 & y >>> 1 | l(), P = P << 1 ^ f, C = (C ^ f) << 1 | f | 1;
    k = P, E = 1 + C - P;
  }
  let T = r - 4;
  return w.map((A) => {
    switch (A - T) {
      case 3:
        return T + 65792 + (t[o++] << 16 | t[o++] << 8 | t[o++]);
      case 2:
        return T + 256 + (t[o++] << 8 | t[o++]);
      case 1:
        return T + t[o++];
      default:
        return A - 1;
    }
  });
}
function q9(t) {
  let e = 0;
  return () => t[e++];
}
function i8(t) {
  return q9(V9(K9(t)));
}
function K9(t) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, a) => e[s.charCodeAt(0)] = a);
  let n = t.length, r = new Uint8Array(6 * n >> 3);
  for (let s = 0, a = 0, i = 0, o = 0; s < n; s++)
    o = o << 6 | e[t.charCodeAt(s)], i += 6, i >= 8 && (r[a++] = o >> (i -= 8));
  return r;
}
function W9(t) {
  return t & 1 ? ~t >> 1 : t >> 1;
}
function Q9(t, e) {
  let n = Array(t);
  for (let r = 0, s = 0; r < t; r++) n[r] = s += W9(e());
  return n;
}
function cd(t, e = 0) {
  let n = [];
  for (; ; ) {
    let r = t(), s = t();
    if (!s) break;
    e += r;
    for (let a = 0; a < s; a++)
      n.push(e + a);
    e += s + 1;
  }
  return n;
}
function o8(t) {
  return ld(() => {
    let e = cd(t);
    if (e.length) return e;
  });
}
function c8(t) {
  let e = [];
  for (; ; ) {
    let n = t();
    if (n == 0) break;
    e.push(J9(n, t));
  }
  for (; ; ) {
    let n = t() - 1;
    if (n < 0) break;
    e.push(X9(n, t));
  }
  return e.flat();
}
function ld(t) {
  let e = [];
  for (; ; ) {
    let n = t(e.length);
    if (!n) break;
    e.push(n);
  }
  return e;
}
function l8(t, e, n) {
  let r = Array(t).fill().map(() => []);
  for (let s = 0; s < e; s++)
    Q9(t, n).forEach((a, i) => r[i].push(a));
  return r;
}
function J9(t, e) {
  let n = 1 + e(), r = e(), s = ld(e);
  return l8(s.length, 1 + t, e).flatMap((i, o) => {
    let [c, ...u] = i;
    return Array(s[o]).fill().map((l, d) => {
      let p = d * r;
      return [c + d * n, u.map((f) => f + p)];
    });
  });
}
function X9(t, e) {
  let n = 1 + e();
  return l8(n, 1 + t, e).map((s) => [s[0], s.slice(1)]);
}
function Z9(t) {
  let e = [], n = cd(t);
  return s(r([]), []), e;
  function r(a) {
    let i = t(), o = ld(() => {
      let c = cd(t).map((u) => n[u]);
      if (c.length) return r(c);
    });
    return { S: i, B: o, Q: a };
  }
  function s({ S: a, B: i }, o, c) {
    if (!(a & 4 && c === o[o.length - 1])) {
      a & 2 && (c = o[o.length - 1]), a & 1 && e.push(o);
      for (let u of i)
        for (let l of u.Q)
          s(u, [...o, l], c);
    }
  }
}
function Y9(t) {
  return t.toString(16).toUpperCase().padStart(2, "0");
}
function u8(t) {
  return `{${Y9(t)}}`;
}
function eB(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; ) {
    let s = t.codePointAt(n);
    n += s < 65536 ? 1 : 2, e.push(s);
  }
  return e;
}
function Bl(t) {
  let n = t.length;
  if (n < 4096) return String.fromCodePoint(...t);
  let r = [];
  for (let s = 0; s < n; )
    r.push(String.fromCodePoint(...t.slice(s, s += 4096)));
  return r.join("");
}
function tB(t, e) {
  let n = t.length, r = n - e.length;
  for (let s = 0; r == 0 && s < n; s++) r = t[s] - e[s];
  return r;
}
var nB = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const ud = 44032, jp = 4352, Vp = 4449, qp = 4519, d8 = 19, f8 = 21, Pl = 28, Kp = f8 * Pl, rB = d8 * Kp, sB = ud + rB, aB = jp + d8, iB = Vp + f8, oB = qp + Pl;
function Nu(t) {
  return t >> 24 & 255;
}
function p8(t) {
  return t & 16777215;
}
let Ly, Cx, Hy, gp;
function cB() {
  let t = i8(nB);
  Ly = new Map(o8(t).flatMap((e, n) => e.map((r) => [r, n + 1 << 24]))), Cx = new Set(cd(t)), Hy = /* @__PURE__ */ new Map(), gp = /* @__PURE__ */ new Map();
  for (let [e, n] of c8(t)) {
    if (!Cx.has(e) && n.length == 2) {
      let [r, s] = n, a = gp.get(r);
      a || (a = /* @__PURE__ */ new Map(), gp.set(r, a)), a.set(s, e);
    }
    Hy.set(e, n.reverse());
  }
}
function h8(t) {
  return t >= ud && t < sB;
}
function lB(t, e) {
  if (t >= jp && t < aB && e >= Vp && e < iB)
    return ud + (t - jp) * Kp + (e - Vp) * Pl;
  if (h8(t) && e > qp && e < oB && (t - ud) % Pl == 0)
    return t + (e - qp);
  {
    let n = gp.get(t);
    return n && (n = n.get(e), n) ? n : -1;
  }
}
function m8(t) {
  Ly || cB();
  let e = [], n = [], r = !1;
  function s(a) {
    let i = Ly.get(a);
    i && (r = !0, a |= i), e.push(a);
  }
  for (let a of t)
    for (; ; ) {
      if (a < 128)
        e.push(a);
      else if (h8(a)) {
        let i = a - ud, o = i / Kp | 0, c = i % Kp / Pl | 0, u = i % Pl;
        s(jp + o), s(Vp + c), u > 0 && s(qp + u);
      } else {
        let i = Hy.get(a);
        i ? n.push(...i) : s(a);
      }
      if (!n.length) break;
      a = n.pop();
    }
  if (r && e.length > 1) {
    let a = Nu(e[0]);
    for (let i = 1; i < e.length; i++) {
      let o = Nu(e[i]);
      if (o == 0 || a <= o) {
        a = o;
        continue;
      }
      let c = i - 1;
      for (; ; ) {
        let u = e[c + 1];
        if (e[c + 1] = e[c], e[c] = u, !c || (a = Nu(e[--c]), a <= o)) break;
      }
      a = Nu(e[i]);
    }
  }
  return e;
}
function uB(t) {
  let e = [], n = [], r = -1, s = 0;
  for (let a of t) {
    let i = Nu(a), o = p8(a);
    if (r == -1)
      i == 0 ? r = o : e.push(o);
    else if (s > 0 && s >= i)
      i == 0 ? (e.push(r, ...n), n.length = 0, r = o) : n.push(o), s = i;
    else {
      let c = lB(r, o);
      c >= 0 ? r = c : s == 0 && i == 0 ? (e.push(r), r = o) : (n.push(o), s = i);
    }
  }
  return r >= 0 && e.push(r, ...n), e;
}
function y8(t) {
  return m8(t).map(p8);
}
function dB(t) {
  return uB(m8(t));
}
const Tx = 45, b8 = ".", g8 = 65039, w8 = 1, Wp = (t) => Array.from(t);
function dd(t, e) {
  return t.P.has(e) || t.Q.has(e);
}
class fB extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let _y, E8, ki, $y, x8, yc, g0, Yo, mi, Sx, Gy;
function M1() {
  if (_y) return;
  let t = i8(j9);
  const e = () => cd(t), n = () => new Set(e()), r = (l, d) => d.forEach((p) => l.add(p));
  _y = new Map(c8(t)), E8 = n(), ki = e(), $y = new Set(e().map((l) => ki[l])), ki = new Set(ki), x8 = n(), n();
  let s = o8(t), a = t();
  const i = () => {
    let l = /* @__PURE__ */ new Set();
    return e().forEach((d) => r(l, s[d])), r(l, e()), l;
  };
  yc = ld((l) => {
    let d = ld(t).map((p) => p + 96);
    if (d.length) {
      let p = l >= a;
      d[0] -= 32, d = Bl(d), p && (d = `Restricted[${d}]`);
      let f = i(), b = i(), y = !t();
      return { N: d, P: f, Q: b, M: y, R: p };
    }
  }), g0 = n(), Yo = /* @__PURE__ */ new Map();
  let o = e().concat(Wp(g0)).sort((l, d) => l - d);
  o.forEach((l, d) => {
    let p = t(), f = o[d] = p ? o[d - p] : { V: [], M: /* @__PURE__ */ new Map() };
    f.V.push(l), g0.has(l) || Yo.set(l, f);
  });
  for (let { V: l, M: d } of new Set(Yo.values())) {
    let p = [];
    for (let b of l) {
      let y = yc.filter((w) => dd(w, b)), g = p.find(({ G: w }) => y.some((k) => w.has(k)));
      g || (g = { G: /* @__PURE__ */ new Set(), V: [] }, p.push(g)), g.V.push(b), r(g.G, y);
    }
    let f = p.flatMap((b) => Wp(b.G));
    for (let { G: b, V: y } of p) {
      let g = new Set(f.filter((w) => !b.has(w)));
      for (let w of y)
        d.set(w, g);
    }
  }
  mi = /* @__PURE__ */ new Set();
  let c = /* @__PURE__ */ new Set();
  const u = (l) => mi.has(l) ? c.add(l) : mi.add(l);
  for (let l of yc) {
    for (let d of l.P) u(d);
    for (let d of l.Q) u(d);
  }
  for (let l of mi)
    !Yo.has(l) && !c.has(l) && Yo.set(l, w8);
  r(mi, y8(mi)), Sx = Z9(t).map((l) => fB.from(l)).sort(tB), Gy = /* @__PURE__ */ new Map();
  for (let l of Sx) {
    let d = [Gy];
    for (let p of l) {
      let f = d.map((b) => {
        let y = b.get(p);
        return y || (y = /* @__PURE__ */ new Map(), b.set(p, y)), y;
      });
      p === g8 ? d.push(...f) : d = f;
    }
    for (let p of d)
      p.V = l;
  }
}
function L1(t) {
  return (A8(t) ? "" : `${H1(Wh([t]))} `) + u8(t);
}
function H1(t) {
  return `"${t}"`;
}
function pB(t) {
  if (t.length >= 4 && t[2] == Tx && t[3] == Tx)
    throw new Error(`invalid label extension: "${Bl(t.slice(0, 4))}"`);
}
function hB(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function mB(t) {
  let e = t[0], n = kx.get(e);
  if (n) throw Gu(`leading ${n}`);
  let r = t.length, s = -1;
  for (let a = 1; a < r; a++) {
    e = t[a];
    let i = kx.get(e);
    if (i) {
      if (s == a) throw Gu(`${n} + ${i}`);
      s = a + 1, n = i;
    }
  }
  if (s == r) throw Gu(`trailing ${n}`);
}
function Wh(t, e = 1 / 0, n = u8) {
  let r = [];
  yB(t[0]) && r.push(""), t.length > e && (e >>= 1, t = [...t.slice(0, e), 8230, ...t.slice(-e)]);
  let s = 0, a = t.length;
  for (let i = 0; i < a; i++) {
    let o = t[i];
    A8(o) && (r.push(Bl(t.slice(s, i))), r.push(n(o)), s = i + 1);
  }
  return r.push(Bl(t.slice(s, a))), r.join("");
}
function yB(t) {
  return M1(), ki.has(t);
}
function A8(t) {
  return M1(), x8.has(t);
}
function bB(t) {
  return xB(gB(t, dB, vB));
}
function gB(t, e, n) {
  if (!t) return [];
  M1();
  let r = 0;
  return t.split(b8).map((s) => {
    let a = eB(s), i = {
      input: a,
      offset: r
      // codepoint, not substring!
    };
    r += a.length + 1;
    try {
      let o = i.tokens = kB(a, e, n), c = o.length, u;
      if (!c)
        throw new Error("empty label");
      let l = i.output = o.flat();
      if (hB(l), !(i.emoji = c > 1 || o[0].is_emoji) && l.every((p) => p < 128))
        pB(l), u = "ASCII";
      else {
        let p = o.flatMap((f) => f.is_emoji ? [] : f);
        if (!p.length)
          u = "Emoji";
        else {
          if (ki.has(l[0])) throw Gu("leading combining mark");
          for (let y = 1; y < c; y++) {
            let g = o[y];
            if (!g.is_emoji && ki.has(g[0]))
              throw Gu(`emoji + combining mark: "${Bl(o[y - 1])} + ${Wh([g[0]])}"`);
          }
          mB(l);
          let f = Wp(new Set(p)), [b] = EB(f);
          AB(b, p), wB(b, f), u = b.N;
        }
      }
      i.type = u;
    } catch (o) {
      i.error = o;
    }
    return i;
  });
}
function wB(t, e) {
  let n, r = [];
  for (let s of e) {
    let a = Yo.get(s);
    if (a === w8) return;
    if (a) {
      let i = a.M.get(s);
      if (n = n ? n.filter((o) => i.has(o)) : Wp(i), !n.length) return;
    } else
      r.push(s);
  }
  if (n) {
    for (let s of n)
      if (r.every((a) => dd(s, a)))
        throw new Error(`whole-script confusable: ${t.N}/${s.N}`);
  }
}
function EB(t) {
  let e = yc;
  for (let n of t) {
    let r = e.filter((s) => dd(s, n));
    if (!r.length)
      throw yc.some((s) => dd(s, n)) ? v8(e[0], n) : k8(n);
    if (e = r, r.length == 1) break;
  }
  return e;
}
function xB(t) {
  return t.map(({ input: e, error: n, output: r }) => {
    if (n) {
      let s = n.message;
      throw new Error(t.length == 1 ? s : `Invalid label ${H1(Wh(e, 63))}: ${s}`);
    }
    return Bl(r);
  }).join(b8);
}
function k8(t) {
  return new Error(`disallowed character: ${L1(t)}`);
}
function v8(t, e) {
  let n = L1(e), r = yc.find((s) => s.P.has(e));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`);
}
function Gu(t) {
  return new Error(`illegal placement: ${t}`);
}
function AB(t, e) {
  for (let n of e)
    if (!dd(t, n))
      throw v8(t, n);
  if (t.M) {
    let n = y8(e);
    for (let r = 1, s = n.length; r < s; r++)
      if ($y.has(n[r])) {
        let a = r + 1;
        for (let i; a < s && $y.has(i = n[a]); a++)
          for (let o = r; o < a; o++)
            if (n[o] == i)
              throw new Error(`duplicate non-spacing marks: ${L1(i)}`);
        if (a - r > vx)
          throw new Error(`excessive non-spacing marks: ${H1(Wh(n.slice(r - 1, a)))} (${a - r}/${vx})`);
        r = a;
      }
  }
}
function kB(t, e, n) {
  let r = [], s = [];
  for (t = t.slice().reverse(); t.length; ) {
    let a = CB(t);
    if (a)
      s.length && (r.push(e(s)), s = []), r.push(n(a));
    else {
      let i = t.pop();
      if (mi.has(i))
        s.push(i);
      else {
        let o = _y.get(i);
        if (o)
          s.push(...o);
        else if (!E8.has(i))
          throw k8(i);
      }
    }
  }
  return s.length && r.push(e(s)), r;
}
function vB(t) {
  return t.filter((e) => e != g8);
}
function CB(t, e) {
  let n = Gy, r, s = t.length;
  for (; s && (n = n.get(t[--s]), !!n); ) {
    let { V: a } = n;
    a && (r = a, t.length = s);
  }
  return r;
}
const C8 = new Uint8Array(32);
C8.fill(0);
function Ix(t) {
  return U(t.length !== 0, "invalid ENS name; empty component", "comp", t), t;
}
function T8(t) {
  const e = kn(TB(t)), n = [];
  if (t.length === 0)
    return n;
  let r = 0;
  for (let s = 0; s < e.length; s++)
    e[s] === 46 && (n.push(Ix(e.slice(r, s))), r = s + 1);
  return U(r < e.length, "invalid ENS name; empty component", "name", t), n.push(Ix(e.slice(r))), n;
}
function TB(t) {
  try {
    if (t.length === 0)
      throw new Error("empty label");
    return bB(t);
  } catch (e) {
    U(!1, `invalid ENS name (${e.message})`, "name", t);
  }
}
function zy(t) {
  U(typeof t == "string", "invalid ENS name; not a string", "name", t), U(t.length, "invalid ENS name (empty label)", "name", t);
  let e = C8;
  const n = T8(t);
  for (; n.length; )
    e = ke(_e([e, ke(n.pop())]));
  return z(e);
}
function SB(t, e) {
  const n = e;
  return U(n <= 255, "DNS encoded label cannot exceed 255", "length", n), z(_e(T8(t).map((r) => {
    U(r.length <= n, `label ${JSON.stringify(t)} exceeds ${n} bytes`, "name", t);
    const s = new Uint8Array(r.length + 1);
    return s.set(r, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
function S8(t) {
  return typeof t == "string" && (t = kn(t)), ke(_e([
    kn(e8),
    kn(String(t.length)),
    t
  ]));
}
const IB = new RegExp("^bytes([0-9]+)$"), OB = new RegExp("^(u?int)([0-9]*)$"), BB = new RegExp("^(.*)\\[([0-9]*)\\]$");
function I8(t, e, n) {
  switch (t) {
    case "address":
      return ee(n ? Mn(e, 32) : de(e));
    case "string":
      return kn(e);
    case "bytes":
      return ee(e);
    case "bool":
      return e = e ? "0x01" : "0x00", ee(n ? Mn(e, 32) : e);
  }
  let r = t.match(OB);
  if (r) {
    let s = r[1] === "int", a = parseInt(r[2] || "256");
    return U((!r[2] || r[2] === String(a)) && a % 8 === 0 && a !== 0 && a <= 256, "invalid number type", "type", t), n && (a = 256), s && (e = S1(e, a)), ee(Mn(dt(e), a / 8));
  }
  if (r = t.match(IB), r) {
    const s = parseInt(r[1]);
    return U(String(s) === r[1] && s !== 0 && s <= 32, "invalid bytes type", "type", t), U(fo(e) === s, `invalid value for ${t}`, "value", e), n ? ee(uk(e, 32)) : e;
  }
  if (r = t.match(BB), r && Array.isArray(e)) {
    const s = r[1], a = parseInt(r[2] || String(e.length));
    U(a === e.length, `invalid array length for ${t}`, "value", e);
    const i = [];
    return e.forEach(function(o) {
      i.push(I8(s, o, !0));
    }), ee(_e(i));
  }
  U(!1, "invalid type", "type", t);
}
function Ae(t, e) {
  U(t.length === e.length, "wrong number of values; expected ${ types.length }", "values", e);
  const n = [];
  return t.forEach(function(r, s) {
    n.push(I8(r, e[s]));
  }), z(_e(n));
}
function ho(t, e) {
  return ke(Ae(t, e));
}
const O8 = new Uint8Array(32);
O8.fill(0);
const PB = BigInt(-1), B8 = BigInt(0), P8 = BigInt(1), UB = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function NB(t) {
  const e = ee(t), n = e.length % 32;
  return n ? _e([e, O8.slice(n)]) : z(e);
}
const RB = Ir(P8, 32), DB = Ir(B8, 32), Ox = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, w0 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function Bx(t) {
  return function(e) {
    return U(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e;
  };
}
const FB = {
  name: Bx("name"),
  version: Bx("version"),
  chainId: function(t) {
    const e = re(t, "domain.chainId");
    return U(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : kr(e);
  },
  verifyingContract: function(t) {
    try {
      return de(t).toLowerCase();
    } catch {
    }
    U(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t);
  },
  salt: function(t) {
    const e = ee(t, "domain.salt");
    return U(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), z(e);
  }
};
function E0(t) {
  {
    const e = t.match(/^(u?)int(\d+)$/);
    if (e) {
      const n = e[1] === "", r = parseInt(e[2]);
      U(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", t);
      const s = Pu(UB, n ? r - 1 : r), a = n ? (s + P8) * PB : B8;
      return function(i) {
        const o = re(i, "value");
        return U(o >= a && o <= s, `value out-of-bounds for ${t}`, "value", o), Ir(n ? S1(o, 256) : o, 32);
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const n = parseInt(e[1]);
      return U(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t), function(r) {
        const s = ee(r);
        return U(s.length === n, `invalid length for ${t}`, "value", r), NB(r);
      };
    }
  }
  switch (t) {
    case "address":
      return function(e) {
        return Mn(de(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? RB : DB;
      };
    case "bytes":
      return function(e) {
        return ke(e);
      };
    case "string":
      return function(e) {
        return is(e);
      };
  }
  return null;
}
function Px(t, e) {
  return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
function Of(t) {
  const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: t };
}
var Ld, Os, cl, Uh, U8;
const Vn = class Vn {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    B(this, Uh);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    O(this, "primaryType");
    B(this, Ld);
    B(this, Os);
    B(this, cl);
    x(this, Os, /* @__PURE__ */ new Map()), x(this, cl, /* @__PURE__ */ new Map());
    const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = {};
    Object.keys(e).forEach((c) => {
      a[c] = e[c].map(({ name: u, type: l }) => {
        let { base: d, index: p } = Of(l);
        return d === "int" && !e.int && (d = "int256"), d === "uint" && !e.uint && (d = "uint256"), { name: u, type: d + (p || "") };
      }), n.set(c, /* @__PURE__ */ new Set()), r.set(c, []), s.set(c, /* @__PURE__ */ new Set());
    }), x(this, Ld, JSON.stringify(a));
    for (const c in a) {
      const u = /* @__PURE__ */ new Set();
      for (const l of a[c]) {
        U(!u.has(l.name), `duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(c)}`, "types", e), u.add(l.name);
        const d = Of(l.type).base;
        U(d !== c, `circular type reference to ${JSON.stringify(d)}`, "types", e), !E0(d) && (U(r.has(d), `unknown type ${JSON.stringify(d)}`, "types", e), r.get(d).push(c), n.get(c).add(d));
      }
    }
    const i = Array.from(r.keys()).filter((c) => r.get(c).length === 0);
    U(i.length !== 0, "missing primary type", "types", e), U(i.length === 1, `ambiguous primary types or unused types: ${i.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), le(this, { primaryType: i[0] });
    function o(c, u) {
      U(!u.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), u.add(c);
      for (const l of n.get(c))
        if (r.has(l)) {
          o(l, u);
          for (const d of u)
            s.get(d).add(l);
        }
      u.delete(c);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [c, u] of s) {
      const l = Array.from(u);
      l.sort(), m(this, Os).set(c, Px(c, a[c]) + l.map((d) => Px(d, a[d])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(m(this, Ld));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let n = m(this, cl).get(e);
    return n || (n = G(this, Uh, U8).call(this, e), m(this, cl).set(e, n)), n;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const n = m(this, Os).get(e);
    return U(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, n) {
    return this.getEncoder(e)(n);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, n) {
    return ke(this.encodeData(e, n));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, n, r) {
    if (E0(e))
      return r(e, n);
    const s = Of(e).array;
    if (s)
      return U(s.count === -1 || s.count === n.length, `array length mismatch; expected length ${s.count}`, "value", n), n.map((i) => this._visit(s.prefix, i, r));
    const a = this.types[e];
    if (a)
      return a.reduce((i, { name: o, type: c }) => (i[o] = this._visit(c, n[o], r), i), {});
    U(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, n) {
    return this._visit(this.primaryType, e, n);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new Vn(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return Vn.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, n, r) {
    return Vn.from(n).hashStruct(e, r);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const n = [];
    for (const r in e) {
      if (e[r] == null)
        continue;
      const s = Ox[r];
      U(s, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({ name: r, type: s });
    }
    return n.sort((r, s) => w0.indexOf(r.name) - w0.indexOf(s.name)), Vn.hashStruct("EIP712Domain", { EIP712Domain: n }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, n, r) {
    return _e([
      "0x1901",
      Vn.hashDomain(e),
      Vn.from(n).hash(r)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, n, r) {
    return ke(Vn.encode(e, n, r));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, n, r, s) {
    e = Object.assign({}, e);
    for (const o in e)
      e[o] == null && delete e[o];
    const a = {};
    e.verifyingContract && !Re(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x");
    const i = Vn.from(n);
    i.visit(r, (o, c) => (o === "address" && !Re(c, 20) && (a[c] = "0x"), c));
    for (const o in a)
      a[o] = await s(o);
    return e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]), r = i.visit(r, (o, c) => o === "address" && a[c] ? a[c] : c), { domain: e, value: r };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, n, r) {
    Vn.hashDomain(e);
    const s = {}, a = [];
    w0.forEach((c) => {
      const u = e[c];
      u != null && (s[c] = FB[c](u), a.push({ name: c, type: Ox[c] }));
    });
    const i = Vn.from(n);
    n = i.types;
    const o = Object.assign({}, n);
    return U(o.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), o.EIP712Domain = a, i.encode(r), {
      types: o,
      domain: s,
      primaryType: i.primaryType,
      message: i.visit(r, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return z(ee(u));
        if (c.match(/^u?int/))
          return re(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return U(typeof u == "string", "invalid string", "value", u), u;
        }
        U(!1, "unsupported type", "type", c);
      })
    };
  }
};
Ld = new WeakMap(), Os = new WeakMap(), cl = new WeakMap(), Uh = new WeakSet(), U8 = function(e) {
  {
    const s = E0(e);
    if (s)
      return s;
  }
  const n = Of(e).array;
  if (n) {
    const s = n.prefix, a = this.getEncoder(s);
    return (i) => {
      U(n.count === -1 || n.count === i.length, `array length mismatch; expected length ${n.count}`, "value", i);
      let o = i.map(a);
      return m(this, Os).has(s) && (o = o.map(ke)), ke(_e(o));
    };
  }
  const r = this.types[e];
  if (r) {
    const s = is(m(this, Os).get(e));
    return (a) => {
      const i = r.map(({ name: o, type: c }) => {
        const u = this.getEncoder(c)(a[o]);
        return m(this, Os).has(c) ? ke(u) : u;
      });
      return i.unshift(s), _e(i);
    };
  }
  U(!1, `unknown type: ${e}`, "type", e);
};
let fd = Vn;
function fn(t) {
  const e = /* @__PURE__ */ new Set();
  return t.forEach((n) => e.add(n)), Object.freeze(e);
}
const MB = "external public payable override", LB = fn(MB.split(" ")), N8 = "constant external internal payable private public pure view override", HB = fn(N8.split(" ")), R8 = "constructor error event fallback function receive struct", D8 = fn(R8.split(" ")), F8 = "calldata memory storage payable indexed", _B = fn(F8.split(" ")), $B = "tuple returns", GB = [R8, F8, $B, N8].join(" "), zB = fn(GB.split(" ")), jB = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, VB = new RegExp("^(\\s*)"), qB = new RegExp("^([0-9]+)"), KB = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), M8 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), L8 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var Ct, xr, Hd, jy;
const Nh = class Nh {
  constructor(e) {
    B(this, Hd);
    B(this, Ct);
    B(this, xr);
    x(this, Ct, 0), x(this, xr, e.slice());
  }
  get offset() {
    return m(this, Ct);
  }
  get length() {
    return m(this, xr).length - m(this, Ct);
  }
  clone() {
    return new Nh(m(this, xr));
  }
  reset() {
    x(this, Ct, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const n = this.peek();
    if (n.type !== "KEYWORD" || !e.has(n.text))
      throw new Error(`expected keyword ${n.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const n = this.peek();
      throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = G(this, Hd, jy).call(this, m(this, Ct) + 1, e.match + 1);
    return x(this, Ct, e.match + 1), n;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = [];
    for (; m(this, Ct) < e.match - 1; ) {
      const r = this.peek().linkNext;
      n.push(G(this, Hd, jy).call(this, m(this, Ct) + 1, r)), x(this, Ct, r);
    }
    return x(this, Ct, e.match + 1), n;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (m(this, Ct) >= m(this, xr).length)
      throw new Error("out-of-bounds");
    return m(this, xr)[m(this, Ct)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const n = this.peekType("KEYWORD");
    return n != null && e.has(n) ? n : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const n = this.peek();
    return n.type === e ? n.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return ra(this, Ct)._++, e;
  }
  toString() {
    const e = [];
    for (let n = m(this, Ct); n < m(this, xr).length; n++) {
      const r = m(this, xr)[n];
      e.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
Ct = new WeakMap(), xr = new WeakMap(), Hd = new WeakSet(), jy = function(e = 0, n = 0) {
  return new Nh(m(this, xr).slice(e, n).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - e,
    linkBack: r.linkBack - e,
    linkNext: r.linkNext - e
  }))));
};
let Or = Nh;
function ui(t) {
  const e = [], n = (i) => {
    const o = a < t.length ? JSON.stringify(t[a]) : "$EOI";
    throw new Error(`invalid token ${o} at ${a}: ${i}`);
  };
  let r = [], s = [], a = 0;
  for (; a < t.length; ) {
    let i = t.substring(a), o = i.match(VB);
    o && (a += o[1].length, i = t.substring(a));
    const c = { depth: r.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: a, value: -1 };
    e.push(c);
    let u = jB[i[0]] || "";
    if (u) {
      if (c.type = u, c.text = i[0], a++, u === "OPEN_PAREN")
        r.push(e.length - 1), s.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        r.length === 0 && n("no matching open bracket"), c.match = r.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (u === "COMMA")
        c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1, s.push(e.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let l = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const d = e.pop().text;
          l = d + l, e[e.length - 1].value = Ee(d);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += l;
      }
      continue;
    }
    if (o = i.match(KB), o) {
      if (c.text = o[1], a += c.text.length, zB.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(L8)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (o = i.match(qB), o) {
      c.text = o[1], c.type = "NUMBER", a += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(i[0])} at position ${a}`);
  }
  return new Or(e.map((i) => Object.freeze(i)));
}
function Ux(t, e) {
  let n = [];
  for (const r in e.keys())
    t.has(r) && n.push(r);
  if (n.length > 1)
    throw new Error(`conflicting types: ${n.join(", ")}`);
}
function Qh(t, e) {
  if (e.peekKeyword(D8)) {
    const n = e.pop().text;
    if (n !== t)
      throw new Error(`expected ${t}, got ${n}`);
  }
  return e.popType("ID");
}
function $s(t, e) {
  const n = /* @__PURE__ */ new Set();
  for (; ; ) {
    const r = t.peekType("KEYWORD");
    if (r == null || e && !e.has(r))
      break;
    if (t.pop(), n.has(r))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    n.add(r);
  }
  return Object.freeze(n);
}
function H8(t) {
  let e = $s(t, HB);
  return Ux(e, fn("constant payable nonpayable".split(" "))), Ux(e, fn("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function Ls(t, e) {
  return t.popParams().map((n) => Nt.from(n, e));
}
function _8(t) {
  if (t.peekType("AT")) {
    if (t.pop(), t.peekType("NUMBER"))
      return re(t.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function vo(t) {
  if (t.length)
    throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`);
}
const WB = new RegExp(/^(.*)\[([0-9]*)\]$/);
function Nx(t) {
  const e = t.match(L8);
  if (U(e, "invalid type", "type", t), t === "uint")
    return "uint256";
  if (t === "int")
    return "int256";
  if (e[2]) {
    const n = parseInt(e[2]);
    U(n !== 0 && n <= 32, "invalid bytes length", "type", t);
  } else if (e[3]) {
    const n = parseInt(e[3]);
    U(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t);
  }
  return t;
}
const qe = {}, On = Symbol.for("_ethers_internal"), Rx = "_ParamTypeInternal", Dx = "_ErrorInternal", Fx = "_EventInternal", Mx = "_ConstructorInternal", Lx = "_FallbackInternal", Hx = "_FunctionInternal", _x = "_StructInternal";
var ll, wp;
const qn = class qn {
  /**
   *  @private
   */
  constructor(e, n, r, s, a, i, o, c) {
    B(this, ll);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    O(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    O(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    O(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    O(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    O(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    O(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    O(this, "arrayChildren");
    if (Hh(e, qe, "ParamType"), Object.defineProperty(this, On, { value: Rx }), i && (i = Object.freeze(i.slice())), s === "array") {
      if (o == null || c == null)
        throw new Error("");
    } else if (o != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (i == null)
        throw new Error("");
    } else if (i != null)
      throw new Error("");
    le(this, {
      name: n,
      type: r,
      baseType: s,
      indexed: a,
      components: i,
      arrayLength: o,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const r = this.name || "";
      if (this.isArray()) {
        const a = JSON.parse(this.arrayChildren.format("json"));
        return a.name = r, a.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(a);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((a) => JSON.parse(a.format(e)))), JSON.stringify(s);
    }
    let n = "";
    return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? n += "(" + this.components.map((r) => r.format(e)).join(e === "full" ? ", " : ",") + ")" : n += this.type, e !== "sighash" && (this.indexed === !0 && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, n) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s) => r.arrayChildren.walk(s, n));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s, a) => r.components[a].walk(s, n));
    }
    return n(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, n) {
    const r = [], s = [e];
    return G(this, ll, wp).call(this, r, e, n, (a) => {
      s[0] = a;
    }), r.length && await Promise.all(r), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, n) {
    if (qn.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return qn.from(ui(e), n);
      } catch {
        U(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof Or) {
      let o = "", c = "", u = null;
      $s(e, fn(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", u = e.popParams().map((y) => qn.from(y)), o = `tuple(${u.map((y) => y.format()).join(",")})`) : (o = Nx(e.popType("TYPE")), c = o);
      let l = null, d = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const y = e.pop();
        l = new qn(qe, "", o, c, null, u, d, l), d = y.value, o += y.text, c = "array", u = null;
      }
      let p = null;
      if ($s(e, _B).has("indexed")) {
        if (!n)
          throw new Error("");
        p = !0;
      }
      const b = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new qn(qe, b, o, c, p, u, d, l);
    }
    const r = e.name;
    U(!r || typeof r == "string" && r.match(M8), "invalid name", "obj.name", r);
    let s = e.indexed;
    s != null && (U(n, "parameter cannot be indexed", "obj.indexed", e.indexed), s = !!s);
    let a = e.type, i = a.match(WB);
    if (i) {
      const o = parseInt(i[2] || "-1"), c = qn.from({
        type: i[1],
        components: e.components
      });
      return new qn(qe, r || "", a, "array", s, null, o, c);
    }
    if (a === "tuple" || a.startsWith(
      "tuple("
      /* fix: ) */
    ) || a.startsWith(
      "("
      /* fix: ) */
    )) {
      const o = e.components != null ? e.components.map((u) => qn.from(u)) : null;
      return new qn(qe, r || "", a, "tuple", s, o, null, null);
    }
    return a = Nx(e.type), new qn(qe, r || "", a, a, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[On] === Rx;
  }
};
ll = new WeakSet(), wp = function(e, n, r, s) {
  if (this.isArray()) {
    if (!Array.isArray(n))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && n.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const i = this.arrayChildren, o = n.slice();
    o.forEach((c, u) => {
      var l;
      G(l = i, ll, wp).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  if (this.isTuple()) {
    const i = this.components;
    let o;
    if (Array.isArray(n))
      o = n.slice();
    else {
      if (n == null || typeof n != "object")
        throw new Error("invalid tuple value");
      o = i.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in n))
          throw new Error(`missing value for component ${c.name}`);
        return n[c.name];
      });
    }
    if (o.length !== this.components.length)
      throw new Error("array is wrong length");
    o.forEach((c, u) => {
      var l;
      G(l = i[u], ll, wp).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  const a = r(this.type, n);
  a.then ? e.push(async function() {
    s(await a);
  }()) : s(a);
};
let Nt = qn;
class Co {
  /**
   *  @private
   */
  constructor(e, n, r) {
    /**
     *  The type of the fragment.
     */
    O(this, "type");
    /**
     *  The inputs for the fragment.
     */
    O(this, "inputs");
    Hh(e, qe, "Fragment"), r = Object.freeze(r.slice()), le(this, { type: n, inputs: r });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        Co.from(JSON.parse(e));
      } catch {
      }
      return Co.from(ui(e));
    }
    if (e instanceof Or)
      switch (e.peekKeyword(D8)) {
        case "constructor":
          return Ms.from(e);
        case "error":
          return xn.from(e);
        case "event":
          return ts.from(e);
        case "fallback":
        case "receive":
          return xs.from(e);
        case "function":
          return ns.from(e);
        case "struct":
          return mo.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return Ms.from(e);
        case "error":
          return xn.from(e);
        case "event":
          return ts.from(e);
        case "fallback":
        case "receive":
          return xs.from(e);
        case "function":
          return ns.from(e);
        case "struct":
          return mo.from(e);
      }
      q(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    U(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return Ms.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return xn.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return ts.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return ns.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return mo.isFragment(e);
  }
}
class Jh extends Co {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, r, a);
    /**
     *  The name of the fragment.
     */
    O(this, "name");
    U(typeof s == "string" && s.match(M8), "invalid identifier", "name", s), a = Object.freeze(a.slice()), le(this, { name: s });
  }
}
function pd(t, e) {
  return "(" + e.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")";
}
class xn extends Jh {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "error", n, r), Object.defineProperty(this, On, { value: Dx });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return is(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("error"), n.push(this.name + pd(e, this.inputs)), n.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (xn.isFragment(e))
      return e;
    if (typeof e == "string")
      return xn.from(ui(e));
    if (e instanceof Or) {
      const n = Qh("error", e), r = Ls(e);
      return vo(e), new xn(qe, n, r);
    }
    return new xn(qe, e.name, e.inputs ? e.inputs.map(Nt.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[On] === Dx;
  }
}
class ts extends Jh {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, "event", r, s);
    /**
     *  Whether this event is anonymous.
     */
    O(this, "anonymous");
    Object.defineProperty(this, On, { value: Fx }), le(this, { anonymous: a });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return is(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("event"), r.push(this.name + pd(n, this.inputs)), n !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(n, r) {
    return r = (r || []).map((a) => Nt.from(a)), new ts(qe, n, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(n) {
    if (ts.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return ts.from(ui(n));
      } catch {
        U(!1, "invalid event fragment", "obj", n);
      }
    else if (n instanceof Or) {
      const r = Qh("event", n), s = Ls(n, !0), a = !!$s(n, fn(["anonymous"])).has("anonymous");
      return vo(n), new ts(qe, r, s, a);
    }
    return new ts(qe, n.name, n.inputs ? n.inputs.map((r) => Nt.from(r, !0)) : [], !!n.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(n) {
    return n && n[On] === Fx;
  }
}
class Ms extends Co {
  /**
   *  @private
   */
  constructor(n, r, s, a, i) {
    super(n, r, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    O(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    O(this, "gas");
    Object.defineProperty(this, On, { value: Mx }), le(this, { payable: a, gas: i });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(n) {
    if (q(n != null && n !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), n === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [`constructor${pd(n, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(n) {
    if (Ms.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return Ms.from(ui(n));
      } catch {
        U(!1, "invalid constuctor fragment", "obj", n);
      }
    else if (n instanceof Or) {
      $s(n, fn(["constructor"]));
      const r = Ls(n), s = !!$s(n, LB).has("payable"), a = _8(n);
      return vo(n), new Ms(qe, "constructor", r, s, a);
    }
    return new Ms(qe, "constructor", n.inputs ? n.inputs.map(Nt.from) : [], !!n.payable, n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(n) {
    return n && n[On] === Mx;
  }
}
class xs extends Co {
  constructor(n, r, s) {
    super(n, "fallback", r);
    /**
     *  If the function can be sent value during invocation.
     */
    O(this, "payable");
    Object.defineProperty(this, On, { value: Lx }), le(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(n) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (n === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: s });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(n) {
    if (xs.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return xs.from(ui(n));
      } catch {
        U(!1, "invalid fallback fragment", "obj", n);
      }
    else if (n instanceof Or) {
      const r = n.toString(), s = n.peekKeyword(fn(["fallback", "receive"]));
      if (U(s, "type must be fallback or receive", "obj", r), n.popKeyword(fn(["fallback", "receive"])) === "receive") {
        const c = Ls(n);
        return U(c.length === 0, "receive cannot have arguments", "obj.inputs", c), $s(n, fn(["payable"])), vo(n), new xs(qe, [], !0);
      }
      let i = Ls(n);
      i.length ? U(i.length === 1 && i[0].type === "bytes", "invalid fallback inputs", "obj.inputs", i.map((c) => c.format("minimal")).join(", ")) : i = [Nt.from("bytes")];
      const o = H8(n);
      if (U(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o), $s(n, fn(["returns"])).has("returns")) {
        const c = Ls(n);
        U(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return vo(n), new xs(qe, i, o === "payable");
    }
    if (n.type === "receive")
      return new xs(qe, [], !0);
    if (n.type === "fallback") {
      const r = [Nt.from("bytes")], s = n.stateMutability === "payable";
      return new xs(qe, r, s);
    }
    U(!1, "invalid fallback description", "obj", n);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(n) {
    return n && n[On] === Lx;
  }
}
class ns extends Jh {
  /**
   *  @private
   */
  constructor(n, r, s, a, i, o) {
    super(n, "function", r, a);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    O(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    O(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    O(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    O(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    O(this, "gas");
    Object.defineProperty(this, On, { value: Hx }), i = Object.freeze(i.slice()), le(this, { constant: s === "view" || s === "pure", gas: o, outputs: i, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return is(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("function"), r.push(this.name + pd(n, this.inputs)), n !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(pd(n, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(n, r) {
    return r = (r || []).map((a) => Nt.from(a)), new ns(qe, n, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(n) {
    if (ns.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return ns.from(ui(n));
      } catch {
        U(!1, "invalid function fragment", "obj", n);
      }
    else if (n instanceof Or) {
      const s = Qh("function", n), a = Ls(n), i = H8(n);
      let o = [];
      $s(n, fn(["returns"])).has("returns") && (o = Ls(n));
      const c = _8(n);
      return vo(n), new ns(qe, s, i, a, o, c);
    }
    let r = n.stateMutability;
    return r == null && (r = "payable", typeof n.constant == "boolean" ? (r = "view", n.constant || (r = "payable", typeof n.payable == "boolean" && !n.payable && (r = "nonpayable"))) : typeof n.payable == "boolean" && !n.payable && (r = "nonpayable")), new ns(qe, n.name, r, n.inputs ? n.inputs.map(Nt.from) : [], n.outputs ? n.outputs.map(Nt.from) : [], n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(n) {
    return n && n[On] === Hx;
  }
}
class mo extends Jh {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "struct", n, r), Object.defineProperty(this, On, { value: _x });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return mo.from(ui(e));
      } catch {
        U(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof Or) {
      const n = Qh("struct", e), r = Ls(e);
      return vo(e), new mo(qe, n, r);
    }
    return new mo(qe, e.name, e.inputs ? e.inputs.map(Nt.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[On] === _x;
  }
}
const Ur = /* @__PURE__ */ new Map();
Ur.set(0, "GENERIC_PANIC");
Ur.set(1, "ASSERT_FALSE");
Ur.set(17, "OVERFLOW");
Ur.set(18, "DIVIDE_BY_ZERO");
Ur.set(33, "ENUM_RANGE_ERROR");
Ur.set(34, "BAD_STORAGE_DATA");
Ur.set(49, "STACK_UNDERFLOW");
Ur.set(50, "ARRAY_RANGE_ERROR");
Ur.set(65, "OUT_OF_MEMORY");
Ur.set(81, "UNINITIALIZED_FUNCTION_CALL");
const QB = new RegExp(/^bytes([0-9]*)$/), JB = new RegExp(/^(u?int)([0-9]*)$/);
let x0 = null, $x = 1024;
function XB(t, e, n, r) {
  let s = "missing revert data", a = null;
  const i = null;
  let o = null;
  if (n) {
    s = "execution reverted";
    const u = ee(n);
    if (n = z(n), u.length === 0)
      s += " (no data present; likely require(false) occurred", a = "require(false)";
    else if (u.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (z(u.slice(0, 4)) === "0x08c379a0")
      try {
        a = r.decode(["string"], u.slice(4))[0], o = {
          signature: "Error(string)",
          name: "Error",
          args: [a]
        }, s += `: ${JSON.stringify(a)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (z(u.slice(0, 4)) === "0x4e487b71")
      try {
        const l = Number(r.decode(["uint256"], u.slice(4))[0]);
        o = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [l]
        }, a = `Panic due to ${Ur.get(l) || "UNKNOWN"}(${l})`, s += `: ${a}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: e.to ? de(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = de(e.from)), je(s, "CALL_EXCEPTION", {
    action: t,
    data: n,
    reason: a,
    transaction: c,
    invocation: i,
    revert: o
  });
}
var Ba, ec;
const Rh = class Rh {
  constructor() {
    B(this, Ba);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const n = e.map((s) => G(this, Ba, ec).call(this, Nt.from(s)));
    return new If(n, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, n) {
    ok(n.length, e.length, "types/values length mismatch");
    const r = e.map((i) => G(this, Ba, ec).call(this, Nt.from(i))), s = new If(r, "_"), a = new Oy();
    return s.encode(a, n), a.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, n, r) {
    const s = e.map((i) => G(this, Ba, ec).call(this, Nt.from(i)));
    return new If(s, "_").decode(new By(n, r, $x));
  }
  static _setDefaultMaxInflation(e) {
    U(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), $x = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return x0 == null && (x0 = new Rh()), x0;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, n, r) {
    return XB(e, n, r, Rh.defaultAbiCoder());
  }
};
Ba = new WeakSet(), ec = function(e) {
  if (e.isArray())
    return new p9(G(this, Ba, ec).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new If(e.components.map((r) => G(this, Ba, ec).call(this, r)), e.name);
  switch (e.baseType) {
    case "address":
      return new d9(e.name);
    case "bool":
      return new h9(e.name);
    case "string":
      return new k9(e.name);
    case "bytes":
      return new m9(e.name);
    case "":
      return new g9(e.name);
  }
  let n = e.type.match(JB);
  if (n) {
    let r = parseInt(n[2] || "256");
    return U(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new A9(r / 8, n[1] === "int", e.name);
  }
  if (n = e.type.match(QB), n) {
    let r = parseInt(n[1]);
    return U(r !== 0 && r <= 32, "invalid bytes length", "param", e), new y9(r, e.name);
  }
  U(!1, "invalid type", "type", e.type);
};
let Wt = Rh;
class ZB {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    O(this, "fragment");
    /**
     *  The name of the Event.
     */
    O(this, "name");
    /**
     *  The full Event signature.
     */
    O(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    O(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    O(this, "args");
    const s = e.name, a = e.format();
    le(this, {
      fragment: e,
      name: s,
      signature: a,
      topic: n,
      args: r
    });
  }
}
class YB {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    O(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    O(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    O(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    O(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    O(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    O(this, "value");
    const a = e.name, i = e.format();
    le(this, {
      fragment: e,
      name: a,
      args: r,
      signature: i,
      selector: n,
      value: s
    });
  }
}
class eP {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment.
     */
    O(this, "fragment");
    /**
     *  The name of the Error.
     */
    O(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    O(this, "args");
    /**
     *  The full Error signature.
     */
    O(this, "signature");
    /**
     *  The selector for the Error.
     */
    O(this, "selector");
    const s = e.name, a = e.format();
    le(this, {
      fragment: e,
      name: s,
      args: r,
      signature: a,
      selector: n
    });
  }
}
class Gx {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    O(this, "hash");
    /**
     *  @_ignore:
     */
    O(this, "_isIndexed");
    le(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const zx = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, jx = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (t) => `reverted with reason string ${JSON.stringify(t)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (t) => {
      let e = "unknown panic code";
      return t >= 0 && t <= 255 && zx[t.toString()] && (e = zx[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`;
    }
  }
};
var Qr, Jr, Xr, _t, ss, Ep, xp;
const xi = class xi {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    B(this, ss);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    O(this, "fragments");
    /**
     *  The Contract constructor.
     */
    O(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    O(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    O(this, "receive");
    B(this, Qr);
    B(this, Jr);
    B(this, Xr);
    //    #structs: Map<string, StructFragment>;
    B(this, _t);
    let n = [];
    typeof e == "string" ? n = JSON.parse(e) : n = e, x(this, Xr, /* @__PURE__ */ new Map()), x(this, Qr, /* @__PURE__ */ new Map()), x(this, Jr, /* @__PURE__ */ new Map());
    const r = [];
    for (const i of n)
      try {
        r.push(Co.from(i));
      } catch (o) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(i)}:`, o.message);
      }
    le(this, {
      fragments: Object.freeze(r)
    });
    let s = null, a = !1;
    x(this, _t, this.getAbiCoder()), this.fragments.forEach((i, o) => {
      let c;
      switch (i.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          le(this, { deploy: i });
          return;
        case "fallback":
          i.inputs.length === 0 ? a = !0 : (U(!s || i.payable !== s.payable, "conflicting fallback fragments", `fragments[${o}]`, i), s = i, a = s.payable);
          return;
        case "function":
          c = m(this, Xr);
          break;
        case "event":
          c = m(this, Jr);
          break;
        case "error":
          c = m(this, Qr);
          break;
        default:
          return;
      }
      const u = i.format();
      c.has(u) || c.set(u, i);
    }), this.deploy || le(this, {
      deploy: Ms.from("constructor()")
    }), le(this, { fallback: s, receive: a });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const n = e ? "minimal" : "full";
    return this.fragments.map((s) => s.format(n));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((n) => n.format("json"));
    return JSON.stringify(e.map((n) => JSON.parse(n)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Wt.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const n = G(this, ss, Ep).call(this, e, null, !1);
    return U(n, "no matching function", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!G(this, ss, Ep).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, n) {
    return G(this, ss, Ep).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const n = Array.from(m(this, Xr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, Xr).get(s), r);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const n = G(this, ss, xp).call(this, e, null, !1);
    return U(n, "no matching event", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!G(this, ss, xp).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, n) {
    return G(this, ss, xp).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const n = Array.from(m(this, Jr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, Jr).get(s), r);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, n) {
    if (Re(e)) {
      const s = e.toLowerCase();
      if (jx[s])
        return xn.from(jx[s].signature);
      for (const a of m(this, Qr).values())
        if (s === a.selector)
          return a;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [a, i] of m(this, Qr))
        a.split(
          "("
          /* fix:) */
        )[0] === e && s.push(i);
      if (s.length === 0)
        return e === "Error" ? xn.from("error Error(string)") : e === "Panic" ? xn.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const a = s.map((i) => JSON.stringify(i.format())).join(", ");
        U(!1, `ambiguous error description (i.e. ${a})`, "name", e);
      }
      return s[0];
    }
    if (e = xn.from(e).format(), e === "Error(string)")
      return xn.from("error Error(string)");
    if (e === "Panic(uint256)")
      return xn.from("error Panic(uint256)");
    const r = m(this, Qr).get(e);
    return r || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const n = Array.from(m(this, Qr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, Qr).get(s), r);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, n) {
    return m(this, _t).decode(e, n);
  }
  _encodeParams(e, n) {
    return m(this, _t).encode(e, n);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      U(r, "unknown error", "fragment", e), e = r;
    }
    return U(Ve(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, Ve(n, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      U(r, "unknown error", "fragment", e), e = r;
    }
    return _e([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      U(r, "unknown function", "fragment", e), e = r;
    }
    return U(Ve(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, Ve(n, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      U(r, "unknown function", "fragment", e), e = r;
    }
    return _e([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const a = this.getFunction(e);
      U(a, "unknown function", "fragment", e), e = a;
    }
    let r = "invalid length for result data";
    const s = ln(n);
    if (s.length % 32 === 0)
      try {
        return m(this, _t).decode(e.outputs, s);
      } catch {
        r = "could not decode result data";
      }
    q(!1, r, "BAD_DATA", {
      value: z(s),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, n) {
    const r = ee(e, "data"), s = Wt.getBuiltinCallException("call", n, r);
    if (s.message.startsWith("execution reverted (unknown custom error)")) {
      const o = z(r.slice(0, 4)), c = this.getError(o);
      if (c)
        try {
          const u = m(this, _t).decode(c.inputs, r.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const i = this.parseTransaction(n);
    return i && (s.invocation = {
      method: i.name,
      signature: i.signature,
      args: i.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      U(r, "unknown function", "fragment", e), e = r;
    }
    return z(m(this, _t).encode(e.outputs, n || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, n) {
    if (typeof e == "string") {
      const a = this.getEvent(e);
      U(a, "unknown event", "eventFragment", e), e = a;
    }
    q(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: n.length, expectedCount: e.inputs.length });
    const r = [];
    e.anonymous || r.push(e.topicHash);
    const s = (a, i) => a.type === "string" ? is(i) : a.type === "bytes" ? ke(z(i)) : (a.type === "bool" && typeof i == "boolean" ? i = i ? "0x01" : "0x00" : a.type.match(/^u?int/) ? i = Ir(i) : a.type.match(/^bytes/) ? i = uk(i, 32) : a.type === "address" && m(this, _t).encode(["address"], [i]), Mn(z(i), 32));
    for (n.forEach((a, i) => {
      const o = e.inputs[i];
      if (!o.indexed) {
        U(a == null, "cannot filter non-indexed parameters; must be null", "contract." + o.name, a);
        return;
      }
      a == null ? r.push(null) : o.baseType === "array" || o.baseType === "tuple" ? U(!1, "filtering with tuples or arrays not supported", "contract." + o.name, a) : Array.isArray(a) ? r.push(a.map((c) => s(o, c))) : r.push(s(o, a));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(e, n) {
    if (typeof e == "string") {
      const i = this.getEvent(e);
      U(i, "unknown event", "eventFragment", e), e = i;
    }
    const r = [], s = [], a = [];
    return e.anonymous || r.push(e.topicHash), U(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((i, o) => {
      const c = n[o];
      if (i.indexed)
        if (i.type === "string")
          r.push(is(c));
        else if (i.type === "bytes")
          r.push(ke(c));
        else {
          if (i.baseType === "tuple" || i.baseType === "array")
            throw new Error("not implemented");
          r.push(m(this, _t).encode([i.type], [c]));
        }
      else
        s.push(i), a.push(c);
    }), {
      data: m(this, _t).encode(s, a),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, n, r) {
    if (typeof e == "string") {
      const f = this.getEvent(e);
      U(f, "unknown event", "eventFragment", e), e = f;
    }
    if (r != null && !e.anonymous) {
      const f = e.topicHash;
      U(Re(r[0], 32) && r[0].toLowerCase() === f, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
    }
    const s = [], a = [], i = [];
    e.inputs.forEach((f, b) => {
      f.indexed ? f.type === "string" || f.type === "bytes" || f.baseType === "tuple" || f.baseType === "array" ? (s.push(Nt.from({ type: "bytes32", name: f.name })), i.push(!0)) : (s.push(f), i.push(!1)) : (a.push(f), i.push(!1));
    });
    const o = r != null ? m(this, _t).decode(s, _e(r)) : null, c = m(this, _t).decode(a, n, !0), u = [], l = [];
    let d = 0, p = 0;
    return e.inputs.forEach((f, b) => {
      let y = null;
      if (f.indexed)
        if (o == null)
          y = new Gx(null);
        else if (i[b])
          y = new Gx(o[p++]);
        else
          try {
            y = o[p++];
          } catch (g) {
            y = g;
          }
      else
        try {
          y = c[d++];
        } catch (g) {
          y = g;
        }
      u.push(y), l.push(f.name || null);
    }), Cl.fromItems(u, l);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const n = ee(e.data, "tx.data"), r = re(e.value != null ? e.value : 0, "tx.value"), s = this.getFunction(z(n.slice(0, 4)));
    if (!s)
      return null;
    const a = m(this, _t).decode(s.inputs, n.slice(4));
    return new YB(s, s.selector, a, r);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const n = this.getEvent(e.topics[0]);
    return !n || n.anonymous ? null : new ZB(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const n = z(e), r = this.getError(Ve(n, 0, 4));
    if (!r)
      return null;
    const s = m(this, _t).decode(r.inputs, Ve(n, 4));
    return new eP(r, r.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof xi ? e : typeof e == "string" ? new xi(JSON.parse(e)) : typeof e.formatJson == "function" ? new xi(e.formatJson()) : typeof e.format == "function" ? new xi(e.format("json")) : new xi(e);
  }
};
Qr = new WeakMap(), Jr = new WeakMap(), Xr = new WeakMap(), _t = new WeakMap(), ss = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
Ep = function(e, n, r) {
  if (Re(e)) {
    const a = e.toLowerCase();
    for (const i of m(this, Xr).values())
      if (a === i.selector)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of m(this, Xr))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      const i = n.length > 0 ? n[n.length - 1] : null;
      let o = n.length, c = !0;
      Vt.isTyped(i) && i.type === "overrides" && (c = !1, o--);
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs.length;
        l !== o && (!c || l !== o - 1) && a.splice(u, 1);
      }
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs;
        for (let d = 0; d < n.length; d++)
          if (Vt.isTyped(n[d])) {
            if (d >= l.length) {
              if (n[d].type === "overrides")
                continue;
              a.splice(u, 1);
              break;
            }
            if (n[d].type !== l[d].baseType) {
              a.splice(u, 1);
              break;
            }
          }
      }
    }
    if (a.length === 1 && n && n.length !== a[0].inputs.length) {
      const i = n[n.length - 1];
      (i == null || Array.isArray(i) || typeof i != "object") && a.splice(0, 1);
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      U(!1, `ambiguous function description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = m(this, Xr).get(ns.from(e).format());
  return s || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
xp = function(e, n, r) {
  if (Re(e)) {
    const a = e.toLowerCase();
    for (const i of m(this, Jr).values())
      if (a === i.topicHash)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of m(this, Jr))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      for (let i = a.length - 1; i >= 0; i--)
        a[i].inputs.length < n.length && a.splice(i, 1);
      for (let i = a.length - 1; i >= 0; i--) {
        const o = a[i].inputs;
        for (let c = 0; c < n.length; c++)
          if (Vt.isTyped(n[c]) && n[c].type !== o[c].baseType) {
            a.splice(i, 1);
            break;
          }
      }
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      U(!1, `ambiguous event description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = m(this, Jr).get(ts.from(e).format());
  return s || null;
};
let Qt = xi;
const $8 = BigInt(0);
function bc(t) {
  return t ?? null;
}
function rt(t) {
  return t == null ? null : t.toString();
}
class Vx {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, n, r) {
    /**
     *  The gas price for legacy networks.
     */
    O(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    O(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    O(this, "maxPriorityFeePerGas");
    le(this, {
      gasPrice: bc(e),
      maxFeePerGas: bc(n),
      maxPriorityFeePerGas: bc(r)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: n, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: rt(e),
      maxFeePerGas: rt(n),
      maxPriorityFeePerGas: rt(r)
    };
  }
}
function Qp(t) {
  const e = {};
  t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = z(t.data));
  const n = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of n)
    !(s in t) || t[s] == null || (e[s] = re(t[s], `request.${s}`));
  const r = "type,nonce".split(/,/);
  for (const s of r)
    !(s in t) || t[s] == null || (e[s] = Ee(t[s], `request.${s}`));
  return t.accessList && (e.accessList = Ho(t.accessList)), t.authorizationList && (e.authorizationList = t.authorizationList.slice()), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map((s) => ko(s) ? z(s) : Object.assign({}, s))), e;
}
var Bs;
class tP {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, n) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    O(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    O(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    O(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    O(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    O(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    O(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    O(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    O(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    O(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    O(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    O(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    O(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    O(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    O(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    O(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    O(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    O(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    O(this, "baseFeePerGas");
    B(this, Bs);
    x(this, Bs, e.transactions.map((r) => typeof r != "string" ? new hd(r, n) : r)), le(this, {
      provider: n,
      hash: bc(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      parentBeaconBlockRoot: e.parentBeaconBlockRoot,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      blobGasUsed: e.blobGasUsed,
      excessBlobGas: e.excessBlobGas,
      miner: e.miner,
      prevRandao: bc(e.prevRandao),
      extraData: e.extraData,
      baseFeePerGas: bc(e.baseFeePerGas),
      stateRoot: e.stateRoot,
      receiptsRoot: e.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return m(this, Bs).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = m(this, Bs).slice();
    return e.length === 0 ? [] : (q(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: n, extraData: r, gasLimit: s, gasUsed: a, hash: i, miner: o, prevRandao: c, nonce: u, number: l, parentHash: d, parentBeaconBlockRoot: p, stateRoot: f, receiptsRoot: b, timestamp: y, transactions: g } = this;
    return {
      _type: "Block",
      baseFeePerGas: rt(e),
      difficulty: rt(n),
      extraData: r,
      gasLimit: rt(s),
      gasUsed: rt(a),
      blobGasUsed: rt(this.blobGasUsed),
      excessBlobGas: rt(this.excessBlobGas),
      hash: i,
      miner: o,
      prevRandao: c,
      nonce: u,
      number: l,
      parentHash: d,
      timestamp: y,
      parentBeaconBlockRoot: p,
      stateRoot: f,
      receiptsRoot: b,
      transactions: g
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const n = this.transactions;
    return {
      next: () => e < this.length ? {
        value: n[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return m(this, Bs).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let n;
    if (typeof e == "number")
      n = m(this, Bs)[e];
    else {
      const r = e.toLowerCase();
      for (const s of m(this, Bs))
        if (typeof s == "string") {
          if (s !== r)
            continue;
          n = s;
          break;
        } else {
          if (s.hash !== r)
            continue;
          n = s;
          break;
        }
    }
    if (n == null)
      throw new Error("no such tx");
    return typeof n == "string" ? await this.provider.getTransaction(n) : n;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const n = this.prefetchedTransactions;
    if (typeof e == "number")
      return n[e];
    e = e.toLowerCase();
    for (const r of n)
      if (r.hash === e)
        return r;
    U(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return nP(this);
  }
}
Bs = new WeakMap();
class Xd {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    O(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    O(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    O(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    O(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    O(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    O(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    O(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    O(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    O(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    O(this, "transactionIndex");
    this.provider = n;
    const r = Object.freeze(e.topics.slice());
    le(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: r,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: n, blockNumber: r, data: s, index: a, removed: i, topics: o, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: e,
      blockHash: n,
      blockNumber: r,
      data: s,
      index: a,
      removed: i,
      topics: o,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return q(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return q(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return q(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return rP(this);
  }
}
var _d;
class G8 {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    O(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    O(this, "to");
    /**
     *  The sender of the transaction.
     */
    O(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    O(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    O(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    O(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    O(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    O(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    O(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    O(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    O(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    O(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    O(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    O(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    O(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    O(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    O(this, "root");
    B(this, _d);
    x(this, _d, Object.freeze(e.logs.map((s) => new Xd(s, n))));
    let r = $8;
    e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), le(this, {
      provider: n,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      blobGasUsed: e.blobGasUsed,
      gasPrice: r,
      blobGasPrice: e.blobGasPrice,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return m(this, _d);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: n,
      contractAddress: r,
      hash: s,
      index: a,
      blockHash: i,
      blockNumber: o,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: l,
      root: d
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: i,
      blockNumber: o,
      //byzantium, 
      contractAddress: r,
      cumulativeGasUsed: rt(this.cumulativeGasUsed),
      from: n,
      gasPrice: rt(this.gasPrice),
      blobGasUsed: rt(this.blobGasUsed),
      blobGasPrice: rt(this.blobGasPrice),
      gasUsed: rt(this.gasUsed),
      hash: s,
      index: a,
      logs: u,
      logsBloom: c,
      root: d,
      status: l,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return j8(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return q(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), z8(this, e);
  }
}
_d = new WeakMap();
var Pa;
const BE = class BE {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    O(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    O(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    O(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    O(this, "index");
    /**
     *  The transaction hash.
     */
    O(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    O(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    O(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    O(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    O(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    O(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    O(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    O(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    O(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    O(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    O(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    O(this, "value");
    /**
     *  The chain ID.
     */
    O(this, "chainId");
    /**
     *  The signature.
     */
    O(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    O(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    O(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    O(this, "authorizationList");
    B(this, Pa);
    this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, x(this, Pa, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: n, index: r, hash: s, type: a, to: i, from: o, nonce: c, data: u, signature: l, accessList: d, blobVersionedHashes: p } = this;
    return {
      _type: "TransactionResponse",
      accessList: d,
      blockNumber: e,
      blockHash: n,
      blobVersionedHashes: p,
      chainId: rt(this.chainId),
      data: u,
      from: o,
      gasLimit: rt(this.gasLimit),
      gasPrice: rt(this.gasPrice),
      hash: s,
      maxFeePerGas: rt(this.maxFeePerGas),
      maxPriorityFeePerGas: rt(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: rt(this.maxFeePerBlobGas),
      nonce: c,
      signature: l,
      to: i,
      index: r,
      type: a,
      value: rt(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const r = await this.getTransaction();
      r && (e = r.blockNumber);
    }
    if (e == null)
      return null;
    const n = this.provider.getBlock(e);
    if (n == null)
      throw new Error("TODO");
    return n;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: n, blockNumber: r } = await Tt({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, n) {
    const r = e ?? 1, s = n ?? 0;
    let a = m(this, Pa), i = -1, o = a === -1;
    const c = async () => {
      if (o)
        return null;
      const { blockNumber: p, nonce: f } = await Tt({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (f < this.nonce) {
        a = p;
        return;
      }
      if (o)
        return null;
      const b = await this.getTransaction();
      if (!(b && b.blockNumber != null))
        for (i === -1 && (i = a - 3, i < m(this, Pa) && (i = m(this, Pa))); i <= p; ) {
          if (o)
            return null;
          const y = await this.provider.getBlock(i, !0);
          if (y == null)
            return;
          for (const g of y)
            if (g === this.hash)
              return;
          for (let g = 0; g < y.length; g++) {
            const w = await y.getTransaction(g);
            if (w.from === this.from && w.nonce === this.nonce) {
              if (o)
                return null;
              const k = await this.provider.getTransactionReceipt(w.hash);
              if (k == null || p - k.blockNumber + 1 < r)
                return;
              let E = "replaced";
              w.data === this.data && w.to === this.to && w.value === this.value ? E = "repriced" : w.data === "0x" && w.from === w.to && w.value === $8 && (E = "cancelled"), q(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: E === "replaced" || E === "cancelled",
                reason: E,
                replacement: w.replaceableTransaction(a),
                hash: w.hash,
                receipt: k
              });
            }
          }
          i++;
        }
    }, u = (p) => {
      if (p == null || p.status !== 0)
        return p;
      q(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: p.to,
          from: p.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: p
      });
    }, l = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0)
      return u(l);
    if (l) {
      if (r === 1 || await l.confirmations() >= r)
        return u(l);
    } else if (await c(), r === 0)
      return null;
    return await new Promise((p, f) => {
      const b = [], y = () => {
        b.forEach((w) => w());
      };
      if (b.push(() => {
        o = !0;
      }), s > 0) {
        const w = setTimeout(() => {
          y(), f(je("wait for transaction timeout", "TIMEOUT"));
        }, s);
        b.push(() => {
          clearTimeout(w);
        });
      }
      const g = async (w) => {
        if (await w.confirmations() >= r) {
          y();
          try {
            p(u(w));
          } catch (k) {
            f(k);
          }
        }
      };
      if (b.push(() => {
        this.provider.off(this.hash, g);
      }), this.provider.on(this.hash, g), a >= 0) {
        const w = async () => {
          try {
            await c();
          } catch (k) {
            if (Bt(k, "TRANSACTION_REPLACED")) {
              y(), f(k);
              return;
            }
          }
          o || this.provider.once("block", w);
        };
        b.push(() => {
          this.provider.off("block", w);
        }), this.provider.once("block", w);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return q(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), j8(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return q(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), q(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), z8(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    U(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const n = new BE(this, this.provider);
    return x(n, Pa, e), n;
  }
};
Pa = new WeakMap();
let hd = BE;
function nP(t) {
  return { orphan: "drop-block", hash: t.hash, number: t.number };
}
function z8(t, e) {
  return { orphan: "reorder-transaction", tx: t, other: e };
}
function j8(t) {
  return { orphan: "drop-transaction", tx: t };
}
function rP(t) {
  return { orphan: "drop-log", log: {
    transactionHash: t.transactionHash,
    blockHash: t.blockHash,
    blockNumber: t.blockNumber,
    address: t.address,
    data: t.data,
    topics: Object.freeze(t.topics.slice()),
    index: t.index
  } };
}
class _1 extends Xd {
  /**
   * @_ignore:
   */
  constructor(n, r, s) {
    super(n, n.provider);
    /**
     *  The Contract Interface.
     */
    O(this, "interface");
    /**
     *  The matching event.
     */
    O(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    O(this, "args");
    const a = r.decodeEventLog(s, n.data, n.topics);
    le(this, { args: a, fragment: s, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class V8 extends Xd {
  /**
   * @_ignore:
   */
  constructor(n, r) {
    super(n, n.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    O(this, "error");
    le(this, { error: r });
  }
}
var ul;
class sP extends G8 {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    B(this, ul);
    x(this, ul, n);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((n) => {
      const r = n.topics.length ? m(this, ul).getEvent(n.topics[0]) : null;
      if (r)
        try {
          return new _1(n, m(this, ul), r);
        } catch (s) {
          return new V8(n, s);
        }
      return n;
    });
  }
}
ul = new WeakMap();
var $d;
class $1 extends hd {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    B(this, $d);
    x(this, $d, n);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(n, r) {
    const s = await super.wait(n, r);
    return s == null ? null : new sP(m(this, $d), this.provider, s);
  }
}
$d = new WeakMap();
class q8 extends dk {
  /**
   *  @_event:
   */
  constructor(n, r, s, a) {
    super(n, r, s);
    /**
     *  The log with no matching events.
     */
    O(this, "log");
    le(this, { log: a });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class aP extends q8 {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s, a) {
    super(e, n, r, new _1(a, e.interface, s));
    const i = e.interface.decodeEventLog(s, this.log.data, this.log.topics);
    le(this, { args: i, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const qx = BigInt(0);
function K8(t) {
  return t && typeof t.call == "function";
}
function W8(t) {
  return t && typeof t.estimateGas == "function";
}
function Xh(t) {
  return t && typeof t.resolveName == "function";
}
function Q8(t) {
  return t && typeof t.sendTransaction == "function";
}
function J8(t) {
  if (t != null) {
    if (Xh(t))
      return t;
    if (t.provider)
      return t.provider;
  }
}
var Gd;
class iP {
  constructor(e, n, r) {
    B(this, Gd);
    O(this, "fragment");
    if (le(this, { fragment: n }), n.inputs.length < r.length)
      throw new Error("too many arguments");
    const s = To(e.runner, "resolveName"), a = Xh(s) ? s : null;
    x(this, Gd, async function() {
      const i = await Promise.all(n.inputs.map((o, c) => r[c] == null ? null : o.walkAsync(r[c], (l, d) => l === "address" ? Array.isArray(d) ? Promise.all(d.map((p) => dn(p, a))) : dn(d, a) : d)));
      return e.interface.encodeFilterTopics(n, i);
    }());
  }
  getTopicFilter() {
    return m(this, Gd);
  }
}
Gd = new WeakMap();
function To(t, e) {
  return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null;
}
function vi(t) {
  return t == null ? null : t.provider || null;
}
async function X8(t, e) {
  const n = Vt.dereference(t, "overrides");
  U(typeof n == "object", "invalid overrides parameter", "overrides", t);
  const r = Qp(n);
  return U(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), U(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
}
async function oP(t, e, n) {
  const r = To(t, "resolveName"), s = Xh(r) ? r : null;
  return await Promise.all(e.map((a, i) => a.walkAsync(n[i], (o, c) => (c = Vt.dereference(c, o), o === "address" ? dn(c, s) : c))));
}
function cP(t) {
  const e = async function(i) {
    const o = await X8(i, ["data"]);
    o.to = await t.getAddress(), o.from && (o.from = await dn(o.from, J8(t.runner)));
    const c = t.interface, u = re(o.value || qx, "overrides.value") === qx, l = (o.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !l && !u && U(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", i), U(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data);
    const d = c.receive || c.fallback && c.fallback.payable;
    return U(d || u, "cannot send value to non-payable fallback", "overrides.value", o.value), U(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data), o;
  }, n = async function(i) {
    const o = To(t.runner, "call");
    q(K8(o), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await e(i);
    try {
      return await o.call(c);
    } catch (u) {
      throw T1(u) && u.data ? t.interface.makeError(u.data, c) : u;
    }
  }, r = async function(i) {
    const o = t.runner;
    q(Q8(o), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await o.sendTransaction(await e(i)), u = vi(t.runner);
    return new $1(t.interface, u, c);
  }, s = async function(i) {
    const o = To(t.runner, "estimateGas");
    return q(W8(o), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await o.estimateGas(await e(i));
  }, a = async (i) => await r(i);
  return le(a, {
    _contract: t,
    estimateGas: s,
    populateTransaction: e,
    send: r,
    staticCall: n
  }), a;
}
function lP(t, e) {
  const n = function(...u) {
    const l = t.interface.getFunction(e, u);
    return q(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: u }
    }), l;
  }, r = async function(...u) {
    const l = n(...u);
    let d = {};
    if (l.inputs.length + 1 === u.length && (d = await X8(u.pop()), d.from && (d.from = await dn(d.from, J8(t.runner)))), l.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const p = await oP(t.runner, l.inputs, u);
    return Object.assign({}, d, await Tt({
      to: t.getAddress(),
      data: t.interface.encodeFunctionData(l, p)
    }));
  }, s = async function(...u) {
    const l = await o(...u);
    return l.length === 1 ? l[0] : l;
  }, a = async function(...u) {
    const l = t.runner;
    q(Q8(l), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const d = await l.sendTransaction(await r(...u)), p = vi(t.runner);
    return new $1(t.interface, p, d);
  }, i = async function(...u) {
    const l = To(t.runner, "estimateGas");
    return q(W8(l), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await l.estimateGas(await r(...u));
  }, o = async function(...u) {
    const l = To(t.runner, "call");
    q(K8(l), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const d = await r(...u);
    let p = "0x";
    try {
      p = await l.call(d);
    } catch (b) {
      throw T1(b) && b.data ? t.interface.makeError(b.data, d) : b;
    }
    const f = n(...u);
    return t.interface.decodeFunctionResult(f, p);
  }, c = async (...u) => n(...u).constant ? await s(...u) : await a(...u);
  return le(c, {
    name: t.interface.getFunctionName(e),
    _contract: t,
    _key: e,
    getFragment: n,
    estimateGas: i,
    populateTransaction: r,
    send: a,
    staticCall: s,
    staticCallResult: o
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = t.interface.getFunction(e);
      return q(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), u;
    }
  }), c;
}
function uP(t, e) {
  const n = function(...s) {
    const a = t.interface.getEvent(e, s);
    return q(a, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: s }
    }), a;
  }, r = function(...s) {
    return new iP(t, n(...s), s);
  };
  return le(r, {
    name: t.interface.getEventName(e),
    _contract: t,
    _key: e,
    getFragment: n
  }), Object.defineProperty(r, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = t.interface.getEvent(e);
      return q(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), s;
    }
  }), r;
}
const Jp = Symbol.for("_ethersInternal_contract"), Z8 = /* @__PURE__ */ new WeakMap();
function dP(t, e) {
  Z8.set(t[Jp], e);
}
function Un(t) {
  return Z8.get(t[Jp]);
}
function fP(t) {
  return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment;
}
async function G1(t, e) {
  let n, r = null;
  if (Array.isArray(e)) {
    const a = function(i) {
      if (Re(i, 32))
        return i;
      const o = t.interface.getEvent(i);
      return U(o, "unknown fragment", "name", i), o.topicHash;
    };
    n = e.map((i) => i == null ? null : Array.isArray(i) ? i.map(a) : a(i));
  } else e === "*" ? n = [null] : typeof e == "string" ? Re(e, 32) ? n = [e] : (r = t.interface.getEvent(e), U(r, "unknown fragment", "event", e), n = [r.topicHash]) : fP(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [r.topicHash]) : U(!1, "unknown event name", "event", e);
  n = n.map((a) => {
    if (a == null)
      return null;
    if (Array.isArray(a)) {
      const i = Array.from(new Set(a.map((o) => o.toLowerCase())).values());
      return i.length === 1 ? i[0] : (i.sort(), i);
    }
    return a.toLowerCase();
  });
  const s = n.map((a) => a == null ? "null" : Array.isArray(a) ? a.join("|") : a).join("&");
  return { fragment: r, tag: s, topics: n };
}
async function Ru(t, e) {
  const { subs: n } = Un(t);
  return n.get((await G1(t, e)).tag) || null;
}
async function Kx(t, e, n) {
  const r = vi(t.runner);
  q(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: s, tag: a, topics: i } = await G1(t, n), { addr: o, subs: c } = Un(t);
  let u = c.get(a);
  if (!u) {
    const d = { address: o || t, topics: i }, p = (g) => {
      let w = s;
      if (w == null)
        try {
          w = t.interface.getEvent(g.topics[0]);
        } catch {
        }
      if (w) {
        const k = w, E = s ? t.interface.decodeEventLog(s, g.data, g.topics) : [];
        qy(t, n, E, (T) => new aP(t, T, n, k, g));
      } else
        qy(t, n, [], (k) => new q8(t, k, n, g));
    };
    let f = [];
    u = { tag: a, listeners: [], start: () => {
      f.length || f.push(r.on(d, p));
    }, stop: async () => {
      if (f.length == 0)
        return;
      let g = f;
      f = [], await Promise.all(g), r.off(d, p);
    } }, c.set(a, u);
  }
  return u;
}
let Vy = Promise.resolve();
async function pP(t, e, n, r) {
  await Vy;
  const s = await Ru(t, e);
  if (!s)
    return !1;
  const a = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: i, once: o }) => {
    const c = Array.from(n);
    r && c.push(r(o ? null : i));
    try {
      i.call(t, ...c);
    } catch {
    }
    return !o;
  }), s.listeners.length === 0 && (s.stop(), Un(t).subs.delete(s.tag)), a > 0;
}
async function qy(t, e, n, r) {
  try {
    await Vy;
  } catch {
  }
  const s = pP(t, e, n, r);
  return Vy = s, await s;
}
const Bf = ["then"];
var e6;
e6 = Jp;
const rd = class rd {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, n, r, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    O(this, "target");
    /**
     *  The contract Interface.
     */
    O(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    O(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    O(this, "filters");
    /**
     *  @_ignore:
     */
    O(this, e6);
    /**
     *  The fallback or receive function if any.
     */
    O(this, "fallback");
    U(typeof e == "string" || t8(e), "invalid value for Contract target", "target", e), r == null && (r = null);
    const a = Qt.from(n);
    le(this, { target: e, runner: r, interface: a }), Object.defineProperty(this, Jp, { value: {} });
    let i, o = null, c = null;
    if (s) {
      const d = vi(r);
      c = new $1(this.interface, d, s);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (Re(e))
        o = e, i = Promise.resolve(e);
      else {
        const d = To(r, "resolveName");
        if (!Xh(d))
          throw je("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        i = d.resolveName(e).then((p) => {
          if (p == null)
            throw je("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return Un(this).addr = p, p;
        });
      }
    else
      i = e.getAddress().then((d) => {
        if (d == null)
          throw new Error("TODO");
        return Un(this).addr = d, d;
      });
    dP(this, { addrPromise: i, addr: o, deployTx: c, subs: u });
    const l = new Proxy({}, {
      get: (d, p, f) => {
        if (typeof p == "symbol" || Bf.indexOf(p) >= 0)
          return Reflect.get(d, p, f);
        try {
          return this.getEvent(p);
        } catch (b) {
          if (!Bt(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, p) => Bf.indexOf(p) >= 0 ? Reflect.has(d, p) : Reflect.has(d, p) || this.interface.hasEvent(String(p))
    });
    return le(this, { filters: l }), le(this, {
      fallback: a.receive || a.fallback ? cP(this) : null
    }), new Proxy(this, {
      get: (d, p, f) => {
        if (typeof p == "symbol" || p in d || Bf.indexOf(p) >= 0)
          return Reflect.get(d, p, f);
        try {
          return d.getFunction(p);
        } catch (b) {
          if (!Bt(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, p) => typeof p == "symbol" || p in d || Bf.indexOf(p) >= 0 ? Reflect.has(d, p) : d.interface.hasFunction(p)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new rd(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new rd(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Un(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = vi(this.runner);
    q(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const n = await e.getCode(await this.getAddress());
    return n === "0x" ? null : n;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = vi(this.runner);
    return q(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, a) => {
      const i = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          r.once("block", i);
        } catch (o) {
          a(o);
        }
      };
      i();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Un(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), lP(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), uP(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, n, r) {
    n == null && (n = 0), r == null && (r = "latest");
    const { addr: s, addrPromise: a } = Un(this), i = s || await a, { fragment: o, topics: c } = await G1(this, e), u = { address: i, topics: c, fromBlock: n, toBlock: r }, l = vi(this.runner);
    return q(l, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await l.getLogs(u)).map((d) => {
      let p = o;
      if (p == null)
        try {
          p = this.interface.getEvent(d.topics[0]);
        } catch {
        }
      if (p)
        try {
          return new _1(d, this.interface, p);
        } catch (f) {
          return new V8(d, f);
        }
      return new Xd(d, l);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, n) {
    const r = await Kx(this, "on", e);
    return r.listeners.push({ listener: n, once: !1 }), r.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, n) {
    const r = await Kx(this, "once", e);
    return r.listeners.push({ listener: n, once: !0 }), r.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...n) {
    return await qy(this, e, n, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const s = await Ru(this, e);
      return s ? s.listeners.length : 0;
    }
    const { subs: n } = Un(this);
    let r = 0;
    for (const { listeners: s } of n.values())
      r += s.length;
    return r;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const s = await Ru(this, e);
      return s ? s.listeners.map(({ listener: a }) => a) : [];
    }
    const { subs: n } = Un(this);
    let r = [];
    for (const { listeners: s } of n.values())
      r = r.concat(s.map(({ listener: a }) => a));
    return r;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, n) {
    const r = await Ru(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (n == null || r.listeners.length === 0) && (r.stop(), Un(this).subs.delete(r.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const n = await Ru(this, e);
      if (!n)
        return this;
      n.stop(), Un(this).subs.delete(n.tag);
    } else {
      const { subs: n } = Un(this);
      for (const { tag: r, stop: s } of n.values())
        s(), n.delete(r);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, n) {
    return await this.on(e, n);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, n) {
    return await this.off(e, n);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class n extends rd {
      constructor(s, a = null) {
        super(s, e, a);
      }
    }
    return n;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, n, r) {
    return r == null && (r = null), new this(e, n, r);
  }
};
let Ky = rd;
function hP() {
  return Ky;
}
class rs extends hP() {
}
function A0(t) {
  return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : U(!1, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`;
}
class mP {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    /**
     *  The name.
     */
    O(this, "name");
    le(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
}
const Y8 = new RegExp("^(ipfs)://(.*)$", "i"), Wx = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  Y8,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var Ua, no, Na, tc, Dh, ev;
const hc = class hc {
  constructor(e, n, r) {
    B(this, Na);
    /**
     *  The connected provider.
     */
    O(this, "provider");
    /**
     *  The address of the resolver.
     */
    O(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    O(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    B(this, Ua);
    B(this, no);
    le(this, { provider: e, address: n, name: r }), x(this, Ua, null), x(this, no, new rs(n, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return m(this, Ua) == null && x(this, Ua, (async () => {
      try {
        return await m(this, no).supportsInterface("0x9061b923");
      } catch (e) {
        if (Bt(e, "CALL_EXCEPTION"))
          return !1;
        throw x(this, Ua, null), e;
      }
    })()), await m(this, Ua);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const a = await G(this, Na, tc).call(this, "addr(bytes32)");
        return a == null || a === ti ? null : a;
      } catch (a) {
        if (Bt(a, "CALL_EXCEPTION"))
          return null;
        throw a;
      }
    if (e >= 0 && e < 2147483648) {
      let a = e + 2147483648;
      const i = await G(this, Na, tc).call(this, "addr(bytes32,uint)", [a]);
      if (Re(i, 20))
        return de(i);
    }
    let n = null;
    for (const a of this.provider.plugins)
      if (a instanceof mP && a.supportsCoinType(e)) {
        n = a;
        break;
      }
    if (n == null)
      return null;
    const r = await G(this, Na, tc).call(this, "addr(bytes32,uint)", [e]);
    if (r == null || r === "0x")
      return null;
    const s = await n.decodeAddress(e, r);
    if (s != null)
      return s;
    q(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: r }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const n = await G(this, Na, tc).call(this, "text(bytes32,string)", [e]);
    return n == null || n === "0x" ? null : n;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await G(this, Na, tc).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (n) {
      const s = n[1] === "e3010170" ? "ipfs" : "ipns", a = parseInt(n[4], 16);
      if (n[5].length === a * 2)
        return `${s}://${wI("0x" + n[2])}`;
    }
    const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64)
      return `bzz://${r[1]}`;
    q(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const n = await this.getText("avatar");
      if (n == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: n });
      for (let r = 0; r < Wx.length; r++) {
        const s = n.match(Wx[r]);
        if (s == null)
          continue;
        const a = s[1].toLowerCase();
        switch (a) {
          case "https":
          case "data":
            return e.push({ type: "url", value: n }), { linkage: e, url: n };
          case "ipfs": {
            const i = A0(n);
            return e.push({ type: "ipfs", value: n }), e.push({ type: "url", value: i }), { linkage: e, url: i };
          }
          case "erc721":
          case "erc1155": {
            const i = a === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: a, value: n });
            const o = await this.getAddress();
            if (o == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return e.push({ type: `!${a}caip`, value: s[2] || "" }), { url: null, linkage: e };
            const u = c[1], l = new rs(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (a === "erc721") {
              const y = await l.ownerOf(u);
              if (o !== y)
                return e.push({ type: "!owner", value: y }), { url: null, linkage: e };
              e.push({ type: "owner", value: y });
            } else if (a === "erc1155") {
              const y = await l.balanceOf(o, u);
              if (!y)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: y.toString() });
            }
            let d = await l[i](u);
            if (d == null || d === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: d }), a === "erc1155" && (d = d.replace("{id}", Ir(u, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: d })), d.match(/^ipfs:/i) && (d = A0(d)), e.push({ type: "metadata-url", value: d });
            let p = {};
            const f = await new as(d).send();
            f.assertOk();
            try {
              p = f.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: f.bodyText });
              } catch {
                const w = f.body;
                return w && e.push({ type: "!metadata", value: z(w) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!p)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(p) });
            let b = p.image;
            if (typeof b != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!b.match(/^(https:\/\/|data:)/i)) {
              if (b.match(Y8) == null)
                return e.push({ type: "!imageUrl-ipfs", value: b }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: b }), b = A0(b);
            }
            return e.push({ type: "url", value: b }), { linkage: e, url: b };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const n = await e.getNetwork(), r = n.getPlugin("org.ethers.plugins.network.Ens");
    return q(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: n }
    }), r.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, n) {
    var s;
    let r = n;
    for (; ; ) {
      if (r === "" || r === "." || n !== "eth" && r === "eth")
        return null;
      const a = await G(s = hc, Dh, ev).call(s, e, r);
      if (a != null) {
        const i = new hc(e, a, n);
        return r !== n && !await i.supportsWildcard() ? null : i;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
};
Ua = new WeakMap(), no = new WeakMap(), Na = new WeakSet(), tc = async function(e, n) {
  n = (n || []).slice();
  const r = m(this, no).interface;
  n.unshift(zy(this.name));
  let s = null;
  await this.supportsWildcard() && (s = r.getFunction(e), q(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: e }
  }), n = [
    SB(this.name, 255),
    r.encodeFunctionData(s, n)
  ], e = "resolve(bytes,bytes)"), n.push({
    enableCcipRead: !0
  });
  try {
    const a = await m(this, no)[e](...n);
    return s ? r.decodeFunctionResult(s, a)[0] : a;
  } catch (a) {
    if (!Bt(a, "CALL_EXCEPTION"))
      throw a;
  }
  return null;
}, Dh = new WeakSet(), ev = async function(e, n) {
  const r = await hc.getEnsAddress(e);
  try {
    const a = await new rs(r, [
      "function resolver(bytes32) view returns (address)"
    ], e).resolver(zy(n), {
      enableCcipRead: !0
    });
    return a === ti ? null : a;
  } catch (s) {
    throw s;
  }
  return null;
}, B(hc, Dh);
let Xp = hc;
const Qx = BigInt(0);
function Ce(t, e) {
  return function(n) {
    return n == null ? e : t(n);
  };
}
function md(t, e) {
  return (n) => {
    if (e && n == null)
      return null;
    if (!Array.isArray(n))
      throw new Error("not an array");
    return n.map((r) => t(r));
  };
}
function Zd(t, e) {
  return (n) => {
    const r = {};
    for (const s in t) {
      let a = s;
      if (e && s in e && !(a in n)) {
        for (const i of e[s])
          if (i in n) {
            a = i;
            break;
          }
      }
      try {
        const i = t[s](n[a]);
        i !== void 0 && (r[s] = i);
      } catch (i) {
        const o = i instanceof Error ? i.message : "not-an-error";
        q(!1, `invalid value for value.${s} (${o})`, "BAD_DATA", { value: n });
      }
    }
    return r;
  };
}
function yP(t) {
  switch (t) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  U(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
}
function Ul(t) {
  return U(Re(t, !0), "invalid data", "value", t), t;
}
function St(t) {
  return U(Re(t, 32), "invalid hash", "value", t), t;
}
const bP = Zd({
  address: de,
  blockHash: St,
  blockNumber: Ee,
  data: Ul,
  index: Ee,
  removed: Ce(yP, !1),
  topics: md(St),
  transactionHash: St,
  transactionIndex: Ee
}, {
  index: ["logIndex"]
});
function gP(t) {
  return bP(t);
}
const wP = Zd({
  hash: Ce(St),
  parentHash: St,
  parentBeaconBlockRoot: Ce(St, null),
  number: Ee,
  timestamp: Ee,
  nonce: Ce(Ul),
  difficulty: re,
  gasLimit: re,
  gasUsed: re,
  stateRoot: Ce(St, null),
  receiptsRoot: Ce(St, null),
  blobGasUsed: Ce(re, null),
  excessBlobGas: Ce(re, null),
  miner: Ce(de),
  prevRandao: Ce(St, null),
  extraData: Ul,
  baseFeePerGas: Ce(re)
}, {
  prevRandao: ["mixHash"]
});
function EP(t) {
  const e = wP(t);
  return e.transactions = t.transactions.map((n) => typeof n == "string" ? n : tv(n)), e;
}
const xP = Zd({
  transactionIndex: Ee,
  blockNumber: Ee,
  transactionHash: St,
  address: de,
  topics: md(St),
  data: Ul,
  index: Ee,
  blockHash: St
}, {
  index: ["logIndex"]
});
function AP(t) {
  return xP(t);
}
const kP = Zd({
  to: Ce(de, null),
  from: Ce(de, null),
  contractAddress: Ce(de, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: Ee,
  root: Ce(z),
  gasUsed: re,
  blobGasUsed: Ce(re, null),
  logsBloom: Ce(Ul),
  blockHash: St,
  hash: St,
  logs: md(AP),
  blockNumber: Ee,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: re,
  effectiveGasPrice: Ce(re),
  blobGasPrice: Ce(re, null),
  status: Ce(Ee),
  type: Ce(Ee, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function vP(t) {
  return kP(t);
}
function tv(t) {
  t.to && re(t.to) === Qx && (t.to = "0x0000000000000000000000000000000000000000");
  const e = Zd({
    hash: St,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: Ce(Ee, void 0),
    type: (n) => n === "0x" || n == null ? 0 : Ee(n),
    accessList: Ce(Ho, null),
    blobVersionedHashes: Ce(md(St, !0), null),
    authorizationList: Ce(md((n) => {
      let r;
      if (n.signature)
        r = n.signature;
      else {
        let s = n.yParity;
        s === "0x1b" ? s = 0 : s === "0x1c" && (s = 1), r = Object.assign({}, n, { yParity: s });
      }
      return {
        address: de(n.address),
        chainId: re(n.chainId),
        nonce: re(n.nonce),
        signature: vn.from(r)
      };
    }, !1), null),
    blockHash: Ce(St, null),
    blockNumber: Ce(Ee, null),
    transactionIndex: Ce(Ee, null),
    from: de,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: Ce(re),
    maxPriorityFeePerGas: Ce(re),
    maxFeePerGas: Ce(re),
    maxFeePerBlobGas: Ce(re, null),
    gasLimit: re,
    to: Ce(de, null),
    value: re,
    nonce: Ee,
    data: Ul,
    creates: Ce(de, null),
    chainId: Ce(re, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(t);
  if (e.to == null && e.creates == null && (e.creates = u9(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = vn.from(t.signature) : e.signature = vn.from(t), e.chainId == null) {
    const n = e.signature.legacyChainId;
    n != null && (e.chainId = n);
  }
  return e.blockHash && re(e.blockHash) === Qx && (e.blockHash = null), e;
}
const CP = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Yd {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    O(this, "name");
    le(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new Yd(this.name);
  }
}
class Zh extends Yd {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(n, r) {
    n == null && (n = 0);
    super(`org.ethers.network.plugins.GasCost#${n || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    O(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    O(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    O(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    O(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    O(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    O(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    O(this, "txAccessListAddress");
    const s = { effectiveBlock: n };
    function a(i, o) {
      let c = (r || {})[i];
      c == null && (c = o), U(typeof c == "number", `invalud value for ${i}`, "costs", r), s[i] = c;
    }
    a("txBase", 21e3), a("txCreate", 32e3), a("txDataZero", 4), a("txDataNonzero", 16), a("txAccessListStorageKey", 1900), a("txAccessListAddress", 2400), le(this, s);
  }
  clone() {
    return new Zh(this.effectiveBlock, this);
  }
}
class Yh extends Yd {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    O(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    O(this, "targetNetwork");
    le(this, {
      address: n || CP,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new Yh(this.address, this.targetNetwork);
  }
}
var zd, jd;
class TP extends Yd {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    B(this, zd);
    B(this, jd);
    x(this, zd, n), x(this, jd, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return m(this, zd);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return m(this, jd);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
zd = new WeakMap(), jd = new WeakMap();
const k0 = /* @__PURE__ */ new Map();
var dl, fl, Ra;
const mc = class mc {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, n) {
    B(this, dl);
    B(this, fl);
    B(this, Ra);
    x(this, dl, e), x(this, fl, re(n)), x(this, Ra, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return m(this, dl);
  }
  set name(e) {
    x(this, dl, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return m(this, fl);
  }
  set chainId(e) {
    x(this, fl, re(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === re(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === re(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === re(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(m(this, Ra).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (m(this, Ra).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, Ra).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return m(this, Ra).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((n) => n.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new mc(this.name, this.chainId);
    return this.plugins.forEach((n) => {
      e.attachPlugin(n.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new Zh();
    let r = n.txBase;
    if (e.to == null && (r += n.txCreate), e.data)
      for (let s = 2; s < e.data.length; s += 2)
        e.data.substring(s, s + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
    if (e.accessList) {
      const s = Ho(e.accessList);
      for (const a in s)
        r += n.txAccessListAddress + n.txAccessListStorageKey * s[a].storageKeys.length;
    }
    return r;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (SP(), e == null)
      return mc.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const n = k0.get(e);
      if (n)
        return n();
      if (typeof e == "bigint")
        return new mc("unknown", e);
      U(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      U(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const n = new mc(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new Yh(e.ensAddress, e.ensNetwork)), n;
    }
    U(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, n) {
    typeof e == "number" && (e = BigInt(e));
    const r = k0.get(e);
    r && U(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), k0.set(e, n);
  }
};
dl = new WeakMap(), fl = new WeakMap(), Ra = new WeakMap();
let Sr = mc;
function Jx(t, e) {
  const n = String(t);
  if (!n.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${t}`);
  const r = n.split(".");
  if (r.length === 1 && r.push(""), r.length !== 2)
    throw new Error(`invalid gwei value: ${t}`);
  for (; r[1].length < e; )
    r[1] += "0";
  if (r[1].length > 9) {
    let s = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || s++, r[1] = s.toString();
  }
  return BigInt(r[0] + r[1]);
}
function Xx(t) {
  return new TP(t, async (e, n, r) => {
    r.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [a, i] = await Promise.all([
        r.send(),
        e()
      ]);
      s = a;
      const o = s.bodyJson.standard;
      return {
        gasPrice: i.gasPrice,
        maxFeePerGas: Jx(o.maxFee, 9),
        maxPriorityFeePerGas: Jx(o.maxPriorityFee, 9)
      };
    } catch (a) {
      q(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", { request: r, response: s, error: a });
    }
  });
}
let Zx = !1;
function SP() {
  if (Zx)
    return;
  Zx = !0;
  function t(e, n, r) {
    const s = function() {
      const a = new Sr(e, n);
      return r.ensNetwork != null && a.attachPlugin(new Yh(null, r.ensNetwork)), a.attachPlugin(new Zh()), (r.plugins || []).forEach((i) => {
        a.attachPlugin(i);
      }), a;
    };
    Sr.register(e, s), Sr.register(n, s), r.altNames && r.altNames.forEach((a) => {
      Sr.register(a, s);
    });
  }
  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), t("ropsten", 3, { ensNetwork: 3 }), t("rinkeby", 4, { ensNetwork: 4 }), t("goerli", 5, { ensNetwork: 5 }), t("kovan", 42, { ensNetwork: 42 }), t("sepolia", 11155111, { ensNetwork: 11155111 }), t("holesky", 17e3, { ensNetwork: 17e3 }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
    ensNetwork: 1
  }), t("arbitrum-goerli", 421613, {}), t("arbitrum-sepolia", 421614, {}), t("base", 8453, { ensNetwork: 1 }), t("base-goerli", 84531, {}), t("base-sepolia", 84532, {}), t("bnb", 56, { ensNetwork: 1 }), t("bnbt", 97, {}), t("linea", 59144, { ensNetwork: 1 }), t("linea-goerli", 59140, {}), t("linea-sepolia", 59141, {}), t("matic", 137, {
    ensNetwork: 1,
    plugins: [
      Xx("https://gasstation.polygon.technology/v2")
    ]
  }), t("matic-amoy", 80002, {}), t("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      Xx("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), t("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), t("optimism-goerli", 420, {}), t("optimism-sepolia", 11155420, {}), t("xdai", 100, { ensNetwork: 1 });
}
function Wy(t) {
  return JSON.parse(JSON.stringify(t));
}
var Ps, Xn, Da, Zr, pl, Ap;
class IP {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    B(this, pl);
    B(this, Ps);
    B(this, Xn);
    B(this, Da);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    B(this, Zr);
    x(this, Ps, e), x(this, Xn, null), x(this, Da, 4e3), x(this, Zr, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return m(this, Da);
  }
  set pollingInterval(e) {
    x(this, Da, e);
  }
  start() {
    m(this, Xn) || (x(this, Xn, m(this, Ps)._setTimeout(G(this, pl, Ap).bind(this), m(this, Da))), G(this, pl, Ap).call(this));
  }
  stop() {
    m(this, Xn) && (m(this, Ps)._clearTimeout(m(this, Xn)), x(this, Xn, null));
  }
  pause(e) {
    this.stop(), e && x(this, Zr, -2);
  }
  resume() {
    this.start();
  }
}
Ps = new WeakMap(), Xn = new WeakMap(), Da = new WeakMap(), Zr = new WeakMap(), pl = new WeakSet(), Ap = async function() {
  try {
    const e = await m(this, Ps).getBlockNumber();
    if (m(this, Zr) === -2) {
      x(this, Zr, e);
      return;
    }
    if (e !== m(this, Zr)) {
      for (let n = m(this, Zr) + 1; n <= e; n++) {
        if (m(this, Xn) == null)
          return;
        await m(this, Ps).emit("block", n);
      }
      x(this, Zr, e);
    }
  } catch {
  }
  m(this, Xn) != null && x(this, Xn, m(this, Ps)._setTimeout(G(this, pl, Ap).bind(this), m(this, Da)));
};
var ro, so, Fa;
class z1 {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    B(this, ro);
    B(this, so);
    B(this, Fa);
    x(this, ro, e), x(this, Fa, !1), x(this, so, (n) => {
      this._poll(n, m(this, ro));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, n) {
    throw new Error("sub-classes must override this");
  }
  start() {
    m(this, Fa) || (x(this, Fa, !0), m(this, so).call(this, -2), m(this, ro).on("block", m(this, so)));
  }
  stop() {
    m(this, Fa) && (x(this, Fa, !1), m(this, ro).off("block", m(this, so)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
ro = new WeakMap(), so = new WeakMap(), Fa = new WeakMap();
var hl, Us;
class OP extends z1 {
  constructor(n, r) {
    super(n);
    B(this, hl);
    B(this, Us);
    x(this, hl, r), x(this, Us, -2);
  }
  pause(n) {
    n && x(this, Us, -2), super.pause(n);
  }
  async _poll(n, r) {
    const s = await r.getBlock(m(this, hl));
    s != null && (m(this, Us) === -2 ? x(this, Us, s.number) : s.number > m(this, Us) && (r.emit(m(this, hl), s.number), x(this, Us, s.number)));
  }
}
hl = new WeakMap(), Us = new WeakMap();
var Fh;
class BP extends z1 {
  constructor(n, r) {
    super(n);
    B(this, Fh);
    x(this, Fh, Wy(r));
  }
  async _poll(n, r) {
    throw new Error("@TODO");
  }
}
Fh = new WeakMap();
var ml;
class PP extends z1 {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(n, r) {
    super(n);
    B(this, ml);
    x(this, ml, r);
  }
  async _poll(n, r) {
    const s = await r.getTransactionReceipt(m(this, ml));
    s && r.emit(m(this, ml), s);
  }
}
ml = new WeakMap();
var Ns, yl, bl, Ma, Zn, Mh, nv;
class j1 {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, n) {
    B(this, Mh);
    B(this, Ns);
    B(this, yl);
    B(this, bl);
    B(this, Ma);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    B(this, Zn);
    x(this, Ns, e), x(this, yl, Wy(n)), x(this, bl, G(this, Mh, nv).bind(this)), x(this, Ma, !1), x(this, Zn, -2);
  }
  start() {
    m(this, Ma) || (x(this, Ma, !0), m(this, Zn) === -2 && m(this, Ns).getBlockNumber().then((e) => {
      x(this, Zn, e);
    }), m(this, Ns).on("block", m(this, bl)));
  }
  stop() {
    m(this, Ma) && (x(this, Ma, !1), m(this, Ns).off("block", m(this, bl)));
  }
  pause(e) {
    this.stop(), e && x(this, Zn, -2);
  }
  resume() {
    this.start();
  }
}
Ns = new WeakMap(), yl = new WeakMap(), bl = new WeakMap(), Ma = new WeakMap(), Zn = new WeakMap(), Mh = new WeakSet(), nv = async function(e) {
  if (m(this, Zn) === -2)
    return;
  const n = Wy(m(this, yl));
  n.fromBlock = m(this, Zn) + 1, n.toBlock = e;
  const r = await m(this, Ns).getLogs(n);
  if (r.length === 0) {
    m(this, Zn) < e - 60 && x(this, Zn, e - 60);
    return;
  }
  for (const s of r)
    m(this, Ns).emit(m(this, yl), s), x(this, Zn, s.blockNumber);
};
const UP = BigInt(2), NP = 10;
function Pf(t) {
  return t && typeof t.then == "function";
}
function kp(t, e) {
  return t + ":" + JSON.stringify(e, (n, r) => {
    if (r == null)
      return "null";
    if (typeof r == "bigint")
      return `bigint:${r.toString()}`;
    if (typeof r == "string")
      return r.toLowerCase();
    if (typeof r == "object" && !Array.isArray(r)) {
      const s = Object.keys(r);
      return s.sort(), s.reduce((a, i) => (a[i] = r[i], a), {});
    }
    return r;
  });
}
class rv {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    /**
     *  The name fof the event.
     */
    O(this, "name");
    le(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function RP(t) {
  return JSON.parse(JSON.stringify(t));
}
function Qy(t) {
  return t = Array.from(new Set(t).values()), t.sort(), t;
}
async function v0(t, e) {
  if (t == null)
    throw new Error("invalid event");
  if (Array.isArray(t) && (t = { topics: t }), typeof t == "string")
    switch (t) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: t, tag: t };
    }
  if (Re(t, 32)) {
    const n = t.toLowerCase();
    return { type: "transaction", tag: kp("tx", { hash: n }), hash: n };
  }
  if (t.orphan) {
    const n = t;
    return { type: "orphan", tag: kp("orphan", n), filter: RP(n) };
  }
  if (t.address || t.topics) {
    const n = t, r = {
      topics: (n.topics || []).map((s) => s == null ? null : Array.isArray(s) ? Qy(s.map((a) => a.toLowerCase())) : s.toLowerCase())
    };
    if (n.address) {
      const s = [], a = [], i = (o) => {
        Re(o) ? s.push(o) : a.push((async () => {
          s.push(await dn(o, e));
        })());
      };
      Array.isArray(n.address) ? n.address.forEach(i) : i(n.address), a.length && await Promise.all(a), r.address = Qy(s.map((o) => o.toLowerCase()));
    }
    return { filter: r, tag: kp("event", r), type: "event" };
  }
  U(!1, "unknown ProviderEvent", "event", t);
}
function C0() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const DP = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var $t, La, Gt, gl, Fn, ao, Ha, Rs, Vd, Yn, wl, El, we, Pn, Jy, Xy, Du, Zy, Fu, vp;
class FP {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, n) {
    B(this, we);
    B(this, $t);
    B(this, La);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    B(this, Gt);
    B(this, gl);
    B(this, Fn);
    B(this, ao);
    B(this, Ha);
    // The most recent block number if running an event or -1 if no "block" event
    B(this, Rs);
    B(this, Vd);
    B(this, Yn);
    B(this, wl);
    B(this, El);
    if (x(this, El, Object.assign({}, DP, n || {})), e === "any")
      x(this, ao, !0), x(this, Fn, null);
    else if (e) {
      const r = Sr.from(e);
      x(this, ao, !1), x(this, Fn, Promise.resolve(r)), setTimeout(() => {
        this.emit("network", r, null);
      }, 0);
    } else
      x(this, ao, !1), x(this, Fn, null);
    x(this, Rs, -1), x(this, Ha, /* @__PURE__ */ new Map()), x(this, $t, /* @__PURE__ */ new Map()), x(this, La, /* @__PURE__ */ new Map()), x(this, Gt, null), x(this, gl, !1), x(this, Vd, 1), x(this, Yn, /* @__PURE__ */ new Map()), x(this, wl, !1);
  }
  get pollingInterval() {
    return m(this, El).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(m(this, La).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (m(this, La).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, La).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return m(this, La).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return m(this, wl);
  }
  set disableCcipRead(e) {
    x(this, wl, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, n, r) {
    if (this.disableCcipRead || r.length === 0 || e.to == null)
      return null;
    const s = e.to.toLowerCase(), a = n.toLowerCase(), i = [];
    for (let o = 0; o < r.length; o++) {
      const c = r[o], u = c.replace("{sender}", s).replace("{data}", a), l = new as(u);
      c.indexOf("{data}") === -1 && (l.body = { data: a, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: l, index: o, urls: r });
      let d = "unknown error", p;
      try {
        p = await l.send();
      } catch (f) {
        i.push(f.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: { error: f } });
        continue;
      }
      try {
        const f = p.bodyJson;
        if (f.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: l, result: f }), f.data;
        f.message && (d = f.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: f });
      } catch {
      }
      q(p.statusCode < 400 || p.statusCode >= 500, `response not found during CCIP fetch: ${d}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: c, errorMessage: d } }), i.push(d);
    }
    q(!1, `error encountered during CCIP fetch: ${i.map((o) => JSON.stringify(o)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: r, errorMessages: i }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, n) {
    return new tP(EP(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, n) {
    return new Xd(gP(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, n) {
    return new G8(vP(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, n) {
    return new hd(tv(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    q(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    q(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = Ee(await G(this, we, Pn).call(this, { method: "getBlockNumber" }), "%response");
    return m(this, Rs) >= 0 && x(this, Rs, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return dn(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (Re(e))
      return Re(e, 32) ? e : kr(e);
    if (typeof e == "bigint" && (e = Ee(e, "blockTag")), typeof e == "number")
      return e >= 0 ? kr(e) : m(this, Rs) >= 0 ? kr(m(this, Rs) + e) : this.getBlockNumber().then((n) => kr(n + e));
    U(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const n = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? Qy(c.map((u) => u.toLowerCase())) : c.toLowerCase()), r = "blockHash" in e ? e.blockHash : void 0, s = (c, u, l) => {
      let d;
      switch (c.length) {
        case 0:
          break;
        case 1:
          d = c[0];
          break;
        default:
          c.sort(), d = c;
      }
      if (r && (u != null || l != null))
        throw new Error("invalid filter");
      const p = {};
      return d && (p.address = d), n.length && (p.topics = n), u && (p.fromBlock = u), l && (p.toBlock = l), r && (p.blockHash = r), p;
    };
    let a = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const c of e.address)
          a.push(this._getAddress(c));
      else
        a.push(this._getAddress(e.address));
    let i;
    "fromBlock" in e && (i = this._getBlockTag(e.fromBlock));
    let o;
    return "toBlock" in e && (o = this._getBlockTag(e.toBlock)), a.filter((c) => typeof c != "string").length || i != null && typeof i != "string" || o != null && typeof o != "string" ? Promise.all([Promise.all(a), i, o]).then((c) => s(c[0], c[1], c[2])) : s(a, i, o);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const n = Qp(e), r = [];
    if (["to", "from"].forEach((s) => {
      if (n[s] == null)
        return;
      const a = dn(n[s], this);
      Pf(a) ? r.push(async function() {
        n[s] = await a;
      }()) : n[s] = a;
    }), n.blockTag != null) {
      const s = this._getBlockTag(n.blockTag);
      Pf(s) ? r.push(async function() {
        n.blockTag = await s;
      }()) : n.blockTag = s;
    }
    return r.length ? async function() {
      return await Promise.all(r), n;
    }() : n;
  }
  async getNetwork() {
    if (m(this, Fn) == null) {
      const s = (async () => {
        try {
          const a = await this._detectNetwork();
          return this.emit("network", a, null), a;
        } catch (a) {
          throw m(this, Fn) === s && x(this, Fn, null), a;
        }
      })();
      return x(this, Fn, s), (await s).clone();
    }
    const e = m(this, Fn), [n, r] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return n.chainId !== r.chainId && (m(this, ao) ? (this.emit("network", r, n), m(this, Fn) === e && x(this, Fn, Promise.resolve(r))) : q(!1, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), n.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), n = async () => {
      const { _block: s, gasPrice: a, priorityFee: i } = await Tt({
        _block: G(this, we, Zy).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const l = await G(this, we, Pn).call(this, { method: "getGasPrice" });
            return re(l, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const l = await G(this, we, Pn).call(this, { method: "getPriorityFee" });
            return re(l, "%response");
          } catch {
          }
          return null;
        })()
      });
      let o = null, c = null;
      const u = this._wrapBlock(s, e);
      return u && u.baseFeePerGas && (c = i ?? BigInt("1000000000"), o = u.baseFeePerGas * UP + c), new Vx(a, o, c);
    }, r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const s = new as(r.url), a = await r.processFunc(n, this, s);
      return new Vx(a.gasPrice, a.maxFeePerGas, a.maxPriorityFeePerGas);
    }
    return await n();
  }
  async estimateGas(e) {
    let n = this._getTransactionRequest(e);
    return Pf(n) && (n = await n), re(await G(this, we, Pn).call(this, {
      method: "estimateGas",
      transaction: n
    }), "%response");
  }
  async call(e) {
    const { tx: n, blockTag: r } = await Tt({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await G(this, we, Xy).call(this, G(this, we, Jy).call(this, n, r, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, n) {
    return re(await G(this, we, Du).call(this, { method: "getBalance" }, e, n), "%response");
  }
  async getTransactionCount(e, n) {
    return Ee(await G(this, we, Du).call(this, { method: "getTransactionCount" }, e, n), "%response");
  }
  async getCode(e, n) {
    return z(await G(this, we, Du).call(this, { method: "getCode" }, e, n));
  }
  async getStorage(e, n, r) {
    const s = re(n, "position");
    return z(await G(this, we, Du).call(this, { method: "getStorage", position: s }, e, r));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: n, hash: r, network: s } = await Tt({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), a = zp.from(e);
    if (a.hash !== r)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(a, s).replaceableTransaction(n);
  }
  // Queries
  async getBlock(e, n) {
    const { network: r, params: s } = await Tt({
      network: this.getNetwork(),
      params: G(this, we, Zy).call(this, e, !!n)
    });
    return s == null ? null : this._wrapBlock(s, r);
  }
  async getTransaction(e) {
    const { network: n, params: r } = await Tt({
      network: this.getNetwork(),
      params: G(this, we, Pn).call(this, { method: "getTransaction", hash: e })
    });
    return r == null ? null : this._wrapTransactionResponse(r, n);
  }
  async getTransactionReceipt(e) {
    const { network: n, params: r } = await Tt({
      network: this.getNetwork(),
      params: G(this, we, Pn).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (r == null)
      return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const s = await G(this, we, Pn).call(this, { method: "getTransaction", hash: e });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(r, n);
  }
  async getTransactionResult(e) {
    const { result: n } = await Tt({
      network: this.getNetwork(),
      result: G(this, we, Pn).call(this, { method: "getTransactionResult", hash: e })
    });
    return n == null ? null : z(n);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let n = this._getFilter(e);
    Pf(n) && (n = await n);
    const { network: r, params: s } = await Tt({
      network: this.getNetwork(),
      params: G(this, we, Pn).call(this, { method: "getLogs", filter: n })
    });
    return s.map((a) => this._wrapLog(a, r));
  }
  // ENS
  _getProvider(e) {
    q(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await Xp.fromName(this, e);
  }
  async getAvatar(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAvatar() : null;
  }
  async resolveName(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAddress() : null;
  }
  async lookupAddress(e) {
    e = de(e);
    const n = zy(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await Xp.getEnsAddress(this), a = await new rs(r, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(n);
      if (a == null || a === ti)
        return null;
      const o = await new rs(a, [
        "function name(bytes32) view returns (string)"
      ], this).name(n);
      return await this.resolveName(o) !== e ? null : o;
    } catch (r) {
      if (Bt(r, "BAD_DATA") && r.value === "0x" || Bt(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(e, n, r) {
    const s = n ?? 1;
    return s === 0 ? this.getTransactionReceipt(e) : new Promise(async (a, i) => {
      let o = null;
      const c = async (u) => {
        try {
          const l = await this.getTransactionReceipt(e);
          if (l != null && u - l.blockNumber + 1 >= s) {
            a(l), o && (clearTimeout(o), o = null);
            return;
          }
        } catch (l) {
          console.log("EEE", l);
        }
        this.once("block", c);
      };
      r != null && (o = setTimeout(() => {
        o != null && (o = null, this.off("block", c), i(je("timeout", "TIMEOUT", { reason: "timeout" })));
      }, r)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    q(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const n = m(this, Yn).get(e);
    n && (n.timer && clearTimeout(n.timer), m(this, Yn).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, n) {
    n == null && (n = 0);
    const r = ra(this, Vd)._++, s = () => {
      m(this, Yn).delete(r), e();
    };
    if (this.paused)
      m(this, Yn).set(r, { timer: null, func: s, time: n });
    else {
      const a = setTimeout(s, n);
      m(this, Yn).set(r, { timer: a, func: s, time: C0() });
    }
    return r;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const n of m(this, $t).values())
      e(n.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new rv(e.type);
      case "block": {
        const n = new IP(this);
        return n.pollingInterval = this.pollingInterval, n;
      }
      case "safe":
      case "finalized":
        return new OP(this, e.type);
      case "event":
        return new j1(this, e.filter);
      case "transaction":
        return new PP(this, e.hash);
      case "orphan":
        return new BP(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, n) {
    for (const r of m(this, $t).values())
      if (r.subscriber === e) {
        r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), m(this, Gt) != null && n.pause(m(this, Gt));
        break;
      }
  }
  async on(e, n) {
    const r = await G(this, we, vp).call(this, e);
    return r.listeners.push({ listener: n, once: !1 }), r.started || (r.subscriber.start(), r.started = !0, m(this, Gt) != null && r.subscriber.pause(m(this, Gt))), this;
  }
  async once(e, n) {
    const r = await G(this, we, vp).call(this, e);
    return r.listeners.push({ listener: n, once: !0 }), r.started || (r.subscriber.start(), r.started = !0, m(this, Gt) != null && r.subscriber.pause(m(this, Gt))), this;
  }
  async emit(e, ...n) {
    const r = await G(this, we, Fu).call(this, e, n);
    if (!r || r.listeners.length === 0)
      return !1;
    const s = r.listeners.length;
    return r.listeners = r.listeners.filter(({ listener: a, once: i }) => {
      const o = new dk(this, i ? null : a, e);
      try {
        a.call(this, ...n, o);
      } catch {
      }
      return !i;
    }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), m(this, $t).delete(r.tag)), s > 0;
  }
  async listenerCount(e) {
    if (e) {
      const r = await G(this, we, Fu).call(this, e);
      return r ? r.listeners.length : 0;
    }
    let n = 0;
    for (const { listeners: r } of m(this, $t).values())
      n += r.length;
    return n;
  }
  async listeners(e) {
    if (e) {
      const r = await G(this, we, Fu).call(this, e);
      return r ? r.listeners.map(({ listener: s }) => s) : [];
    }
    let n = [];
    for (const { listeners: r } of m(this, $t).values())
      n = n.concat(r.map(({ listener: s }) => s));
    return n;
  }
  async off(e, n) {
    const r = await G(this, we, Fu).call(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), m(this, $t).delete(r.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: n, started: r, subscriber: s } = await G(this, we, vp).call(this, e);
      r && s.stop(), m(this, $t).delete(n);
    } else
      for (const [n, { started: r, subscriber: s }] of m(this, $t))
        r && s.stop(), m(this, $t).delete(n);
    return this;
  }
  // Alias for "on"
  async addListener(e, n) {
    return await this.on(e, n);
  }
  // Alias for "off"
  async removeListener(e, n) {
    return this.off(e, n);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return m(this, gl);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of m(this, Yn).keys())
      this._clearTimeout(e);
    x(this, gl, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return m(this, Gt) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (x(this, Rs, -1), m(this, Gt) != null) {
      if (m(this, Gt) == !!e)
        return;
      q(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((n) => n.pause(e)), x(this, Gt, !!e);
    for (const n of m(this, Yn).values())
      n.timer && clearTimeout(n.timer), n.time = C0() - n.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (m(this, Gt) != null) {
      this._forEachSubscriber((e) => e.resume()), x(this, Gt, null);
      for (const e of m(this, Yn).values()) {
        let n = e.time;
        n < 0 && (n = 0), e.time = C0(), setTimeout(e.func, n);
      }
    }
  }
}
$t = new WeakMap(), La = new WeakMap(), Gt = new WeakMap(), gl = new WeakMap(), Fn = new WeakMap(), ao = new WeakMap(), Ha = new WeakMap(), Rs = new WeakMap(), Vd = new WeakMap(), Yn = new WeakMap(), wl = new WeakMap(), El = new WeakMap(), we = new WeakSet(), Pn = async function(e) {
  const n = m(this, El).cacheTimeout;
  if (n < 0)
    return await this._perform(e);
  const r = kp(e.method, e);
  let s = m(this, Ha).get(r);
  return s || (s = this._perform(e), m(this, Ha).set(r, s), setTimeout(() => {
    m(this, Ha).get(r) === s && m(this, Ha).delete(r);
  }, n)), await s;
}, Jy = async function(e, n, r) {
  q(r < NP, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, e, { blockTag: n, enableCcipRead: !0 })
  });
  const s = Qp(e);
  try {
    return z(await this._perform({ method: "call", transaction: s, blockTag: n }));
  } catch (a) {
    if (!this.disableCcipRead && T1(a) && a.data && r >= 0 && n === "latest" && s.to != null && Ve(a.data, 0, 4) === "0x556f1830") {
      const i = a.data, o = await dn(s.to, this);
      let c;
      try {
        c = $P(Ve(a.data, 4));
      } catch (d) {
        q(!1, d.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: i }
        });
      }
      q(c.sender.toLowerCase() === o.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: i,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(s, c.calldata, c.urls);
      q(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: a.data, errorArgs: c.errorArgs }
      });
      const l = {
        to: o,
        data: _e([c.selector, _P([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: l });
      try {
        const d = await G(this, we, Jy).call(this, l, n, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, l), result: d }), d;
      } catch (d) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, l), error: d }), d;
      }
    }
    throw a;
  }
}, Xy = async function(e) {
  const { value: n } = await Tt({
    network: this.getNetwork(),
    value: e
  });
  return n;
}, Du = async function(e, n, r) {
  let s = this._getAddress(n), a = this._getBlockTag(r);
  return (typeof s != "string" || typeof a != "string") && ([s, a] = await Promise.all([s, a])), await G(this, we, Xy).call(this, G(this, we, Pn).call(this, Object.assign(e, { address: s, blockTag: a })));
}, Zy = async function(e, n) {
  if (Re(e, 32))
    return await G(this, we, Pn).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: n
    });
  let r = this._getBlockTag(e);
  return typeof r != "string" && (r = await r), await G(this, we, Pn).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: n
  });
}, Fu = async function(e, n) {
  let r = await v0(e, this);
  return r.type === "event" && n && n.length > 0 && n[0].removed === !0 && (r = await v0({ orphan: "drop-log", log: n[0] }, this)), m(this, $t).get(r.tag) || null;
}, vp = async function(e) {
  const n = await v0(e, this), r = n.tag;
  let s = m(this, $t).get(r);
  return s || (s = { subscriber: this._getSubscriber(n), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, m(this, $t).set(r, s)), s;
};
function MP(t, e) {
  try {
    const n = Yy(t, e);
    if (n)
      return _p(n);
  } catch {
  }
  return null;
}
function Yy(t, e) {
  if (t === "0x")
    return null;
  try {
    const n = Ee(Ve(t, e, e + 32)), r = Ee(Ve(t, n, n + 32));
    return Ve(t, n + 32, n + 32 + r);
  } catch {
  }
  return null;
}
function Yx(t) {
  const e = dt(t);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const n = new Uint8Array(32);
  return n.set(e, 32 - e.length), n;
}
function LP(t) {
  if (t.length % 32 === 0)
    return t;
  const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
  return e.set(t), e;
}
const HP = new Uint8Array([]);
function _P(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++)
    e.push(HP), n += 32;
  for (let r = 0; r < t.length; r++) {
    const s = ee(t[r]);
    e[r] = Yx(n), e.push(Yx(s.length)), e.push(LP(s)), n += 32 + Math.ceil(s.length / 32) * 32;
  }
  return _e(e);
}
const e2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function $P(t) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  q(fo(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const n = Ve(t, 0, 32);
  q(Ve(n, 0, 12) === Ve(e2, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = Ve(n, 12);
  try {
    const r = [], s = Ee(Ve(t, 32, 64)), a = Ee(Ve(t, s, s + 32)), i = Ve(t, s + 32);
    for (let o = 0; o < a; o++) {
      const c = MP(i, o * 32);
      if (c == null)
        throw new Error("abort");
      r.push(c);
    }
    e.urls = r;
  } catch {
    q(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const r = Yy(t, 64);
    if (r == null)
      throw new Error("abort");
    e.calldata = r;
  } catch {
    q(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  q(Ve(t, 100, 128) === Ve(e2, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = Ve(t, 96, 100);
  try {
    const r = Yy(t, 128);
    if (r == null)
      throw new Error("abort");
    e.extraData = r;
  } catch {
    q(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => e[r]), e;
}
function pi(t, e) {
  if (t.provider)
    return t.provider;
  q(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function t2(t, e) {
  let n = Qp(e);
  if (n.to != null && (n.to = dn(n.to, t)), n.from != null) {
    const r = n.from;
    n.from = Promise.all([
      t.getAddress(),
      dn(r, t)
    ]).then(([s, a]) => (U(s.toLowerCase() === a.toLowerCase(), "transaction from mismatch", "tx.from", a), s));
  } else
    n.from = t.getAddress();
  return await Tt(n);
}
class sv {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    /**
     *  The provider this signer is connected to.
     */
    O(this, "provider");
    le(this, { provider: e || null });
  }
  async getNonce(e) {
    return pi(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await t2(this, e);
  }
  async populateTransaction(e) {
    const n = pi(this, "populateTransaction"), r = await t2(this, e);
    r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const s = await this.provider.getNetwork();
    if (r.chainId != null) {
      const i = re(r.chainId);
      U(i === s.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      r.chainId = s.chainId;
    const a = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (r.gasPrice != null && (r.type === 2 || a) ? U(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && a && U(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const i = await n.getFeeData();
      q(i.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), r.gasPrice == null && (r.gasPrice = i.gasPrice);
    } else {
      const i = await n.getFeeData();
      if (r.type == null)
        if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
          if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, r.gasPrice != null) {
            const o = r.gasPrice;
            delete r.gasPrice, r.maxFeePerGas = o, r.maxPriorityFeePerGas = o;
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
        else i.gasPrice != null ? (q(!a, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : q(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
    }
    return await Tt(r);
  }
  async populateAuthorization(e) {
    const n = Object.assign({}, e);
    return n.chainId == null && (n.chainId = (await pi(this, "getNetwork").getNetwork()).chainId), n.nonce == null && (n.nonce = await this.getNonce()), n;
  }
  async estimateGas(e) {
    return pi(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return pi(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await pi(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const n = pi(this, "sendTransaction"), r = await this.populateTransaction(e);
    delete r.from;
    const s = zp.from(r);
    return await n.broadcastTransaction(await this.signTransaction(s));
  }
  // @TODO: in v7 move this to be abstract
  authorize(e) {
    q(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
function GP(t) {
  return JSON.parse(JSON.stringify(t));
}
var sn, Yr, io, _a, oo, xl, li, eb, tb;
class av {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    B(this, li);
    B(this, sn);
    B(this, Yr);
    B(this, io);
    B(this, _a);
    B(this, oo);
    B(this, xl);
    x(this, sn, e), x(this, Yr, null), x(this, io, G(this, li, eb).bind(this)), x(this, _a, !1), x(this, oo, null), x(this, xl, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, n) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    m(this, _a) || (x(this, _a, !0), G(this, li, eb).call(this, -2));
  }
  stop() {
    m(this, _a) && (x(this, _a, !1), x(this, xl, !0), G(this, li, tb).call(this), m(this, sn).off("block", m(this, io)));
  }
  pause(e) {
    e && G(this, li, tb).call(this), m(this, sn).off("block", m(this, io));
  }
  resume() {
    this.start();
  }
}
sn = new WeakMap(), Yr = new WeakMap(), io = new WeakMap(), _a = new WeakMap(), oo = new WeakMap(), xl = new WeakMap(), li = new WeakSet(), eb = async function(e) {
  try {
    m(this, Yr) == null && x(this, Yr, this._subscribe(m(this, sn)));
    let n = null;
    try {
      n = await m(this, Yr);
    } catch (a) {
      if (!Bt(a, "UNSUPPORTED_OPERATION") || a.operation !== "eth_newFilter")
        throw a;
    }
    if (n == null) {
      x(this, Yr, null), m(this, sn)._recoverSubscriber(this, this._recover(m(this, sn)));
      return;
    }
    const r = await m(this, sn).getNetwork();
    if (m(this, oo) || x(this, oo, r), m(this, oo).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (m(this, xl))
      return;
    const s = await m(this, sn).send("eth_getFilterChanges", [n]);
    await this._emitResults(m(this, sn), s);
  } catch (n) {
    console.log("@TODO", n);
  }
  m(this, sn).once("block", m(this, io));
}, tb = function() {
  const e = m(this, Yr);
  e && (x(this, Yr, null), e.then((n) => {
    m(this, sn).destroyed || m(this, sn).send("eth_uninstallFilter", [n]);
  }));
};
var co;
class zP extends av {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(n, r) {
    super(n);
    B(this, co);
    x(this, co, GP(r));
  }
  _recover(n) {
    return new j1(n, m(this, co));
  }
  async _subscribe(n) {
    return await n.send("eth_newFilter", [m(this, co)]);
  }
  async _emitResults(n, r) {
    for (const s of r)
      n.emit(m(this, co), n._wrapLog(s, n._network));
  }
}
co = new WeakMap();
class jP extends av {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, n) {
    for (const r of n)
      e.emit("pending", r);
  }
}
const VP = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Cp(t) {
  if (t == null || VP.indexOf(typeof t) >= 0 || typeof t.getAddress == "function")
    return t;
  if (Array.isArray(t))
    return t.map(Cp);
  if (typeof t == "object")
    return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
  throw new Error(`should not happen: ${t} (${typeof t})`);
}
function qP(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function qo(t) {
  return t && t.toLowerCase();
}
function n2(t) {
  return t && typeof t.pollingInterval == "number";
}
const iv = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class T0 extends sv {
  constructor(n, r) {
    super(n);
    O(this, "address");
    r = de(r), le(this, { address: r });
  }
  connect(n) {
    q(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(n) {
    return await this.populateCall(n);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(n) {
    const r = Cp(n), s = [];
    if (r.from) {
      const i = r.from;
      s.push((async () => {
        const o = await dn(i, this.provider);
        U(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = o;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && s.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const i = r.to;
      s.push((async () => {
        r.to = await dn(i, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const a = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [a]);
  }
  async sendTransaction(n) {
    const r = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(n);
    return await new Promise((a, i) => {
      const o = [1e3, 100];
      let c = 0;
      const u = async () => {
        try {
          const l = await this.provider.getTransaction(s);
          if (l != null) {
            a(l.replaceableTransaction(r));
            return;
          }
        } catch (l) {
          if (Bt(l, "CANCELLED") || Bt(l, "BAD_DATA") || Bt(l, "NETWORK_ERROR") || Bt(l, "UNSUPPORTED_OPERATION")) {
            l.info == null && (l.info = {}), l.info.sendTransactionHash = s, i(l);
            return;
          }
          if (Bt(l, "INVALID_ARGUMENT") && (c++, l.info == null && (l.info = {}), l.info.sendTransactionHash = s, c > 10)) {
            i(l);
            return;
          }
          this.provider.emit("error", je("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: l }));
        }
        this.provider._setTimeout(() => {
          u();
        }, o.pop() || 4e3);
      };
      u();
    });
  }
  async signTransaction(n) {
    const r = Cp(n);
    if (r.from) {
      const a = await dn(r.from, this.provider);
      U(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = a;
    } else
      r.from = this.address;
    const s = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(n) {
    const r = typeof n == "string" ? kn(n) : n;
    return await this.provider.send("personal_sign", [
      z(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(n, r, s) {
    const a = Cp(s), i = await fd.resolveNames(n, r, a, async (o) => {
      const c = await dn(o);
      return U(c != null, "TypedData does not support null address", "value", o), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(fd.getPayload(i.domain, r, i.value))
    ]);
  }
  async unlock(n) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      n,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(n) {
    const r = typeof n == "string" ? kn(n) : n;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      z(r)
    ]);
  }
}
var lo, Al, Ds, es, Ar, er, wn, qd, nb;
class KP extends FP {
  constructor(n, r) {
    super(n, r);
    B(this, qd);
    B(this, lo);
    // The next ID to use for the JSON-RPC ID field
    B(this, Al);
    // Payloads are queued and triggered in batches using the drainTimer
    B(this, Ds);
    B(this, es);
    B(this, Ar);
    B(this, er);
    B(this, wn);
    x(this, Al, 1), x(this, lo, Object.assign({}, iv, r || {})), x(this, Ds, []), x(this, es, null), x(this, er, null), x(this, wn, null);
    {
      let a = null;
      const i = new Promise((o) => {
        a = o;
      });
      x(this, Ar, { promise: i, resolve: a });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (U(!s || n !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), s && n != null && x(this, er, Sr.from(n))) : s && (U(n == null || s.matches(n), "staticNetwork MUST match network object", "options", r), x(this, er, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(n) {
    return m(this, lo)[n];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return q(m(this, er), "network is not available yet", "NETWORK_ERROR"), m(this, er);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(n) {
    if (n.method === "call" || n.method === "estimateGas") {
      let s = n.transaction;
      if (s && s.type != null && re(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const a = await this.getFeeData();
        a.maxFeePerGas == null && a.maxPriorityFeePerGas == null && (n = Object.assign({}, n, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(n);
    return r != null ? await this.send(r.method, r.args) : super._perform(n);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const n = this._getOption("staticNetwork");
    if (n)
      if (n === !0) {
        if (m(this, er))
          return m(this, er);
      } else
        return n;
    return m(this, wn) ? await m(this, wn) : this.ready ? (x(this, wn, (async () => {
      try {
        const r = Sr.from(re(await this.send("eth_chainId", [])));
        return x(this, wn, null), r;
      } catch (r) {
        throw x(this, wn, null), r;
      }
    })()), await m(this, wn)) : (x(this, wn, (async () => {
      const r = {
        id: ra(this, Al)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let s;
      try {
        s = (await this._send(r))[0], x(this, wn, null);
      } catch (a) {
        throw x(this, wn, null), this.emit("debug", { action: "receiveRpcError", error: a }), a;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return Sr.from(re(s.result));
      throw this.getRpcError(r, s);
    })()), await m(this, wn));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    m(this, Ar) == null || m(this, Ar).resolve == null || (m(this, Ar).resolve(), x(this, Ar, null), (async () => {
      for (; m(this, er) == null && !this.destroyed; )
        try {
          x(this, er, await this._detectNetwork());
        } catch (n) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", je("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: n } })), await qP(1e3);
        }
      G(this, qd, nb).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (m(this, Ar) != null)
      return await m(this, Ar).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(n) {
    return n.type === "pending" ? new jP(this) : n.type === "event" ? this._getOption("polling") ? new j1(this, n.filter) : new zP(this, n.filter) : n.type === "orphan" && n.filter.orphan === "drop-log" ? new rv("orphan") : super._getSubscriber(n);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return m(this, Ar) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(n) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (n[s] == null)
        return;
      let a = s;
      s === "gasLimit" && (a = "gas"), r[a] = kr(re(n[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      n[s] != null && (r[s] = z(n[s]));
    }), n.accessList && (r.accessList = Ho(n.accessList)), n.blobVersionedHashes && (r.blobVersionedHashes = n.blobVersionedHashes.map((s) => s.toLowerCase())), n.authorizationList && (r.authorizationList = n.authorizationList.map((s) => {
      const a = a8(s);
      return {
        address: a.address,
        nonce: kr(a.nonce),
        chainId: kr(a.chainId),
        yParity: kr(a.signature.yParity),
        r: kr(a.signature.r),
        s: kr(a.signature.s)
      };
    })), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(n) {
    switch (n.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [qo(n.address), n.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [qo(n.address), n.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [qo(n.address), n.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            qo(n.address),
            "0x" + n.position.toString(16),
            n.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [n.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in n)
          return {
            method: "eth_getBlockByNumber",
            args: [n.blockTag, !!n.includeTransactions]
          };
        if ("blockHash" in n)
          return {
            method: "eth_getBlockByHash",
            args: [n.blockHash, !!n.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [n.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [n.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(n.transaction), n.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(n.transaction)]
        };
      case "getLogs":
        return n.filter && n.filter.address != null && (Array.isArray(n.filter.address) ? n.filter.address = n.filter.address.map(qo) : n.filter.address = qo(n.filter.address)), { method: "eth_getLogs", args: [n.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(n, r) {
    const { method: s } = n, { error: a } = r;
    if (s === "eth_estimateGas" && a.message) {
      const c = a.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return je("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
      if (c.match(/nonce/i) && c.match(/too low/i))
        return je("nonce has already been used", "NONCE_EXPIRED", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = rb(a), u = Wt.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", n.params[0], c ? c.data : null);
      return u.info = { error: a, payload: n }, u;
    }
    const i = JSON.stringify(QP(a));
    if (typeof a.message == "string" && a.message.match(/user denied|ethers-user-denied/i))
      return je("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: n, error: a }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = n.params[0];
      if (i.match(/insufficient funds|base fee exceeds gas limit/i))
        return je("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: a }
        });
      if (i.match(/nonce/i) && i.match(/too low/i))
        return je("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: a } });
      if (i.match(/replacement transaction/i) && i.match(/underpriced/i))
        return je("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: a } });
      if (i.match(/only replay-protected/i))
        return je("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: a } }
        });
    }
    let o = !!i.match(/the method .* does not exist/i);
    return o || a && a.details && a.details.startsWith("Unauthorized method:") && (o = !0), o ? je("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: n.method,
      info: { error: a, payload: n }
    }) : je("could not coalesce error", "UNKNOWN_ERROR", { error: a, payload: n });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(n, r) {
    if (this.destroyed)
      return Promise.reject(je("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n }));
    const s = ra(this, Al)._++, a = new Promise((i, o) => {
      m(this, Ds).push({
        resolve: i,
        reject: o,
        payload: { method: n, params: r, id: s, jsonrpc: "2.0" }
      });
    });
    return G(this, qd, nb).call(this), a;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(n) {
    n == null && (n = 0);
    const r = this.send("eth_accounts", []);
    if (typeof n == "number") {
      const a = await r;
      if (n >= a.length)
        throw new Error("no such account");
      return new T0(this, a[n]);
    }
    const { accounts: s } = await Tt({
      network: this.getNetwork(),
      accounts: r
    });
    n = de(n);
    for (const a of s)
      if (de(a) === n)
        return new T0(this, n);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((r) => new T0(this, r));
  }
  destroy() {
    m(this, es) && (clearTimeout(m(this, es)), x(this, es, null));
    for (const { payload: n, reject: r } of m(this, Ds))
      r(je("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n.method }));
    x(this, Ds, []), super.destroy();
  }
}
lo = new WeakMap(), Al = new WeakMap(), Ds = new WeakMap(), es = new WeakMap(), Ar = new WeakMap(), er = new WeakMap(), wn = new WeakMap(), qd = new WeakSet(), nb = function() {
  if (m(this, es))
    return;
  const n = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  x(this, es, setTimeout(() => {
    x(this, es, null);
    const r = m(this, Ds);
    for (x(this, Ds, []); r.length; ) {
      const s = [r.shift()];
      for (; r.length && s.length !== m(this, lo).batchMaxCount; )
        if (s.push(r.shift()), JSON.stringify(s.map((i) => i.payload)).length > m(this, lo).batchMaxSize) {
          r.unshift(s.pop());
          break;
        }
      (async () => {
        const a = s.length === 1 ? s[0].payload : s.map((i) => i.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: a });
        try {
          const i = await this._send(a);
          this.emit("debug", { action: "receiveRpcResult", result: i });
          for (const { resolve: o, reject: c, payload: u } of s) {
            if (this.destroyed) {
              c(je("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const l = i.filter((d) => d.id === u.id)[0];
            if (l == null) {
              const d = je("missing response for request", "BAD_DATA", {
                value: i,
                info: { payload: u }
              });
              this.emit("error", d), c(d);
              continue;
            }
            if ("error" in l) {
              c(this.getRpcError(u, l));
              continue;
            }
            o(l.result);
          }
        } catch (i) {
          this.emit("debug", { action: "receiveRpcError", error: i });
          for (const { reject: o } of s)
            o(i);
        }
      })();
    }
  }, n));
};
var $a;
class WP extends KP {
  constructor(n, r) {
    super(n, r);
    B(this, $a);
    let s = this._getOption("pollingInterval");
    s == null && (s = iv.pollingInterval), x(this, $a, s);
  }
  _getSubscriber(n) {
    const r = super._getSubscriber(n);
    return n2(r) && (r.pollingInterval = m(this, $a)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return m(this, $a);
  }
  set pollingInterval(n) {
    if (!Number.isInteger(n) || n < 0)
      throw new Error("invalid interval");
    x(this, $a, n), this._forEachSubscriber((r) => {
      n2(r) && (r.pollingInterval = m(this, $a));
    });
  }
}
$a = new WeakMap();
var kl, t6;
let V1 = (t6 = class extends WP {
  constructor(n, r, s) {
    n == null && (n = "http://localhost:8545");
    super(r, s);
    B(this, kl);
    typeof n == "string" ? x(this, kl, new as(n)) : x(this, kl, n.clone());
  }
  _getConnection() {
    return m(this, kl).clone();
  }
  async send(n, r) {
    return await this._start(), await super.send(n, r);
  }
  async _send(n) {
    const r = this._getConnection();
    r.body = JSON.stringify(n), r.setHeader("content-type", "application/json");
    const s = await r.send();
    s.assertOk();
    let a = s.bodyJson;
    return Array.isArray(a) || (a = [a]), a;
  }
}, kl = new WeakMap(), t6);
function rb(t) {
  if (t == null)
    return null;
  if (typeof t.message == "string" && t.message.match(/revert/i) && Re(t.data))
    return { message: t.message, data: t.data };
  if (typeof t == "object") {
    for (const e in t) {
      const n = rb(t[e]);
      if (n)
        return n;
    }
    return null;
  }
  if (typeof t == "string")
    try {
      return rb(JSON.parse(t));
    } catch {
    }
  return null;
}
function sb(t, e) {
  if (t != null) {
    if (typeof t.message == "string" && e.push(t.message), typeof t == "object")
      for (const n in t)
        sb(t[n], e);
    if (typeof t == "string")
      try {
        return sb(JSON.parse(t), e);
      } catch {
      }
  }
}
function QP(t) {
  const e = [];
  return sb(t, e), e;
}
const JP = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), ab = (t) => {
  const e = t.toString(16);
  return `${e.length % 2 === 0 ? "0x" : "0x0"}${e}`;
}, Mu = (t, e) => typeof e == "bigint" ? {
  $bigint: e.toString()
} : e, XP = (t, e, n) => Ae(["string", "uint256", "address", "bytes32"], ["", e, t, n]), r2 = (t, e, n) => ke(XP(t, e, n));
function Zp() {
  return Zp = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Zp.apply(null, arguments);
}
var pr = /* @__PURE__ */ function(t) {
  return t[t.DEBUG = 1] = "DEBUG", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.DISABLED = 5] = "DISABLED", t;
}(pr || {});
class ZP {
  constructor(e) {
    this.config = e, this.logLevel = void 0, this.configure(e);
  }
  configure(e) {
    switch (this.config = Zp({}, this.config, e), this.config.logLevel) {
      case "DEBUG":
        this.logLevel = pr.DEBUG;
        break;
      case "INFO":
        this.logLevel = pr.INFO;
        break;
      case "WARN":
        this.logLevel = pr.WARN;
        break;
      case "ERROR":
        this.logLevel = pr.ERROR;
        break;
      case "DISABLED":
        this.logLevel = pr.DISABLED;
        break;
      default:
        this.logLevel = pr.INFO;
        break;
    }
    this.config.silence === void 0 && (this.config.silence = !1);
  }
  debug(e, ...n) {
    this.config.silence !== !0 && this.logLevel === pr.DEBUG && console.log(e, ...n);
  }
  info(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= pr.INFO && console.log(e, ...n);
  }
  warn(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= pr.WARN && (console.warn(e, ...n), this.config.onwarn && this.config.onwarn(e, n));
  }
  error(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= pr.ERROR && (console.error(e, ...n), this.config.onerror && this.config.onerror(e, n));
  }
}
const dr = new ZP({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: !0
}), ov = (t, e, n) => {
  const r = new as(t);
  return n && r.setHeader("Authorization", `BEARER ${n}`), e && r.setHeader("X-Access-Key", e), r;
}, YP = (t) => {
  const e = Zp({}, t.types);
  return delete e.EIP712Domain, fd.hash(t.domain, e, t.message);
}, cv = (t) => ee(YP(t));
function Nl() {
  return Nl = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Nl.apply(null, arguments);
}
const e4 = (t, e = !1, n = !1) => {
  if (!t) throw new Error("invalid network config: empty config");
  const r = [];
  if (Array.isArray(t) ? r.push(...t) : r.push(t), r.length === 0) {
    if (e) throw new Error("invalid network config: empty config");
    return !1;
  }
  const s = r.map((u) => u.chainId).sort(), a = s.filter((u, l) => s.indexOf(u) !== l);
  if (a.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate chainIds ${a}`);
    return !1;
  }
  r.forEach((u) => u.name = u.name.toLowerCase());
  const i = r.map((u) => u.name).sort(), o = i.filter((u, l) => i.indexOf(u) !== l);
  if (o.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate network names ${o}`);
    return !1;
  }
  let c = !1;
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if ((!l.rpcUrl || l.rpcUrl === "") && !l.provider) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: rpcUrl or provider must be provided`);
      return !1;
    }
    if (!n && !l.relayer) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: relayer must be provided`);
      return !1;
    }
    if (l.isDefaultChain) {
      if (c) {
        if (e) throw new Error(`invalid network config for chainId ${l.chainId}: DefaultChain is already set by another config`);
        return !1;
      }
      c = !0;
    }
  }
  if (!c) {
    if (e) throw new Error("invalid network config: DefaultChain must be set");
    return !1;
  }
  return !0;
}, t4 = (t, e = !1) => (e4(t, !0, e), t), n4 = (t) => t4(r4(t)), r4 = (t) => {
  if (!t)
    return [];
  const e = t.sort((r, s) => r.chainId === s.chainId ? 0 : r.chainId < s.chainId ? -1 : 1), n = e.findIndex((r) => r.isDefaultChain);
  return n > 0 && e.splice(0, 0, e.splice(n, 1)[0]), e;
}, q1 = (t, e) => typeof t == "string" ? (e = e || {}, t.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(n, r) {
  let s = e[r];
  return typeof s == "function" ? s = s() : s == null ? s = "" : typeof s == "object" || typeof s == "symbol" ? s = s.toString() : s = s.valueOf(), s;
})) : "", s4 = (t) => q1("https://${network}-indexer.sequence.app", {
  network: t
}), a4 = (t) => q1("https://${network}-relayer.sequence.app", {
  network: t
}), i4 = (t) => q1("https://nodes.sequence.app/${network}", {
  network: t
}), ce = (t, e) => {
  const n = Ty[t];
  if (!n)
    throw new Error(`Network with chainId ${t} not found`);
  const r = i4(n.name);
  return Nl({}, n, {
    rpcUrl: r,
    indexerUrl: s4(n.name),
    relayer: {
      url: a4(n.name),
      provider: {
        url: r
      }
    }
  }, e);
}, o4 = [Nl({}, Ty[v.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), Nl({}, Ty[v.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})], c4 = n4([Nl({}, ce(v.POLYGON), {
  isDefaultChain: !0,
  isAuthChain: !0
}), ce(v.MAINNET), ce(v.BSC), ce(v.AVALANCHE), ce(v.ARBITRUM), ce(v.ARBITRUM_NOVA), ce(v.OPTIMISM), ce(v.OPTIMISM_SEPOLIA), ce(v.POLYGON_ZKEVM), ce(v.GNOSIS), ce(v.RINKEBY, {
  disabled: !0
}), ce(v.GOERLI, {
  disabled: !0
}), ce(v.SEPOLIA), ce(v.POLYGON_MUMBAI, {
  disabled: !0
}), ce(v.POLYGON_AMOY), ce(v.BSC_TESTNET), ce(v.ARBITRUM_SEPOLIA), ce(v.BASE), ce(v.BASE_SEPOLIA), ce(v.HOMEVERSE), ce(v.HOMEVERSE_TESTNET), ce(v.XAI), ce(v.XAI_SEPOLIA), ce(v.AVALANCHE_TESTNET), ce(v.B3), ce(v.B3_SEPOLIA), ce(v.APECHAIN), ce(v.APECHAIN_TESTNET), ce(v.BLAST), ce(v.BLAST_SEPOLIA), ce(v.TELOS), ce(v.TELOS_TESTNET), ce(v.BORNE_TESTNET), ce(v.SKALE_NEBULA), ce(v.SKALE_NEBULA_TESTNET), ce(v.SONEIUM), ce(v.SONEIUM_MINATO), ce(v.TOY_TESTNET), ce(v.IMMUTABLE_ZKEVM), ce(v.IMMUTABLE_ZKEVM_TESTNET), ce(v.ROOT_NETWORK), ce(v.ROOT_NETWORK_PORCINI), ce(v.LAOS), ce(v.LAOS_SIGMA_TESTNET), ce(v.MOONBEAM), ce(v.MOONBASE_ALPHA), ce(v.ETHERLINK), ce(v.ETHERLINK_TESTNET), ce(v.SOMNIA), ce(v.SOMNIA_TESTNET), ce(v.MONAD_TESTNET), ce(v.INCENTIV_TESTNET), ce(v.SEI), ce(v.SEI_TESTNET), ...o4]), l4 = "0xd7571bd1e3af468c3a49966c9a92a2e907cdfa52", u4 = "0x9a013e7d186611af36a918ef23d81886e8c256f8", d4 = "0xc1A9B197eBb31Fc2B613C59dAC3f3E5698A429D0", f4 = "https://dev-indexer.sequence.app", p4 = "https://dev-api.sequence.app", h4 = "dev", m4 = {
  8453: "0x2bf4c63199eD7D8A737E8DB2cC19E0C0103F6bE3",
  84532: "0xdcd9160492C6D43ABbd28D4d06F68ad77f1A0F2b",
  421614: "0xf18A16E1C778baCA5d6f7F48cC4c9bb913e5e579",
  42161: "0x674827B6BE8780DBdb96DC02c735275e3a982c90",
  137: "0x4dBb20eA3A969F1A44d7653D4Dc8632B853E36DE"
}, y4 = "AQAAAAAAAJbd_5JOcE50AqglZCtvu51YlGI", b4 = "AQAAAAAAAJbd_5JOcE50AqglZCtvu51YlGI", g4 = !1, w4 = "https://databeat.sequence.app", E4 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHAiOiJzZXEtdHJhaWxzIiwiZXhwIjoyMDI4MTIwOTg4fQ.KZIjEziul_nZ4kjEXudvfqeWmVekc5ftXKx_EqDrmZU", x4 = "10c5ac56159da00924d110c07c3f6e3a", A4 = "cmc25oq0a01dvl40mn0ex5e1o", k4 = "client-WY6MrvK6dbp1FSBPU1DKa6ymAHrJBPYxyFX39dFCCd56L", Dne = "https://trails.build/", v4 = "0.03", ht = {
  sequenceProjectAccessKey: y4,
  rpcSequenceProjectAccessKey: b4,
  sequenceUseV3Relayers: g4,
  sequenceIndexerUrl: f4,
  sequenceApiUrl: p4,
  sequenceEnv: h4,
  walletConnectProjectId: x4,
  privyAppId: A4,
  privyClientId: k4,
  slippageTolerance: v4
};
function $o() {
  return ht.sequenceProjectAccessKey;
}
function Fne(t) {
  ht.sequenceProjectAccessKey = t;
}
function lv() {
  return ht.rpcSequenceProjectAccessKey;
}
function Mne(t) {
  ht.sequenceUseV3Relayers = t;
}
function ql() {
  return ht.sequenceUseV3Relayers;
}
function Lne(t) {
  ht.sequenceIndexerUrl = t;
}
function C4() {
  return ht.sequenceIndexerUrl;
}
function Hne(t) {
  ht.sequenceApiUrl = t;
}
function uv() {
  return ht.sequenceApiUrl;
}
function _ne(t) {
  ht.sequenceEnv = t;
}
function Kl() {
  return ht.sequenceEnv;
}
function $ne(t) {
  ht.walletConnectProjectId = t;
}
function Gne() {
  return ht.walletConnectProjectId;
}
function zne(t) {
  ht.privyAppId = t;
}
function jne() {
  return ht.privyAppId;
}
function Vne(t) {
  ht.privyClientId = t;
}
function qne() {
  return ht.privyClientId;
}
function Kne(t) {
  ht.slippageTolerance = t;
}
function T4() {
  return ht.slippageTolerance;
}
function S4({
  apiUrl: t = uv(),
  projectAccessKey: e = $o(),
  jwt: n
}) {
  return new e7(t, e, n);
}
const ef = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = i6();
  return Eo(() => S4({
    apiUrl: (t == null ? void 0 : t.apiUrl) ?? r.apiUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.apiUrl, t]);
};
function h(t) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...t
  };
}
const I4 = /* @__PURE__ */ h({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: !1
}), dv = "2.33.3";
let uu = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) => e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
  version: `viem@${dv}`
}, H = class ib extends Error {
  constructor(e, n = {}) {
    var o;
    const r = (() => {
      var c;
      return n.cause instanceof ib ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof ib && n.cause.docsPath || n.docsPath, a = (o = uu.getDocsUrl) == null ? void 0 : o.call(uu, { ...n, docsPath: s }), i = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...r ? [`Details: ${r}`] : [],
      ...uu.version ? [`Version: ${uu.version}`] : []
    ].join(`
`);
    super(i, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = e, this.version = dv;
  }
  walk(e) {
    return fv(this, e);
  }
};
function fv(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? fv(t.cause, e) : e ? null : t;
}
let pv = class extends H {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
};
class O4 extends H {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
let B4 = class extends H {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
};
function Wl(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function it(t) {
  return Wl(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
function Gs(t, { dir: e = "left" } = {}) {
  let n = typeof t == "string" ? t.replace("0x", "") : t, r = 0;
  for (let s = 0; s < n.length - 1 && n[e === "left" ? s : n.length - s - 1].toString() === "0"; s++)
    r++;
  return n = e === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof t == "string" ? (n.length === 1 && e === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
let hv = class extends H {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}, mv = class extends H {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
class s2 extends H {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function zt(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string" ? Ka(t, { dir: e, size: n }) : P4(t, { dir: e, size: n });
}
function Ka(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  const r = t.replace("0x", "");
  if (r.length > n * 2)
    throw new mv({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function P4(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  if (t.length > n)
    throw new mv({
      size: t.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let s = 0; s < n; s++) {
    const a = e === "right";
    r[a ? s : n - s - 1] = t[a ? s : t.length - s - 1];
  }
  return r;
}
const U4 = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Ue(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? J(t, e) : typeof t == "string" ? yd(t, e) : typeof t == "boolean" ? yv(t, e) : Jt(t, e);
}
function yv(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (fs(n, { size: e.size }), zt(n, { size: e.size })) : n;
}
function Jt(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += U4[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (fs(r, { size: e.size }), zt(r, { dir: "right", size: e.size })) : r;
}
function J(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const c = typeof t == "bigint" ? "n" : "";
    throw new pv({
      max: a ? `${a}${c}` : void 0,
      min: `${i}${c}`,
      signed: n,
      size: r,
      value: `${t}${c}`
    });
  }
  const o = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? zt(o, { size: r }) : o;
}
const N4 = /* @__PURE__ */ new TextEncoder();
function yd(t, e = {}) {
  const n = N4.encode(t);
  return Jt(n, e);
}
const R4 = /* @__PURE__ */ new TextEncoder();
function gc(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? F4(t, e) : typeof t == "boolean" ? D4(t, e) : Wl(t) ? Cn(t, e) : bv(t, e);
}
function D4(t, e = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(t), typeof e.size == "number" ? (fs(n, { size: e.size }), zt(n, { size: e.size })) : n;
}
const ps = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function a2(t) {
  if (t >= ps.zero && t <= ps.nine)
    return t - ps.zero;
  if (t >= ps.A && t <= ps.F)
    return t - (ps.A - 10);
  if (t >= ps.a && t <= ps.f)
    return t - (ps.a - 10);
}
function Cn(t, e = {}) {
  let n = t;
  e.size && (fs(n, { size: e.size }), n = zt(n, { dir: "right", size: e.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const s = r.length / 2, a = new Uint8Array(s);
  for (let i = 0, o = 0; i < s; i++) {
    const c = a2(r.charCodeAt(o++)), u = a2(r.charCodeAt(o++));
    if (c === void 0 || u === void 0)
      throw new H(`Invalid byte sequence ("${r[o - 2]}${r[o - 1]}" in "${r}").`);
    a[i] = c * 16 + u;
  }
  return a;
}
function F4(t, e) {
  const n = J(t, e);
  return Cn(n);
}
function bv(t, e = {}) {
  const n = R4.encode(t);
  return typeof e.size == "number" ? (fs(n, { size: e.size }), zt(n, { dir: "right", size: e.size })) : n;
}
function fs(t, { size: e }) {
  if (it(t) > e)
    throw new B4({
      givenSize: it(t),
      maxSize: e
    });
}
function Fe(t, e = {}) {
  const { signed: n } = e;
  e.size && fs(t, { size: e.size });
  const r = BigInt(t);
  if (!n)
    return r;
  const s = (t.length - 2) / 2, a = (1n << BigInt(s) * 8n - 1n) - 1n;
  return r <= a ? r : r - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function ni(t, e = {}) {
  return Number(Fe(t, e));
}
function em(t, e) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (s) => {
      const a = e(s);
      if (n)
        for (const i of n)
          delete a[i];
      return {
        ...a,
        ...r(s)
      };
    },
    type: t
  });
}
const gv = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function tm(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? ni(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? ni(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? gv[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = M4(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
const K1 = /* @__PURE__ */ em("transaction", tm);
function M4(t) {
  return t.map((e) => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function wv(t) {
  const e = (t.transactions ?? []).map((n) => typeof n == "string" ? n : tm(n));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
const W1 = /* @__PURE__ */ em("block", wv);
function Q1(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...n ? { args: e, eventName: n } : {}
  };
}
const L4 = {
  "0x0": "reverted",
  "0x1": "success"
};
function Ev(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map((n) => Q1(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? ni(t.transactionIndex) : null,
    status: t.status ? L4[t.status] : null,
    type: t.type ? gv[t.type] || t.type : null
  };
  return t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)), t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)), e;
}
const xv = /* @__PURE__ */ em("transactionReceipt", Ev), H4 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function J1(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = _4(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((n) => Jt(n)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = J(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = J(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = J(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = J(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = J(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = J(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = H4[t.type]), typeof t.value < "u" && (e.value = J(t.value)), e;
}
const Av = /* @__PURE__ */ em("transactionRequest", J1);
function _4(t) {
  return t.map((e) => ({
    address: e.address,
    r: e.r ? J(BigInt(e.r)) : e.r,
    s: e.s ? J(BigInt(e.s)) : e.s,
    chainId: J(e.chainId),
    nonce: J(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: J(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: J(e.v) } : {}
  }));
}
const $4 = 2n ** 16n - 1n, tf = 2n ** 256n - 1n, X1 = 50000n, i2 = $4 * 32n, kv = {
  block: /* @__PURE__ */ W1({
    format(t) {
      var n;
      const e = (n = t.transactions) == null ? void 0 : n.map((r) => {
        var a;
        if (typeof r == "string")
          return r;
        const s = (a = kv.transaction) == null ? void 0 : a.format(r);
        return s.typeHex === "0x71" ? s.type = "eip712" : s.typeHex === "0xff" && (s.type = "priority"), s;
      });
      return {
        l1BatchNumber: t.l1BatchNumber ? Fe(t.l1BatchNumber) : null,
        l1BatchTimestamp: t.l1BatchTimestamp ? Fe(t.l1BatchTimestamp) : null,
        transactions: e
      };
    }
  }),
  transaction: /* @__PURE__ */ K1({
    format(t) {
      const e = {};
      return t.type === "0x71" ? e.type = "eip712" : t.type === "0xff" && (e.type = "priority"), {
        ...e,
        l1BatchNumber: t.l1BatchNumber ? Fe(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Fe(t.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: /* @__PURE__ */ xv({
    format(t) {
      return {
        l1BatchNumber: t.l1BatchNumber ? Fe(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Fe(t.l1BatchTxIndex) : null,
        logs: t.logs.map((e) => ({
          ...Q1(e),
          l1BatchNumber: e.l1BatchNumber ? Fe(e.l1BatchNumber) : null,
          transactionLogIndex: ni(e.transactionLogIndex),
          logType: e.logType
        })),
        l2ToL1Logs: t.l2ToL1Logs.map((e) => ({
          blockNumber: Fe(e.blockHash),
          blockHash: e.blockHash,
          l1BatchNumber: e.l1BatchNumber ? Fe(e.l1BatchNumber) : null,
          transactionIndex: Fe(e.transactionIndex),
          shardId: Fe(e.shardId),
          isService: e.isService,
          sender: e.sender,
          key: e.key,
          value: e.value,
          transactionHash: e.transactionHash,
          logIndex: Fe(e.logIndex)
        }))
      };
    }
  }),
  transactionRequest: /* @__PURE__ */ Av({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(t) {
      return t.gasPerPubdata || t.paymaster && t.paymasterInput || t.factoryDeps || t.customSignature ? {
        eip712Meta: {
          ...t.gasPerPubdata ? { gasPerPubdata: Ue(t.gasPerPubdata) } : { gasPerPubdata: Ue(X1) },
          ...t.paymaster && t.paymasterInput ? {
            paymasterParams: {
              paymaster: t.paymaster,
              paymasterInput: Array.from(Cn(t.paymasterInput))
            }
          } : {},
          ...t.factoryDeps ? {
            factoryDeps: t.factoryDeps.map((e) => Array.from(Cn(e)))
          } : {},
          ...t.customSignature ? {
            customSignature: Array.from(Cn(t.customSignature))
          } : {}
        },
        type: "0x71"
      } : {};
    }
  })
};
function Tn(t) {
  return typeof t[0] == "string" ? cr(t) : G4(t);
}
function G4(t) {
  let e = 0;
  for (const s of t)
    e += s.length;
  const n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function cr(t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
class o2 extends H {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class z4 extends H {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class j4 extends H {
  constructor({ count: e, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const V4 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new j4({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new z4({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new o2({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new o2({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const n = e ?? this.position;
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(t);
    return this.position += e ?? t, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Z1(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(V4);
  return n.bytes = t, n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = e, n;
}
function os(t, e = "hex") {
  const n = vv(t), r = Z1(new Uint8Array(n.length));
  return n.encode(r), e === "hex" ? Jt(r.bytes) : r.bytes;
}
function vv(t) {
  return Array.isArray(t) ? q4(t.map((e) => vv(e))) : K4(t);
}
function q4(t) {
  const e = t.reduce((s, a) => s + a.length, 0), n = Cv(e);
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(s) {
      e <= 55 ? s.pushByte(192 + e) : (s.pushByte(247 + n), n === 1 ? s.pushUint8(e) : n === 2 ? s.pushUint16(e) : n === 3 ? s.pushUint24(e) : s.pushUint32(e));
      for (const { encode: a } of t)
        a(s);
    }
  };
}
function K4(t) {
  const e = typeof t == "string" ? Cn(t) : t, n = Cv(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + n + e.length,
    encode(s) {
      e.length === 1 && e[0] < 128 ? s.pushBytes(e) : e.length <= 55 ? (s.pushByte(128 + e.length), s.pushBytes(e)) : (s.pushByte(183 + n), n === 1 ? s.pushUint8(e.length) : n === 2 ? s.pushUint16(e.length) : n === 3 ? s.pushUint24(e.length) : s.pushUint32(e.length), s.pushBytes(e));
    }
  };
}
function Cv(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new H("Length is too large.");
}
const W4 = {
  gwei: 9,
  wei: 18
}, Q4 = {
  ether: -9,
  wei: 9
};
function Tv(t, e) {
  let n = t.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(e, "0");
  let [s, a] = [
    n.slice(0, n.length - e),
    n.slice(n.length - e)
  ];
  return a = a.replace(/(0+)$/, ""), `${r ? "-" : ""}${s || "0"}${a ? `.${a}` : ""}`;
}
function J4(t, e = "wei") {
  return Tv(t, W4[e]);
}
function Hs(t, e = "wei") {
  return Tv(t, Q4[e]);
}
function nm(t) {
  const e = Object.entries(t).map(([r, s]) => s === void 0 || s === !1 ? null : [r, s]).filter(Boolean), n = e.reduce((r, [s]) => Math.max(r, s.length), 0);
  return e.map(([r, s]) => `  ${`${r}:`.padEnd(n + 1)}  ${s}`).join(`
`);
}
class X4 extends H {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class Z4 extends H {
  constructor({ v: e }) {
    super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class Y4 extends H {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        nm(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class eU extends H {
  constructor({ storageKey: e }) {
    super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
function tU(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (const n of t) {
    const { chainId: r, nonce: s, ...a } = n, i = n.address;
    e.push([
      r ? Ue(r) : "0x",
      i,
      s ? Ue(s) : "0x",
      ...Jl({}, a)
    ]);
  }
  return e;
}
function Sv(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((a) => Cn(a)) : t.blobs, s = [];
  for (const a of r)
    s.push(Uint8Array.from(e.blobToKzgCommitment(a)));
  return n === "bytes" ? s : s.map((a) => Jt(a));
}
function Iv(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((i) => Cn(i)) : t.blobs, s = typeof t.commitments[0] == "string" ? t.commitments.map((i) => Cn(i)) : t.commitments, a = [];
  for (let i = 0; i < r.length; i++) {
    const o = r[i], c = s[i];
    a.push(Uint8Array.from(e.computeBlobKzgProof(o, c)));
  }
  return n === "bytes" ? a : a.map((i) => Jt(i));
}
const Ko = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Y1(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bd(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Br(t, ...e) {
  if (!Y1(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function nU(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  bd(t.outputLen), bd(t.blockLen);
}
function Rl(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ov(t, e) {
  Br(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
function rU(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ri(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function S0(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function Lr(t, e) {
  return t << 32 - e | t >>> e;
}
const sU = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function aU(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function iU(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = aU(t[e]);
  return t;
}
const c2 = sU ? (t) => t : iU, Bv = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", oU = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Dl(t) {
  if (Br(t), Bv)
    return t.toHex();
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += oU[t[n]];
  return e;
}
const hs = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function l2(t) {
  if (t >= hs._0 && t <= hs._9)
    return t - hs._0;
  if (t >= hs.A && t <= hs.F)
    return t - (hs.A - 10);
  if (t >= hs.a && t <= hs.f)
    return t - (hs.a - 10);
}
function ew(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (Bv)
    return Uint8Array.fromHex(t);
  const e = t.length, n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, a = 0; s < n; s++, a += 2) {
    const i = l2(t.charCodeAt(a)), o = l2(t.charCodeAt(a + 1));
    if (i === void 0 || o === void 0) {
      const c = t[a] + t[a + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + a);
    }
    r[s] = i * 16 + o;
  }
  return r;
}
function cU(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function rm(t) {
  return typeof t == "string" && (t = cU(t)), Br(t), t;
}
function Ci(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    Br(s), e += s.length;
  }
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
class tw {
}
function sm(t) {
  const e = (r) => t().update(rm(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function lU(t = 32) {
  if (Ko && typeof Ko.getRandomValues == "function")
    return Ko.getRandomValues(new Uint8Array(t));
  if (Ko && typeof Ko.randomBytes == "function")
    return Uint8Array.from(Ko.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
function uU(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
function dU(t, e, n) {
  return t & e ^ ~t & n;
}
function fU(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
class Pv extends tw {
  constructor(e, n, r, s) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = S0(this.buffer);
  }
  update(e) {
    Rl(this), e = rm(e), Br(e);
    const { view: n, buffer: r, blockLen: s } = this, a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = S0(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Rl(this), Ov(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, ri(this.buffer.subarray(i)), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    uU(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = S0(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.destroyed = i, e.finished = a, e.length = s, e.pos = o, s % n && e.buffer.set(r), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const la = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Ft = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]), Mt = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]), Uf = /* @__PURE__ */ BigInt(2 ** 32 - 1), u2 = /* @__PURE__ */ BigInt(32);
function pU(t, e = !1) {
  return e ? { h: Number(t & Uf), l: Number(t >> u2 & Uf) } : { h: Number(t >> u2 & Uf) | 0, l: Number(t & Uf) | 0 };
}
function Uv(t, e = !1) {
  const n = t.length;
  let r = new Uint32Array(n), s = new Uint32Array(n);
  for (let a = 0; a < n; a++) {
    const { h: i, l: o } = pU(t[a], e);
    [r[a], s[a]] = [i, o];
  }
  return [r, s];
}
const d2 = (t, e, n) => t >>> n, f2 = (t, e, n) => t << 32 - n | e >>> n, Wo = (t, e, n) => t >>> n | e << 32 - n, Qo = (t, e, n) => t << 32 - n | e >>> n, Nf = (t, e, n) => t << 64 - n | e >>> n - 32, Rf = (t, e, n) => t >>> n - 32 | e << 64 - n, hU = (t, e, n) => t << n | e >>> 32 - n, mU = (t, e, n) => e << n | t >>> 32 - n, yU = (t, e, n) => e << n - 32 | t >>> 64 - n, bU = (t, e, n) => t << n - 32 | e >>> 64 - n;
function ms(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const gU = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), wU = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, EU = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), xU = (t, e, n, r, s) => e + n + r + s + (t / 2 ** 32 | 0) | 0, AU = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), kU = (t, e, n, r, s, a) => e + n + r + s + a + (t / 2 ** 32 | 0) | 0, vU = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ua = /* @__PURE__ */ new Uint32Array(64);
class CU extends Pv {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = la[0] | 0, this.B = la[1] | 0, this.C = la[2] | 0, this.D = la[3] | 0, this.E = la[4] | 0, this.F = la[5] | 0, this.G = la[6] | 0, this.H = la[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      ua[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const p = ua[d - 15], f = ua[d - 2], b = Lr(p, 7) ^ Lr(p, 18) ^ p >>> 3, y = Lr(f, 17) ^ Lr(f, 19) ^ f >>> 10;
      ua[d] = y + ua[d - 7] + b + ua[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const p = Lr(o, 6) ^ Lr(o, 11) ^ Lr(o, 25), f = l + p + dU(o, c, u) + vU[d] + ua[d] | 0, y = (Lr(r, 2) ^ Lr(r, 13) ^ Lr(r, 22)) + fU(r, s, a) | 0;
      l = u, u = c, c = o, o = i + f | 0, i = a, a = s, s = r, r = f + y | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    ri(ua);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ri(this.buffer);
  }
}
const Nv = Uv([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), TU = Nv[0], SU = Nv[1], da = /* @__PURE__ */ new Uint32Array(80), fa = /* @__PURE__ */ new Uint32Array(80);
class Rv extends Pv {
  constructor(e = 64) {
    super(128, e, 16, !1), this.Ah = Mt[0] | 0, this.Al = Mt[1] | 0, this.Bh = Mt[2] | 0, this.Bl = Mt[3] | 0, this.Ch = Mt[4] | 0, this.Cl = Mt[5] | 0, this.Dh = Mt[6] | 0, this.Dl = Mt[7] | 0, this.Eh = Mt[8] | 0, this.El = Mt[9] | 0, this.Fh = Mt[10] | 0, this.Fl = Mt[11] | 0, this.Gh = Mt[12] | 0, this.Gl = Mt[13] | 0, this.Hh = Mt[14] | 0, this.Hl = Mt[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: a, Cl: i, Dh: o, Dl: c, Eh: u, El: l, Fh: d, Fl: p, Gh: f, Gl: b, Hh: y, Hl: g } = this;
    return [e, n, r, s, a, i, o, c, u, l, d, p, f, b, y, g];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c, u, l, d, p, f, b, y, g) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = p | 0, this.Gh = f | 0, this.Gl = b | 0, this.Hh = y | 0, this.Hl = g | 0;
  }
  process(e, n) {
    for (let E = 0; E < 16; E++, n += 4)
      da[E] = e.getUint32(n), fa[E] = e.getUint32(n += 4);
    for (let E = 16; E < 80; E++) {
      const T = da[E - 15] | 0, A = fa[E - 15] | 0, N = Wo(T, A, 1) ^ Wo(T, A, 8) ^ d2(T, A, 7), D = Qo(T, A, 1) ^ Qo(T, A, 8) ^ f2(T, A, 7), P = da[E - 2] | 0, C = fa[E - 2] | 0, S = Wo(P, C, 19) ^ Nf(P, C, 61) ^ d2(P, C, 6), R = Qo(P, C, 19) ^ Rf(P, C, 61) ^ f2(P, C, 6), M = EU(D, R, fa[E - 7], fa[E - 16]), _ = xU(M, N, S, da[E - 7], da[E - 16]);
      da[E] = _ | 0, fa[E] = M | 0;
    }
    let { Ah: r, Al: s, Bh: a, Bl: i, Ch: o, Cl: c, Dh: u, Dl: l, Eh: d, El: p, Fh: f, Fl: b, Gh: y, Gl: g, Hh: w, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const T = Wo(d, p, 14) ^ Wo(d, p, 18) ^ Nf(d, p, 41), A = Qo(d, p, 14) ^ Qo(d, p, 18) ^ Rf(d, p, 41), N = d & f ^ ~d & y, D = p & b ^ ~p & g, P = AU(k, A, D, SU[E], fa[E]), C = kU(P, w, T, N, TU[E], da[E]), S = P | 0, R = Wo(r, s, 28) ^ Nf(r, s, 34) ^ Nf(r, s, 39), M = Qo(r, s, 28) ^ Rf(r, s, 34) ^ Rf(r, s, 39), _ = r & a ^ r & o ^ a & o, j = s & i ^ s & c ^ i & c;
      w = y | 0, k = g | 0, y = f | 0, g = b | 0, f = d | 0, b = p | 0, { h: d, l: p } = ms(u | 0, l | 0, C | 0, S | 0), u = o | 0, l = c | 0, o = a | 0, c = i | 0, a = r | 0, i = s | 0;
      const I = gU(S, M, j);
      r = wU(I, C, R, _), s = I | 0;
    }
    ({ h: r, l: s } = ms(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: a, l: i } = ms(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: o, l: c } = ms(this.Ch | 0, this.Cl | 0, o | 0, c | 0), { h: u, l } = ms(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: p } = ms(this.Eh | 0, this.El | 0, d | 0, p | 0), { h: f, l: b } = ms(this.Fh | 0, this.Fl | 0, f | 0, b | 0), { h: y, l: g } = ms(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: w, l: k } = ms(this.Hh | 0, this.Hl | 0, w | 0, k | 0), this.set(r, s, a, i, o, c, u, l, d, p, f, b, y, g, w, k);
  }
  roundClean() {
    ri(da, fa);
  }
  destroy() {
    ri(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class IU extends Rv {
  constructor() {
    super(48), this.Ah = Ft[0] | 0, this.Al = Ft[1] | 0, this.Bh = Ft[2] | 0, this.Bl = Ft[3] | 0, this.Ch = Ft[4] | 0, this.Cl = Ft[5] | 0, this.Dh = Ft[6] | 0, this.Dl = Ft[7] | 0, this.Eh = Ft[8] | 0, this.El = Ft[9] | 0, this.Fh = Ft[10] | 0, this.Fl = Ft[11] | 0, this.Gh = Ft[12] | 0, this.Gl = Ft[13] | 0, this.Hh = Ft[14] | 0, this.Hl = Ft[15] | 0;
  }
}
const Dv = /* @__PURE__ */ sm(() => new CU()), Zne = /* @__PURE__ */ sm(() => new Rv()), Yne = /* @__PURE__ */ sm(() => new IU()), nw = Dv;
function Fv(t, e) {
  const n = e || "hex", r = nw(Wl(t, { strict: !1 }) ? gc(t) : t);
  return n === "bytes" ? r : Ue(r);
}
function OU(t) {
  const { commitment: e, version: n = 1 } = t, r = t.to ?? (typeof e == "string" ? "hex" : "bytes"), s = Fv(e, "bytes");
  return s.set([n], 0), r === "bytes" ? s : Jt(s);
}
function BU(t) {
  const { commitments: e, version: n } = t, r = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), s = [];
  for (const a of e)
    s.push(OU({
      commitment: a,
      to: r,
      version: n
    }));
  return s;
}
const p2 = 6, Mv = 32, rw = 4096, Lv = Mv * rw, h2 = Lv * p2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * rw * p2, Hv = 1;
class PU extends H {
  constructor({ maxSize: e, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class _v extends H {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class UU extends H {
  constructor({ hash: e, size: n }) {
    super(`Versioned hash "${e}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class NU extends H {
  constructor({ hash: e, version: n }) {
    super(`Versioned hash "${e}" version is invalid.`, {
      metaMessages: [
        `Expected: ${Hv}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function RU(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), n = typeof t.data == "string" ? Cn(t.data) : t.data, r = it(n);
  if (!r)
    throw new _v();
  if (r > h2)
    throw new PU({
      maxSize: h2,
      size: r
    });
  const s = [];
  let a = !0, i = 0;
  for (; a; ) {
    const o = Z1(new Uint8Array(Lv));
    let c = 0;
    for (; c < rw; ) {
      const u = n.slice(i, i + (Mv - 1));
      if (o.pushByte(0), o.pushBytes(u), u.length < 31) {
        o.pushByte(128), a = !1;
        break;
      }
      c++, i += 31;
    }
    s.push(o);
  }
  return e === "bytes" ? s.map((o) => o.bytes) : s.map((o) => Jt(o.bytes));
}
function DU(t) {
  const { data: e, kzg: n, to: r } = t, s = t.blobs ?? RU({ data: e, to: r }), a = t.commitments ?? Sv({ blobs: s, kzg: n, to: r }), i = t.proofs ?? Iv({ blobs: s, commitments: a, kzg: n, to: r }), o = [];
  for (let c = 0; c < s.length; c++)
    o.push({
      blob: s[c],
      commitment: a[c],
      proof: i[c]
    });
  return o;
}
let ot = class extends H {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
};
class ob extends H {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...e && r.blockCreated && r.blockCreated > e ? [
          `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`
        ] : [
          `- The chain does not have the contract "${r.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class $v extends H {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class Ql extends H {
  constructor({ chainId: e }) {
    super(typeof e == "number" ? `Chain ID "${e}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
let oc = class extends H {
  constructor({ cause: e, message: n } = {}) {
    var s;
    const r = (s = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : s.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
};
Object.defineProperty(oc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(oc, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class si extends H {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Hs(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(si, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class cb extends H {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Hs(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(cb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class lb extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(lb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class ub extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(ub, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class db extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(db, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class fb extends H {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(fb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class pb extends H {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(pb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class hb extends H {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(hb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class mb extends H {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(mb, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Fl extends H {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${Hs(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${Hs(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Fl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Gv extends H {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
let sw = class extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
};
const FU = BigInt(0), du = BigInt(1), MU = BigInt(2), LU = BigInt(7), HU = BigInt(256), _U = BigInt(113), zv = [], jv = [], Vv = [];
for (let t = 0, e = du, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], zv.push(2 * (5 * r + n)), jv.push((t + 1) * (t + 2) / 2 % 64);
  let s = FU;
  for (let a = 0; a < 7; a++)
    e = (e << du ^ (e >> LU) * _U) % HU, e & MU && (s ^= du << (du << /* @__PURE__ */ BigInt(a)) - du);
  Vv.push(s);
}
const qv = Uv(Vv, !0), $U = qv[0], GU = qv[1], m2 = (t, e, n) => n > 32 ? yU(t, e, n) : hU(t, e, n), y2 = (t, e, n) => n > 32 ? bU(t, e, n) : mU(t, e, n);
function zU(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = m2(u, l, 1) ^ n[o], p = y2(u, l, 1) ^ n[o + 1];
      for (let f = 0; f < 50; f += 10)
        t[i + f] ^= d, t[i + f + 1] ^= p;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = jv[i], c = m2(s, a, o), u = y2(s, a, o), l = zv[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= $U[r], t[1] ^= GU[r];
  }
  ri(n);
}
class aw extends tw {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, bd(r), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = rU(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    c2(this.state32), zU(this.state32, this.rounds), c2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Rl(this), e = rm(e), Br(e);
    const { blockLen: n, state: r } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Rl(this, !1), Br(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return bd(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Ov(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, ri(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new aw(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
}
const jU = (t, e, n) => sm(() => new aw(e, t, n)), Kv = jU(1, 136, 256 / 8);
function nt(t, e) {
  const n = e || "hex", r = Kv(Wl(t, { strict: !1 }) ? gc(t) : t);
  return n === "bytes" ? r : Ue(r);
}
const I0 = /* @__PURE__ */ new sw(8192);
function am(t, e) {
  if (I0.has(`${t}.${e}`))
    return I0.get(`${t}.${e}`);
  const n = t.substring(2).toLowerCase(), r = nt(bv(n), "bytes"), s = n.split("");
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && s[i] && (s[i] = s[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && s[i + 1] && (s[i + 1] = s[i + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return I0.set(`${t}.${e}`, a), a;
}
function rre(t, e) {
  if (!ze(t, { strict: !1 }))
    throw new ot({ address: t });
  return am(t, e);
}
const VU = /^0x[a-fA-F0-9]{40}$/, O0 = /* @__PURE__ */ new sw(8192);
function ze(t, e) {
  const { strict: n = !0 } = e ?? {}, r = `${t}.${n}`;
  if (O0.has(r))
    return O0.get(r);
  const s = VU.test(t) ? t.toLowerCase() === t ? !0 : n ? am(t) === t : !0 : !1;
  return O0.set(r, s), s;
}
function gd(t, e, n, { strict: r } = {}) {
  return Wl(t, { strict: !1 }) ? qU(t, e, n, {
    strict: r
  }) : Jv(t, e, n, {
    strict: r
  });
}
function Wv(t, e) {
  if (typeof e == "number" && e > 0 && e > it(t) - 1)
    throw new hv({
      offset: e,
      position: "start",
      size: it(t)
    });
}
function Qv(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && it(t) !== n - e)
    throw new hv({
      offset: n,
      position: "end",
      size: it(t)
    });
}
function Jv(t, e, n, { strict: r } = {}) {
  Wv(t, e);
  const s = t.slice(e, n);
  return r && Qv(s, e, n), s;
}
function qU(t, e, n, { strict: r } = {}) {
  Wv(t, e);
  const s = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return r && Qv(s, e, n), s;
}
function KU(t) {
  const { authorizationList: e } = t;
  if (e)
    for (const n of e) {
      const { chainId: r } = n, s = n.address;
      if (!ze(s))
        throw new ot({ address: s });
      if (r < 0)
        throw new Ql({ chainId: r });
    }
  iw(t);
}
function WU(t) {
  const { blobVersionedHashes: e } = t;
  if (e) {
    if (e.length === 0)
      throw new _v();
    for (const n of e) {
      const r = it(n), s = ni(gd(n, 0, 1));
      if (r !== 32)
        throw new UU({ hash: n, size: r });
      if (s !== Hv)
        throw new NU({
          hash: n,
          version: s
        });
    }
  }
  iw(t);
}
function iw(t) {
  const { chainId: e, maxPriorityFeePerGas: n, maxFeePerGas: r, to: s } = t;
  if (e <= 0)
    throw new Ql({ chainId: e });
  if (s && !ze(s))
    throw new ot({ address: s });
  if (r && r > tf)
    throw new si({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new Fl({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function QU(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (e <= 0)
    throw new Ql({ chainId: e });
  if (a && !ze(a))
    throw new ot({ address: a });
  if (n || s)
    throw new H("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > tf)
    throw new si({ maxFeePerGas: r });
}
function JU(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (a && !ze(a))
    throw new ot({ address: a });
  if (typeof e < "u" && e <= 0)
    throw new Ql({ chainId: e });
  if (n || s)
    throw new H("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > tf)
    throw new si({ maxFeePerGas: r });
}
function XU(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new Y4({ transaction: t });
}
function nf(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const { address: r, storageKeys: s } = t[n];
    for (let a = 0; a < s.length; a++)
      if (s[a].length - 2 !== 64)
        throw new eU({ storageKey: s[a] });
    if (!ze(r, { strict: !1 }))
      throw new ot({ address: r });
    e.push([r, s]);
  }
  return e;
}
function ow(t, e) {
  const n = XU(t);
  return n === "eip1559" ? eN(t, e) : n === "eip2930" ? tN(t, e) : n === "eip4844" ? YU(t, e) : n === "eip7702" ? ZU(t, e) : nN(t, e);
}
function ZU(t, e) {
  const { authorizationList: n, chainId: r, gas: s, nonce: a, to: i, value: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  KU(t);
  const p = nf(l), f = tU(n);
  return cr([
    "0x04",
    os([
      J(r),
      a ? J(a) : "0x",
      u ? J(u) : "0x",
      c ? J(c) : "0x",
      s ? J(s) : "0x",
      i ?? "0x",
      o ? J(o) : "0x",
      d ?? "0x",
      p,
      f,
      ...Jl(t, e)
    ])
  ]);
}
function YU(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerBlobGas: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  WU(t);
  let p = t.blobVersionedHashes, f = t.sidecars;
  if (t.blobs && (typeof p > "u" || typeof f > "u")) {
    const E = typeof t.blobs[0] == "string" ? t.blobs : t.blobs.map((N) => Jt(N)), T = t.kzg, A = Sv({
      blobs: E,
      kzg: T
    });
    if (typeof p > "u" && (p = BU({
      commitments: A
    })), typeof f > "u") {
      const N = Iv({ blobs: E, commitments: A, kzg: T });
      f = DU({ blobs: E, commitments: A, proofs: N });
    }
  }
  const b = nf(l), y = [
    J(n),
    s ? J(s) : "0x",
    u ? J(u) : "0x",
    c ? J(c) : "0x",
    r ? J(r) : "0x",
    a ?? "0x",
    i ? J(i) : "0x",
    d ?? "0x",
    b,
    o ? J(o) : "0x",
    p ?? [],
    ...Jl(t, e)
  ], g = [], w = [], k = [];
  if (f)
    for (let E = 0; E < f.length; E++) {
      const { blob: T, commitment: A, proof: N } = f[E];
      g.push(T), w.push(A), k.push(N);
    }
  return cr([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    os(f ? [y, g, w, k] : y)
  ]);
}
function eN(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, data: l } = t;
  iw(t);
  const d = nf(u), p = [
    J(n),
    s ? J(s) : "0x",
    c ? J(c) : "0x",
    o ? J(o) : "0x",
    r ? J(r) : "0x",
    a ?? "0x",
    i ? J(i) : "0x",
    l ?? "0x",
    d,
    ...Jl(t, e)
  ];
  return cr([
    "0x02",
    os(p)
  ]);
}
function tN(t, e) {
  const { chainId: n, gas: r, data: s, nonce: a, to: i, value: o, accessList: c, gasPrice: u } = t;
  QU(t);
  const l = nf(c), d = [
    J(n),
    a ? J(a) : "0x",
    u ? J(u) : "0x",
    r ? J(r) : "0x",
    i ?? "0x",
    o ? J(o) : "0x",
    s ?? "0x",
    l,
    ...Jl(t, e)
  ];
  return cr([
    "0x01",
    os(d)
  ]);
}
function nN(t, e) {
  const { chainId: n = 0, gas: r, data: s, nonce: a, to: i, value: o, gasPrice: c } = t;
  JU(t);
  let u = [
    a ? J(a) : "0x",
    c ? J(c) : "0x",
    r ? J(r) : "0x",
    i ?? "0x",
    o ? J(o) : "0x",
    s ?? "0x"
  ];
  if (e) {
    const l = (() => {
      if (e.v >= 35n)
        return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + e.v - 27n);
      const f = 27n + (e.v === 27n ? 0n : 1n);
      if (e.v !== f)
        throw new Z4({ v: e.v });
      return f;
    })(), d = Gs(e.r), p = Gs(e.s);
    u = [
      ...u,
      J(l),
      d === "0x00" ? "0x" : d,
      p === "0x00" ? "0x" : p
    ];
  } else n > 0 && (u = [
    ...u,
    J(n),
    "0x",
    "0x"
  ]);
  return os(u);
}
function Jl(t, e) {
  const n = e ?? t, { v: r, yParity: s } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof s > "u")
    return [];
  const a = Gs(n.r), i = Gs(n.s);
  return [typeof s == "number" ? s ? J(1) : "0x" : r === 0n ? "0x" : r === 1n ? J(1) : r === 27n ? "0x" : J(1), a === "0x00" ? "0x" : a, i === "0x00" ? "0x" : i];
}
class rN extends H {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join(`
`), { name: "InvalidEip712TransactionError" });
  }
}
function Xv(t) {
  return !!(t.type === "eip712" || "customSignature" in t && t.customSignature || "paymaster" in t && t.paymaster || "paymasterInput" in t && t.paymasterInput || "gasPerPubdata" in t && typeof t.gasPerPubdata == "bigint" || "factoryDeps" in t && t.factoryDeps);
}
function Zv(t) {
  const { chainId: e, to: n, from: r, paymaster: s, paymasterInput: a } = t;
  if (!Xv(t))
    throw new rN();
  if (!e || e <= 0)
    throw new Ql({ chainId: e });
  if (n && !ze(n))
    throw new ot({ address: n });
  if (r && !ze(r))
    throw new ot({ address: r });
  if (s && !ze(s))
    throw new ot({ address: s });
  if (s && !a)
    throw new H("`paymasterInput` must be provided when `paymaster` is defined");
  if (!s && a)
    throw new H("`paymaster` must be provided when `paymasterInput` is defined");
}
function sN(t, e) {
  return Xv(t) ? iN(t) : ow(t, e);
}
const aN = {
  transaction: sN
};
function iN(t) {
  const { chainId: e, gas: n, nonce: r, to: s, from: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, customSignature: u, factoryDeps: l, paymaster: d, paymasterInput: p, gasPerPubdata: f, data: b } = t;
  Zv(t);
  const y = [
    r ? Ue(r) : "0x",
    c ? Ue(c) : "0x",
    o ? Ue(o) : "0x",
    n ? Ue(n) : "0x",
    s ?? "0x",
    i ? Ue(i) : "0x",
    b ?? "0x",
    Ue(e),
    Ue(""),
    Ue(""),
    Ue(e),
    a ?? "0x",
    Ue(f || X1),
    l ?? [],
    u ?? "0x",
    // EIP712 signature
    d && p ? [d, p] : []
  ];
  return cr([
    "0x71",
    os(y)
  ]);
}
class oN extends H {
  constructor({ givenLength: e, maxBytecodeSize: n }) {
    super(`Bytecode cannot be longer than ${n} bytes. Given length: ${e}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
}
class cN extends H {
  constructor({ givenLengthInWords: e }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${e}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
}
class lN extends H {
  constructor({ givenLength: e }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${e}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
}
function uN(t) {
  const e = gc(t);
  if (e.length % 32 !== 0)
    throw new lN({
      givenLength: e.length
    });
  if (e.length > i2)
    throw new oN({
      givenLength: e.length,
      maxBytecodeSize: i2
    });
  const n = Fv(e), r = gc(n), s = e.length / 32;
  if (s % 2 === 0)
    throw new cN({
      givenLengthInWords: s
    });
  const a = gc(s), i = zt(a, { size: 2 }), o = new Uint8Array([1, 0]);
  return r.set(o, 0), r.set(i, 2), r;
}
const dN = (t) => {
  Zv(t);
  const e = fN(t);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: t.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message: e
  };
};
function fN(t) {
  const { gas: e, nonce: n, to: r, from: s, value: a, maxFeePerGas: i, maxPriorityFeePerGas: o, factoryDeps: c, paymaster: u, paymasterInput: l, gasPerPubdata: d, data: p } = t;
  return {
    txType: 113n,
    from: BigInt(s),
    to: r ? BigInt(r) : 0n,
    gasLimit: e ?? 0n,
    gasPerPubdataByteLimit: d ?? X1,
    maxFeePerGas: i ?? 0n,
    maxPriorityFeePerGas: o ?? 0n,
    paymaster: u ? BigInt(u) : 0n,
    nonce: n ? BigInt(n) : 0n,
    value: a ?? 0n,
    data: p ?? "0x",
    factoryDeps: (c == null ? void 0 : c.map((f) => Ue(uN(f)))) ?? [],
    paymasterInput: l || "0x"
  };
}
const Ln = {
  blockTime: 1e3,
  formatters: kv,
  serializers: aN,
  custom: {
    getEip712Domain: dN
  }
}, yb = /* @__PURE__ */ h({
  ...Ln,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
}), pN = /* @__PURE__ */ h({
  ...Ln,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
}), hN = /* @__PURE__ */ h({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: !1
}), mN = /* @__PURE__ */ h({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: !1
}), yN = /* @__PURE__ */ h({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: !1
}), bN = /* @__PURE__ */ h({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: !1
}), gN = /* @__PURE__ */ h({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
}), wN = /* @__PURE__ */ h({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: !0
}), EN = /* @__PURE__ */ h({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: !1
}), xN = /* @__PURE__ */ h({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: !0
}), Yv = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, cw = {
  block: /* @__PURE__ */ W1({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const s = tm(r);
          return s.typeHex === "0x7e" && (s.isSystemTx = r.isSystemTx, s.mint = r.mint ? Fe(r.mint) : void 0, s.sourceHash = r.sourceHash, s.type = "deposit"), s;
        }),
        stateRoot: t.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ K1({
    format(t) {
      const e = {};
      return t.type === "0x7e" && (e.isSystemTx = t.isSystemTx, e.mint = t.mint ? Fe(t.mint) : void 0, e.sourceHash = t.sourceHash, e.type = "deposit"), e;
    }
  }),
  transactionReceipt: /* @__PURE__ */ xv({
    format(t) {
      return {
        l1GasPrice: t.l1GasPrice ? Fe(t.l1GasPrice) : null,
        l1GasUsed: t.l1GasUsed ? Fe(t.l1GasUsed) : null,
        l1Fee: t.l1Fee ? Fe(t.l1Fee) : null,
        l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null
      };
    }
  })
};
function e3(t, e) {
  return vN(t) ? kN(t) : ow(t, e);
}
const AN = {
  transaction: e3
};
function kN(t) {
  CN(t);
  const { sourceHash: e, data: n, from: r, gas: s, isSystemTx: a, mint: i, to: o, value: c } = t, u = [
    e,
    r,
    o ?? "0x",
    i ? Ue(i) : "0x",
    c ? Ue(c) : "0x",
    s ? Ue(s) : "0x",
    a ? "0x1" : "0x",
    n ?? "0x"
  ];
  return cr([
    "0x7e",
    os(u)
  ]);
}
function vN(t) {
  return t.type === "deposit" || typeof t.sourceHash < "u";
}
function CN(t) {
  const { from: e, to: n } = t;
  if (e && !ze(e))
    throw new ot({ address: e });
  if (n && !ze(n))
    throw new ot({ address: n });
}
const K = {
  blockTime: 2e3,
  contracts: Yv,
  formatters: cw,
  serializers: AN
}, Df = 1, bb = /* @__PURE__ */ h({
  ...K,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Df]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [Df]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [Df]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId: Df
}), Ff = 11155111, TN = /* @__PURE__ */ h({
  ...K,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Ff]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [Ff]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [Ff]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: Ff
}), SN = /* @__PURE__ */ h({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), IN = 42161, So = /* @__PURE__ */ h({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: IN
}), ON = /* @__PURE__ */ h({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: !0
}), ut = /* @__PURE__ */ h({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 250,
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), BN = /* @__PURE__ */ h({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: !0
}), ai = /* @__PURE__ */ h({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
}), cs = /* @__PURE__ */ h({
  id: 421614,
  name: "Arbitrum Sepolia",
  blockTime: 250,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: !0
}), gb = /* @__PURE__ */ h({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
}), PN = /* @__PURE__ */ h({
  id: 463,
  name: "Areum",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areum.network"],
      webSocket: ["wss://mainnet-ws.areum.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areum Explorer",
      url: "https://explorer.areum.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: !1
}), UN = /* @__PURE__ */ h({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: !1
}), NN = /* @__PURE__ */ h({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: !0
}), RN = /* @__PURE__ */ h({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: !0
}), DN = /* @__PURE__ */ h({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
}), FN = /* @__PURE__ */ h({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
}), MN = /* @__PURE__ */ h({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: !1,
  contracts: {}
}), LN = /* @__PURE__ */ h({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
}), HN = /* @__PURE__ */ h({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: !1
}), _N = /* @__PURE__ */ h({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: !1
}), $N = /* @__PURE__ */ h({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: !0
}), GN = /* @__PURE__ */ h({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: !0
}), zN = /* @__PURE__ */ h({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
}), jN = /* @__PURE__ */ h({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: !0
}), VN = /* @__PURE__ */ h({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: !0
}), qN = /* @__PURE__ */ h({
  id: 785,
  name: "Autheo Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Autheo",
    symbol: "THEO"
  },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc1.autheo.com",
        "https://testnet-rpc2.autheo.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Autheo Testnet Block Explorer",
      url: "https://testnet-explorer.autheo.com/"
    }
  }
}), pn = /* @__PURE__ */ h({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), ii = /* @__PURE__ */ h({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: !0
}), KN = 8453, Io = /* @__PURE__ */ h({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: KN
}), WN = 168587773, Yp = /* @__PURE__ */ h({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: !0,
  sourceId: WN
}), QN = /* @__PURE__ */ h({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
}), fu = 1, At = /* @__PURE__ */ h({
  ...K,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [fu]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [fu]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [fu]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [fu]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: fu
}), JN = /* @__PURE__ */ h({
  ...At,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://mainnet-preconf.base.org"]
    }
  }
}), XN = /* @__PURE__ */ h({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: !0
}), Mf = 5, t3 = /* @__PURE__ */ h({
  ...K,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Mf]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [Mf]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [Mf]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: !0,
  sourceId: Mf
}), pu = 11155111, zs = /* @__PURE__ */ h({
  ...K,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [pu]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [pu]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [pu]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [pu]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: !0,
  sourceId: pu
}), ZN = /* @__PURE__ */ h({
  ...zs,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://sepolia-preconf.base.org"]
    }
  }
}), YN = /* @__PURE__ */ h({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
}), eR = /* @__PURE__ */ h({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: !0
}), tR = /* @__PURE__ */ h({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
}), nR = /* @__PURE__ */ h({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: !0
}), wb = /* @__PURE__ */ h({
  id: 80094,
  name: "Berachain",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 877008
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: !1
}), rR = /* @__PURE__ */ h({
  id: 80069,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: !0
}), sR = /* @__PURE__ */ h({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: !0
}), aR = /* @__PURE__ */ h({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: !0
}), iR = /* @__PURE__ */ h({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
}), oR = /* @__PURE__ */ h({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: !1
}), cR = /* @__PURE__ */ h({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: !1
}), lR = /* @__PURE__ */ h({
  id: 96,
  name: "KUB Mainnet",
  nativeCurrency: { name: "KUB Coin", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KUB Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
}), uR = /* @__PURE__ */ h({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: !0
}), dR = /* @__PURE__ */ h({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
}), fR = /* @__PURE__ */ h({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: !0
}), pR = /* @__PURE__ */ h({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: !1
}), hR = /* @__PURE__ */ h({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
}), mR = /* @__PURE__ */ h({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: !0
}), yR = h({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
}), Lf = 1, Ml = /* @__PURE__ */ h({
  ...K,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    },
    l2OutputOracle: {
      [Lf]: {
        address: "0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76",
        blockCreated: 19300358
      }
    },
    portal: {
      [Lf]: {
        address: "0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb",
        blockCreated: 19300357
      }
    },
    l1StandardBridge: {
      [Lf]: {
        address: "0x697402166Fbf2F22E970df8a6486Ef171dbfc524",
        blockCreated: 19300360
      }
    }
  },
  sourceId: Lf
}), bR = 11155111, eh = /* @__PURE__ */ h({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: !0,
  sourceId: bR
}), B0 = 1, Eb = h({
  ...K,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [B0]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [B0]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: B0
}), xb = /* @__PURE__ */ h({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
}), gR = /* @__PURE__ */ h({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: !0
}), P0 = 11155111, wR = h({
  ...K,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [P0]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [P0]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: !0,
  sourceId: P0
}), ER = /* @__PURE__ */ h({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: !1
}), xR = /* @__PURE__ */ h({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Botanix", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: !0
}), AR = /* @__PURE__ */ h({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: !1
}), kR = /* @__PURE__ */ h({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: !0
}), vR = /* @__PURE__ */ h({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
}), CR = /* @__PURE__ */ h({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: !0
}), wd = /* @__PURE__ */ h({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), TR = /* @__PURE__ */ h({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: !1
}), th = /* @__PURE__ */ h({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: !0
}), SR = /* @__PURE__ */ h({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
}), IR = /* @__PURE__ */ h({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: !0
}), OR = /* @__PURE__ */ h({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
}), BR = /* @__PURE__ */ h({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: !0
}), PR = /* @__PURE__ */ h({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
}), UR = /* @__PURE__ */ h({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: !0
}), NR = /* @__PURE__ */ h({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), RR = /* @__PURE__ */ h({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
}), DR = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (t) => {
    var s;
    if (!((s = t.request) != null && s.feeCurrency))
      return null;
    const [e, n] = await Promise.all([
      FR(t.client, t.request.feeCurrency),
      MR(t.client, t.request.feeCurrency)
    ]);
    return {
      maxFeePerGas: t.multiply(e - n) + n,
      maxPriorityFeePerGas: n
    };
  }
};
async function FR(t, e) {
  const n = await t.request({
    method: "eth_gasPrice",
    params: [e]
  });
  return BigInt(n);
}
async function MR(t, e) {
  const n = await t.request({
    method: "eth_maxPriorityFeePerGas",
    params: [e]
  });
  return BigInt(n);
}
function n3(t) {
  return t === 0 || t === 0n || t === void 0 || t === null || t === "0" || t === "" || typeof t == "string" && (Gs(t).toLowerCase() === "0x" || Gs(t).toLowerCase() === "0x00");
}
function Lu(t) {
  return !n3(t);
}
function LR(t) {
  return typeof t.maxFeePerGas < "u" && typeof t.maxPriorityFeePerGas < "u";
}
function r3(t) {
  return t.type === "cip64" ? !0 : LR(t) && Lu(t.feeCurrency);
}
const HR = {
  block: /* @__PURE__ */ W1({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : {
          ...tm(r),
          ...r.gatewayFee ? {
            gatewayFee: Fe(r.gatewayFee),
            gatewayFeeRecipient: r.gatewayFeeRecipient
          } : {},
          feeCurrency: r.feeCurrency
        })
      };
    }
  }),
  transaction: /* @__PURE__ */ K1({
    format(t) {
      if (t.type === "0x7e")
        return {
          isSystemTx: t.isSystemTx,
          mint: t.mint ? Fe(t.mint) : void 0,
          sourceHash: t.sourceHash,
          type: "deposit"
        };
      const e = { feeCurrency: t.feeCurrency };
      return t.type === "0x7b" ? e.type = "cip64" : (t.type === "0x7c" && (e.type = "cip42"), e.gatewayFee = t.gatewayFee ? Fe(t.gatewayFee) : null, e.gatewayFeeRecipient = t.gatewayFeeRecipient), e;
    }
  }),
  transactionRequest: /* @__PURE__ */ Av({
    format(t) {
      const e = {};
      return t.feeCurrency && (e.feeCurrency = t.feeCurrency), r3(t) && (e.type = "0x7b"), e;
    }
  })
};
function _R(t, e) {
  return r3(t) ? GR(t, e) : e3(t, e);
}
const $R = {
  transaction: _R
};
function GR(t, e) {
  jR(t);
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, feeCurrency: l, data: d } = t, p = [
    Ue(n),
    s ? Ue(s) : "0x",
    c ? Ue(c) : "0x",
    o ? Ue(o) : "0x",
    r ? Ue(r) : "0x",
    a ?? "0x",
    i ? Ue(i) : "0x",
    d ?? "0x",
    nf(u),
    l,
    ...Jl(t, e)
  ];
  return cr([
    "0x7b",
    os(p)
  ]);
}
const zR = tf;
function jR(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a, feeCurrency: i } = t;
  if (e <= 0)
    throw new Ql({ chainId: e });
  if (a && !ze(a))
    throw new ot({ address: a });
  if (r)
    throw new H("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (Lu(s) && s > zR)
    throw new si({ maxFeePerGas: s });
  if (Lu(n) && Lu(s) && n > s)
    throw new Fl({ maxFeePerGas: s, maxPriorityFeePerGas: n });
  if (Lu(i) && !ze(i))
    throw new H("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  if (n3(i))
    throw new H("`feeCurrency` must be provided for CIP-64 transactions.");
}
const Ed = {
  blockTime: 1e3,
  contracts: Yv,
  formatters: HR,
  serializers: $R,
  fees: DR
}, Ab = /* @__PURE__ */ h({
  ...Ed,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: !1
}), Hf = 17e3, VR = /* @__PURE__ */ h({
  ...Ed,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...Ed.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [Hf]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [Hf]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [Hf]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [Hf]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: !0
}), U0 = 11155111, qR = /* @__PURE__ */ h({
  ...Ed,
  id: 11142220,
  name: "Celo Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "S-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://forno.celo-sepolia.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Sepolia Explorer",
      url: "https://celo-sepolia.blockscout.com/",
      apiUrl: "https://celo-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...Ed.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    },
    portal: {
      [U0]: {
        address: "0x44ae3d41a335a7d05eb533029917aad35662dcc2",
        blockCreated: 8825790
      }
    },
    disputeGameFactory: {
      [U0]: {
        address: "0x57c45d82d1a995f1e135b8d7edc0a6bb5211cfaa",
        blockCreated: 8825790
      }
    },
    l1StandardBridge: {
      [U0]: {
        address: "0xec18a3c30131a0db4246e785355fbc16e2eaf408",
        blockCreated: 8825790
      }
    }
  },
  testnet: !0
}), KR = /* @__PURE__ */ h({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
}), WR = /* @__PURE__ */ h({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiliz.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8080847
    }
  }
}), QR = /* @__PURE__ */ h({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
}), JR = /* @__PURE__ */ h({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: !0
}), XR = /* @__PURE__ */ h({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
}), ZR = /* @__PURE__ */ h({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: !1
}), YR = /* @__PURE__ */ h({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: !1
}), eD = /* @__PURE__ */ h({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
}), tD = /* @__PURE__ */ h({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: !0,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
}), nD = /* @__PURE__ */ h({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: !1
}), rD = /* @__PURE__ */ h({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: !0
}), sD = /* @__PURE__ */ h({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: !0
}), aD = 1, kb = /* @__PURE__ */ h({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: aD
}), iD = 11155111, oD = /* @__PURE__ */ h({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: !0,
  sourceId: iD
}), cD = h({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
}), lD = h({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), uD = /* @__PURE__ */ h({
  id: 102030,
  name: "Creditcoin3 Mainnet",
  nativeCurrency: { name: "Creditcoin3 Mainnet", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: !1
}), dD = /* @__PURE__ */ h({
  id: 102031,
  name: "Creditcoin3 Testnet",
  nativeCurrency: { name: "Creditcoin3 Testnet", symbol: "TCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: !0
}), vb = /* @__PURE__ */ h({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
}), fD = /* @__PURE__ */ h({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer (Testnet)",
      url: "https://explorer.cronos.org/testnet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: !0
}), pD = /* @__PURE__ */ h({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
}), hD = /* @__PURE__ */ h({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: !0
}), mD = /* @__PURE__ */ h({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
}), yD = /* @__PURE__ */ h({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: !0
}), Cb = /* @__PURE__ */ h({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), bD = /* @__PURE__ */ h({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: !0
}), gD = /* @__PURE__ */ h({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: !1
}), wD = /* @__PURE__ */ h({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: !0
}), ED = /* @__PURE__ */ h({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
}), xD = /* @__PURE__ */ h({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: !1
}), AD = /* @__PURE__ */ h({
  ...K,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...K.contracts
  }
}), kD = /* @__PURE__ */ h({
  ...K,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...K.contracts
  }
}), vD = /* @__PURE__ */ h({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
}), CD = /* @__PURE__ */ h({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: !0
}), Tb = /* @__PURE__ */ h({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
}), TD = /* @__PURE__ */ h({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
}), SD = /* @__PURE__ */ h({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: !1
}), ID = /* @__PURE__ */ h({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
}), OD = h({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: !0
}), BD = /* @__PURE__ */ h({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
}), PD = /* @__PURE__ */ h({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), UD = /* @__PURE__ */ h({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
}), ND = /* @__PURE__ */ h({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: !0
}), RD = /* @__PURE__ */ h({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});
function DD({ blockNumber: t, chain: e, contract: n }) {
  var s;
  const r = (s = e == null ? void 0 : e.contracts) == null ? void 0 : s[n];
  if (!r)
    throw new ob({
      chain: e,
      contract: { name: n }
    });
  if (t && r.blockCreated && r.blockCreated > t)
    throw new ob({
      blockNumber: t,
      chain: e,
      contract: {
        name: n,
        blockCreated: r.blockCreated
      }
    });
  return r.address;
}
const FD = /* @__PURE__ */ h({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: !0
}), MD = /* @__PURE__ */ h({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: !1
}), LD = /* @__PURE__ */ h({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: !1
}), HD = /* @__PURE__ */ h({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: !0
}), _D = /* @__PURE__ */ h({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
}), $D = /* @__PURE__ */ h({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
}), GD = /* @__PURE__ */ h({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
}), zD = /* @__PURE__ */ h({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
}), jD = /* @__PURE__ */ h({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
}), VD = /* @__PURE__ */ h({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: !1
}), qD = /* @__PURE__ */ h({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: !0
}), KD = /* @__PURE__ */ h({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
}), WD = /* @__PURE__ */ h({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: !0
}), QD = /* @__PURE__ */ h({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: !1
}), JD = /* @__PURE__ */ h({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: !0
}), XD = /* @__PURE__ */ h({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: !1
}), ZD = /* @__PURE__ */ h({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: !0
}), YD = /* @__PURE__ */ h({
  ...K,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: !0
}), eF = /* @__PURE__ */ h({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: !1
}), tF = /* @__PURE__ */ h({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: !1
}), nF = /* @__PURE__ */ h({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
}), rF = /* @__PURE__ */ h({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
}), sF = /* @__PURE__ */ h({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: !0
}), aF = /* @__PURE__ */ h({
  id: 42793,
  name: "Etherlink",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
}), iF = /* @__PURE__ */ h({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: !0
}), oF = /* @__PURE__ */ h({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), cF = /* @__PURE__ */ h({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
}), lF = /* @__PURE__ */ h({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
}), uF = /* @__PURE__ */ h({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
}), dF = /* @__PURE__ */ h({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
}), fF = /* @__PURE__ */ h({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: !1
}), pF = /* @__PURE__ */ h({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
}), hF = /* @__PURE__ */ h({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
}), mF = /* @__PURE__ */ h({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
}), yF = /* @__PURE__ */ h({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: !0
}), bF = /* @__PURE__ */ h({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: !0
}), gF = /* @__PURE__ */ h({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
}), wF = /* @__PURE__ */ h({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
}), EF = /* @__PURE__ */ h({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: !0
}), xF = /* @__PURE__ */ h({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: !0
}), AF = /* @__PURE__ */ h({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: !1
}), kF = /* @__PURE__ */ h({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
}), vF = /* @__PURE__ */ h({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
}), CF = /* @__PURE__ */ h({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: !0
}), Sb = /* @__PURE__ */ h({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  },
  blockTime: 800
}), TF = /* @__PURE__ */ h({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
}), SF = /* @__PURE__ */ h({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: !0,
  blockTime: 800
}), IF = /* @__PURE__ */ h({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
}), OF = /* @__PURE__ */ h({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: !0
}), BF = /* @__PURE__ */ h({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: !0
}), PF = /* @__PURE__ */ h({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: !0
}), Ib = /* @__PURE__ */ h({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
}), Jo = 1, UF = /* @__PURE__ */ h({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...K.contracts,
    addressManager: {
      [Jo]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [Jo]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [Jo]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [Jo]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [Jo]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: Jo
}), NF = /* @__PURE__ */ h({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: !0
}), Xo = 11155111, RF = /* @__PURE__ */ h({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...K.contracts,
    addressManager: {
      [Xo]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [Xo]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [Xo]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [Xo]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [Xo]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0,
  sourceId: Xo
}), DF = /* @__PURE__ */ h({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
}), FF = /* @__PURE__ */ h({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), _f = 1, MF = /* @__PURE__ */ h({
  ...K,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [_f]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [_f]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [_f]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: _f
}), $f = 17e3, LF = /* @__PURE__ */ h({
  ...K,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [$f]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [$f]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [$f]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: $f
}), HF = 1, Ob = /* @__PURE__ */ h({
  ...K,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...K.contracts
  },
  sourceId: HF
}), _F = 11155111, $F = h({
  ...K,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: !0,
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: _F
}), GF = /* @__PURE__ */ h({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
}), zF = /* @__PURE__ */ h({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
}), jF = /* @__PURE__ */ h({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: !1
}), VF = /* @__PURE__ */ h({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: !0
}), Gf = 17e3, qF = h({
  ...K,
  name: "Garnet Testnet",
  testnet: !0,
  id: 17069,
  sourceId: Gf,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Gf]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [Gf]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [Gf]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
}), KF = /* @__PURE__ */ h({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
}), WF = /* @__PURE__ */ h({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: !1
}), QF = /* @__PURE__ */ h({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), JF = /* @__PURE__ */ h({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), Oo = /* @__PURE__ */ h({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
}), nh = /* @__PURE__ */ h({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: !0
}), XF = /* @__PURE__ */ h({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), ZF = /* @__PURE__ */ h({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: !0
}), YF = /* @__PURE__ */ h({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: !1
}), eM = /* @__PURE__ */ h({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: !1
}), tM = /* @__PURE__ */ h({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), nM = /* @__PURE__ */ h({
  id: 440017,
  name: "Graphite Network",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Spectre",
      url: "https://main.atgraphite.com",
      apiUrl: "https://api.main.atgraphite.com/api"
    }
  },
  testnet: !1
}), rM = /* @__PURE__ */ h({
  id: 54170,
  name: "Graphite Network Testnet",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-test-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-test-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Testnet Spectre",
      url: "https://test.atgraphite.com",
      apiUrl: "https://api.test.atgraphite.com/api"
    }
  },
  testnet: !0
}), Bb = /* @__PURE__ */ h({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
}), sM = /* @__PURE__ */ h({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
}), aM = /* @__PURE__ */ h({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: !1
}), iM = /* @__PURE__ */ h({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: !0
}), oM = /* @__PURE__ */ h({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
}), cM = /* @__PURE__ */ h({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0
}), lM = /* @__PURE__ */ h({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
}), uM = /* @__PURE__ */ h({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
}), dM = /* @__PURE__ */ h({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), fM = /* @__PURE__ */ h({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
}), pM = /* @__PURE__ */ h({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), hM = /* @__PURE__ */ h({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://hashkeychain-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkeychain-testnet-explorer.alt.technology"
    }
  },
  testnet: !0
}), mM = /* @__PURE__ */ h({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: !0
}), yM = /* @__PURE__ */ h({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: !1
}), bM = /* @__PURE__ */ h({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: !0
}), gM = /* @__PURE__ */ h({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: !0
}), wM = /* @__PURE__ */ h({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: !1
}), Pb = /* @__PURE__ */ h({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: !1
}), EM = /* @__PURE__ */ h({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: !0
}), xM = /* @__PURE__ */ h({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: !0
}), AM = /* @__PURE__ */ h({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: !0
}), kM = /* @__PURE__ */ h({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: !1
}), vM = 42161, CM = /* @__PURE__ */ h({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: vM
}), TM = 421614, SM = /* @__PURE__ */ h({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: TM
}), IM = /* @__PURE__ */ h({
  id: 7080969,
  name: "Humanity Testnet",
  nativeCurrency: {
    name: "tHP",
    symbol: "tHP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.humanity.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Humanity Testnet Explorer",
      url: "https://humanity-testnet.explorer.alchemy.com",
      apiUrl: "https://humanity-testnet.explorer.alchemy.com/api"
    }
  },
  testnet: !0
}), OM = /* @__PURE__ */ h({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
}), BM = /* @__PURE__ */ h({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), Ub = /* @__PURE__ */ h({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: !1
}), PM = /* @__PURE__ */ h({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: !0
}), UM = /* @__PURE__ */ h({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: !1
}), NM = /* @__PURE__ */ h({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
}), RM = /* @__PURE__ */ h({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: !0
}), DM = /* @__PURE__ */ h({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
}), FM = /* @__PURE__ */ h({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
}), MM = /* @__PURE__ */ h({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: !0
}), zf = 1, Nb = /* @__PURE__ */ h({
  ...K,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...K.contracts,
    disputeGameFactory: {
      [zf]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [zf]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [zf]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: !1,
  sourceId: zf
}), jf = 11155111, LM = /* @__PURE__ */ h({
  ...K,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [jf]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [jf]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [jf]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: !0,
  sourceId: jf
}), HM = /* @__PURE__ */ h({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
}), _M = /* @__PURE__ */ h({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: !0
}), $M = /* @__PURE__ */ h({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
}), GM = /* @__PURE__ */ h({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: !0
}), zM = /* @__PURE__ */ h({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
}), jM = /* @__PURE__ */ h({
  id: 8899,
  name: "JB Chain",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: !1
}), VM = /* @__PURE__ */ h({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: !0
}), qM = /* @__PURE__ */ h({
  id: 81,
  name: "Japan Open Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Token",
    symbol: "JOC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.japanopenchain.org:8545",
        "https://rpc-2.japanopenchain.org:8545",
        "https://rpc-3.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.japanopenchain.org"
    }
  },
  testnet: !1
}), KM = /* @__PURE__ */ h({
  id: 10081,
  name: "Japan Open Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Testnet Token",
    symbol: "JOCT"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.testnet.japanopenchain.org:8545",
        "https://rpc-2.testnet.japanopenchain.org:8545",
        "https://rpc-3.testnet.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Testnet Block Explorer",
      url: "https://explorer.testnet.japanopenchain.org"
    }
  },
  testnet: !0
}), WM = /* @__PURE__ */ h({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
}), QM = /* @__PURE__ */ h({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
}), JM = /* @__PURE__ */ h({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
}), XM = /* @__PURE__ */ h({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
}), ZM = /* @__PURE__ */ h({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
}), YM = /* @__PURE__ */ h({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
}), eL = /* @__PURE__ */ h({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
}), tL = /* @__PURE__ */ h({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
}), nL = /* @__PURE__ */ h({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
}), rL = /* @__PURE__ */ h({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
}), sL = /* @__PURE__ */ h({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: !0
}), aL = /* @__PURE__ */ h({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
}), iL = /* @__PURE__ */ h({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
}), oL = /* @__PURE__ */ h({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: !1
}), cL = /* @__PURE__ */ h({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), lL = /* @__PURE__ */ h({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), uL = /* @__PURE__ */ h({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: !1
}), dL = /* @__PURE__ */ h({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: !1
}), fL = /* @__PURE__ */ h({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: !0
}), pL = /* @__PURE__ */ h({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: !1
}), hL = /* @__PURE__ */ h({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: !1
}), mL = /* @__PURE__ */ h({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), yL = /* @__PURE__ */ h({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), bL = /* @__PURE__ */ h({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), gL = /* @__PURE__ */ h({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), wL = h({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: !0
}), EL = /* @__PURE__ */ h({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: !1
}), xL = /* @__PURE__ */ h({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: !0
}), AL = /* @__PURE__ */ h({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: !1
}), kL = /* @__PURE__ */ h({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: !0
}), vL = /* @__PURE__ */ h({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: !1
}), CL = /* @__PURE__ */ h({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
}), TL = /* @__PURE__ */ h({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: !0
}), SL = /* @__PURE__ */ h({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: !0
}), IL = /* @__PURE__ */ h({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: !0
}), OL = /* @__PURE__ */ h({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: !1
});
function ir(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
class Go extends H {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
const BL = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, PL = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, UL = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function Ll(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new VL(t.type);
  return `${t.name}(${lw(t.inputs, { includeName: e })})`;
}
function lw(t, { includeName: e = !1 } = {}) {
  return t ? t.map((n) => NL(n, { includeName: e })).join(e ? ", " : ",") : "";
}
function NL(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${lw(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
class RL extends H {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class b2 extends H {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class DL extends H {
  constructor({ data: e, params: n, size: r }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${lw(n, { includeName: !0 })})`,
        `Data:   ${e} (${r} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = n, this.size = r;
  }
}
class uw extends H {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class FL extends H {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super([
      `ABI encoding array length mismatch for type ${r}.`,
      `Expected length: ${e}`,
      `Given length: ${n}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class ML extends H {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${it(n)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class LL extends H {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class sre extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,
      "Cannot encode error result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the inputs exist on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorInputsNotFoundError"
    });
  }
}
class are extends H {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Error ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorNotFoundError"
    });
  }
}
class s3 extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class rh extends H {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class HL extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Function "${e}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class ire extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded function signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionSignatureNotFoundError"
    });
  }
}
class _L extends H {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${Ll(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Ll(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
let $L = class extends H {
  constructor({ expectedSize: e, givenSize: n }) {
    super(`Expected bytes${e}, got bytes${n}.`, {
      name: "BytesSizeMismatchError"
    });
  }
};
class GL extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiEncodingType" });
  }
}
class zL extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiDecodingType" });
  }
}
let jL = class extends H {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
};
class VL extends H {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
const qL = (t) => nt(gc(t));
function KL(t) {
  return qL(t);
}
const WL = "1.0.8";
let Hn = class Rb extends Error {
  constructor(e, n = {}) {
    var i;
    const r = n.cause instanceof Rb ? n.cause.details : (i = n.cause) != null && i.message ? n.cause.message : n.details, s = n.cause instanceof Rb && n.cause.docsPath || n.docsPath, a = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...s ? [`Docs: https://abitype.dev${s}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: abitype@${WL}`
    ].join(`
`);
    super(a), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.shortMessage = e;
  }
};
function Qs(t, e) {
  const n = t.exec(e);
  return n == null ? void 0 : n.groups;
}
const a3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, i3 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, o3 = /^\(.+?\).*?$/, g2 = /^tuple(?<array>(\[(\d*)\])*)$/;
function Db(t) {
  let e = t.type;
  if (g2.test(t.type) && "components" in t) {
    e = "(";
    const n = t.components.length;
    for (let s = 0; s < n; s++) {
      const a = t.components[s];
      e += Db(a), s < n - 1 && (e += ", ");
    }
    const r = Qs(g2, t.type);
    return e += `)${(r == null ? void 0 : r.array) ?? ""}`, Db({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function hu(t) {
  let e = "";
  const n = t.length;
  for (let r = 0; r < n; r++) {
    const s = t[r];
    e += Db(s), r !== n - 1 && (e += ", ");
  }
  return e;
}
function sh(t) {
  var e;
  return t.type === "function" ? `function ${t.name}(${hu(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${(e = t.outputs) != null && e.length ? ` returns (${hu(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${hu(t.inputs)})` : t.type === "error" ? `error ${t.name}(${hu(t.inputs)})` : t.type === "constructor" ? `constructor(${hu(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? `fallback() external${t.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
const c3 = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function QL(t) {
  return c3.test(t);
}
function JL(t) {
  return Qs(c3, t);
}
const l3 = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function XL(t) {
  return l3.test(t);
}
function ZL(t) {
  return Qs(l3, t);
}
const u3 = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function YL(t) {
  return u3.test(t);
}
function eH(t) {
  return Qs(u3, t);
}
const d3 = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function f3(t) {
  return d3.test(t);
}
function tH(t) {
  return Qs(d3, t);
}
const p3 = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function nH(t) {
  return p3.test(t);
}
function rH(t) {
  return Qs(p3, t);
}
const h3 = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function sH(t) {
  return h3.test(t);
}
function aH(t) {
  return Qs(h3, t);
}
const iH = /^receive\(\) external payable$/;
function oH(t) {
  return iH.test(t);
}
const cH = /* @__PURE__ */ new Set(["indexed"]), Fb = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class lH extends Hn {
  constructor({ signature: e }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,
      docsPath: "/api/human#parseabiitem-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiItemError"
    });
  }
}
class uH extends Hn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class dH extends Hn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class fH extends Hn {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class pH extends Hn {
  constructor({ param: e, name: n }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class hH extends Hn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class mH extends Hn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class yH extends Hn {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class Xl extends Hn {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class bH extends Hn {
  constructor({ signature: e }) {
    super("Unknown signature.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class gH extends Hn {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class wH extends Hn {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class EH extends Hn {
  constructor({ current: e, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function xH(t, e, n) {
  let r = "";
  if (n)
    for (const s of Object.entries(n)) {
      if (!s)
        continue;
      let a = "";
      for (const i of s[1])
        a += `[${i.type}${i.name ? `:${i.name}` : ""}]`;
      r += `(${s[0]}{${a}})`;
    }
  return e ? `${e}:${t}${r}` : t;
}
const N0 = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function m3(t, e = {}) {
  if (YL(t))
    return AH(t, e);
  if (XL(t))
    return kH(t, e);
  if (QL(t))
    return vH(t, e);
  if (nH(t))
    return CH(t, e);
  if (sH(t))
    return TH(t);
  if (oH(t))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new bH({ signature: t });
}
function AH(t, e = {}) {
  const n = eH(t);
  if (!n)
    throw new Xl({ signature: t, type: "function" });
  const r = Tr(n.parameters), s = [], a = r.length;
  for (let o = 0; o < a; o++)
    s.push(Bo(r[o], {
      modifiers: Fb,
      structs: e,
      type: "function"
    }));
  const i = [];
  if (n.returns) {
    const o = Tr(n.returns), c = o.length;
    for (let u = 0; u < c; u++)
      i.push(Bo(o[u], {
        modifiers: Fb,
        structs: e,
        type: "function"
      }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s,
    outputs: i
  };
}
function kH(t, e = {}) {
  const n = ZL(t);
  if (!n)
    throw new Xl({ signature: t, type: "event" });
  const r = Tr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Bo(r[i], {
      modifiers: cH,
      structs: e,
      type: "event"
    }));
  return { name: n.name, type: "event", inputs: s };
}
function vH(t, e = {}) {
  const n = JL(t);
  if (!n)
    throw new Xl({ signature: t, type: "error" });
  const r = Tr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Bo(r[i], { structs: e, type: "error" }));
  return { name: n.name, type: "error", inputs: s };
}
function CH(t, e = {}) {
  const n = rH(t);
  if (!n)
    throw new Xl({ signature: t, type: "constructor" });
  const r = Tr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Bo(r[i], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s
  };
}
function TH(t) {
  const e = aH(t);
  if (!e)
    throw new Xl({ signature: t, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable"
  };
}
const SH = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, IH = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, OH = /^u?int$/;
function Bo(t, e) {
  var d, p;
  const n = xH(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs);
  if (N0.has(n))
    return N0.get(n);
  const r = o3.test(t), s = Qs(r ? IH : SH, t);
  if (!s)
    throw new fH({ param: t });
  if (s.name && PH(s.name))
    throw new pH({ param: t, name: s.name });
  const a = s.name ? { name: s.name } : {}, i = s.modifier === "indexed" ? { indexed: !0 } : {}, o = (e == null ? void 0 : e.structs) ?? {};
  let c, u = {};
  if (r) {
    c = "tuple";
    const f = Tr(s.type), b = [], y = f.length;
    for (let g = 0; g < y; g++)
      b.push(Bo(f[g], { structs: o }));
    u = { components: b };
  } else if (s.type in o)
    c = "tuple", u = { components: o[s.type] };
  else if (OH.test(s.type))
    c = `${s.type}256`;
  else if (c = s.type, (e == null ? void 0 : e.type) !== "struct" && !y3(c))
    throw new dH({ type: c });
  if (s.modifier) {
    if (!((p = (d = e == null ? void 0 : e.modifiers) == null ? void 0 : d.has) != null && p.call(d, s.modifier)))
      throw new hH({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
    if (Fb.has(s.modifier) && !UH(c, !!s.array))
      throw new mH({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
  }
  const l = {
    type: `${c}${s.array ?? ""}`,
    ...a,
    ...i,
    ...u
  };
  return N0.set(n, l), l;
}
function Tr(t, e = [], n = "", r = 0) {
  const s = t.trim().length;
  for (let a = 0; a < s; a++) {
    const i = t[a], o = t.slice(a + 1);
    switch (i) {
      case ",":
        return r === 0 ? Tr(o, [...e, n.trim()]) : Tr(o, e, `${n}${i}`, r);
      case "(":
        return Tr(o, e, `${n}${i}`, r + 1);
      case ")":
        return Tr(o, e, `${n}${i}`, r - 1);
      default:
        return Tr(o, e, `${n}${i}`, r);
    }
  }
  if (n === "")
    return e;
  if (r !== 0)
    throw new EH({ current: n, depth: r });
  return e.push(n.trim()), e;
}
function y3(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || a3.test(t) || i3.test(t);
}
const BH = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function PH(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || t === "tuple" || a3.test(t) || i3.test(t) || BH.test(t);
}
function UH(t, e) {
  return e || t === "bytes" || t === "string" || t === "tuple";
}
function NH(t) {
  const e = {}, n = t.length;
  for (let i = 0; i < n; i++) {
    const o = t[i];
    if (!f3(o))
      continue;
    const c = tH(o);
    if (!c)
      throw new Xl({ signature: o, type: "struct" });
    const u = c.properties.split(";"), l = [], d = u.length;
    for (let p = 0; p < d; p++) {
      const b = u[p].trim();
      if (!b)
        continue;
      const y = Bo(b, {
        type: "struct"
      });
      l.push(y);
    }
    if (!l.length)
      throw new gH({ signature: o });
    e[c.name] = l;
  }
  const r = {}, s = Object.entries(e), a = s.length;
  for (let i = 0; i < a; i++) {
    const [o, c] = s[i];
    r[o] = b3(c, e);
  }
  return r;
}
const RH = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function b3(t, e, n = /* @__PURE__ */ new Set()) {
  const r = [], s = t.length;
  for (let a = 0; a < s; a++) {
    const i = t[a];
    if (o3.test(i.type))
      r.push(i);
    else {
      const c = Qs(RH, i.type);
      if (!(c != null && c.type))
        throw new yH({ abiParameter: i });
      const { array: u, type: l } = c;
      if (l in e) {
        if (n.has(l))
          throw new wH({ type: l });
        r.push({
          ...i,
          type: `tuple${u ?? ""}`,
          components: b3(e[l] ?? [], e, /* @__PURE__ */ new Set([...n, l]))
        });
      } else if (y3(l))
        r.push(i);
      else
        throw new uH({ type: l });
    }
  }
  return r;
}
function im(t) {
  const e = NH(t), n = [], r = t.length;
  for (let s = 0; s < r; s++) {
    const a = t[s];
    f3(a) || n.push(m3(a, e));
  }
  return n;
}
function w2(t) {
  let e;
  if (e = m3(t), !e)
    throw new lH({ signature: t });
  return e;
}
function DH(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new H("Unable to normalize signature.");
  return s;
}
const FH = (t) => {
  const e = typeof t == "string" ? t : sh(t);
  return DH(e);
};
function g3(t) {
  return KL(FH(t));
}
const dw = (t) => gd(g3(t), 0, 4);
function MH(t, e = {}) {
  typeof e.size < "u" && fs(t, { size: e.size });
  const n = Jt(t, e);
  return Fe(n, e);
}
function LH(t, e = {}) {
  let n = t;
  if (typeof e.size < "u" && (fs(n, { size: e.size }), n = Gs(n)), n.length > 1 || n[0] > 1)
    throw new O4(n);
  return !!n[0];
}
function _s(t, e = {}) {
  typeof e.size < "u" && fs(t, { size: e.size });
  const n = Jt(t, e);
  return ni(n, e);
}
function HH(t, e = {}) {
  let n = t;
  return typeof e.size < "u" && (fs(n, { size: e.size }), n = Gs(n, { dir: "right" })), new TextDecoder().decode(n);
}
const _H = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, w3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function Wa(t, e) {
  if (t.length !== e.length)
    throw new LL({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = $H({
    params: t,
    values: e
  }), r = pw(n);
  return r.length === 0 ? "0x" : r;
}
function $H({ params: t, values: e }) {
  const n = [];
  for (let r = 0; r < t.length; r++)
    n.push(fw({ param: t[r], value: e[r] }));
  return n;
}
function fw({ param: t, value: e }) {
  const n = hw(t.type);
  if (n) {
    const [r, s] = n;
    return zH(e, { length: r, param: { ...t, type: s } });
  }
  if (t.type === "tuple")
    return WH(e, {
      param: t
    });
  if (t.type === "address")
    return GH(e);
  if (t.type === "bool")
    return VH(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const r = t.type.startsWith("int"), [, , s = "256"] = w3.exec(t.type) ?? [];
    return qH(e, {
      signed: r,
      size: Number(s)
    });
  }
  if (t.type.startsWith("bytes"))
    return jH(e, { param: t });
  if (t.type === "string")
    return KH(e);
  throw new GL(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function pw(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += it(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(J(e + s, { size: 32 })), r.push(o), s += it(o)) : n.push(o);
  }
  return Tn([...n, ...r]);
}
function GH(t) {
  if (!ze(t))
    throw new ot({ address: t });
  return { dynamic: !1, encoded: Ka(t.toLowerCase()) };
}
function zH(t, { length: e, param: n }) {
  const r = e === null;
  if (!Array.isArray(t))
    throw new jL(t);
  if (!r && t.length !== e)
    throw new FL({
      expectedLength: e,
      givenLength: t.length,
      type: `${n.type}[${e}]`
    });
  let s = !1;
  const a = [];
  for (let i = 0; i < t.length; i++) {
    const o = fw({ param: n, value: t[i] });
    o.dynamic && (s = !0), a.push(o);
  }
  if (r || s) {
    const i = pw(a);
    if (r) {
      const o = J(a.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: a.length > 0 ? Tn([o, i]) : o
      };
    }
    if (s)
      return { dynamic: !0, encoded: i };
  }
  return {
    dynamic: !1,
    encoded: Tn(a.map(({ encoded: i }) => i))
  };
}
function jH(t, { param: e }) {
  const [, n] = e.type.split("bytes"), r = it(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = Ka(s, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Tn([Ka(J(r, { size: 32 })), s])
    };
  }
  if (r !== Number.parseInt(n))
    throw new ML({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: Ka(t, { dir: "right" }) };
}
function VH(t) {
  if (typeof t != "boolean")
    throw new H(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: Ka(yv(t)) };
}
function qH(t, { signed: e, size: n = 256 }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new pv({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: J(t, {
      size: 32,
      signed: e
    })
  };
}
function KH(t) {
  const e = yd(t), n = Math.ceil(it(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(Ka(gd(e, s * 32, (s + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Tn([
      Ka(J(it(e), { size: 32 })),
      ...r
    ])
  };
}
function WH(t, { param: e }) {
  let n = !1;
  const r = [];
  for (let s = 0; s < e.components.length; s++) {
    const a = e.components[s], i = Array.isArray(t) ? s : a.name, o = fw({
      param: a,
      value: t[i]
    });
    r.push(o), o.dynamic && (n = !0);
  }
  return {
    dynamic: n,
    encoded: n ? pw(r) : Tn(r.map(({ encoded: s }) => s))
  };
}
function hw(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function E3(t, e) {
  const n = typeof e == "string" ? Cn(e) : e, r = Z1(n);
  if (it(n) === 0 && t.length > 0)
    throw new uw();
  if (it(e) && it(e) < 32)
    throw new DL({
      data: typeof e == "string" ? e : Jt(e),
      params: t,
      size: it(e)
    });
  let s = 0;
  const a = [];
  for (let i = 0; i < t.length; ++i) {
    const o = t[i];
    r.setPosition(s);
    const [c, u] = wc(r, o, {
      staticPosition: 0
    });
    s += u, a.push(c);
  }
  return a;
}
function wc(t, e, { staticPosition: n }) {
  const r = hw(e.type);
  if (r) {
    const [s, a] = r;
    return JH(t, { ...e, type: a }, { length: s, staticPosition: n });
  }
  if (e.type === "tuple")
    return e_(t, e, { staticPosition: n });
  if (e.type === "address")
    return QH(t);
  if (e.type === "bool")
    return XH(t);
  if (e.type.startsWith("bytes"))
    return ZH(t, e, { staticPosition: n });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return YH(t, e);
  if (e.type === "string")
    return t_(t, { staticPosition: n });
  throw new zL(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const E2 = 32, Mb = 32;
function QH(t) {
  const e = t.readBytes(32);
  return [am(Jt(Jv(e, -20))), 32];
}
function JH(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const i = _s(t.readBytes(Mb)), o = r + i, c = o + E2;
    t.setPosition(o);
    const u = _s(t.readBytes(E2)), l = xd(e);
    let d = 0;
    const p = [];
    for (let f = 0; f < u; ++f) {
      t.setPosition(c + (l ? f * 32 : d));
      const [b, y] = wc(t, e, {
        staticPosition: c
      });
      d += y, p.push(b);
    }
    return t.setPosition(r + 32), [p, 32];
  }
  if (xd(e)) {
    const i = _s(t.readBytes(Mb)), o = r + i, c = [];
    for (let u = 0; u < n; ++u) {
      t.setPosition(o + u * 32);
      const [l] = wc(t, e, {
        staticPosition: o
      });
      c.push(l);
    }
    return t.setPosition(r + 32), [c, 32];
  }
  let s = 0;
  const a = [];
  for (let i = 0; i < n; ++i) {
    const [o, c] = wc(t, e, {
      staticPosition: r + s
    });
    s += c, a.push(o);
  }
  return [a, s];
}
function XH(t) {
  return [LH(t.readBytes(32), { size: 32 }), 32];
}
function ZH(t, e, { staticPosition: n }) {
  const [r, s] = e.type.split("bytes");
  if (!s) {
    const i = _s(t.readBytes(32));
    t.setPosition(n + i);
    const o = _s(t.readBytes(32));
    if (o === 0)
      return t.setPosition(n + 32), ["0x", 32];
    const c = t.readBytes(o);
    return t.setPosition(n + 32), [Jt(c), 32];
  }
  return [Jt(t.readBytes(Number.parseInt(s), 32)), 32];
}
function YH(t, e) {
  const n = e.type.startsWith("int"), r = Number.parseInt(e.type.split("int")[1] || "256"), s = t.readBytes(32);
  return [
    r > 48 ? MH(s, { signed: n }) : _s(s, { signed: n }),
    32
  ];
}
function e_(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: i }) => !i), s = r ? [] : {};
  let a = 0;
  if (xd(e)) {
    const i = _s(t.readBytes(Mb)), o = n + i;
    for (let c = 0; c < e.components.length; ++c) {
      const u = e.components[c];
      t.setPosition(o + a);
      const [l, d] = wc(t, u, {
        staticPosition: o
      });
      a += d, s[r ? c : u == null ? void 0 : u.name] = l;
    }
    return t.setPosition(n + 32), [s, 32];
  }
  for (let i = 0; i < e.components.length; ++i) {
    const o = e.components[i], [c, u] = wc(t, o, {
      staticPosition: n
    });
    s[r ? i : o == null ? void 0 : o.name] = c, a += u;
  }
  return [s, a];
}
function t_(t, { staticPosition: e }) {
  const n = _s(t.readBytes(32)), r = e + n;
  t.setPosition(r);
  const s = _s(t.readBytes(32));
  if (s === 0)
    return t.setPosition(e + 32), ["", 32];
  const a = t.readBytes(s, 32), i = HH(Gs(a));
  return t.setPosition(e + 32), [i, 32];
}
function xd(t) {
  var r;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (r = t.components) == null ? void 0 : r.some(xd);
  const n = hw(t.type);
  return !!(n && xd({ ...t, type: n[1] }));
}
function x3(t) {
  const { abi: e, data: n } = t, r = gd(n, 0, 4);
  if (r === "0x")
    throw new uw();
  const a = [...e || [], PL, UL].find((i) => i.type === "error" && r === dw(Ll(i)));
  if (!a)
    throw new s3(r, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: a,
    args: "inputs" in a && a.inputs && a.inputs.length > 0 ? E3(a.inputs, gd(n, 4)) : void 0,
    errorName: a.name
  };
}
const Zl = (t, e, n) => JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() : s, n);
function A3({ abiItem: t, args: e, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${n ? t.name : ""}(${t.inputs.map((s, a) => `${r && s.name ? `${s.name}: ` : ""}${typeof e[a] == "object" ? Zl(e[a]) : e[a]}`).join(", ")})`;
}
const n_ = g3;
function mw(t) {
  const { abi: e, args: n = [], name: r } = t, s = Wl(r, { strict: !1 }), a = e.filter((o) => s ? o.type === "function" ? dw(o) === r : o.type === "event" ? n_(o) === r : !1 : "name" in o && o.name === r);
  if (a.length === 0)
    return;
  if (a.length === 1)
    return a[0];
  let i;
  for (const o of a) {
    if (!("inputs" in o))
      continue;
    if (!n || n.length === 0) {
      if (!o.inputs || o.inputs.length === 0)
        return o;
      continue;
    }
    if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== n.length)
      continue;
    if (n.every((u, l) => {
      const d = "inputs" in o && o.inputs[l];
      return d ? Lb(u, d) : !1;
    })) {
      if (i && "inputs" in i && i.inputs) {
        const u = k3(o.inputs, i.inputs, n);
        if (u)
          throw new _L({
            abiItem: o,
            type: u[0]
          }, {
            abiItem: i,
            type: u[1]
          });
      }
      i = o;
    }
  }
  return i || a[0];
}
function Lb(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return ze(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => Lb(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => Lb(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function k3(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return k3(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? ze(n[r], { strict: !1 }) : i.includes("address") && i.includes("bytes") ? ze(n[r], { strict: !1 }) : !1)
      return i;
  }
}
class r_ extends H {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class s_ extends H {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function x2(t) {
  return t.reduce((e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`, "");
}
function a_(t) {
  return t.reduce((e, { address: n, ...r }) => {
    let s = `${e}    ${n}:
`;
    return r.nonce && (s += `      nonce: ${r.nonce}
`), r.balance && (s += `      balance: ${r.balance}
`), r.code && (s += `      code: ${r.code}
`), r.state && (s += `      state:
`, s += x2(r.state)), r.stateDiff && (s += `      stateDiff:
`, s += x2(r.stateDiff)), s;
  }, `  State Override:
`).slice(0, -1);
}
const i_ = (t) => t, v3 = (t) => t;
class o_ extends H {
  constructor(e, { account: n, docsPath: r, chain: s, data: a, gas: i, gasPrice: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, to: d, value: p, stateOverride: f }) {
    var g;
    const b = n ? ir(n) : void 0;
    let y = nm({
      from: b == null ? void 0 : b.address,
      to: d,
      value: typeof p < "u" && `${J4(p)} ${((g = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : g.symbol) || "ETH"}`,
      data: a,
      gas: i,
      gasPrice: typeof o < "u" && `${Hs(o)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Hs(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Hs(u)} gwei`,
      nonce: l
    });
    f && (y += `
${a_(f)}`), super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Raw Call Arguments:",
        y
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class C3 extends H {
  constructor(e, { abi: n, args: r, contractAddress: s, docsPath: a, functionName: i, sender: o }) {
    const c = mw({ abi: n, args: r, name: i }), u = c ? A3({
      abiItem: c,
      args: r,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, l = c ? Ll(c, { includeName: !0 }) : void 0, d = nm({
      address: s && i_(s),
      function: l,
      args: u && u !== "()" && `${[...Array((i == null ? void 0 : i.length) ?? 0).keys()].map(() => " ").join("")}${u}`,
      sender: o
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${i}".`, {
      cause: e,
      docsPath: a,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        d && "Contract Call:",
        d
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = n, this.args = r, this.cause = e, this.contractAddress = s, this.functionName = i, this.sender = o;
  }
}
class T3 extends H {
  constructor({ abi: e, data: n, functionName: r, message: s }) {
    let a, i, o, c;
    if (n && n !== "0x")
      try {
        i = x3({ abi: e, data: n });
        const { abiItem: l, errorName: d, args: p } = i;
        if (d === "Error")
          c = p[0];
        else if (d === "Panic") {
          const [f] = p;
          c = BL[f];
        } else {
          const f = l ? Ll(l, { includeName: !0 }) : void 0, b = l && p ? A3({
            abiItem: l,
            args: p,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          o = [
            f ? `Error: ${f}` : "",
            b && b !== "()" ? `       ${[...Array((d == null ? void 0 : d.length) ?? 0).keys()].map(() => " ").join("")}${b}` : ""
          ];
        }
      } catch (l) {
        a = l;
      }
    else s && (c = s);
    let u;
    a instanceof s3 && (u = a.signature, o = [
      `Unable to decode signature "${u}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`
    ]), super(c && c !== "execution reverted" || u ? [
      `The contract function "${r}" reverted with the following ${u ? "signature" : "reason"}:`,
      c || u
    ].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: a,
      metaMessages: o,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "raw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = i, this.raw = n, this.reason = c, this.signature = u;
  }
}
class S3 extends H {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class c_ extends H {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class I3 extends H {
  constructor({ data: e, message: n }) {
    super(n || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class lre extends H {
  constructor({ body: e, cause: n, details: r, headers: s, status: a, url: i }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        a && `Status: ${a}`,
        `URL: ${v3(i)}`,
        e && `Request body: ${Zl(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = s, this.status = a, this.url = i;
  }
}
class O3 extends H {
  constructor({ body: e, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${v3(r)}`, `Request body: ${Zl(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code, this.data = n.data;
  }
}
const l_ = -1;
class u_ extends H {
  constructor(e, { code: n, docsPath: r, metaMessages: s, name: a, shortMessage: i }) {
    super(i, {
      cause: e,
      docsPath: r,
      metaMessages: s || (e == null ? void 0 : e.metaMessages),
      name: a || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = a || e.name, this.code = e instanceof O3 ? e.code : n ?? l_;
  }
}
class om extends u_ {
  constructor(e) {
    super(e, {
      code: om.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(om, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
function d_(t, e) {
  const n = (t.details || "").toLowerCase(), r = t instanceof H ? t.walk((s) => (s == null ? void 0 : s.code) === oc.code) : t;
  return r instanceof H ? new oc({
    cause: t,
    message: r.details
  }) : oc.nodeMessage.test(n) ? new oc({
    cause: t,
    message: t.details
  }) : si.nodeMessage.test(n) ? new si({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : cb.nodeMessage.test(n) ? new cb({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : lb.nodeMessage.test(n) ? new lb({ cause: t, nonce: e == null ? void 0 : e.nonce }) : ub.nodeMessage.test(n) ? new ub({ cause: t, nonce: e == null ? void 0 : e.nonce }) : db.nodeMessage.test(n) ? new db({ cause: t, nonce: e == null ? void 0 : e.nonce }) : fb.nodeMessage.test(n) ? new fb({ cause: t }) : pb.nodeMessage.test(n) ? new pb({ cause: t, gas: e == null ? void 0 : e.gas }) : hb.nodeMessage.test(n) ? new hb({ cause: t, gas: e == null ? void 0 : e.gas }) : mb.nodeMessage.test(n) ? new mb({ cause: t }) : Fl.nodeMessage.test(n) ? new Fl({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new Gv({
    cause: t
  });
}
function B3(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = d_(t, n);
    return s instanceof Gv ? t : s;
  })();
  return new o_(r, {
    docsPath: e,
    ...n
  });
}
function P3(t, { format: e }) {
  if (!e)
    return {};
  const n = {};
  function r(a) {
    const i = Object.keys(a);
    for (const o of i)
      o in t && (n[o] = t[o]), a[o] && typeof a[o] == "object" && !Array.isArray(a[o]) && r(a[o]);
  }
  const s = e(t || {});
  return r(s), n;
}
function U3(t) {
  const { account: e, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: s, to: a } = t, i = e ? ir(e) : void 0;
  if (i && !ze(i.address))
    throw new ot({ address: i.address });
  if (a && !ze(a))
    throw new ot({ address: a });
  if (typeof n < "u" && (typeof r < "u" || typeof s < "u"))
    throw new X4();
  if (r && r > tf)
    throw new si({ maxFeePerGas: r });
  if (s && r && s > r)
    throw new Fl({ maxFeePerGas: r, maxPriorityFeePerGas: s });
}
async function f_(t, e) {
  var s, a, i;
  const { account: n = t.account } = e;
  if (!n)
    throw new Go();
  const r = ir(n);
  try {
    const { accessList: o, blockNumber: c, blockTag: u, data: l, gas: d, gasPrice: p, maxFeePerGas: f, maxPriorityFeePerGas: b, nonce: y, to: g, value: w, ...k } = e, T = (typeof c == "bigint" ? J(c) : void 0) || u;
    U3(e);
    const A = (i = (a = (s = t.chain) == null ? void 0 : s.formatters) == null ? void 0 : a.transactionRequest) == null ? void 0 : i.format, D = (A || J1)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...P3(k, { format: A }),
      from: r == null ? void 0 : r.address,
      accessList: o,
      data: l,
      gas: d,
      gasPrice: p,
      maxFeePerGas: f,
      maxPriorityFeePerGas: b,
      nonce: y,
      to: g,
      value: w
    }), { baseFeePerGas: P, gasLimit: C, priorityFeePerGas: S } = await t.request({
      method: "linea_estimateGas",
      params: T ? [D, T] : [D]
    });
    return {
      baseFeePerGas: BigInt(P),
      gasLimit: BigInt(C),
      priorityFeePerGas: BigInt(S)
    };
  } catch (o) {
    throw B3(o, {
      ...e,
      account: r,
      chain: t.chain
    });
  }
}
const yw = {
  fees: {
    estimateFeesPerGas: A2,
    async maxPriorityFeePerGas({ block: t, client: e, request: n }) {
      const r = await A2({
        block: t,
        client: e,
        multiply: (s) => s,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function A2({ client: t, multiply: e, request: n, type: r }) {
  try {
    const s = await f_(t, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: a } = s, o = e(BigInt(s.baseFeePerGas)) + a;
    return r === "legacy" ? { gasPrice: o } : {
      maxFeePerGas: o,
      maxPriorityFeePerGas: a
    };
  } catch {
    return null;
  }
}
const js = /* @__PURE__ */ h({
  ...yw,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x3aA974fb3f8C1E02796048BDCdeD79e9D53a6965",
      blockCreated: 6683e3
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !1
}), p_ = /* @__PURE__ */ h({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), rf = /* @__PURE__ */ h({
  ...yw,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x72560a31B3DAEE82B984a7F51c6b3b1bb7CC9F50",
      blockCreated: 2395255
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !0
}), h_ = /* @__PURE__ */ h({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), Vf = 1, Hb = /* @__PURE__ */ h({
  ...K,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [Vf]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [Vf]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [Vf]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: Vf
}), qf = 11155111, m_ = /* @__PURE__ */ h({
  ...K,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [qf]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [qf]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [qf]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: !0,
  sourceId: qf
}), y_ = /* @__PURE__ */ h({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), b_ = /* @__PURE__ */ h({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: !1
}), g_ = /* @__PURE__ */ h({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
}), w_ = /* @__PURE__ */ h({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: !0
}), E_ = /* @__PURE__ */ h({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: !1
}), x_ = /* @__PURE__ */ h({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: !0
}), A_ = /* @__PURE__ */ h({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: !1
}), k_ = /* @__PURE__ */ h({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: !0
}), v_ = /* @__PURE__ */ h({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
}), C_ = /* @__PURE__ */ h({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
}), $e = /* @__PURE__ */ h({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), T_ = /* @__PURE__ */ h({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: !0
}), _b = /* @__PURE__ */ h({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
}), S_ = /* @__PURE__ */ h({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: !0
}), I_ = /* @__PURE__ */ h({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: !0
}), $b = /* @__PURE__ */ h({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
}), O_ = /* @__PURE__ */ h({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: !0
}), B_ = /* @__PURE__ */ h({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: !0
}), P_ = /* @__PURE__ */ h({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: !1
}), U_ = /* @__PURE__ */ h({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
}), N_ = /* @__PURE__ */ h({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: !0
}), R_ = /* @__PURE__ */ h({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: !1
}), D_ = /* @__PURE__ */ h({
  id: 6342,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), F_ = /* @__PURE__ */ h({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: !0
}), M_ = /* @__PURE__ */ h({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
}), L_ = /* @__PURE__ */ h({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
}), H_ = /* @__PURE__ */ h({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
}), __ = /* @__PURE__ */ h({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: !0
}), $_ = /* @__PURE__ */ h({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
}), G_ = /* @__PURE__ */ h({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: !0
}), z_ = /* @__PURE__ */ h({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: !1
}), Kf = 1, j_ = /* @__PURE__ */ h({
  ...K,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Kf]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [Kf]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [Kf]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: Kf
}), V_ = /* @__PURE__ */ h({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
}), q_ = /* @__PURE__ */ h({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
}), Gb = /* @__PURE__ */ h({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
}), K_ = /* @__PURE__ */ h({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
}), W_ = /* @__PURE__ */ h({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
}), Q_ = /* @__PURE__ */ h({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
}), J_ = /* @__PURE__ */ h({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: !0
}), zb = /* @__PURE__ */ h({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: !1
}), X_ = /* @__PURE__ */ h({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: !0
}), Z_ = /* @__PURE__ */ h({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: !0
}), Wf = 1, jb = /* @__PURE__ */ h({
  ...K,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [Wf]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [Wf]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [Wf]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: Wf
}), Qf = 11155111, Y_ = /* @__PURE__ */ h({
  ...K,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Qf]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [Qf]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [Qf]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: !0,
  sourceId: Qf
}), e$ = /* @__PURE__ */ h({
  id: 10143,
  name: "Monad Testnet",
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: !0
}), t$ = /* @__PURE__ */ h({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: !0
}), n$ = /* @__PURE__ */ h({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: !1
}), r$ = /* @__PURE__ */ h({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
}), s$ = /* @__PURE__ */ h({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: !1
}), Vb = /* @__PURE__ */ h({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3654913
    }
  },
  testnet: !1
}), a$ = /* @__PURE__ */ h({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: !0
}), i$ = /* @__PURE__ */ h({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: !0
}), o$ = /* @__PURE__ */ h({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: !1
}), c$ = /* @__PURE__ */ h({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
}), l$ = /* @__PURE__ */ h({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: !1
}), u$ = /* @__PURE__ */ h({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: !0
}), d$ = /* @__PURE__ */ h({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: !0
}), f$ = /* @__PURE__ */ h({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: !1
}), p$ = /* @__PURE__ */ h({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: !1
}), h$ = /* @__PURE__ */ h({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: !0
}), m$ = /* @__PURE__ */ h({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: !1
}), y$ = /* @__PURE__ */ h({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
}), b$ = /* @__PURE__ */ h({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
}), g$ = /* @__PURE__ */ h({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
}), w$ = /* @__PURE__ */ h({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: !0
}), E$ = /* @__PURE__ */ h({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
}), x$ = /* @__PURE__ */ h({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: !0
}), A$ = /* @__PURE__ */ h({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
}), k$ = /* @__PURE__ */ h({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: !1
}), v$ = h({
  id: 166,
  name: "Omni",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.omni.network"],
      webSocket: ["wss://mainnet.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "OmniScan",
      url: "https://omniscan.network"
    }
  },
  testnet: !1
}), C$ = /* @__PURE__ */ h({
  id: 164,
  name: "Omni Omega",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://omega.omni.network"],
      webSocket: ["wss://omega.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Omega OmniScan",
      url: "https://omega.omniscan.network/"
    }
  },
  testnet: !0
}), T$ = /* @__PURE__ */ h({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: !1
}), S$ = /* @__PURE__ */ h({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
}), Jf = 56, qb = /* @__PURE__ */ h({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [Jf]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [Jf]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [Jf]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: Jf
}), Xf = 97, I$ = /* @__PURE__ */ h({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [Xf]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [Xf]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [Xf]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: !0,
  sourceId: Xf
}), mu = 1, Pt = /* @__PURE__ */ h({
  ...K,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [mu]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [mu]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [mu]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [mu]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: mu
}), Zf = 5, O$ = /* @__PURE__ */ h({
  ...K,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [Zf]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [Zf]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [Zf]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: !0,
  sourceId: Zf
}), yu = 11155111, oi = /* @__PURE__ */ h({
  ...K,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [yu]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [yu]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [yu]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [yu]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: !0,
  sourceId: yu
}), B$ = /* @__PURE__ */ h({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: !1
}), P$ = /* @__PURE__ */ h({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: !0
}), U$ = /* @__PURE__ */ h({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: !1
}), N$ = /* @__PURE__ */ h({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: !0
}), R$ = /* @__PURE__ */ h({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
}), D$ = /* @__PURE__ */ h({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
}), F$ = /* @__PURE__ */ h({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: !0
}), M$ = /* @__PURE__ */ h({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://peaq-rpc.publicnode.com",
        "https://peaq.api.onfinality.io/public",
        "https://peaq-rpc.dwellir.com",
        "https://evm.peaq.network"
      ],
      webSocket: [
        "wss://peaq-rpc.publicnode.com",
        "wss://peaq.api.onfinality.io/public",
        "wss://peaq-rpc.dwellir.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
}), Yf = 1, L$ = /* @__PURE__ */ h({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [Yf]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [Yf]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [Yf]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: cw,
  sourceId: Yf
}), ep = 11155111, H$ = /* @__PURE__ */ h({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [ep]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [ep]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [ep]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: cw,
  sourceId: ep,
  testnet: !0
}), _$ = /* @__PURE__ */ h({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
}), $$ = /* @__PURE__ */ h({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: !1
}), G$ = /* @__PURE__ */ h({
  id: 9746,
  name: "Plasma Testnet",
  nativeCurrency: {
    name: "Testnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "RouteScan",
      url: "https://testnet.plasmaexplorer.io"
    }
  },
  testnet: !0
}), z$ = /* @__PURE__ */ h({
  ...Ln,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: !0
}), j$ = /* @__PURE__ */ h({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
}), V$ = 1, Kb = /* @__PURE__ */ h({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: V$
}), q$ = 11155111, K$ = /* @__PURE__ */ h({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: !0,
  sourceId: q$
}), W$ = 1, Q$ = /* @__PURE__ */ h({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: W$
}), J$ = 11155111, X$ = /* @__PURE__ */ h({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: !0,
  sourceId: J$
}), Z$ = 11155111, Y$ = /* @__PURE__ */ h({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: !0,
  sourceId: Z$
}), eG = /* @__PURE__ */ h({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: !0
}), ft = /* @__PURE__ */ h({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
}), ci = /* @__PURE__ */ h({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: !0
}), tG = /* @__PURE__ */ h({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
}), Wb = /* @__PURE__ */ h({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
}), nG = /* @__PURE__ */ h({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
}), rG = /* @__PURE__ */ h({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
}), sG = /* @__PURE__ */ h({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: !1,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), aG = /* @__PURE__ */ h({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), iG = /* @__PURE__ */ h({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: !0
}), oG = /* @__PURE__ */ h({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: !1,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://ipfs.scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), cG = /* @__PURE__ */ h({
  id: 943,
  name: "PulseChain V4",
  testnet: !0,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), lG = /* @__PURE__ */ h({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: !0
}), k2 = 11155111, uG = h({
  ...K,
  name: "Pyrope Testnet",
  testnet: !0,
  id: 695569,
  sourceId: k2,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...K.contracts,
    l1StandardBridge: {
      [k2]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
}), dG = /* @__PURE__ */ h({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: !1
}), fG = /* @__PURE__ */ h({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
}), pG = /* @__PURE__ */ h({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: !0
}), hG = /* @__PURE__ */ h({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
}), mG = /* @__PURE__ */ h({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: !1
}), yG = /* @__PURE__ */ h({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: !0
}), tp = 1, Qb = h({
  ...K,
  name: "Redstone",
  id: 690,
  sourceId: tp,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [tp]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [tp]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [tp]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
}), bG = /* @__PURE__ */ h({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: !1
}), gG = /* @__PURE__ */ h({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: !1
}), wG = /* @__PURE__ */ h({
  id: 50342,
  name: "Reddio",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.reddio.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://reddio.cloud.blockscout.com",
      apiUrl: "https://reddio.cloud.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 848849
    }
  },
  testnet: !1
}), EG = /* @__PURE__ */ h({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: !0
}), xG = /* @__PURE__ */ h({
  id: 11155931,
  name: "RISE Testnet",
  nativeCurrency: { name: "RISE Testnet Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.riselabs.xyz"],
      webSocket: ["wss://testnet.riselabs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.testnet.riselabs.xyz/",
      apiUrl: "https://explorer.testnet.riselabs.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  },
  testnet: !0
}), AG = /* @__PURE__ */ h({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), kG = /* @__PURE__ */ h({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
}), vG = /* @__PURE__ */ h({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
}), Jb = /* @__PURE__ */ h({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
}), CG = /* @__PURE__ */ h({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
}), TG = /* @__PURE__ */ h({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: !0
}), SG = /* @__PURE__ */ h({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
}), IG = /* @__PURE__ */ h({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: !0
}), np = 1, OG = /* @__PURE__ */ h({
  ...K,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [np]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [np]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [np]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: np
}), rp = 11155111, BG = /* @__PURE__ */ h({
  ...K,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [rp]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [rp]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [rp]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: !0,
  sourceId: rp
}), PG = /* @__PURE__ */ h({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: !1
}), UG = /* @__PURE__ */ h({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
}), NG = /* @__PURE__ */ h({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: !0
}), Xb = /* @__PURE__ */ h({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: !1
}), RG = /* @__PURE__ */ h({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
}), DG = /* @__PURE__ */ h({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: !0
}), FG = /* @__PURE__ */ h({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
}), MG = /* @__PURE__ */ h({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: !0
}), Zb = /* @__PURE__ */ h({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: !1
}), LG = /* @__PURE__ */ h({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: !0
}), Yb = /* @__PURE__ */ h({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
}), HG = /* @__PURE__ */ h({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: !0
}), _G = /* @__PURE__ */ h({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: !0
}), $G = /* @__PURE__ */ h({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 98697651
    }
  },
  testnet: !0
}), ls = /* @__PURE__ */ h({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: !0
}), sp = 1, eg = /* @__PURE__ */ h({
  ...K,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [sp]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [sp]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [sp]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: sp
}), GG = 11155111, zG = /* @__PURE__ */ h({
  ...K,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: GG
}), jG = /* @__PURE__ */ h({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: !1
}), VG = /* @__PURE__ */ h({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: !0
}), qG = /* @__PURE__ */ h({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
}), KG = /* @__PURE__ */ h({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: !0
}), WG = /* @__PURE__ */ h({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: !1
}), QG = /* @__PURE__ */ h({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
}), JG = /* @__PURE__ */ h({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: !0
}), XG = /* @__PURE__ */ h({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
}), ZG = /* @__PURE__ */ h({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
}), YG = /* @__PURE__ */ h({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: !0
}), ez = /* @__PURE__ */ h({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: !1
}), tz = /* @__PURE__ */ h({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), nz = /* @__PURE__ */ h({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
}), rz = /* @__PURE__ */ h({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: !0
}), sz = /* @__PURE__ */ h({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), az = /* @__PURE__ */ h({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), iz = /* @__PURE__ */ h({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
}), oz = /* @__PURE__ */ h({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: !0
}), cz = /* @__PURE__ */ h({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), lz = /* @__PURE__ */ h({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), uz = /* @__PURE__ */ h({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
}), dz = /* @__PURE__ */ h({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: !0
}), fz = /* @__PURE__ */ h({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), pz = /* @__PURE__ */ h({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
}), hz = /* @__PURE__ */ h({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: !0
}), mz = /* @__PURE__ */ h({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: !0
}), bu = 1, yz = /* @__PURE__ */ h({
  ...K,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [bu]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [bu]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [bu]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [bu]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: bu
}), gu = 11155111, bz = /* @__PURE__ */ h({
  ...K,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [gu]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [gu]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [gu]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [gu]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: !0,
  sourceId: gu
}), gz = /* @__PURE__ */ h({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://shannon-explorer.somnia.network/",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x841b8199E6d3Db3C6f264f6C2bd8848b3cA64223",
      blockCreated: 71314235
    }
  },
  testnet: !0
}), wu = 1, Po = /* @__PURE__ */ h({
  ...K,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [wu]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [wu]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [wu]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [wu]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: wu
}), Eu = 11155111, ah = /* @__PURE__ */ h({
  ...K,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [Eu]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [Eu]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [Eu]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [Eu]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: Eu
}), tg = /* @__PURE__ */ h({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: !1
}), wz = /* @__PURE__ */ h({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: !0
}), Ez = /* @__PURE__ */ h({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: !0
}), xz = /* @__PURE__ */ h({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
}), Az = /* @__PURE__ */ h({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: !0
}), kz = /* @__PURE__ */ h({
  ...Ln,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: !1
}), vz = /* @__PURE__ */ h({
  ...Ln,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: !0
}), Cz = /* @__PURE__ */ h({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: !0
}), v2 = /* @__PURE__ */ h({
  ...yw,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: !0
}), Tz = /* @__PURE__ */ h({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: !1
}), ng = /* @__PURE__ */ h({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.xyz",
      apiUrl: "https://storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !1
}), Sz = /* @__PURE__ */ h({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.xyz",
      apiUrl: "https://aeneid.storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !0
}), Iz = /* @__PURE__ */ h({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: !0
}), Oz = /* @__PURE__ */ h({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: !0
}), Bz = /* @__PURE__ */ h({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
}), Pz = /* @__PURE__ */ h({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: !1
}), rg = /* @__PURE__ */ h({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: !1
}), xu = 1, sg = /* @__PURE__ */ h({
  ...K,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...K.contracts,
    disputeGameFactory: {
      [xu]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [xu]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [xu]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [xu]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: xu
}), R0 = 11155111, Uz = /* @__PURE__ */ h({
  ...K,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [R0]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [R0]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: !0,
  sourceId: R0
}), Nz = /* @__PURE__ */ h({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: !1
}), Rz = /* @__PURE__ */ h({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io	"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: !0
}), Dz = /* @__PURE__ */ h({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: !0
}), ag = /* @__PURE__ */ h({
  ...K,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), Fz = /* @__PURE__ */ h({
  ...K,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), Mz = /* @__PURE__ */ h({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: !1
}), Lz = /* @__PURE__ */ h({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
}), Hz = /* @__PURE__ */ h({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
}), _z = /* @__PURE__ */ h({
  id: 239,
  name: "TAC",
  nativeCurrency: { name: "TAC", symbol: "TAC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/tac"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://tac.blockscout.com",
      apiUrl: "https://tac.blockscout.com/api"
    },
    native: {
      name: "TAC Explorer",
      url: "https://explorer.tac.build",
      apiUrl: "https://explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), $z = /* @__PURE__ */ h({
  id: 2391,
  name: "TAC SPB Testnet",
  nativeCurrency: {
    name: "TAC",
    symbol: "TAC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://spb.rpc.tac.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "TAC",
      url: "https://spb.explorer.tac.build",
      apiUrl: "https://spb.explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 471429
    }
  },
  testnet: !0
}), ig = /* @__PURE__ */ h({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
}), Gz = /* @__PURE__ */ h({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: !0
}), zz = /* @__PURE__ */ h({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: !0
}), jz = /* @__PURE__ */ h({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
}), Vz = /* @__PURE__ */ h({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
}), qz = /* @__PURE__ */ h({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
}), Kz = /* @__PURE__ */ h({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: !0
}), Wz = /* @__PURE__ */ h({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: !0
}), Qz = /* @__PURE__ */ h({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
}), Jz = /* @__PURE__ */ h({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: !0
}), Xz = /* @__PURE__ */ h({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: !1
}), Zz = /* @__PURE__ */ h({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: !1
}), Yz = /* @__PURE__ */ h({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: !1
}), ej = /* @__PURE__ */ h({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: !1
}), tj = /* @__PURE__ */ h({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: !1
}), nj = /* @__PURE__ */ h({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: !0
}), rj = /* @__PURE__ */ h({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), sj = /* @__PURE__ */ h({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: !0
}), aj = /* @__PURE__ */ h({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: !0
}), ij = /* @__PURE__ */ h({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: !1
}), oj = /* @__PURE__ */ h({
  ...Ln,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: !1
}), cj = /* @__PURE__ */ h({
  ...Ln,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: !0
}), og = /* @__PURE__ */ h({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
}), lj = /* @__PURE__ */ h({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: !0
}), uj = /* @__PURE__ */ h({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: !1
}), dj = /* @__PURE__ */ h({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
}), fj = /* @__PURE__ */ h({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: !0
}), pj = /* @__PURE__ */ h({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: !1
}), hj = /* @__PURE__ */ h({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: !0
}), ap = 1, Vs = /* @__PURE__ */ h({
  ...K,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [ap]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [ap]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [ap]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: ap
}), ip = 11155111, sf = /* @__PURE__ */ h({
  ...K,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [ip]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [ip]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [ip]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: !0,
  sourceId: ip
}), mj = /* @__PURE__ */ h({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
}), yj = /* @__PURE__ */ h({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: !0
}), bj = /* @__PURE__ */ h({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
}), gj = /* @__PURE__ */ h({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
}), wj = /* @__PURE__ */ h({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: !1
}), Ej = /* @__PURE__ */ h({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
}), xj = /* @__PURE__ */ h({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: !1
}), Aj = /* @__PURE__ */ h({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: !1
}), kj = /* @__PURE__ */ h({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: !0
}), vj = /* @__PURE__ */ h({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: !1
}), Cj = /* @__PURE__ */ h({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: !0
}), Tj = /* @__PURE__ */ h({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
}), Sj = /* @__PURE__ */ h({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: !0
}), Ij = /* @__PURE__ */ h({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: !0
}), Oj = /* @__PURE__ */ h({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
}), Bj = /* @__PURE__ */ h({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: !0
}), Pj = /* @__PURE__ */ h({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: !0
}), Uj = /* @__PURE__ */ h({
  testnet: !1,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
}), Nj = /* @__PURE__ */ h({
  testnet: !0,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
}), Rj = /* @__PURE__ */ h({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: !0
}), Au = 1, qs = /* @__PURE__ */ h({
  ...K,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [Au]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [Au]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [Au]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [Au]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: !1,
  sourceId: Au
}), ku = 11155111, af = /* @__PURE__ */ h({
  ...K,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [ku]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [ku]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [ku]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [ku]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: !0,
  sourceId: ku
}), Dj = /* @__PURE__ */ h({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: !1
}), Uo = /* @__PURE__ */ h({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: !1
}), ih = /* @__PURE__ */ h({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: !0
}), Fj = /* @__PURE__ */ h({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
}), Mj = /* @__PURE__ */ h({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
}), Lj = /* @__PURE__ */ h({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
}), C2 = /* @__PURE__ */ h({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: !0
}), Hj = /* @__PURE__ */ h({
  id: 20250217,
  name: "Xphere Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "XP",
    symbol: "XP"
  },
  rpcUrls: {
    default: {
      http: ["https://en-bkk.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xp.tamsa.io"
    }
  },
  testnet: !1
}), _j = /* @__PURE__ */ h({
  id: 1998991,
  name: "Xphere Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "XPT",
    symbol: "XPT"
  },
  rpcUrls: {
    default: {
      http: ["http://testnet.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xpt.tamsa.io"
    }
  },
  testnet: !0
}), $j = /* @__PURE__ */ h({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), Gj = /* @__PURE__ */ h({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: !0
}), zj = /* @__PURE__ */ h({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: !0
}), jj = /* @__PURE__ */ h({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: !0
}), Vj = /* @__PURE__ */ h({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
}), qj = /* @__PURE__ */ h({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: !0
}), Kj = /* @__PURE__ */ h({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: !0
}), Wj = /* @__PURE__ */ h({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: !1
}), cg = /* @__PURE__ */ h({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: !0
}), Qj = /* @__PURE__ */ h({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: !1
}), Jj = /* @__PURE__ */ h({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://explorer.zetachain.com"
    }
  },
  testnet: !1
}), Xj = /* @__PURE__ */ h({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://athens.explorer.zetachain.com"
    }
  },
  testnet: !0
}), Zj = /* @__PURE__ */ h({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: !0
}), Yj = /* @__PURE__ */ h({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: !1
}), eV = /* @__PURE__ */ h({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: !0
}), D0 = 1, lg = /* @__PURE__ */ h({
  ...K,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [D0]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [D0]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [D0]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: !1
}), F0 = 11155111, tV = /* @__PURE__ */ h({
  ...K,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [F0]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [F0]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [F0]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: !0
}), M0 = 11155111, nV = /* @__PURE__ */ h({
  ...K,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [M0]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [M0]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [M0]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: !0
}), rV = /* @__PURE__ */ h({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: !1
}), sV = /* @__PURE__ */ h({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: !0
}), aV = /* @__PURE__ */ h({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
}), iV = /* @__PURE__ */ h({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
}), oh = /* @__PURE__ */ h({
  ...Ln,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
}), T2 = /* @__PURE__ */ h({
  ...Ln,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: !0
}), oV = /* @__PURE__ */ h({
  ...Ln,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), cV = /* @__PURE__ */ h({
  ...Ln,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), lV = /* @__PURE__ */ h({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: !0
}), S2 = /* @__PURE__ */ h({
  ...Ln,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: !0
}), I2 = /* @__PURE__ */ h({
  ...Ln,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: !0
}), op = 1, ch = /* @__PURE__ */ h({
  ...K,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [op]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [op]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [op]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: op
}), cp = 11155111, uV = /* @__PURE__ */ h({
  ...K,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...K.contracts,
    l2OutputOracle: {
      [cp]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [cp]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [cp]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: cp,
  testnet: !0
}), O2 = 5, dV = /* @__PURE__ */ h({
  ...K,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...K.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [O2]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: O2,
  testnet: !0
}), cm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abey: I4,
  abstract: yb,
  abstractTestnet: pN,
  acala: hN,
  acria: mN,
  adf: yN,
  aioz: bN,
  alephZero: gN,
  alephZeroTestnet: wN,
  alienx: EN,
  alienxHalTestnet: xN,
  ancient8: bb,
  ancient8Sepolia: TN,
  anvil: SN,
  apeChain: So,
  apexTestnet: ON,
  arbitrum: ut,
  arbitrumGoerli: BN,
  arbitrumNova: ai,
  arbitrumSepolia: cs,
  arenaz: gb,
  areonNetwork: UN,
  areonNetworkTestnet: NN,
  areum: PN,
  artelaTestnet: RN,
  arthera: DN,
  artheraTestnet: FN,
  assetChain: MN,
  assetChainTestnet: LN,
  astar: HN,
  astarZkEVM: _N,
  astarZkyoto: $N,
  atletaOlympia: GN,
  aurora: zN,
  auroraTestnet: jN,
  auroria: VN,
  autheoTestnet: qN,
  avalanche: pn,
  avalancheFuji: ii,
  b3: Io,
  b3Sepolia: Yp,
  bahamut: QN,
  base: At,
  baseGoerli: t3,
  basePreconf: JN,
  baseSepolia: zs,
  baseSepoliaPreconf: ZN,
  basecampTestnet: XN,
  beam: YN,
  beamTestnet: eR,
  bearNetworkChainMainnet: tR,
  bearNetworkChainTestnet: nR,
  berachain: wb,
  berachainBepolia: rR,
  berachainTestnet: sR,
  berachainTestnetbArtio: aR,
  bevmMainnet: iR,
  bifrost: oR,
  birdlayer: yR,
  bitTorrent: hR,
  bitTorrentTestnet: mR,
  bitgert: cR,
  bitkub: lR,
  bitkubTestnet: uR,
  bitlayer: dR,
  bitlayerTestnet: fR,
  bitrock: pR,
  blast: Ml,
  blastSepolia: eh,
  bob: Eb,
  bobSepolia: wR,
  boba: xb,
  bobaSepolia: gR,
  boolBetaMainnet: ER,
  botanixTestnet: xR,
  bounceBit: AR,
  bounceBitTestnet: kR,
  bronos: vR,
  bronosTestnet: CR,
  bsc: wd,
  bscGreenfield: TR,
  bscTestnet: th,
  bsquared: SR,
  bsquaredTestnet: IR,
  btr: OR,
  btrTestnet: BR,
  bxn: PR,
  bxnTestnet: UR,
  cannon: NR,
  canto: RR,
  celo: Ab,
  celoAlfajores: VR,
  celoSepolia: qR,
  chang: KR,
  chiliz: WR,
  chips: QR,
  citreaTestnet: JR,
  classic: XR,
  coinbit: ZR,
  coinex: YR,
  confluxESpace: eD,
  confluxESpaceTestnet: tD,
  coreDao: nD,
  coreTestnet1: rD,
  coreTestnet2: sD,
  corn: kb,
  cornTestnet: oD,
  crab: cD,
  creatorTestnet: lD,
  creditCoin3Mainnet: uD,
  creditCoin3Testnet: dD,
  cronos: vb,
  cronosTestnet: fD,
  cronoszkEVM: pD,
  cronoszkEVMTestnet: hD,
  crossbell: mD,
  curtis: yD,
  cyber: Cb,
  cyberTestnet: bD,
  dailyNetwork: gD,
  dailyNetworkTestnet: wD,
  darwinia: ED,
  dbkchain: xD,
  dchain: AD,
  dchainTestnet: kD,
  defichainEvm: vD,
  defichainEvmTestnet: CD,
  degen: Tb,
  dfk: TD,
  diode: SD,
  disChain: ID,
  dodochainTestnet: OD,
  dogechain: BD,
  donatuz: PD,
  dosChain: UD,
  dosChainTestnet: ND,
  dreyerxMainnet: RD,
  dreyerxTestnet: FD,
  dustboyIoT: MD,
  dymension: LD,
  edexa: _D,
  edexaTestnet: HD,
  edgeless: $D,
  edgelessTestnet: GD,
  edgeware: zD,
  edgewareTestnet: jD,
  eduChain: VD,
  eduChainTestnet: qD,
  ekta: KD,
  ektaTestnet: WD,
  elastos: QD,
  elastosTestnet: JD,
  electroneum: XD,
  electroneumTestnet: ZD,
  elysiumTestnet: YD,
  energy: eF,
  enuls: tF,
  eon: nF,
  eos: rF,
  eosTestnet: sF,
  etherlink: aF,
  etherlinkTestnet: iF,
  ethernity: oF,
  etp: cF,
  evmos: lF,
  evmosTestnet: uF,
  excelonMainnet: dF,
  expanse: fF,
  exsat: pF,
  exsatTestnet: hF,
  fantom: mF,
  fantomSonicTestnet: yF,
  fantomTestnet: bF,
  fibo: gF,
  filecoin: wF,
  filecoinCalibration: EF,
  filecoinHyperspace: xF,
  fireChain: AF,
  flame: kF,
  flare: vF,
  flareTestnet: CF,
  flowMainnet: Sb,
  flowPreviewnet: TF,
  flowTestnet: SF,
  fluence: IF,
  fluenceStage: OF,
  fluenceTestnet: BF,
  fluentTestnet: PF,
  form: UF,
  formTestnet: RF,
  forma: Ib,
  formicarium: NF,
  forta: DF,
  foundry: FF,
  fraxtal: MF,
  fraxtalTestnet: LF,
  funkiMainnet: Ob,
  funkiSepolia: $F,
  fuse: GF,
  fuseSparknet: zF,
  fusion: jF,
  fusionTestnet: VF,
  garnet: qF,
  geist: KF,
  genesys: WF,
  glideL1Protocol: QF,
  glideL2Protocol: JF,
  gnosis: Oo,
  gnosisChiado: nh,
  goChain: YF,
  goat: XF,
  gobi: ZF,
  godwoken: eM,
  goerli: tM,
  graphite: nM,
  graphiteTestnet: rM,
  gravity: Bb,
  gunz: sM,
  guruNetwork: aM,
  guruTestnet: iM,
  ham: oM,
  happychainTestnet: cM,
  haqqMainnet: lM,
  haqqTestedge2: uM,
  hardhat: dM,
  harmonyOne: fM,
  hashkey: pM,
  hashkeyTestnet: hM,
  haustTestnet: mM,
  hedera: yM,
  hederaPreviewnet: bM,
  hederaTestnet: gM,
  hela: wM,
  hemi: Pb,
  hemiSepolia: EM,
  holesky: xM,
  hoodi: AM,
  hpb: kM,
  huddle01Mainnet: CM,
  huddle01Testnet: SM,
  humanityTestnet: IM,
  humanode: OM,
  humanodeTestnet5: BM,
  hychain: Ub,
  hychainTestnet: PM,
  iSunCoin: zM,
  idchain: UM,
  immutableZkEvm: NM,
  immutableZkEvmTestnet: RM,
  inEVM: DM,
  initVerse: FM,
  initVerseGenesis: MM,
  ink: Nb,
  inkSepolia: LM,
  iota: HM,
  iotaTestnet: _M,
  iotex: $M,
  iotexTestnet: GM,
  jbc: jM,
  jbcTestnet: VM,
  jocMainnet: qM,
  jocTestnet: KM,
  juneo: WM,
  juneoBCH1Chain: QM,
  juneoDAI1Chain: JM,
  juneoDOGE1Chain: XM,
  juneoEUR1Chain: ZM,
  juneoGLD1Chain: YM,
  juneoLINK1Chain: eL,
  juneoLTC1Chain: tL,
  juneoSGD1Chain: rL,
  juneoSocotraTestnet: sL,
  juneoUSD1Chain: aL,
  juneoUSDT1Chain: iL,
  juneomBTC1Chain: nL,
  kaia: yL,
  kairos: bL,
  kakarotSepolia: cL,
  kakarotStarknetSepolia: lL,
  kardiaChain: uL,
  karura: oL,
  kava: dL,
  kavaTestnet: fL,
  kcc: pL,
  kinto: hL,
  klaytn: mL,
  klaytnBaobab: gL,
  koi: wL,
  kroma: EL,
  kromaSepolia: xL,
  l3x: AL,
  l3xTestnet: kL,
  lavita: vL,
  lens: CL,
  lensTestnet: TL,
  lestnet: SL,
  lightlinkPegasus: IL,
  lightlinkPhoenix: OL,
  linea: js,
  lineaGoerli: p_,
  lineaSepolia: rf,
  lineaTestnet: h_,
  lisk: Hb,
  liskSepolia: m_,
  localhost: y_,
  loop: b_,
  lukso: g_,
  luksoTestnet: w_,
  lumiaMainnet: E_,
  lumiaTestnet: x_,
  lumoz: A_,
  lumozTestnet: k_,
  lycan: v_,
  lyra: C_,
  mainnet: $e,
  mandala: T_,
  manta: _b,
  mantaSepoliaTestnet: S_,
  mantaTestnet: I_,
  mantle: $b,
  mantleSepoliaTestnet: O_,
  mantleTestnet: B_,
  mapProtocol: P_,
  matchain: U_,
  matchainTestnet: N_,
  mchVerse: R_,
  megaethTestnet: D_,
  mekong: F_,
  meld: M_,
  memecore: L_,
  merlin: H_,
  merlinErigonTestnet: __,
  metachain: $_,
  metachainIstanbul: G_,
  metadium: z_,
  metalL2: j_,
  meter: V_,
  meterTestnet: q_,
  metis: Gb,
  metisGoerli: W_,
  metisSepolia: K_,
  mev: Q_,
  mevTestnet: J_,
  mint: zb,
  mintSepoliaTestnet: X_,
  mitosisTestnet: Z_,
  mode: jb,
  modeTestnet: Y_,
  monadTestnet: e$,
  moonbaseAlpha: t$,
  moonbeam: n$,
  moonbeamDev: r$,
  moonriver: s$,
  morph: Vb,
  morphHolesky: a$,
  morphSepolia: i$,
  nahmii: o$,
  nautilus: c$,
  near: l$,
  nearTestnet: u$,
  neonDevnet: d$,
  neonMainnet: f$,
  neoxMainnet: p$,
  neoxT4: h$,
  newton: m$,
  nexi: y$,
  nexilix: b$,
  nibiru: g$,
  oasisTestnet: w$,
  oasys: E$,
  odysseyTestnet: x$,
  okc: A$,
  omax: k$,
  omni: v$,
  omniOmega: C$,
  oneWorld: T$,
  oortMainnetDev: S$,
  opBNB: qb,
  opBNBTestnet: I$,
  optimism: Pt,
  optimismGoerli: O$,
  optimismSepolia: oi,
  optopia: B$,
  optopiaTestnet: P$,
  orderly: U$,
  orderlySepolia: N$,
  otimDevnet: R$,
  palm: D$,
  palmTestnet: F$,
  peaq: M$,
  pgn: L$,
  pgnTestnet: H$,
  phoenix: _$,
  planq: $$,
  plasmaTestnet: G$,
  playfiAlbireo: z$,
  plinga: j$,
  plume: Kb,
  plumeDevnet: K$,
  plumeMainnet: Q$,
  plumeSepolia: X$,
  plumeTestnet: Y$,
  polterTestnet: eG,
  polygon: ft,
  polygonAmoy: ci,
  polygonMumbai: tG,
  polygonZkEvm: Wb,
  polygonZkEvmCardona: nG,
  polygonZkEvmTestnet: rG,
  polynomial: sG,
  polynomialSepolia: aG,
  premiumBlockTestnet: iG,
  pulsechain: oG,
  pulsechainV4: cG,
  pumpfiTestnet: lG,
  pyrope: uG,
  qMainnet: fG,
  qTestnet: pG,
  ql1: dG,
  real: hG,
  redbellyMainnet: mG,
  redbellyTestnet: yG,
  reddio: wG,
  reddioSepolia: EG,
  redstone: Qb,
  rei: bG,
  reyaNetwork: gG,
  riseTestnet: xG,
  rivalz: AG,
  rollux: kG,
  rolluxTestnet: vG,
  ronin: Jb,
  root: CG,
  rootPorcini: TG,
  rootstock: SG,
  rootstockTestnet: IG,
  rss3: OG,
  rss3Sepolia: BG,
  saakuru: PG,
  saga: UG,
  saigon: NG,
  sanko: Xb,
  sapphire: RG,
  sapphireTestnet: DG,
  satoshiVM: FG,
  satoshiVMTestnet: MG,
  scroll: Zb,
  scrollSepolia: LG,
  sei: Yb,
  seiDevnet: HG,
  seiTestnet: $G,
  seismicDevnet: _G,
  sepolia: ls,
  shape: eg,
  shapeSepolia: zG,
  shardeum: jG,
  shardeumSphinx: VG,
  shibarium: qG,
  shibariumTestnet: KG,
  shiden: WG,
  shimmer: QG,
  shimmerTestnet: JG,
  sidraChain: XG,
  silicon: ZG,
  siliconSepolia: YG,
  sixProtocol: ez,
  skaleBlockBrawlers: tz,
  skaleCalypso: nz,
  skaleCalypsoTestnet: rz,
  skaleCryptoBlades: sz,
  skaleCryptoColosseum: az,
  skaleEuropa: iz,
  skaleEuropaTestnet: oz,
  skaleExorde: cz,
  skaleHumanProtocol: lz,
  skaleNebula: uz,
  skaleNebulaTestnet: dz,
  skaleRazor: fz,
  skaleTitan: pz,
  skaleTitanTestnet: hz,
  sketchpad: mz,
  snax: yz,
  snaxTestnet: bz,
  somniaTestnet: gz,
  soneium: Po,
  soneiumMinato: ah,
  songbird: xz,
  songbirdTestnet: Az,
  sonic: tg,
  sonicBlazeTestnet: Ez,
  sonicTestnet: wz,
  sophon: kz,
  sophonTestnet: vz,
  spicy: Cz,
  statusNetworkSepolia: v2,
  statusSepolia: v2,
  step: Tz,
  story: ng,
  storyAeneid: Sz,
  storyOdyssey: Iz,
  storyTestnet: Oz,
  stratis: Bz,
  superlumio: Pz,
  superposition: rg,
  superseed: sg,
  superseedSepolia: Uz,
  swan: Nz,
  swanProximaTestnet: Rz,
  swanSaturnTestnet: Dz,
  swellchain: ag,
  swellchainTestnet: Fz,
  swissdlt: Mz,
  syscoin: Lz,
  syscoinTestnet: Hz,
  tac: _z,
  tacSPB: $z,
  taiko: ig,
  taikoHekla: Gz,
  taikoJolnir: zz,
  taikoKatla: jz,
  taikoTestnetSepolia: Vz,
  taraxa: qz,
  taraxaTestnet: Kz,
  telcoinTestnet: Wz,
  telos: Qz,
  telosTestnet: Jz,
  tenet: Xz,
  ternoa: Zz,
  thaiChain: Yz,
  that: ej,
  theta: tj,
  thetaTestnet: nj,
  thunderCore: rj,
  thunderTestnet: sj,
  tiktrixTestnet: aj,
  tomb: ij,
  treasure: oj,
  treasureTopaz: cj,
  tron: og,
  tronShasta: lj,
  ubiq: uj,
  ultra: dj,
  ultraTestnet: fj,
  ultron: pj,
  ultronTestnet: hj,
  unichain: Vs,
  unichainSepolia: sf,
  unique: mj,
  uniqueOpal: yj,
  uniqueQuartz: bj,
  unreal: gj,
  vanar: wj,
  vechain: Ej,
  velas: xj,
  viction: Aj,
  victionTestnet: kj,
  vision: vj,
  visionTestnet: Cj,
  wanchain: Tj,
  wanchainTestnet: Sj,
  weaveVMAlphanet: Ij,
  wemix: Oj,
  wemixTestnet: Bj,
  westendAssetHub: Pj,
  whitechain: Uj,
  whitechainTestnet: Nj,
  wmcTestnet: Rj,
  worldLand: Dj,
  worldchain: qs,
  worldchainSepolia: af,
  x1Testnet: C2,
  xLayer: Lj,
  xLayerTestnet: C2,
  xai: Uo,
  xaiTestnet: ih,
  xdc: Fj,
  xdcTestnet: Mj,
  xphereMainnet: Hj,
  xphereTestnet: _j,
  xrOne: $j,
  xrSepolia: jj,
  xrplevmDevnet: Gj,
  xrplevmTestnet: zj,
  yooldoVerse: Vj,
  yooldoVerseTestnet: qj,
  zenchainTestnet: Kj,
  zeniq: Wj,
  zeroG: cg,
  zeroNetwork: Qj,
  zetachain: Jj,
  zetachainAthensTestnet: Xj,
  zhejiang: Zj,
  zilliqa: Yj,
  zilliqaTestnet: eV,
  zircuit: lg,
  zircuitGarfieldTestnet: tV,
  zircuitTestnet: nV,
  zkFair: rV,
  zkFairTestnet: sV,
  zkLinkNova: aV,
  zkLinkNovaSepoliaTestnet: iV,
  zkSync: oh,
  zkSyncInMemoryNode: T2,
  zkSyncLocalNode: S2,
  zkSyncSepoliaTestnet: I2,
  zksync: oh,
  zksyncInMemoryNode: T2,
  zksyncLocalCustomHyperchain: oV,
  zksyncLocalHyperchain: cV,
  zksyncLocalHyperchainL1: lV,
  zksyncLocalNode: S2,
  zksyncSepoliaTestnet: I2,
  zora: ch,
  zoraSepolia: uV,
  zoraTestnet: dV
}, Symbol.toStringTag, { value: "Module" }));
var me;
(function(t) {
  t[t.Verbose = 4] = "Verbose", t[t.Info = 3] = "Info", t[t.Warn = 2] = "Warn", t[t.Error = 1] = "Error", t[t.None = 0] = "None";
})(me || (me = {}));
const ug = (t, e, n) => {
  if (n >= e) {
    const r = t.reduce((s, a, i) => ((i + 1) % 2 && s.push(`
`), s.push(a), s), []);
    switch (e) {
      case me.Info:
        console.info(...r);
        break;
      case me.Error:
        console.error(...r);
        break;
      case me.Warn:
        console.warn(...r);
        break;
      default:
        console.log(...r);
        break;
    }
  }
};
function N3(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: fV } = Object.prototype, { getPrototypeOf: bw } = Object, { iterator: lm, toStringTag: R3 } = Symbol, um = /* @__PURE__ */ ((t) => (e) => {
  const n = fV.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Nr = (t) => (t = t.toLowerCase(), (e) => um(e) === t), dm = (t) => (e) => typeof e === t, { isArray: Yl } = Array, Ad = dm("undefined");
function of(t) {
  return t !== null && !Ad(t) && t.constructor !== null && !Ad(t.constructor) && Sn(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const D3 = Nr("ArrayBuffer");
function pV(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && D3(t.buffer), e;
}
const hV = dm("string"), Sn = dm("function"), F3 = dm("number"), cf = (t) => t !== null && typeof t == "object", mV = (t) => t === !0 || t === !1, Tp = (t) => {
  if (um(t) !== "object")
    return !1;
  const e = bw(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(R3 in t) && !(lm in t);
}, yV = (t) => {
  if (!cf(t) || of(t))
    return !1;
  try {
    return Object.keys(t).length === 0 && Object.getPrototypeOf(t) === Object.prototype;
  } catch {
    return !1;
  }
}, bV = Nr("Date"), gV = Nr("File"), wV = Nr("Blob"), EV = Nr("FileList"), xV = (t) => cf(t) && Sn(t.pipe), AV = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Sn(t.append) && ((e = um(t)) === "formdata" || // detect form-data instance
  e === "object" && Sn(t.toString) && t.toString() === "[object FormData]"));
}, kV = Nr("URLSearchParams"), [vV, CV, TV, SV] = ["ReadableStream", "Request", "Response", "Headers"].map(Nr), IV = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function lf(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), Yl(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    if (of(t))
      return;
    const a = n ? Object.getOwnPropertyNames(t) : Object.keys(t), i = a.length;
    let o;
    for (r = 0; r < i; r++)
      o = a[r], e.call(null, t[o], o, t);
  }
}
function M3(t, e) {
  if (of(t))
    return null;
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const Ti = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, L3 = (t) => !Ad(t) && t !== Ti;
function dg() {
  const { caseless: t } = L3(this) && this || {}, e = {}, n = (r, s) => {
    const a = t && M3(e, s) || s;
    Tp(e[a]) && Tp(r) ? e[a] = dg(e[a], r) : Tp(r) ? e[a] = dg({}, r) : Yl(r) ? e[a] = r.slice() : e[a] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && lf(arguments[r], n);
  return e;
}
const OV = (t, e, n, { allOwnKeys: r } = {}) => (lf(e, (s, a) => {
  n && Sn(s) ? t[a] = N3(s, n) : t[a] = s;
}, { allOwnKeys: r }), t), BV = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), PV = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, UV = (t, e, n, r) => {
  let s, a, i;
  const o = {};
  if (e = e || {}, t == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(t), a = s.length; a-- > 0; )
      i = s[a], (!r || r(i, t, e)) && !o[i] && (e[i] = t[i], o[i] = !0);
    t = n !== !1 && bw(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, NV = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, RV = (t) => {
  if (!t) return null;
  if (Yl(t)) return t;
  let e = t.length;
  if (!F3(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, DV = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && bw(Uint8Array)), FV = (t, e) => {
  const r = (t && t[lm]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const a = s.value;
    e.call(t, a[0], a[1]);
  }
}, MV = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, LV = Nr("HTMLFormElement"), HV = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), B2 = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), _V = Nr("RegExp"), H3 = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  lf(n, (s, a) => {
    let i;
    (i = e(s, a, t)) !== !1 && (r[a] = i || s);
  }), Object.defineProperties(t, r);
}, $V = (t) => {
  H3(t, (e, n) => {
    if (Sn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (Sn(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, GV = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((a) => {
      n[a] = !0;
    });
  };
  return Yl(t) ? r(t) : r(String(t).split(e)), n;
}, zV = () => {
}, jV = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
function VV(t) {
  return !!(t && Sn(t.append) && t[R3] === "FormData" && t[lm]);
}
const qV = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (cf(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (of(r))
        return r;
      if (!("toJSON" in r)) {
        e[s] = r;
        const a = Yl(r) ? [] : {};
        return lf(r, (i, o) => {
          const c = n(i, s + 1);
          !Ad(c) && (a[o] = c);
        }), e[s] = void 0, a;
      }
    }
    return r;
  };
  return n(t, 0);
}, KV = Nr("AsyncFunction"), WV = (t) => t && (cf(t) || Sn(t)) && Sn(t.then) && Sn(t.catch), _3 = ((t, e) => t ? setImmediate : e ? ((n, r) => (Ti.addEventListener("message", ({ source: s, data: a }) => {
  s === Ti && a === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), Ti.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Sn(Ti.postMessage)
), QV = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ti) : typeof process < "u" && process.nextTick || _3, JV = (t) => t != null && Sn(t[lm]), L = {
  isArray: Yl,
  isArrayBuffer: D3,
  isBuffer: of,
  isFormData: AV,
  isArrayBufferView: pV,
  isString: hV,
  isNumber: F3,
  isBoolean: mV,
  isObject: cf,
  isPlainObject: Tp,
  isEmptyObject: yV,
  isReadableStream: vV,
  isRequest: CV,
  isResponse: TV,
  isHeaders: SV,
  isUndefined: Ad,
  isDate: bV,
  isFile: gV,
  isBlob: wV,
  isRegExp: _V,
  isFunction: Sn,
  isStream: xV,
  isURLSearchParams: kV,
  isTypedArray: DV,
  isFileList: EV,
  forEach: lf,
  merge: dg,
  extend: OV,
  trim: IV,
  stripBOM: BV,
  inherits: PV,
  toFlatObject: UV,
  kindOf: um,
  kindOfTest: Nr,
  endsWith: NV,
  toArray: RV,
  forEachEntry: FV,
  matchAll: MV,
  isHTMLForm: LV,
  hasOwnProperty: B2,
  hasOwnProp: B2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: H3,
  freezeMethods: $V,
  toObjectSet: GV,
  toCamelCase: HV,
  noop: zV,
  toFiniteNumber: jV,
  findKey: M3,
  global: Ti,
  isContextDefined: L3,
  isSpecCompliantForm: VV,
  toJSONObject: qV,
  isAsyncFn: KV,
  isThenable: WV,
  setImmediate: _3,
  asap: QV,
  isIterable: JV
};
function he(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
L.inherits(he, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: L.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const $3 = he.prototype, G3 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  G3[t] = { value: t };
});
Object.defineProperties(he, G3);
Object.defineProperty($3, "isAxiosError", { value: !0 });
he.from = (t, e, n, r, s, a) => {
  const i = Object.create($3);
  return L.toFlatObject(t, i, function(c) {
    return c !== Error.prototype;
  }, (o) => o !== "isAxiosError"), he.call(i, t.message, e, n, r, s), i.cause = t, i.name = t.name, a && Object.assign(i, a), i;
};
const XV = null;
function fg(t) {
  return L.isPlainObject(t) || L.isArray(t);
}
function z3(t) {
  return L.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function P2(t, e, n) {
  return t ? t.concat(e).map(function(s, a) {
    return s = z3(s), !n && a ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function ZV(t) {
  return L.isArray(t) && !t.some(fg);
}
const YV = L.toFlatObject(L, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function fm(t, e, n) {
  if (!L.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = L.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, g) {
    return !L.isUndefined(g[y]);
  });
  const r = n.metaTokens, s = n.visitor || l, a = n.dots, i = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && L.isSpecCompliantForm(e);
  if (!L.isFunction(s))
    throw new TypeError("visitor must be a function");
  function u(b) {
    if (b === null) return "";
    if (L.isDate(b))
      return b.toISOString();
    if (L.isBoolean(b))
      return b.toString();
    if (!c && L.isBlob(b))
      throw new he("Blob is not supported. Use a Buffer instead.");
    return L.isArrayBuffer(b) || L.isTypedArray(b) ? c && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b;
  }
  function l(b, y, g) {
    let w = b;
    if (b && !g && typeof b == "object") {
      if (L.endsWith(y, "{}"))
        y = r ? y : y.slice(0, -2), b = JSON.stringify(b);
      else if (L.isArray(b) && ZV(b) || (L.isFileList(b) || L.endsWith(y, "[]")) && (w = L.toArray(b)))
        return y = z3(y), w.forEach(function(E, T) {
          !(L.isUndefined(E) || E === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? P2([y], T, a) : i === null ? y : y + "[]",
            u(E)
          );
        }), !1;
    }
    return fg(b) ? !0 : (e.append(P2(g, y, a), u(b)), !1);
  }
  const d = [], p = Object.assign(YV, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: fg
  });
  function f(b, y) {
    if (!L.isUndefined(b)) {
      if (d.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      d.push(b), L.forEach(b, function(w, k) {
        (!(L.isUndefined(w) || w === null) && s.call(
          e,
          w,
          L.isString(k) ? k.trim() : k,
          y,
          p
        )) === !0 && f(w, y ? y.concat(k) : [k]);
      }), d.pop();
    }
  }
  if (!L.isObject(t))
    throw new TypeError("data must be an object");
  return f(t), e;
}
function U2(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function gw(t, e) {
  this._pairs = [], t && fm(t, this, e);
}
const j3 = gw.prototype;
j3.append = function(e, n) {
  this._pairs.push([e, n]);
};
j3.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, U2);
  } : U2;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function eq(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function V3(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || eq;
  L.isFunction(n) && (n = {
    serialize: n
  });
  const s = n && n.serialize;
  let a;
  if (s ? a = s(e, n) : a = L.isURLSearchParams(e) ? e.toString() : new gw(e, n).toString(r), a) {
    const i = t.indexOf("#");
    i !== -1 && (t = t.slice(0, i)), t += (t.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return t;
}
class N2 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    L.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const q3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, tq = typeof URLSearchParams < "u" ? URLSearchParams : gw, nq = typeof FormData < "u" ? FormData : null, rq = typeof Blob < "u" ? Blob : null, sq = {
  isBrowser: !0,
  classes: {
    URLSearchParams: tq,
    FormData: nq,
    Blob: rq
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ww = typeof window < "u" && typeof document < "u", pg = typeof navigator == "object" && navigator || void 0, aq = ww && (!pg || ["ReactNative", "NativeScript", "NS"].indexOf(pg.product) < 0), iq = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", oq = ww && window.location.href || "http://localhost", cq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ww,
  hasStandardBrowserEnv: aq,
  hasStandardBrowserWebWorkerEnv: iq,
  navigator: pg,
  origin: oq
}, Symbol.toStringTag, { value: "Module" })), jt = {
  ...cq,
  ...sq
};
function lq(t, e) {
  return fm(t, new jt.classes.URLSearchParams(), {
    visitor: function(n, r, s, a) {
      return jt.isNode && L.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function uq(t) {
  return L.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function dq(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let a;
  for (r = 0; r < s; r++)
    a = n[r], e[a] = t[a];
  return e;
}
function K3(t) {
  function e(n, r, s, a) {
    let i = n[a++];
    if (i === "__proto__") return !0;
    const o = Number.isFinite(+i), c = a >= n.length;
    return i = !i && L.isArray(s) ? s.length : i, c ? (L.hasOwnProp(s, i) ? s[i] = [s[i], r] : s[i] = r, !o) : ((!s[i] || !L.isObject(s[i])) && (s[i] = []), e(n, r, s[i], a) && L.isArray(s[i]) && (s[i] = dq(s[i])), !o);
  }
  if (L.isFormData(t) && L.isFunction(t.entries)) {
    const n = {};
    return L.forEachEntry(t, (r, s) => {
      e(uq(r), s, n, 0);
    }), n;
  }
  return null;
}
function fq(t, e, n) {
  if (L.isString(t))
    try {
      return (e || JSON.parse)(t), L.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const uf = {
  transitional: q3,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, a = L.isObject(e);
    if (a && L.isHTMLForm(e) && (e = new FormData(e)), L.isFormData(e))
      return s ? JSON.stringify(K3(e)) : e;
    if (L.isArrayBuffer(e) || L.isBuffer(e) || L.isStream(e) || L.isFile(e) || L.isBlob(e) || L.isReadableStream(e))
      return e;
    if (L.isArrayBufferView(e))
      return e.buffer;
    if (L.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return lq(e, this.formSerializer).toString();
      if ((o = L.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return fm(
          o ? { "files[]": e } : e,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || s ? (n.setContentType("application/json", !1), fq(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || uf.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (L.isResponse(e) || L.isReadableStream(e))
      return e;
    if (e && L.isString(e) && (r && !this.responseType || s)) {
      const i = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (i)
          throw o.name === "SyntaxError" ? he.from(o, he.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: jt.classes.FormData,
    Blob: jt.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  uf.headers[t] = {};
});
const pq = L.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), hq = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), n = i.substring(0, s).trim().toLowerCase(), r = i.substring(s + 1).trim(), !(!n || e[n] && pq[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, R2 = Symbol("internals");
function vu(t) {
  return t && String(t).trim().toLowerCase();
}
function Sp(t) {
  return t === !1 || t == null ? t : L.isArray(t) ? t.map(Sp) : String(t);
}
function mq(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const yq = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function L0(t, e, n, r, s) {
  if (L.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!L.isString(e)) {
    if (L.isString(r))
      return e.indexOf(r) !== -1;
    if (L.isRegExp(r))
      return r.test(e);
  }
}
function bq(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function gq(t, e) {
  const n = L.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, a, i) {
        return this[r].call(this, e, s, a, i);
      },
      configurable: !0
    });
  });
}
let In = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function a(o, c, u) {
      const l = vu(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = L.findKey(s, l);
      (!d || s[d] === void 0 || u === !0 || u === void 0 && s[d] !== !1) && (s[d || c] = Sp(o));
    }
    const i = (o, c) => L.forEach(o, (u, l) => a(u, l, c));
    if (L.isPlainObject(e) || e instanceof this.constructor)
      i(e, n);
    else if (L.isString(e) && (e = e.trim()) && !yq(e))
      i(hq(e), n);
    else if (L.isObject(e) && L.isIterable(e)) {
      let o = {}, c, u;
      for (const l of e) {
        if (!L.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        o[u = l[0]] = (c = o[u]) ? L.isArray(c) ? [...c, l[1]] : [c, l[1]] : l[1];
      }
      i(o, n);
    } else
      e != null && a(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = vu(e), e) {
      const r = L.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return mq(s);
        if (L.isFunction(n))
          return n.call(this, s, r);
        if (L.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = vu(e), e) {
      const r = L.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || L0(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function a(i) {
      if (i = vu(i), i) {
        const o = L.findKey(r, i);
        o && (!n || L0(r, r[o], o, n)) && (delete r[o], s = !0);
      }
    }
    return L.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const a = n[r];
      (!e || L0(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return L.forEach(this, (s, a) => {
      const i = L.findKey(r, a);
      if (i) {
        n[i] = Sp(s), delete n[a];
        return;
      }
      const o = e ? bq(a) : String(a).trim();
      o !== a && delete n[a], n[o] = Sp(s), r[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return L.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && L.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[R2] = this[R2] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(i) {
      const o = vu(i);
      r[o] || (gq(s, i), r[o] = !0);
    }
    return L.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
In.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
L.reduceDescriptors(In.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
L.freezeMethods(In);
function H0(t, e) {
  const n = this || uf, r = e || n, s = In.from(r.headers);
  let a = r.data;
  return L.forEach(t, function(o) {
    a = o.call(n, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function W3(t) {
  return !!(t && t.__CANCEL__);
}
function eu(t, e, n) {
  he.call(this, t ?? "canceled", he.ERR_CANCELED, e, n), this.name = "CanceledError";
}
L.inherits(eu, he, {
  __CANCEL__: !0
});
function Q3(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new he(
    "Request failed with status code " + n.status,
    [he.ERR_BAD_REQUEST, he.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function wq(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function Eq(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, a = 0, i;
  return e = e !== void 0 ? e : 1e3, function(c) {
    const u = Date.now(), l = r[a];
    i || (i = u), n[s] = c, r[s] = u;
    let d = a, p = 0;
    for (; d !== s; )
      p += n[d++], d = d % t;
    if (s = (s + 1) % t, s === a && (a = (a + 1) % t), u - i < e)
      return;
    const f = l && u - l;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function xq(t, e) {
  let n = 0, r = 1e3 / e, s, a;
  const i = (u, l = Date.now()) => {
    n = l, s = null, a && (clearTimeout(a), a = null), t(...u);
  };
  return [(...u) => {
    const l = Date.now(), d = l - n;
    d >= r ? i(u, l) : (s = u, a || (a = setTimeout(() => {
      a = null, i(s);
    }, r - d)));
  }, () => s && i(s)];
}
const lh = (t, e, n = 3) => {
  let r = 0;
  const s = Eq(50, 250);
  return xq((a) => {
    const i = a.loaded, o = a.lengthComputable ? a.total : void 0, c = i - r, u = s(c), l = i <= o;
    r = i;
    const d = {
      loaded: i,
      total: o,
      progress: o ? i / o : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && o && l ? (o - i) / u : void 0,
      event: a,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    t(d);
  }, n);
}, D2 = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, F2 = (t) => (...e) => L.asap(() => t(...e)), Aq = jt.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, jt.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(
  new URL(jt.origin),
  jt.navigator && /(msie|trident)/i.test(jt.navigator.userAgent)
) : () => !0, kq = jt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, s, a) {
      const i = [t + "=" + encodeURIComponent(e)];
      L.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()), L.isString(r) && i.push("path=" + r), L.isString(s) && i.push("domain=" + s), a === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function vq(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function Cq(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function J3(t, e, n) {
  let r = !vq(e);
  return t && (r || n == !1) ? Cq(t, e) : e;
}
const M2 = (t) => t instanceof In ? { ...t } : t;
function No(t, e) {
  e = e || {};
  const n = {};
  function r(u, l, d, p) {
    return L.isPlainObject(u) && L.isPlainObject(l) ? L.merge.call({ caseless: p }, u, l) : L.isPlainObject(l) ? L.merge({}, l) : L.isArray(l) ? l.slice() : l;
  }
  function s(u, l, d, p) {
    if (L.isUndefined(l)) {
      if (!L.isUndefined(u))
        return r(void 0, u, d, p);
    } else return r(u, l, d, p);
  }
  function a(u, l) {
    if (!L.isUndefined(l))
      return r(void 0, l);
  }
  function i(u, l) {
    if (L.isUndefined(l)) {
      if (!L.isUndefined(u))
        return r(void 0, u);
    } else return r(void 0, l);
  }
  function o(u, l, d) {
    if (d in e)
      return r(u, l);
    if (d in t)
      return r(void 0, u);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: o,
    headers: (u, l, d) => s(M2(u), M2(l), d, !0)
  };
  return L.forEach(Object.keys({ ...t, ...e }), function(l) {
    const d = c[l] || s, p = d(t[l], e[l], l);
    L.isUndefined(p) && d !== o || (n[l] = p);
  }), n;
}
const X3 = (t) => {
  const e = No({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: a, headers: i, auth: o } = e;
  e.headers = i = In.from(i), e.url = V3(J3(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), o && i.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let c;
  if (L.isFormData(n)) {
    if (jt.hasStandardBrowserEnv || jt.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((c = i.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      i.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (jt.hasStandardBrowserEnv && (r && L.isFunction(r) && (r = r(e)), r || r !== !1 && Aq(e.url))) {
    const u = s && a && kq.read(a);
    u && i.set(s, u);
  }
  return e;
}, Tq = typeof XMLHttpRequest < "u", Sq = Tq && function(t) {
  return new Promise(function(n, r) {
    const s = X3(t);
    let a = s.data;
    const i = In.from(s.headers).normalize();
    let { responseType: o, onUploadProgress: c, onDownloadProgress: u } = s, l, d, p, f, b;
    function y() {
      f && f(), b && b(), s.cancelToken && s.cancelToken.unsubscribe(l), s.signal && s.signal.removeEventListener("abort", l);
    }
    let g = new XMLHttpRequest();
    g.open(s.method.toUpperCase(), s.url, !0), g.timeout = s.timeout;
    function w() {
      if (!g)
        return;
      const E = In.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), A = {
        data: !o || o === "text" || o === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: E,
        config: t,
        request: g
      };
      Q3(function(D) {
        n(D), y();
      }, function(D) {
        r(D), y();
      }, A), g = null;
    }
    "onloadend" in g ? g.onloadend = w : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, g.onabort = function() {
      g && (r(new he("Request aborted", he.ECONNABORTED, t, g)), g = null);
    }, g.onerror = function() {
      r(new he("Network Error", he.ERR_NETWORK, t, g)), g = null;
    }, g.ontimeout = function() {
      let T = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const A = s.transitional || q3;
      s.timeoutErrorMessage && (T = s.timeoutErrorMessage), r(new he(
        T,
        A.clarifyTimeoutError ? he.ETIMEDOUT : he.ECONNABORTED,
        t,
        g
      )), g = null;
    }, a === void 0 && i.setContentType(null), "setRequestHeader" in g && L.forEach(i.toJSON(), function(T, A) {
      g.setRequestHeader(A, T);
    }), L.isUndefined(s.withCredentials) || (g.withCredentials = !!s.withCredentials), o && o !== "json" && (g.responseType = s.responseType), u && ([p, b] = lh(u, !0), g.addEventListener("progress", p)), c && g.upload && ([d, f] = lh(c), g.upload.addEventListener("progress", d), g.upload.addEventListener("loadend", f)), (s.cancelToken || s.signal) && (l = (E) => {
      g && (r(!E || E.type ? new eu(null, t, g) : E), g.abort(), g = null);
    }, s.cancelToken && s.cancelToken.subscribe(l), s.signal && (s.signal.aborted ? l() : s.signal.addEventListener("abort", l)));
    const k = wq(s.url);
    if (k && jt.protocols.indexOf(k) === -1) {
      r(new he("Unsupported protocol " + k + ":", he.ERR_BAD_REQUEST, t));
      return;
    }
    g.send(a || null);
  });
}, Iq = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), s;
    const a = function(u) {
      if (!s) {
        s = !0, o();
        const l = u instanceof Error ? u : this.reason;
        r.abort(l instanceof he ? l : new eu(l instanceof Error ? l.message : l));
      }
    };
    let i = e && setTimeout(() => {
      i = null, a(new he(`timeout ${e} of ms exceeded`, he.ETIMEDOUT));
    }, e);
    const o = () => {
      t && (i && clearTimeout(i), i = null, t.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(a) : u.removeEventListener("abort", a);
      }), t = null);
    };
    t.forEach((u) => u.addEventListener("abort", a));
    const { signal: c } = r;
    return c.unsubscribe = () => L.asap(o), c;
  }
}, Oq = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, Bq = async function* (t, e) {
  for await (const n of Pq(t))
    yield* Oq(n, e);
}, Pq = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, L2 = (t, e, n, r) => {
  const s = Bq(t, e);
  let a = 0, i, o = (c) => {
    i || (i = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await s.next();
        if (u) {
          o(), c.close();
          return;
        }
        let d = l.byteLength;
        if (n) {
          let p = a += d;
          n(p);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw o(u), u;
      }
    },
    cancel(c) {
      return o(c), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, pm = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Z3 = pm && typeof ReadableStream == "function", Uq = pm && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), Y3 = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, Nq = Z3 && Y3(() => {
  let t = !1;
  const e = new Request(jt.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), H2 = 64 * 1024, hg = Z3 && Y3(() => L.isReadableStream(new Response("").body)), uh = {
  stream: hg && ((t) => t.body)
};
pm && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !uh[e] && (uh[e] = L.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new he(`Response type '${e}' is not supported`, he.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const Rq = async (t) => {
  if (t == null)
    return 0;
  if (L.isBlob(t))
    return t.size;
  if (L.isSpecCompliantForm(t))
    return (await new Request(jt.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (L.isArrayBufferView(t) || L.isArrayBuffer(t))
    return t.byteLength;
  if (L.isURLSearchParams(t) && (t = t + ""), L.isString(t))
    return (await Uq(t)).byteLength;
}, Dq = async (t, e) => {
  const n = L.toFiniteNumber(t.getContentLength());
  return n ?? Rq(e);
}, Fq = pm && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: a,
    timeout: i,
    onDownloadProgress: o,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: p
  } = X3(t);
  u = u ? (u + "").toLowerCase() : "text";
  let f = Iq([s, a && a.toAbortSignal()], i), b;
  const y = f && f.unsubscribe && (() => {
    f.unsubscribe();
  });
  let g;
  try {
    if (c && Nq && n !== "get" && n !== "head" && (g = await Dq(l, r)) !== 0) {
      let A = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), N;
      if (L.isFormData(r) && (N = A.headers.get("content-type")) && l.setContentType(N), A.body) {
        const [D, P] = D2(
          g,
          lh(F2(c))
        );
        r = L2(A.body, H2, D, P);
      }
    }
    L.isString(d) || (d = d ? "include" : "omit");
    const w = "credentials" in Request.prototype;
    b = new Request(e, {
      ...p,
      signal: f,
      method: n.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: w ? d : void 0
    });
    let k = await fetch(b, p);
    const E = hg && (u === "stream" || u === "response");
    if (hg && (o || E && y)) {
      const A = {};
      ["status", "statusText", "headers"].forEach((C) => {
        A[C] = k[C];
      });
      const N = L.toFiniteNumber(k.headers.get("content-length")), [D, P] = o && D2(
        N,
        lh(F2(o), !0)
      ) || [];
      k = new Response(
        L2(k.body, H2, D, () => {
          P && P(), y && y();
        }),
        A
      );
    }
    u = u || "text";
    let T = await uh[L.findKey(uh, u) || "text"](k, t);
    return !E && y && y(), await new Promise((A, N) => {
      Q3(A, N, {
        data: T,
        headers: In.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: t,
        request: b
      });
    });
  } catch (w) {
    throw y && y(), w && w.name === "TypeError" && /Load failed|fetch/i.test(w.message) ? Object.assign(
      new he("Network Error", he.ERR_NETWORK, t, b),
      {
        cause: w.cause || w
      }
    ) : he.from(w, w && w.code, t, b);
  }
}), mg = {
  http: XV,
  xhr: Sq,
  fetch: Fq
};
L.forEach(mg, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const _2 = (t) => `- ${t}`, Mq = (t) => L.isFunction(t) || t === null || t === !1, eC = {
  getAdapter: (t) => {
    t = L.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let a = 0; a < e; a++) {
      n = t[a];
      let i;
      if (r = n, !Mq(n) && (r = mg[(i = String(n)).toLowerCase()], r === void 0))
        throw new he(`Unknown adapter '${i}'`);
      if (r)
        break;
      s[i || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(s).map(
        ([o, c]) => `adapter ${o} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = e ? a.length > 1 ? `since :
` + a.map(_2).join(`
`) : " " + _2(a[0]) : "as no adapter specified";
      throw new he(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: mg
};
function _0(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new eu(null, t);
}
function $2(t) {
  return _0(t), t.headers = In.from(t.headers), t.data = H0.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), eC.getAdapter(t.adapter || uf.adapter)(t).then(function(r) {
    return _0(t), r.data = H0.call(
      t,
      t.transformResponse,
      r
    ), r.headers = In.from(r.headers), r;
  }, function(r) {
    return W3(r) || (_0(t), r && r.response && (r.response.data = H0.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = In.from(r.response.headers))), Promise.reject(r);
  });
}
const tC = "1.11.0", hm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  hm[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const G2 = {};
hm.transitional = function(e, n, r) {
  function s(a, i) {
    return "[Axios v" + tC + "] Transitional option '" + a + "'" + i + (r ? ". " + r : "");
  }
  return (a, i, o) => {
    if (e === !1)
      throw new he(
        s(i, " has been removed" + (n ? " in " + n : "")),
        he.ERR_DEPRECATED
      );
    return n && !G2[i] && (G2[i] = !0, console.warn(
      s(
        i,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(a, i, o) : !0;
  };
};
hm.spelling = function(e) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function Lq(t, e, n) {
  if (typeof t != "object")
    throw new he("options must be an object", he.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const a = r[s], i = e[a];
    if (i) {
      const o = t[a], c = o === void 0 || i(o, a, t);
      if (c !== !0)
        throw new he("option " + a + " must be " + c, he.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new he("Unknown option " + a, he.ERR_BAD_OPTION);
  }
}
const Ip = {
  assertOptions: Lq,
  validators: hm
}, Hr = Ip.validators;
let yo = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new N2(),
      response: new N2()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = No(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: a } = n;
    r !== void 0 && Ip.assertOptions(r, {
      silentJSONParsing: Hr.transitional(Hr.boolean),
      forcedJSONParsing: Hr.transitional(Hr.boolean),
      clarifyTimeoutError: Hr.transitional(Hr.boolean)
    }, !1), s != null && (L.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : Ip.assertOptions(s, {
      encode: Hr.function,
      serialize: Hr.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Ip.assertOptions(n, {
      baseUrl: Hr.spelling("baseURL"),
      withXsrfToken: Hr.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let i = a && L.merge(
      a.common,
      a[n.method]
    );
    a && L.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete a[b];
      }
    ), n.headers = In.concat(i, a);
    const o = [];
    let c = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(n) === !1 || (c = c && y.synchronous, o.unshift(y.fulfilled, y.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(y) {
      u.push(y.fulfilled, y.rejected);
    });
    let l, d = 0, p;
    if (!c) {
      const b = [$2.bind(this), void 0];
      for (b.unshift(...o), b.push(...u), p = b.length, l = Promise.resolve(n); d < p; )
        l = l.then(b[d++], b[d++]);
      return l;
    }
    p = o.length;
    let f = n;
    for (d = 0; d < p; ) {
      const b = o[d++], y = o[d++];
      try {
        f = b(f);
      } catch (g) {
        y.call(this, g);
        break;
      }
    }
    try {
      l = $2.call(this, f);
    } catch (b) {
      return Promise.reject(b);
    }
    for (d = 0, p = u.length; d < p; )
      l = l.then(u[d++], u[d++]);
    return l;
  }
  getUri(e) {
    e = No(this.defaults, e);
    const n = J3(e.baseURL, e.url, e.allowAbsoluteUrls);
    return V3(n, e.params, e.paramsSerializer);
  }
};
L.forEach(["delete", "get", "head", "options"], function(e) {
  yo.prototype[e] = function(n, r) {
    return this.request(No(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
L.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(a, i, o) {
      return this.request(No(o || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: i
      }));
    };
  }
  yo.prototype[e] = n(), yo.prototype[e + "Form"] = n(!0);
});
let Hq = class nC {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const i = new Promise((o) => {
        r.subscribe(o), a = o;
      }).then(s);
      return i.cancel = function() {
        r.unsubscribe(a);
      }, i;
    }, e(function(a, i, o) {
      r.reason || (r.reason = new eu(a, i, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new nC(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function _q(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function $q(t) {
  return L.isObject(t) && t.isAxiosError === !0;
}
const yg = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(yg).forEach(([t, e]) => {
  yg[e] = t;
});
function rC(t) {
  const e = new yo(t), n = N3(yo.prototype.request, e);
  return L.extend(n, yo.prototype, e, { allOwnKeys: !0 }), L.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return rC(No(t, s));
  }, n;
}
const Je = rC(uf);
Je.Axios = yo;
Je.CanceledError = eu;
Je.CancelToken = Hq;
Je.isCancel = W3;
Je.VERSION = tC;
Je.toFormData = fm;
Je.AxiosError = he;
Je.Cancel = Je.CanceledError;
Je.all = function(e) {
  return Promise.all(e);
};
Je.spread = _q;
Je.isAxiosError = $q;
Je.mergeConfig = No;
Je.AxiosHeaders = In;
Je.formToJSON = (t) => K3(L.isHTMLForm(t) ? new FormData(t) : t);
Je.getAdapter = eC.getAdapter;
Je.HttpStatusCode = yg;
Je.default = Je;
const {
  Axios: fre,
  AxiosError: pre,
  CanceledError: hre,
  isCancel: mre,
  CancelToken: yre,
  VERSION: bre,
  all: gre,
  Cancel: wre,
  isAxiosError: Ere,
  spread: xre,
  toFormData: Are,
  AxiosHeaders: kre,
  HttpStatusCode: vre,
  formToJSON: Cre,
  getAdapter: Tre,
  mergeConfig: Sre
} = Je;
function Gq(t = {}) {
  return Xt.request(t);
}
function zq(t) {
  return t && t.cause === "APIError";
}
class tu extends Error {
  constructor(e = "Unknown Reason", n, r, s = "APIError", a = {}) {
    super(e, { ...a, cause: "APIError" }), Object.defineProperty(this, "type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "statusCode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "rawError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "APIError", this.type = s, this.statusCode = n, this.endpoint = r == null ? void 0 : r.endpoint, this.rawError = r;
  }
}
const Xt = Je.create();
Xt.interceptors.response.use((t) => (t.headers.Deprecation === "true" && console.warn(`Warning: API ${t.config.url} is deprecated. Stability and performance may be affected.`), t), (t) => {
  var e, n, r, s, a, i;
  return Promise.reject(new tu((n = (e = t.response) == null ? void 0 : e.data) == null ? void 0 : n.message, ((s = (r = t.response) == null ? void 0 : r.data) == null ? void 0 : s.statusCode) || 500, {
    ...(a = t.response) == null ? void 0 : a.data,
    endpoint: (i = t.config) == null ? void 0 : i.url
  }));
});
async function Ew(t, e, n = 15, r = 0) {
  if (r >= n)
    throw `Failed to get data after ${r} attempt(s), aborting`;
  async function s() {
    return (await Xt.request(t)).data;
  }
  const a = await s();
  if (e(a))
    return a;
  await new Promise((o) => setTimeout(o, 5e3)), r++, await Ew(t, e, n, r);
}
async function xw(t, e, n = 15, r = 0, s = 5e3) {
  if (r >= n)
    throw `Failed to get an ok response after ${r} attempt(s), aborting`;
  const a = await Xt.request(t);
  if (e || (e = (i) => i.status === 200), e(a))
    return !0;
  await new Promise((i) => setTimeout(i, s)), r++, await xw(t, e, n, r, s);
}
class jq extends Error {
  constructor(e, n) {
    super(`Failed to receive a successful response for solver status check with hash '${e}' after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "SolverStatusTimeoutError", this.txHash = e;
  }
}
class Vq extends Error {
  constructor(e, n) {
    super(`Deposit transaction with hash '${e}' is pending after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "DepositTransactionTimeoutError", this.txHash = e;
  }
}
class qq extends Error {
  constructor(e, n, r) {
    super(e), Object.defineProperty(this, "receipt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tenderlyError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TransactionConfirmationError", this.receipt = n, this.tenderlyError = r ?? void 0;
  }
}
async function Aw(t, e = 15, n = 0, r = 5e3) {
  if (n >= e)
    throw `Failed to get an ok response after ${n} attempt(s), aborting`;
  if (await t())
    return !0;
  await new Promise((a) => setTimeout(a, r)), n++, await Aw(t, e, n, r);
}
const Kq = (t) => new Promise((e) => {
  Xt.get(`https://api.tenderly.co/api/v1/explorer/${t}`, {
    timeout: 5e3
  }).then((n) => {
    n && n.data && n.data.error_info && e(n.data.error_info), e(null);
  }).catch((n) => {
    console.warn(`Tenderly api failed: ${n}`), e(null);
  });
});
async function Wq(t, e, n, r, s, a, i, o, c, u, l, d, p) {
  var R, M, _, j, I, F, $, V, X, Z, Y, W;
  const f = Me();
  try {
    await Aw(async () => await r.getChainId() === t, 10, void 0, 250);
  } catch {
    throw `Current chain id: ${await r.getChainId()} does not match expected chain id: ${t} `;
  }
  let b, y = !1, g = !1;
  const w = f.pollingInterval ?? 5e3, k = f.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / w;
  let E = !0, T = 0, A;
  const N = !!(Array.isArray(e) && e.length > 1 && r.handleBatchTransactionStep);
  if (N ? A = await ((R = r.handleBatchTransactionStep) == null ? void 0 : R.call(r, t, e)) : A = await r.handleSendTransactionStep(t, Array.isArray(e) ? e[0] : e, n), A === "null")
    throw "User rejected the request";
  const D = Array.isArray(e) ? (M = e.find((Q) => Q.check)) == null ? void 0 : M.check : e.check;
  if (j2({
    txHash: A,
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: f.source
  }), A && !N && !Array.isArray(e) && t === ((j = (_ = l == null ? void 0 : l.currencyOut) == null ? void 0 : _.currency) == null ? void 0 : j.chainId) && z2({
    calldata: JSON.stringify({ ...e.data, txHash: A }),
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: f.source
  }), !A)
    throw Error("Transaction hash not returned from handleSendTransactionStep method");
  s([
    { txHash: A, chainId: t, isBatchTx: N }
  ]);
  const P = (Q) => {
    var oe, te, ae, ue, Ie, Le, Ze;
    if ((oe = Me()) == null || oe.log(["Execute Steps: Polling for confirmation", Q], me.Verbose), p == null || p((te = Q.data) == null ? void 0 : te.status), Q.status === 200 && Q.data && Q.data.status === "failure")
      throw Error("Transaction failed");
    if (Q.status === 200 && Q.data && Q.data.status === "fallback")
      throw Error("Transaction failed: Refunded");
    if (Q.status === 200 && Q.data && Q.data.status === "success") {
      if (A)
        a([
          { txHash: A, chainId: t, isBatchTx: N }
        ]);
      else if ((ae = Q == null ? void 0 : Q.data) != null && ae.inTxHashes) {
        const yt = (Ie = (ue = Q.data) == null ? void 0 : ue.inTxHashes) == null ? void 0 : Ie.map((Ke) => {
          var Yt;
          return {
            txHash: Ke,
            chainId: ((Yt = Q == null ? void 0 : Q.data) == null ? void 0 : Yt.originChainId) ?? t,
            isBatchTx: N
          };
        });
        a(yt);
      }
      const vt = (Ze = (Le = Q.data) == null ? void 0 : Le.txHashes) == null ? void 0 : Ze.map((yt) => {
        var Ke;
        return {
          txHash: yt,
          chainId: ((Ke = Q == null ? void 0 : Q.data) == null ? void 0 : Ke.destinationChainId) ?? c
        };
      });
      return s(vt), !0;
    }
    return !1;
  }, C = async (Q) => {
    var oe, te, ae;
    for (u == null || u(); E && T < k && !y && !g; ) {
      let ue;
      if (D != null && D.endpoint && !((oe = i == null ? void 0 : i.data) != null && oe.useExternalLiquidity)) {
        let Ie = D == null ? void 0 : D.endpoint;
        f.source && !Ie.includes("referrer") && (D == null ? void 0 : D.method) === "GET" && (Ie = Ie.includes("?") ? `${Ie}&referrer=${f.source}` : `${Ie}?referrer=${f.source}`);
        try {
          ue = await Xt.request({
            url: `${i.baseURL}${Ie}`,
            method: D == null ? void 0 : D.method,
            headers: o
          });
        } catch (Le) {
          (te = Me()) == null || te.log(["Execute Steps: Polling for confirmation api error", Le], me.Verbose), ue = {
            data: {},
            status: 200,
            statusText: "OK",
            headers: {},
            config: {
              headers: {}
            }
          };
        }
      }
      ((ae = ue == null ? void 0 : ue.data) == null ? void 0 : ae.status) === "pending" && E && (Q == null || Q.abort()), !ue || P(ue) ? E = !1 : ue && (ue.data.status !== "pending" && (u == null || u(ue), T++), await new Promise((Ie) => setTimeout(Ie, w)));
    }
    if (T >= k)
      throw b ? new jq(A, T) : new Vq(A, T);
    if (y)
      throw Error("Transaction was cancelled");
    return !0;
  }, S = () => {
    const Q = new AbortController(), oe = Q.signal;
    return {
      promise: r.handleConfirmTransactionStep(A, t, (te) => {
        var ae, ue, Ie;
        oe.aborted || (s([{ txHash: te, chainId: t }]), A = te, T = 0, (ae = Me()) == null || ae.log(["Transaction replaced", te], me.Verbose), j2({
          txHash: te,
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: f.source
        }), !N && !Array.isArray(e) && t === ((Ie = (ue = l == null ? void 0 : l.currencyOut) == null ? void 0 : ue.currency) == null ? void 0 : Ie.chainId) && z2({
          calldata: JSON.stringify({ ...e.data, replacementTxHash: te }),
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: f.source
        }));
      }, () => {
        var te;
        oe.aborted || (y = !0, (te = Me()) == null || te.log(["Transaction cancelled"], me.Verbose));
      }).then((te) => {
        var ae;
        if (!oe.aborted) {
          if (b = te, d == null || d(b), b && typeof b == "object" && "status" in b && b.status === "reverted")
            throw "Transaction Reverted";
          (ae = Me()) == null || ae.log(["Transaction Receipt obtained", b], me.Verbose);
        }
      }).catch(async (te) => {
        var ue;
        if (oe.aborted)
          return;
        let ae = null;
        if (b && b.transactionHash && (ae = await Kq(b.transactionHash)), (ue = Me()) == null || ue.log(["Error in handleConfirmTransactionStep", te], me.Error), te.message === "Transaction cancelled")
          y = !0;
        else
          throw g = !0, new qq(te, b, ae);
      }),
      controller: Q
    };
  };
  if (t === 8253038)
    return !0;
  if (N)
    await C();
  else if (
    //Sequence internal functions
    // We want synchronous execution in the following cases:
    // - Approval Signature step required first
    // - Bitcoin is the destination
    // - Canonical route used
    n.id === "approve" || ((F = (I = l == null ? void 0 : l.currencyOut) == null ? void 0 : I.currency) == null ? void 0 : F.chainId) === 8253038 || ($ = i == null ? void 0 : i.data) != null && $.useExternalLiquidity
  )
    await S().promise, ((X = (V = l == null ? void 0 : l.currencyOut) == null ? void 0 : V.currency) == null ? void 0 : X.chainId) !== 8253038 && !((Z = i == null ? void 0 : i.data) != null && Z.useExternalLiquidity) && await C();
  else {
    const { promise: Q, controller: oe } = S(), te = C(oe);
    await Promise.race([Q, te]);
    const ae = ((W = (Y = l == null ? void 0 : l.currencyOut) == null ? void 0 : Y.currency) == null ? void 0 : W.chainId) === t;
    E && (ae ? E = !1 : await te), b || (D ? oe.abort() : await Q);
  }
  return !0;
}
const z2 = async ({ calldata: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (t && s.requestId && e) {
    (i = Me()) == null || i.log(["Posting same chain transaction to notify the solver"], me.Verbose);
    try {
      const c = {
        tx: t,
        chainId: e.toString(),
        requestId: s.requestId,
        referrer: a
      };
      Xt.request({
        url: `${n.baseURL}/transactions/single`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Me()) == null || u.log(["Same chain transaction notified to the solver"], me.Verbose);
      });
    } catch (c) {
      (o = Me()) == null || o.log(["Failed to post same chain transaction to solver", c], me.Warn);
    }
  }
}, j2 = async ({ txHash: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (s.id === "deposit" && t) {
    (i = Me()) == null || i.log(["Posting transaction to notify the solver"], me.Verbose);
    try {
      const c = {
        txHash: t,
        chainId: e.toString(),
        referrer: a
      };
      Xt.request({
        url: `${n.baseURL}/transactions/index`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Me()) == null || u.log(["Transaction notified to the solver"], me.Verbose);
      });
    } catch (c) {
      (o = Me()) == null || o.log(["Failed to post transaction to solver", c], me.Warn);
    }
  }
};
function Qq(t) {
  var a, i;
  const e = t[0], n = t[1], r = (a = e == null ? void 0 : e.items) == null ? void 0 : a.some((o) => o.status === "incomplete"), s = (i = n == null ? void 0 : n.items) == null ? void 0 : i.some((o) => o.status === "incomplete");
  return (e == null ? void 0 : e.id) === "approve" && ((n == null ? void 0 : n.id) === "deposit" || (n == null ? void 0 : n.id) === "swap") && r && s;
}
function Jq(t) {
  var r;
  const e = (r = t[1]) == null ? void 0 : r.id;
  return {
    id: `approve-and-${e}`,
    action: "Confirm transaction in your wallet",
    description: `Batching approval and ${e} transactions`,
    kind: "transaction",
    items: [
      ...t[0].items || [],
      ...(t[1].items || []).map((s) => (s.status = "complete", s.progressState = "complete", s))
    ],
    requestId: t[1].requestId ?? t[0].requestId
  };
}
function sC(t, e) {
  var i, o, c, u, l, d, p, f, b, y, g, w;
  const n = (i = t[0]) == null ? void 0 : i.items, r = (l = (u = (c = (o = n[0]) == null ? void 0 : o.data) == null ? void 0 : c.action) == null ? void 0 : u.parameters) == null ? void 0 : l.amount, s = (b = (f = (p = (d = n[0]) == null ? void 0 : d.data) == null ? void 0 : p.action) == null ? void 0 : f.parameters) == null ? void 0 : b.destination;
  return {
    id: "sign",
    action: "Confirm transaction in your wallet",
    description: "Sign a message to confirm the transaction",
    kind: "signature",
    items: [
      {
        status: "incomplete",
        data: {
          sign: {
            signatureKind: "eip712",
            domain: {
              name: "HyperliquidSignTransaction",
              version: "1",
              chainId: e,
              verifyingContract: "0x0000000000000000000000000000000000000000"
            },
            types: {
              "HyperliquidTransaction:UsdSend": [
                { name: "hyperliquidChain", type: "string" },
                { name: "destination", type: "string" },
                { name: "amount", type: "string" },
                { name: "time", type: "uint64" }
              ],
              EIP712Domain: [
                { name: "name", type: "string" },
                { name: "version", type: "string" },
                { name: "chainId", type: "uint256" },
                { name: "verifyingContract", type: "address" }
              ]
            },
            primaryType: "HyperliquidTransaction:UsdSend",
            value: {
              type: "usdSend",
              signatureChainId: `0x${e.toString(16)}`,
              hyperliquidChain: "Mainnet",
              destination: s == null ? void 0 : s.toLowerCase(),
              amount: r,
              time: (/* @__PURE__ */ new Date()).getTime()
            }
          }
        },
        check: {
          endpoint: `/intents/status?requestId=${(y = t[0]) == null ? void 0 : y.requestId}`,
          method: "GET"
        }
      }
    ],
    requestId: (g = t[0]) == null ? void 0 : g.requestId,
    depositAddress: (w = t[0]) == null ? void 0 : w.depositAddress
  };
}
async function Xq(t, e, n) {
  var c, u, l, d, p, f, b, y, g, w, k, E, T, A, N, D, P;
  t.log(["Execute Steps: Sending signature to Hyperliquid", e], me.Verbose);
  const { r, s, v: a } = WS(e), i = ((l = (u = (c = n == null ? void 0 : n.data) == null ? void 0 : c.sign) == null ? void 0 : u.value) == null ? void 0 : l.time) ?? (/* @__PURE__ */ new Date()).getTime(), o = await Je.post("https://api.hyperliquid.xyz/exchange", {
    signature: {
      r,
      s,
      v: Number(a ?? 0n)
    },
    nonce: i,
    action: {
      type: (f = (p = (d = n == null ? void 0 : n.data) == null ? void 0 : d.sign) == null ? void 0 : p.value) == null ? void 0 : f.type,
      signatureChainId: `0x${(w = (g = (y = (b = n == null ? void 0 : n.data) == null ? void 0 : b.sign) == null ? void 0 : y.domain) == null ? void 0 : g.chainId) == null ? void 0 : w.toString(16)}`,
      hyperliquidChain: "Mainnet",
      destination: (A = (T = (E = (k = n == null ? void 0 : n.data) == null ? void 0 : k.sign) == null ? void 0 : E.value) == null ? void 0 : T.destination) == null ? void 0 : A.toLowerCase(),
      amount: (P = (D = (N = n == null ? void 0 : n.data) == null ? void 0 : N.sign) == null ? void 0 : D.value) == null ? void 0 : P.amount,
      time: i
    }
  });
  if (!o || !o.data || o && o.status !== 200 || o.data.status != "ok")
    throw "Failed to send signature to HyperLiquid";
  return t.log(["Execute Steps: Signature sent to Hyperliquid", o.data], me.Verbose), o.data;
}
async function mm(t, e = {}, n, r, s, a) {
  var p, f;
  const i = Me();
  i != null && i.baseApiUrl && (e.baseURL = i.baseApiUrl);
  const o = i.pollingInterval ?? 5e3, c = i.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / o, u = i.chains.find((b) => b.id === t);
  if (!u)
    throw `Unable to find chain: Chain id ${t}`;
  let l = s, d = !1;
  try {
    if (!l) {
      i.log(["Execute Steps: Fetching Steps", e], me.Verbose);
      const A = await Xt.request(e);
      if (l = A.data, A.status !== 200)
        throw l;
      i.log(["Execute Steps: Steps retrieved", l], me.Verbose);
    }
    if (l.error || !l.steps)
      throw l;
    if (Qq(l.steps) && (d = !!(n != null && n.supportsAtomicBatch && await (n == null ? void 0 : n.supportsAtomicBatch(t))), d)) {
      const A = Jq(l.steps);
      l.steps = [A];
    }
    if (t === 1337 && l.steps[0] && l.steps[0].id !== "sign") {
      const A = await (n == null ? void 0 : n.getChainId()), N = sC(l.steps, A);
      l.steps = [N];
    }
    r({
      steps: [...l == null ? void 0 : l.steps],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details
    });
    let b = -1, y = -1;
    if (l.steps.find((A, N) => {
      if (!A.items)
        return !1;
      if (y = A.items.findIndex((D) => D.status == "incomplete"), y !== -1)
        return b = N, !0;
    }), b === -1)
      return i.log(["Execute Steps: all steps complete"], me.Verbose), l;
    const g = l.steps[b];
    if (a && a[g.id]) {
      const A = a[g.id];
      (p = g.items) == null || p.forEach((N) => {
        A.gasLimit && (N.data.gas = A.gasLimit);
      });
    }
    let w = l.steps[b].items;
    if (!w)
      return i.log(["Execute Steps: skipping step, no items in step"], me.Verbose), l;
    let { kind: k } = g, E = w[y];
    if (!E.data) {
      if (i.log(["Execute Steps: step item data is missing, begin polling"], me.Verbose), l = await Ew(e, (N) => {
        var P, C, S, R;
        i.log(["Execute Steps: step item data is missing, polling", N], me.Verbose);
        const D = N;
        return !!((C = (P = D == null ? void 0 : D.steps) == null ? void 0 : P[b].items) != null && C[y].data || ((R = (S = D == null ? void 0 : D.steps) == null ? void 0 : S[b].items) == null ? void 0 : R[y].status) === "complete");
      }), !l.steps || !l.steps[b].items)
        throw l;
      const A = l.steps[b].items;
      if (!A || !A[y] || !A[y].data)
        throw l;
      w = A, E = A[y], r({
        steps: [...l == null ? void 0 : l.steps],
        fees: { ...l == null ? void 0 : l.fees },
        breakdown: l == null ? void 0 : l.breakdown,
        details: l == null ? void 0 : l.details
      });
    }
    i.log([`Execute Steps: Begin processing step items for: ${g.action}`], me.Verbose);
    const T = w.filter((A) => A.status === "incomplete").map((A) => new Promise(async (N, D) => {
      var P, C;
      try {
        const S = A.data;
        if (!l)
          return;
        switch (k) {
          case "transaction": {
            try {
              i.log([
                "Execute Steps: Begin transaction step for, sending transaction"
              ], me.Verbose);
              const R = ((P = A == null ? void 0 : A.data) == null ? void 0 : P.chainId) ?? t, M = t;
              A.progressState = "confirming", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              }), await Wq(R, d && y === 0 ? w : A, g, n, (j) => {
                i.log([
                  "Execute Steps: Transaction step, got transactions",
                  j
                ], me.Verbose), A.txHashes = j, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (j) => {
                A.internalTxHashes = j, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, e, void 0, M, (j) => {
                j && j.data.status === "delayed" ? A.progressState = "validating_delayed" : A.progressState = "validating", l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, l == null ? void 0 : l.details, (j) => {
                A.receipt = j, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (j) => {
                j != A.checkStatus && (A.checkStatus = j, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }));
              });
            } catch (R) {
              throw R;
            }
            break;
          }
          case "signature": {
            let R;
            const M = S.sign, _ = S.post;
            if (i.log(["Execute Steps: Begin signature step"], me.Verbose), M && (A.progressState = "signing", r({
              steps: [...l.steps],
              fees: { ...l == null ? void 0 : l.fees },
              breakdown: l == null ? void 0 : l.breakdown,
              details: l == null ? void 0 : l.details
            }), R = await n.handleSignMessageStep(A, g), R && (e.params = {
              ...e.params,
              signature: R
            })), t === 1337 && R && await Xq(i, R, A), _) {
              i.log(["Execute Steps: Posting order"], me.Verbose), A.progressState = "posting", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              });
              const j = new URL(`${e.baseURL}${_.endpoint}`), I = {
                "Content-Type": "application/json"
              };
              _.body && !_.body.referrer && (_.body.referrer = i.source);
              try {
                const $ = await async function() {
                  return await Xt.request({
                    url: j.href,
                    data: _.body ? JSON.stringify(_.body) : void 0,
                    method: _.method,
                    params: e.params,
                    headers: I
                  });
                }();
                if ($.data && $.data.steps && Array.isArray($.data.steps)) {
                  l.steps = [...l.steps, ...$.data.steps], r({
                    steps: [...l.steps, ...$.data.steps],
                    fees: { ...l.fees },
                    breakdown: l.breakdown,
                    details: l.details
                  }), i.log([
                    `Execute Steps: New steps appended from ${_.endpoint}`,
                    $.data.steps
                  ], me.Verbose);
                  break;
                }
                if ($.status > 299 || $.status < 200)
                  throw $.data;
                $.data.results ? A.orderData = $.data.results : $.data && $.data.orderId && (A.orderData = [
                  {
                    orderId: $.data.orderId,
                    crossPostingOrderId: $.data.crossPostingOrderId,
                    orderIndex: $.data.orderIndex || 0
                  }
                ]), r({
                  steps: [...l == null ? void 0 : l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              } catch (F) {
                throw F;
              }
            }
            if (A != null && A.check) {
              A.progressState = "validating", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              }), A.isValidatingSignature = !0, r({
                steps: [...l == null ? void 0 : l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              });
              const j = {
                "Content-Type": "application/json"
              };
              await xw({
                url: `${e.baseURL}${A == null ? void 0 : A.check.endpoint}`,
                method: A == null ? void 0 : A.check.method,
                headers: j
              }, (I) => {
                var F, $, V, X, Z, Y, W, Q, oe, te;
                if (i.log([
                  "Execute Steps: Polling execute status to check if indexed",
                  I
                ], me.Verbose), ((F = I == null ? void 0 : I.data) == null ? void 0 : F.status) === "success" && (($ = I == null ? void 0 : I.data) != null && $.txHashes)) {
                  const ae = (X = (V = I.data) == null ? void 0 : V.txHashes) == null ? void 0 : X.map((ue) => ({
                    txHash: ue,
                    chainId: I.data.destinationChainId ?? (u == null ? void 0 : u.id)
                  }));
                  if ((Z = I == null ? void 0 : I.data) != null && Z.inTxHashes) {
                    const ue = (W = (Y = I.data) == null ? void 0 : Y.inTxHashes) == null ? void 0 : W.map((Ie) => ({
                      txHash: Ie,
                      chainId: (u == null ? void 0 : u.id) ?? I.data.originChainId
                    }));
                    A.internalTxHashes = ue;
                  }
                  return A.txHashes = ae, !0;
                } else {
                  if (((Q = I == null ? void 0 : I.data) == null ? void 0 : Q.status) === "failure")
                    throw Error(((oe = I == null ? void 0 : I.data) == null ? void 0 : oe.details) || "Transaction failed");
                  ((te = I == null ? void 0 : I.data) == null ? void 0 : te.status) === "delayed" && (A.progressState = "validating_delayed");
                }
                return !1;
              }, c, 0, o);
            }
            break;
          }
          default:
            break;
        }
        A.status = "complete", A.progressState = "complete", A.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        }), N(A);
      } catch (S) {
        const R = S, M = R ? R.message : "Error: something went wrong";
        R && (l != null && l.steps) && (l.steps[b].error = M, A.error = M, A.errorData = ((C = S == null ? void 0 : S.response) == null ? void 0 : C.data) || S, A.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        })), D(R);
      }
    }));
    return await Promise.all(T), await mm(t, e, n, r, l, a);
  } catch (b) {
    i.log(["Execute Steps: An error occurred", b], me.Error);
    const y = b && ((f = b == null ? void 0 : b.response) != null && f.data) ? b.response.data : b;
    let g = !1;
    throw y && y.message ? g = y.message.includes("Refunded") : y && y.includes && (g = y.includes("Refunded")), l ? (l.error = y, r({
      steps: l.steps ? [...l.steps] : [{}],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details,
      refunded: g,
      error: y
    })) : (l = {
      error: y,
      steps: [],
      refunded: g
    }, r(l)), b;
  }
}
function Zq(t, e) {
  Object.keys(e).map((n) => {
    var s;
    let r = e[n];
    return r !== void 0 && (Array.isArray(r) ? r.forEach((a) => {
      t.searchParams.append(n, a);
    }) : t.searchParams.append(n, (s = e[n]) == null ? void 0 : s.toString())), t;
  });
}
function kw(t) {
  var a;
  const { abi: e, functionName: n, args: r } = t, s = Kt({ abi: e, functionName: n, args: r });
  return {
    to: t.address,
    value: ((a = t == null ? void 0 : t.value) == null ? void 0 : a.toString()) ?? "0",
    data: s
  };
}
function vw(t) {
  return t.extend !== void 0 && t.getPermissions !== void 0;
}
const ym = (t) => ({
  vmType: "evm",
  getChainId: async () => t.getChainId(),
  transport: Ou(t.transport),
  address: async () => {
    var n;
    let e = (n = t.account) == null ? void 0 : n.address;
    return e || ([e] = await t.getAddresses()), e;
  },
  handleSignMessageStep: async (e) => {
    var a;
    const n = Me(), r = (a = e.data) == null ? void 0 : a.sign;
    let s;
    if (r) {
      if (r.signatureKind === "eip191")
        n.log(["Execute Steps: Signing with eip191"], me.Verbose), r.message.match(/0x[0-9a-fA-F]{64}/) ? s = await t.signMessage({
          account: t.account,
          message: {
            raw: r.message
          }
        }) : s = await t.signMessage({
          account: t.account,
          message: r.message
        });
      else if (r.signatureKind === "eip712") {
        const i = {
          account: t.account,
          domain: r.domain,
          types: r.types,
          primaryType: r.primaryType,
          message: r.value
        };
        n.log(["Execute Steps: Signing with eip712", i], me.Verbose), s = await t.signTypedData(i);
      }
    }
    return s;
  },
  handleSendTransactionStep: async (e, n) => {
    var o;
    const r = n.data, s = Me(), a = (o = Me().chains.find((c) => c.id === e)) == null ? void 0 : o.viemChain;
    if (!a)
      throw "Chain not found when sending transaction";
    return await Kd({
      account: t.account ?? r.from,
      chain: a,
      transport: Ou(t.transport, { retryCount: 10, retryDelay: 200 })
    }).sendTransaction({
      chain: a,
      data: r.data,
      account: t.account ?? r.from,
      // use signer.account if it's defined
      to: r.to,
      value: sa(r.value || 0),
      ...r.maxFeePerGas && s.useGasFeeEstimations && {
        maxFeePerGas: sa(r.maxFeePerGas)
      },
      ...r.maxPriorityFeePerGas && s.useGasFeeEstimations && {
        maxPriorityFeePerGas: sa(r.maxPriorityFeePerGas)
      },
      ...r.gas && s.useGasFeeEstimations && {
        gas: sa(r.gas)
      }
    });
  },
  handleConfirmTransactionStep: async (e, n, r, s) => {
    const a = Me(), i = a.chains.find((l) => l.id === n), o = i == null ? void 0 : i.httpRpcUrl;
    return await hn({
      chain: i == null ? void 0 : i.viemChain,
      transport: t.transport ? NE(o ? [Ge(o), Ou(t.transport), Ge()] : [Ou(t.transport), Ge()]) : NE([Ge(o), Ge()]),
      pollingInterval: a.confirmationPollingInterval
    }).waitForTransactionReceipt({
      hash: e,
      onReplaced: (l) => {
        if (l.reason === "cancelled")
          throw s(), Error("Transaction cancelled");
        r(l.transaction.hash);
      }
    });
  },
  switchChain: async (e) => {
    var n;
    try {
      await t.switchChain({
        id: e
      });
      return;
    } catch (r) {
      if (r && (r != null && r.message)) {
        if (r.message.includes("does not support the requested chain"))
          throw new Error("Wallet does not support chain");
        if (r.message.includes("rejected"))
          throw r;
        if (r.message.includes("already pending"))
          return;
      }
      const a = Me().chains.find((i) => i.id === e);
      if (!a)
        throw "Chain missing from Relay Client";
      try {
        await t.addChain({
          chain: a == null ? void 0 : a.viemChain
        });
      } catch (i) {
        if (i instanceof Error && i.name && i.name === "InternalRpcError" && i.message.includes("is not a function")) {
          (n = Me()) == null || n.log([
            "Execute Steps: Detected internal RPC Error when adding a chain to the wallet",
            i
          ], me.Verbose);
          return;
        } else
          throw i;
      }
      return;
    }
  },
  supportsAtomicBatch: async (e) => {
    var n;
    if (!t.account)
      return !1;
    try {
      const r = await t.getCapabilities({
        account: t.account,
        chainId: e
      });
      return (n = r == null ? void 0 : r.atomicBatch) == null ? void 0 : n.supported;
    } catch {
      return !1;
    }
  },
  handleBatchTransactionStep: async (e, n) => {
    var o;
    const r = n.map((c) => ({
      to: c.data.to,
      data: c.data.data,
      value: sa(c.data.value || 0),
      ...c.data.maxFeePerGas && {
        maxFeePerGas: sa(c.data.maxFeePerGas)
      },
      ...c.data.maxPriorityFeePerGas && {
        maxPriorityFeePerGas: sa(c.data.maxPriorityFeePerGas)
      },
      ...c.data.gas && {
        gas: sa(c.data.gas)
      }
    })), a = (o = Me().chains.find((c) => c.id === e)) == null ? void 0 : o.viemChain;
    if (!a)
      throw "Chain not found when sending transaction";
    const { id: i } = await t.sendCalls({
      chain: a,
      account: t.account,
      calls: r
    });
    return i;
  }
}), aC = "https://api.relay.link", Ga = "https://assets.relay.link", Yq = Object.values(cm).reduce((t, e) => (t[e.id] = e, t), {}), iC = (t) => {
  let e;
  const r = [999, 1337].includes(t.id) ? void 0 : Yq[t.id];
  return r ? e = r : e = {
    id: t.id,
    name: t.displayName,
    nativeCurrency: {
      name: t.currency.name ?? "Ethereum",
      decimals: t.currency.decimals ?? 18,
      symbol: t.currency.symbol ?? "ETH"
    },
    rpcUrls: {
      default: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      },
      public: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      }
    },
    blockExplorers: {
      etherscan: {
        name: t.explorerName,
        url: t.explorerUrl
      },
      default: {
        name: t.explorerName,
        url: t.explorerUrl
      }
    }
  }, {
    ...t,
    viemChain: e,
    icon: {
      dark: `${Ga}/icons/${t.id}/dark.png`,
      light: t.iconUrl ?? `${Ga}/icons/${t.id}/light.png`,
      squaredDark: `${Ga}/icons/square/${t.id}/dark.png`,
      squaredLight: `${Ga}/icons/square/${t.id}/light.png`
    }
  };
}, bm = (t) => {
  var e;
  return {
    id: t.id,
    name: t.name.replace(" ", "-"),
    displayName: t.name,
    httpRpcUrl: t.rpcUrls.default && t.rpcUrls.default && t.rpcUrls.default ? t.rpcUrls.default.http[0] ?? "" : "",
    wsRpcUrl: t.rpcUrls && t.rpcUrls.default.webSocket ? t.rpcUrls.default.webSocket[0] ?? "" : "",
    icon: {
      dark: `${Ga}/icons/${t.id}/dark.png`,
      light: `${Ga}/icons/${t.id}/light.png`,
      squaredDark: `${Ga}/icons/square/${t.id}/dark.png`,
      squaredLight: `${Ga}/icons/square/${t.id}/light.png`
    },
    currency: {
      address: Ne,
      ...t.nativeCurrency
    },
    explorerUrl: ((e = t.blockExplorers) == null ? void 0 : e.default.url) ?? "",
    vmType: "evm",
    depositEnabled: !0,
    viemChain: t
  };
}, eK = async (t, e) => {
  let n = "";
  if (e) {
    const s = new URLSearchParams();
    s.set("referrer", e), n = `?${s.toString()}`;
  }
  const r = await Xt.get(`${t}/chains${n}`);
  if (r.data && r.data.chains)
    return r.data.chains.map((s) => iC(s));
  throw "No Chain Data";
}, oC = (t) => {
  let e = null, n, r = [];
  for (const s of t) {
    for (const a of s.items || [])
      if (a.txHashes && a.txHashes.length > 0 && (r = a.txHashes.concat([...r])), a.internalTxHashes && a.internalTxHashes.length > 0 && (r = a.internalTxHashes.concat([...r])), a.status === "incomplete") {
        e = s, n = a;
        break;
      }
    if (e && n)
      break;
  }
  return { currentStep: e, currentStepItem: n, txHashes: r };
};
function Cw(t) {
  return t.abi !== void 0;
}
function Tw(t) {
  return typeof structuredClone == "function" ? structuredClone(t) : JSON.parse(JSON.stringify(t));
}
const tK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APIError: tu,
  get LogLevel() {
    return me;
  },
  adaptViemWallet: ym,
  axios: Xt,
  configureViemChain: iC,
  convertViemChainToRelayChain: bm,
  executeSteps: mm,
  fetchChainConfigs: eK,
  getCurrentStepData: oC,
  isAPIError: zq,
  isSimulateContractRequest: Cw,
  log: ug,
  pollUntilHasData: Ew,
  pollUntilOk: xw,
  prepareCallTransaction: kw,
  prepareHyperliquidSignatureStep: sC,
  repeatUntilOk: Aw,
  request: Gq,
  safeStructuredClone: Tw,
  setParams: Zq
}, Symbol.toStringTag, { value: "Module" })), nK = "2.3.2";
let Hu;
const rK = [
  $e,
  At,
  ch,
  Pt,
  ut,
  ai
].map((t) => bm(t)), sK = [ls, t3].map((t) => bm(t));
class aK {
  log(e, n = me.Info) {
    return ug(e, n, this.logLevel);
  }
  constructor(e) {
    var n;
    if (Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uiVersion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "baseApiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "source", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logLevel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "confirmationPollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxPollingAttemptsBeforeTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useGasFeeEstimations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utils", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { ...tK }
    }), Object.defineProperty(this, "actions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s7
    }), this.version = nK, this.uiVersion = e.uiVersion, this.baseApiUrl = e.baseApiUrl ?? aC, this.logLevel = e.logLevel !== void 0 ? e.logLevel : me.None, this.pollingInterval = e.pollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations ?? !0, e.chains ? this.chains = e.chains : (n = e.baseApiUrl) != null && n.includes("testnets") ? this.chains = sK : this.chains = rK, e.source)
      this.source = e.source;
    else if (typeof window < "u") {
      let r = location.hostname;
      r.indexOf("www.") === 0 && (r = r.replace("www.", "")), this.source = r, console.warn("RelaySDK automatically generated a source based on the url, we recommend providing a source when initializing the sdk. Refer to our docs for steps on how to do this: https://docs.relay.link/references/sdk/getting-started#configuration");
    }
  }
  configure(e) {
    this.baseApiUrl = e.baseApiUrl ? e.baseApiUrl : this.baseApiUrl, this.source = e.source ? e.source : this.source, this.logLevel = e.logLevel !== void 0 ? e.logLevel : me.None, this.pollingInterval = e.pollingInterval ? e.pollingInterval : this.pollingInterval, this.confirmationPollingInterval = e.confirmationPollingInterval ? e.confirmationPollingInterval : this.confirmationPollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout ? e.maxPollingAttemptsBeforeTimeout : this.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations !== void 0 ? e.useGasFeeEstimations : this.useGasFeeEstimations, e.logger ? this.log = e.logger : this.log = (n, r = me.Info) => {
      ug(n, r, this.logLevel);
    }, e.chains && (this.chains = e.chains);
  }
}
function Me() {
  return Hu;
}
function iK(t) {
  return Hu ? Hu.configure(t) : Hu = new aK({ ...t }), Hu;
}
const cC = "0x000000000000000000000000000000000000dead", lC = "CbKGgVKLJFb8bBrf58DnAkdryX6ubewVytn7X957YwNr", uC = "CrfbABN2sSvmoZLu9eDDfXpaC2nHg42R7AXbHs9eg4S9", dC = "bc1q4vxn43l44h30nkluqfxd9eckf45vr2awz38lwa", oK = "THa7BwoPfacfiELa63pbmm3g5PGKYmtJyt", cK = "0x00000000000000000000000000000000000dead0", fC = "0x000000000000000000000000000000000000000000000000000000000000dead", lK = 9286185, uK = 543210, bg = (t, e) => t === "svm" ? e === lK ? uC : lC : t === "bvm" ? dC : e === uK ? cK : t === "tvm" ? oK : t === "suivm" ? fC : cC, V2 = (t) => t ? t === uC || t === lC || t === dC || t === cC || t === fC : !1;
function dK(t) {
  var o, c, u, l, d;
  const { quote: e, wallet: n, depositGasLimit: r, onProgress: s } = t, a = Me();
  if (!a.baseApiUrl || !a.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let i;
  n && (i = vw(n) ? ym(n) : n);
  try {
    if (!i)
      throw new Error("AdaptedWallet is required to execute steps");
    const p = new AbortController(), f = (u = (c = (o = e.details) == null ? void 0 : o.currencyIn) == null ? void 0 : c.currency) == null ? void 0 : u.chainId;
    if (f === void 0)
      throw new Error("Missing chainId from quote");
    if (V2((l = e == null ? void 0 : e.details) == null ? void 0 : l.recipient))
      throw new Error("Recipient should never be burn address");
    if (V2((d = e == null ? void 0 : e.details) == null ? void 0 : d.sender))
      throw new Error("Sender should never be burn address");
    const { request: b, ...y } = e, g = Tw(y), w = new Promise((k, E) => {
      mm(f, b, i, ({ steps: T, fees: A, breakdown: N, details: D, refunded: P, error: C }) => {
        if (p.signal.aborted) {
          console.log("Relay SDK: Execution aborted, skipping progress callback");
          return;
        }
        const { currentStep: S, currentStepItem: R, txHashes: M } = oC(T);
        s == null || s({
          steps: T,
          fees: A,
          breakdown: N,
          details: D,
          currentStep: S,
          currentStepItem: R,
          txHashes: M,
          refunded: P,
          error: C
        });
      }, g, r ? {
        deposit: {
          gasLimit: r
        }
      } : void 0).then((T) => {
        k({ data: T, abortController: p });
      }).catch(E);
    });
    return w.abortController = p, w;
  } catch (p) {
    throw console.error(p), p;
  }
}
const fK = async (t, e, n, r, s) => {
  const a = t.chains.find((l) => l.id === n), i = t.chains.find((l) => l.id === e), o = a ? bg(a.vmType, a.id) : void 0, c = i ? bg(i.vmType, i.id) : void 0;
  let u;
  return s && (u = await s.address()), {
    user: u || o || Ne,
    recipient: r || u || c || Ne
  };
};
async function pK(t, e) {
  var T;
  const { toChainId: n, toCurrency: r, wallet: s, chainId: a, currency: i, tradeType: o, amount: c = "0", recipient: u, options: l, txs: d, user: p } = t, f = Me();
  if (!f.baseApiUrl || !f.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let b;
  s && (b = vw(s) ? ym(s) : s);
  let y;
  d && d.length > 0 && (y = d.map((A) => Cw(A) ? kw(A) : A));
  let g;
  if (e && (g = await fK(f, n, a, u, b)), !p && !(g != null && g.user))
    throw new Error("User is required");
  if (!u && !(g != null && g.recipient))
    throw new Error("Recipient is required");
  const w = {
    user: e ? g == null ? void 0 : g.user : p,
    destinationCurrency: r,
    destinationChainId: n,
    originCurrency: i,
    originChainId: a,
    amount: c,
    recipient: e ? g == null ? void 0 : g.recipient : u,
    tradeType: o,
    referrer: f.source || void 0,
    txs: y,
    ...l
  }, k = {
    url: `${f.baseApiUrl}/quote`,
    method: "post",
    data: w
  }, E = await Xt.request(k);
  if (E.status !== 200)
    throw new tu((T = E == null ? void 0 : E.data) == null ? void 0 : T.message, E.status, E.data);
  return { ...E.data, request: k };
}
async function hK(t) {
  var k;
  const { destinationChainId: e, destinationCurrency: n, originChainId: r, originCurrency: s, tradeType: a, amount: i = "0", user: o, recipient: c, options: u, txs: l } = t, d = Me();
  if (!d.baseApiUrl || !d.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let p;
  l && l.length > 0 && (p = l.map((E) => Cw(E) ? kw(E) : E));
  const f = d.chains.find((E) => E.id === r), b = bg(f == null ? void 0 : f.vmType, f == null ? void 0 : f.id), y = {
    user: o ?? b,
    destinationCurrency: n,
    destinationChainId: e,
    originCurrency: s,
    originChainId: r,
    amount: i,
    recipient: c || (o ?? b),
    tradeType: a,
    referrer: d.source || void 0,
    txs: p,
    ...u
  }, g = {
    url: `${d.baseApiUrl}/price`,
    method: "post",
    data: y
  }, w = await Xt.request(g);
  if (w.status !== 200)
    throw new tu((k = w == null ? void 0 : w.data) == null ? void 0 : k.message, w.status, w.data);
  return { ...w.data, request: g };
}
async function mK(t, e = Xt) {
  const n = Me();
  if (!n)
    throw new Error("Client not initialized");
  t.user = t.user || Ne, t.currency = t.currency;
  const r = await e.get(`${n.baseApiUrl}/config/v2`, { params: t });
  if (r.data)
    return r.data;
  throw "No solver capacity data";
}
async function yK(t) {
  var a;
  const { wallet: e } = t, n = Me();
  if (!n.baseApiUrl || !n.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  const r = {
    url: `${n.baseApiUrl}/app-fees/${e}/balances`,
    method: "get"
  }, s = await Xt.request(r);
  if (s.status !== 200)
    throw new tu((a = s == null ? void 0 : s.data) == null ? void 0 : a.message, s.status, s.data);
  return s.data.balances || [];
}
async function bK(t) {
  var d;
  const { wallet: e, chainId: n, currency: r, recipient: s, onProgress: a } = t, i = Me();
  if (!i.baseApiUrl || !i.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let o;
  if (e && (o = vw(e) ? ym(e) : e), !o)
    throw new Error("AdaptedWallet is required to execute claim steps");
  const c = await o.address(), u = new AbortController(), l = {
    url: `${i.baseApiUrl}/app-fees/${c}/claim`,
    method: "post",
    data: { chainId: n, currency: r, recipient: s || c },
    signal: u.signal
  };
  try {
    const p = await i.utils.axios.request(l);
    if (p.status !== 200)
      throw new tu((d = p == null ? void 0 : p.data) == null ? void 0 : d.message, p.status, p.data);
    const f = p.data.steps || [], b = Tw({
      steps: f
    });
    return { data: await mm(n, l, o, (g) => {
      u.signal.aborted || a == null || a(g);
    }, b), abortController: u };
  } catch (p) {
    throw console.error(p), p;
  }
}
iK({
  baseApiUrl: aC,
  source: "Trails",
  chains: Object.values(cm).map(
    (t) => bm(t)
  )
});
async function gK(t) {
  try {
    const e = Me();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("[trails-sdk] getRelaySDKQuote", t), await e.actions.getQuote({
      wallet: t.wallet,
      chainId: t.chainId,
      toChainId: t.toChainId || t.chainId,
      amount: t.amount,
      currency: t.currency,
      toCurrency: t.toCurrency || t.currency,
      tradeType: t.tradeType || "EXACT_OUTPUT",
      txs: t.txs,
      user: t.wallet.account.address,
      recipient: t.recipient || t.wallet.account.address,
      options: {
        slippageTolerance: t.slippageTolerance ? Math.round(Number(t.slippageTolerance) * 100 * 100).toString() : void 0
      }
    });
  } catch (e) {
    throw console.error("[trails-sdk] Error getting relay quote:", e), e;
  }
}
async function wK(t) {
  try {
    const e = Me();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("[trails-sdk] relaysdkclient", e.chains, t.quote), await e.actions.execute({
      quote: t.quote,
      wallet: t.wallet,
      onProgress: t.onProgress || ((r) => {
        console.log("[trails-sdk] Relay progress:", r);
      })
    });
  } catch (e) {
    throw console.error("[trails-sdk] Error executing relay transaction:", e), e;
  }
}
async function EK(t, e, n) {
  return await wK({
    quote: t,
    wallet: e,
    onProgress: n
  });
}
function xK(t) {
  var n, r, s, a, i, o, c, u, l, d, p, f, b, y, g, w;
  let e = (u = (c = (o = (i = (a = (s = (n = t == null ? void 0 : t.data) == null ? void 0 : n.steps) == null ? void 0 : s[((r = t == null ? void 0 : t.data) == null ? void 0 : r.steps.length) - 1]) == null ? void 0 : a.items) == null ? void 0 : i[0]) == null ? void 0 : o.txHashes) == null ? void 0 : c[0]) == null ? void 0 : u.txHash;
  if (e || (e = (w = (g = (y = (b = (f = (p = (l = t == null ? void 0 : t.data) == null ? void 0 : l.steps) == null ? void 0 : p[((d = t == null ? void 0 : t.data) == null ? void 0 : d.steps.length) - 1]) == null ? void 0 : f.items) == null ? void 0 : b[0]) == null ? void 0 : y.internalTxHashes) == null ? void 0 : g[0]) == null ? void 0 : w.txHash), !e)
    throw new Error("No transaction hash found in relay result");
  return e;
}
const AK = {
  [yb.id]: yb,
  [bb.id]: bb,
  [So.id]: So,
  [ut.id]: ut,
  [ai.id]: ai,
  [gb.id]: gb,
  [pn.id]: pn,
  [Io.id]: Io,
  [At.id]: At,
  [wb.id]: wb,
  [Ml.id]: Ml,
  [qb.id]: qb,
  [Eb.id]: Eb,
  [xb.id]: xb,
  [Ab.id]: Ab,
  [kb.id]: kb,
  [vb.id]: vb,
  [Cb.id]: Cb,
  [Tb.id]: Tb,
  [$e.id]: $e,
  [Sb.id]: Sb,
  [Ib.id]: Ib,
  [Ob.id]: Ob,
  [Oo.id]: Oo,
  [Bb.id]: Bb,
  [Pb.id]: Pb,
  [Ub.id]: Ub,
  [Nb.id]: Nb,
  [js.id]: js,
  [Hb.id]: Hb,
  [_b.id]: _b,
  [$b.id]: $b,
  [Gb.id]: Gb,
  [zb.id]: zb,
  [jb.id]: jb,
  [Vb.id]: Vb,
  [Pt.id]: Pt,
  [Kb.id]: Kb,
  [ft.id]: ft,
  [Wb.id]: Wb,
  [Jb.id]: Jb,
  [Qb.id]: Qb,
  [Xb.id]: Xb,
  [Zb.id]: Zb,
  [Yb.id]: Yb,
  [eg.id]: eg,
  [Po.id]: Po,
  [tg.id]: tg,
  [ng.id]: ng,
  [rg.id]: rg,
  [sg.id]: sg,
  [ag.id]: ag,
  [ig.id]: ig,
  [og.id]: og,
  [Vs.id]: Vs,
  [qs.id]: qs,
  [Uo.id]: Uo,
  [cg.id]: cg,
  [lg.id]: lg,
  [oh.id]: oh,
  [ch.id]: ch
};
async function kK() {
  return Object.values(AK);
}
async function vK() {
  try {
    const t = await TK(), e = [];
    t.forEach((r) => {
      r.disabled || (e.push({
        id: r.currency.id,
        symbol: r.currency.symbol,
        name: r.currency.name,
        contractAddress: r.currency.address,
        decimals: r.currency.decimals,
        chainId: r.id,
        chainName: r.displayName || r.name,
        imageUrl: ""
        // Native currencies typically don't have logoURI
      }), r.featuredTokens.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }), r.erc20Currencies.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }), r.solverCurrencies.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }));
    });
    const n = e.filter(
      (r, s, a) => s === a.findIndex(
        (i) => i.chainId === r.chainId && i.contractAddress.toLowerCase() === r.contractAddress.toLowerCase()
      )
    );
    return console.log(
      `[trails-sdk] Fetched ${n.length} unique tokens from Relay API`
    ), n;
  } catch (t) {
    return console.error("[trails-sdk] Error fetching Relay supported tokens:", t), [];
  }
}
let Cu = null, q2 = 0;
const CK = 5 * 60 * 1e3;
async function TK() {
  const t = Date.now();
  if (Cu && t - q2 < CK)
    return Cu;
  try {
    const e = await fetch("https://api.relay.link/chains");
    if (!e.ok)
      throw new Error(`Failed to fetch chains: ${e.status}`);
    const n = await e.json();
    return Cu = n.chains, q2 = t, n.chains;
  } catch (e) {
    if (console.error("[trails-sdk] Error fetching Relay chains:", e), Cu)
      return Cu;
    throw e;
  }
}
async function SK(t) {
  try {
    const e = await fetch(
      `https://api.relay.link/intents/status/v2?requestId=${t}`
    );
    if (!e.ok)
      throw new Error(
        `Failed to fetch relay status: ${e.status} ${e.statusText}`
      );
    return await e.json();
  } catch (e) {
    throw console.error("[trails-sdk] Error fetching relay request status:", e), e;
  }
}
async function IK(t) {
  var a;
  const r = Date.now(), s = (i) => new Promise((o) => setTimeout(o, i));
  for (; Date.now() - r < 3e5; )
    try {
      const i = await SK(t);
      if (!i)
        throw new Error("No status found");
      if (i.inTxHashes && i.inTxHashes.length > 0 && i.originChainId === i.destinationChainId)
        return i.inTxHashes[i.inTxHashes.length - 1];
      if (console.log("[trails-sdk] Relay status check:", {
        requestId: t,
        status: i.status,
        txHashesCount: ((a = i.txHashes) == null ? void 0 : a.length) || 0
      }), i.txHashes && i.txHashes.length > 0) {
        const o = i.txHashes[i.txHashes.length - 1];
        if (o)
          return console.log("[trails-sdk] Relay transaction completed:", o), o;
      }
      if (i.status === "failed" || i.status === "error")
        throw new Error(
          `Relay transaction failed with status: ${i.status}`
        );
      await s(5e3);
    } catch (i) {
      if (i instanceof Error && (i.message.includes("Failed to fetch relay status") || i.message.includes("No status found"))) {
        console.warn(
          "[trails-sdk] Relay status not yet available, continuing to poll..."
        ), await s(5e3);
        continue;
      }
      throw i;
    }
  throw new Error(
    `Timeout waiting for relay transaction after ${3e5 / 1e3} seconds`
  );
}
const K2 = {
  [ut.id]: "https://nodes.sequence.app/arbitrum",
  [At.id]: "https://nodes.sequence.app/base",
  [$e.id]: "https://nodes.sequence.app/mainnet",
  [Pt.id]: "https://nodes.sequence.app/optimism",
  [Oo.id]: "https://nodes.sequence.app/gnosis",
  [ft.id]: "https://nodes.sequence.app/polygon",
  [Po.id]: "https://nodes.sequence.app/soneium",
  [Uo.id]: "https://nodes.sequence.app/xai",
  [So.id]: "https://nodes.sequence.app/apechain",
  [ai.id]: "https://nodes.sequence.app/arbitrum-nova",
  [pn.id]: "https://nodes.sequence.app/avalanche",
  [Io.id]: "https://nodes.sequence.app/b3",
  [Ml.id]: "https://nodes.sequence.app/blast",
  [wd.id]: "https://nodes.sequence.app/bsc"
}, OK = (t, e = lv()) => K2[t] ? `${K2[t]}/${e}` : null, BK = {
  [So.id]: pe(So.id),
  [ut.id]: pe(ut.id),
  [ai.id]: pe(ai.id),
  [pn.id]: pe(pn.id),
  [Io.id]: pe(Io.id),
  [At.id]: pe(At.id),
  [Ml.id]: pe(ft.id),
  [wd.id]: pe(wd.id),
  [$e.id]: pe($e.id),
  [Oo.id]: pe(Oo.id),
  [Pt.id]: pe(Pt.id),
  [ft.id]: pe(ft.id),
  [Po.id]: pe(Po.id),
  [Uo.id]: pe(Uo.id)
}, PK = {
  [cs.id]: pe(cs.id),
  [ii.id]: pe(ii.id),
  [Yp.id]: pe(Yp.id),
  [zs.id]: pe(zs.id),
  [eh.id]: pe(eh.id),
  [th.id]: pe(th.id),
  [ls.id]: pe(ls.id),
  [nh.id]: pe(nh.id),
  [ci.id]: pe(ci.id),
  [oi.id]: pe(oi.id),
  [ah.id]: pe(ah.id),
  [ih.id]: pe(ih.id)
}, UK = {
  [ut.id]: cs,
  [pn.id]: ii,
  [At.id]: zs,
  [Oo.id]: nh,
  [Pt.id]: oi,
  [ft.id]: ci,
  [$e.id]: ls,
  [Uo.id]: ih,
  [Po.id]: ah,
  [Io.id]: Yp,
  [Ml.id]: eh,
  [wd.id]: th,
  [ai.id]: cs,
  [So.id]: ls
};
function pe(t, e) {
  const n = Object.values(cm).find(
    (r) => r.id === t
  ) || null;
  if (n && !(e != null && e.usePublicRpc)) {
    const r = OK(t);
    r && (n.rpcUrls = {
      default: {
        ...n.rpcUrls.default,
        http: [r]
      },
      public: {
        ...n.rpcUrls.public,
        http: [r]
      }
    });
  }
  return n;
}
function Op(t) {
  let e = 0;
  return typeof t == "number" || typeof t == "string" ? e = Number(t) : e = t.id, UK[e] || null;
}
async function NK() {
  return Object.values(BK);
}
const W2 = [1, 8453, 42161, 10, 137];
function RK(t) {
  return t.sort((e, n) => {
    const r = W2.indexOf(e.id), s = W2.indexOf(n.id);
    return r !== -1 && s !== -1 ? r - s : r !== -1 ? -1 : s !== -1 ? 1 : e.name.localeCompare(n.name);
  });
}
async function pC() {
  const t = await NK(), e = await kK(), r = t.filter(
    (s) => e.some((a) => a.id === s.id)
  ).filter(
    (s, a, i) => a === i.findIndex((o) => o.id === s.id)
  );
  return RK(r);
}
function Ire() {
  const { data: t = [], isLoading: e } = ar({
    queryKey: ["supportedChains"],
    queryFn: pC,
    staleTime: 36e5,
    // 1 hour - chains rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return {
    supportedChains: t || [],
    isLoadingChains: e
  };
}
function hC(t) {
  return Object.keys(PK).includes(t.toString());
}
function Ore(t) {
  switch (t) {
    case 1:
      return "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200";
    case 8453:
      return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200";
    case 42161:
      return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
    case 137:
      return "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200";
    case 10:
      return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
    default:
      return "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200";
  }
}
function DK({
  indexerGatewayUrl: t = C4(),
  projectAccessKey: e = $o(),
  jwt: n
}) {
  return new hI(
    t,
    e,
    n
  );
}
const df = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = i6();
  return Eo(() => DK({
    indexerGatewayUrl: (t == null ? void 0 : t.indexerGatewayUrl) ?? r.indexerGatewayUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.indexerGatewayUrl, t]);
};
function FK(t) {
  for (const e of t)
    if (typeof e != "string")
      return !1;
  return !0;
}
function MK(t) {
  return FK(t) ? im(t) : t;
}
const LK = "0.1.1";
function HK() {
  return LK;
}
let Xe = class gg extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof gg) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof gg && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${HK()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return mC(this, e);
  }
};
function mC(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? mC(t.cause, e) : e ? null : t;
}
const _K = "#__bigint";
function yC(t, e, n) {
  return JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() + _K : s, n);
}
function $K(t, e) {
  if (Z2(t) > e)
    throw new eW({
      givenSize: Z2(t),
      maxSize: e
    });
}
const ys = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Q2(t) {
  if (t >= ys.zero && t <= ys.nine)
    return t - ys.zero;
  if (t >= ys.A && t <= ys.F)
    return t - (ys.A - 10);
  if (t >= ys.a && t <= ys.f)
    return t - (ys.a - 10);
}
function bC(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  if (t.length > r)
    throw new tW({
      size: t.length,
      targetSize: r,
      type: "Bytes"
    });
  const s = new Uint8Array(r);
  for (let a = 0; a < r; a++) {
    const i = n === "right";
    s[i ? a : r - a - 1] = t[i ? a : t.length - a - 1];
  }
  return s;
}
function Sw(t, e) {
  if (or(t) > e)
    throw new WK({
      givenSize: or(t),
      maxSize: e
    });
}
function GK(t, e) {
  if (typeof e == "number" && e > 0 && e > or(t) - 1)
    throw new xC({
      offset: e,
      position: "start",
      size: or(t)
    });
}
function zK(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && or(t) !== n - e)
    throw new xC({
      offset: n,
      position: "end",
      size: or(t)
    });
}
function gC(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new QK({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
const jK = /* @__PURE__ */ new TextEncoder(), VK = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function qK(t, e = {}) {
  const { strict: n = !1 } = e;
  if (!t)
    throw new J2(t);
  if (typeof t != "string")
    throw new J2(t);
  if (n && !/^0x[0-9a-fA-F]*$/.test(t))
    throw new X2(t);
  if (!t.startsWith("0x"))
    throw new X2(t);
}
function Ks(...t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
function wC(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Sw(n, e.size), Ro(n, e.size)) : n;
}
function gm(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += VK[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (Sw(r, e.size), Do(r, e.size)) : r;
}
function nu(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new EC({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? Ro(c, r) : c;
}
function Iw(t, e = {}) {
  return gm(jK.encode(t), e);
}
function Ro(t, e) {
  return gC(t, { dir: "left", size: e });
}
function Do(t, e) {
  return gC(t, { dir: "right", size: e });
}
function wm(t, e, n, r = {}) {
  const { strict: s } = r;
  GK(t, e);
  const a = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return s && zK(a, e, n), a;
}
function or(t) {
  return Math.ceil((t.length - 2) / 2);
}
function KK(t, e = {}) {
  const { strict: n = !1 } = e;
  try {
    return qK(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
let EC = class extends Xe {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
class J2 extends Xe {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? yC(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexTypeError"
    });
  }
}
class X2 extends Xe {
  constructor(e) {
    super(`Value \`${e}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexValueError"
    });
  }
}
let WK = class extends Xe {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeOverflowError"
    });
  }
};
class xC extends Xe {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${r}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}
let QK = class extends Xe {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};
const JK = /* @__PURE__ */ new TextEncoder();
function XK(t) {
  if (!(t instanceof Uint8Array)) {
    if (!t)
      throw new lp(t);
    if (typeof t != "object")
      throw new lp(t);
    if (!("BYTES_PER_ELEMENT" in t))
      throw new lp(t);
    if (t.BYTES_PER_ELEMENT !== 1 || t.constructor.name !== "Uint8Array")
      throw new lp(t);
  }
}
function AC(...t) {
  let e = 0;
  for (const r of t)
    e += r.length;
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
function Hl(t) {
  return t instanceof Uint8Array ? t : typeof t == "string" ? _u(t) : ZK(t);
}
function ZK(t) {
  return t instanceof Uint8Array ? t : new Uint8Array(t);
}
function _u(t, e = {}) {
  const { size: n } = e;
  let r = t;
  n && (Sw(t, n), r = Do(t, n));
  let s = r.slice(2);
  s.length % 2 && (s = `0${s}`);
  const a = s.length / 2, i = new Uint8Array(a);
  for (let o = 0, c = 0; o < a; o++) {
    const u = Q2(s.charCodeAt(c++)), l = Q2(s.charCodeAt(c++));
    if (u === void 0 || l === void 0)
      throw new Xe(`Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`);
    i[o] = u * 16 + l;
  }
  return i;
}
function kC(t, e = {}) {
  const { size: n } = e, r = JK.encode(t);
  return typeof n == "number" ? ($K(r, n), YK(r, n)) : r;
}
function vC(t, e) {
  return bC(t, { dir: "left", size: e });
}
function YK(t, e) {
  return bC(t, { dir: "right", size: e });
}
function Z2(t) {
  return t.length;
}
function zu(t, e = {}) {
  return gm(t, e);
}
function Y2(t) {
  try {
    return XK(t), !0;
  } catch {
    return !1;
  }
}
class lp extends Xe {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? yC(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
}
class eW extends Xe {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeOverflowError"
    });
  }
}
let tW = class extends Xe {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};
function kd(t, e = {}) {
  const { as: n = typeof t == "string" ? "Hex" : "Bytes" } = e, r = Kv(Hl(t));
  return n === "Bytes" ? r : gm(r);
}
function nW(t, e = {}) {
  const { as: n = typeof t == "string" ? "Hex" : "Bytes" } = e, r = nw(Hl(t));
  return n === "Bytes" ? r : gm(r);
}
class rW extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
const sW = {
  checksum: /* @__PURE__ */ new rW(8192)
}, $0 = sW.checksum, aW = /^0x[a-fA-F0-9]{40}$/;
function ff(t, e = {}) {
  const { strict: n = !0 } = e;
  if (!aW.test(t))
    throw new eA({
      address: t,
      cause: new iW()
    });
  if (n) {
    if (t.toLowerCase() === t)
      return;
    if (CC(t) !== t)
      throw new eA({
        address: t,
        cause: new oW()
      });
  }
}
function CC(t) {
  if ($0.has(t))
    return $0.get(t);
  ff(t, { strict: !1 });
  const e = t.substring(2).toLowerCase(), n = kd(kC(e), { as: "Bytes" }), r = e.split("");
  for (let a = 0; a < 40; a += 2)
    n[a >> 1] >> 4 >= 8 && r[a] && (r[a] = r[a].toUpperCase()), (n[a >> 1] & 15) >= 8 && r[a + 1] && (r[a + 1] = r[a + 1].toUpperCase());
  const s = `0x${r.join("")}`;
  return $0.set(t, s), s;
}
function _l(t, e = {}) {
  const { checksum: n = !1 } = e;
  return ff(t), n ? CC(t) : t;
}
function wg(t, e = {}) {
  const { strict: n = !0 } = e ?? {};
  try {
    return ff(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
class eA extends Xe {
  constructor({ address: e, cause: n }) {
    super(`Address "${e}" is invalid.`, {
      cause: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidAddressError"
    });
  }
}
class iW extends Xe {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidInputError"
    });
  }
}
class oW extends Xe {
  constructor() {
    super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidChecksumError"
    });
  }
}
function Eg(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", "error", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new Xe("Unable to normalize signature.");
  return s;
}
function xg(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return wg(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => xg(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => xg(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function TC(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return TC(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? wg(n[r], {
      strict: !1
    }) : i.includes("address") && i.includes("bytes") ? wg(n[r], {
      strict: !1
    }) : !1)
      return i;
  }
}
function cW(t, e = {}) {
  const { prepare: n = !0 } = e, r = (Array.isArray(t), w2(t));
  return {
    ...r,
    ...n ? { hash: cc(r) } : {}
  };
}
function lW(t, e, n) {
  const { args: r = [], prepare: s = !0 } = n ?? {}, a = KK(e, { strict: !1 }), i = t.filter((u) => a ? u.type === "function" || u.type === "error" ? SC(u) === wm(e, 0, 4) : u.type === "event" ? cc(u) === e : !1 : "name" in u && u.name === e);
  if (i.length === 0)
    throw new Ag({ name: e });
  if (i.length === 1)
    return {
      ...i[0],
      ...s ? { hash: cc(i[0]) } : {}
    };
  let o;
  for (const u of i) {
    if (!("inputs" in u))
      continue;
    if (!r || r.length === 0) {
      if (!u.inputs || u.inputs.length === 0)
        return {
          ...u,
          ...s ? { hash: cc(u) } : {}
        };
      continue;
    }
    if (!u.inputs || u.inputs.length === 0 || u.inputs.length !== r.length)
      continue;
    if (r.every((d, p) => {
      const f = "inputs" in u && u.inputs[p];
      return f ? xg(d, f) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const d = TC(u.inputs, o.inputs, r);
        if (d)
          throw new dW({
            abiItem: u,
            type: d[0]
          }, {
            abiItem: o,
            type: d[1]
          });
      }
      o = u;
    }
  }
  const c = (() => {
    if (o)
      return o;
    const [u, ...l] = i;
    return { ...u, overloads: l };
  })();
  if (!c)
    throw new Ag({ name: e });
  return {
    ...c,
    ...s ? { hash: cc(c) } : {}
  };
}
function SC(t) {
  return wm(cc(t), 0, 4);
}
function uW(t) {
  const e = typeof t == "string" ? t : sh(t);
  return Eg(e);
}
function cc(t) {
  return typeof t != "string" && "hash" in t && t.hash ? t.hash : kd(Iw(uW(t)));
}
class dW extends Xe {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${e.type}\` in \`${Eg(sh(e.abiItem))}\`, and`,
        `\`${n.type}\` in \`${Eg(sh(n.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.AmbiguityError"
    });
  }
}
let Ag = class extends Xe {
  constructor({ name: e, data: n, type: r = "item" }) {
    const s = e ? ` with name "${e}"` : n ? ` with data "${n}"` : "";
    super(`ABI ${r}${s} not found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.NotFoundError"
    });
  }
};
const fW = /^(.*)\[([0-9]*)\]$/, pW = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, IC = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function hW({ checksumAddress: t, parameters: e, values: n }) {
  const r = [];
  for (let s = 0; s < e.length; s++)
    r.push(Ow({
      checksumAddress: t,
      parameter: e[s],
      value: n[s]
    }));
  return r;
}
function Ow({ checksumAddress: t = !1, parameter: e, value: n }) {
  const r = e, s = AW(r.type);
  if (s) {
    const [a, i] = s;
    return yW(n, {
      checksumAddress: t,
      length: a,
      parameter: {
        ...r,
        type: i
      }
    });
  }
  if (r.type === "tuple")
    return xW(n, {
      checksumAddress: t,
      parameter: r
    });
  if (r.type === "address")
    return mW(n, {
      checksum: t
    });
  if (r.type === "bool")
    return gW(n);
  if (r.type.startsWith("uint") || r.type.startsWith("int")) {
    const a = r.type.startsWith("int"), [, , i = "256"] = IC.exec(r.type) ?? [];
    return wW(n, {
      signed: a,
      size: Number(i)
    });
  }
  if (r.type.startsWith("bytes"))
    return bW(n, { type: r.type });
  if (r.type === "string")
    return EW(n);
  throw new PC(r.type);
}
function Bw(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += or(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(nu(e + s, { size: 32 })), r.push(o), s += or(o)) : n.push(o);
  }
  return Ks(...n, ...r);
}
function mW(t, e) {
  const { checksum: n = !1 } = e;
  return ff(t, { strict: n }), {
    dynamic: !1,
    encoded: Ro(t.toLowerCase())
  };
}
function yW(t, e) {
  const { checksumAddress: n, length: r, parameter: s } = e, a = r === null;
  if (!Array.isArray(t))
    throw new CW(t);
  if (!a && t.length !== r)
    throw new vW({
      expectedLength: r,
      givenLength: t.length,
      type: `${s.type}[${r}]`
    });
  let i = !1;
  const o = [];
  for (let c = 0; c < t.length; c++) {
    const u = Ow({
      checksumAddress: n,
      parameter: s,
      value: t[c]
    });
    u.dynamic && (i = !0), o.push(u);
  }
  if (a || i) {
    const c = Bw(o);
    if (a) {
      const u = nu(o.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: o.length > 0 ? Ks(u, c) : u
      };
    }
    if (i)
      return { dynamic: !0, encoded: c };
  }
  return {
    dynamic: !1,
    encoded: Ks(...o.map(({ encoded: c }) => c))
  };
}
function bW(t, { type: e }) {
  const [, n] = e.split("bytes"), r = or(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = Do(s, Math.ceil((t.length - 2) / 2 / 32) * 32)), {
      dynamic: !0,
      encoded: Ks(Ro(nu(r, { size: 32 })), s)
    };
  }
  if (r !== Number.parseInt(n))
    throw new OC({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: Do(t) };
}
function gW(t) {
  if (typeof t != "boolean")
    throw new Xe(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: Ro(wC(t)) };
}
function wW(t, { signed: e, size: n }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new EC({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: nu(t, {
      size: 32,
      signed: e
    })
  };
}
function EW(t) {
  const e = Iw(t), n = Math.ceil(or(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(Do(wm(e, s * 32, (s + 1) * 32)));
  return {
    dynamic: !0,
    encoded: Ks(Do(nu(or(e), { size: 32 })), ...r)
  };
}
function xW(t, e) {
  const { checksumAddress: n, parameter: r } = e;
  let s = !1;
  const a = [];
  for (let i = 0; i < r.components.length; i++) {
    const o = r.components[i], c = Array.isArray(t) ? i : o.name, u = Ow({
      checksumAddress: n,
      parameter: o,
      value: t[c]
    });
    a.push(u), u.dynamic && (s = !0);
  }
  return {
    dynamic: s,
    encoded: s ? Bw(a) : Ks(...a.map(({ encoded: i }) => i))
  };
}
function AW(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function kW(t, e, n) {
  const { checksumAddress: r = !1 } = {};
  if (t.length !== e.length)
    throw new BC({
      expectedLength: t.length,
      givenLength: e.length
    });
  const s = hW({
    checksumAddress: r,
    parameters: t,
    values: e
  }), a = Bw(s);
  return a.length === 0 ? "0x" : a;
}
function kg(t, e) {
  if (t.length !== e.length)
    throw new BC({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r], a = e[r];
    n.push(kg.encode(s, a));
  }
  return Ks(...n);
}
(function(t) {
  function e(n, r, s = !1) {
    if (n === "address") {
      const c = r;
      return ff(c), Ro(c.toLowerCase(), s ? 32 : 0);
    }
    if (n === "string")
      return Iw(r);
    if (n === "bytes")
      return r;
    if (n === "bool")
      return Ro(wC(r), s ? 32 : 1);
    const a = n.match(IC);
    if (a) {
      const [c, u, l = "256"] = a, d = Number.parseInt(l) / 8;
      return nu(r, {
        size: s ? 32 : d,
        signed: u === "int"
      });
    }
    const i = n.match(pW);
    if (i) {
      const [c, u] = i;
      if (Number.parseInt(u) !== (r.length - 2) / 2)
        throw new OC({
          expectedSize: Number.parseInt(u),
          value: r
        });
      return Do(r, s ? 32 : 0);
    }
    const o = n.match(fW);
    if (o && Array.isArray(r)) {
      const [c, u] = o, l = [];
      for (let d = 0; d < r.length; d++)
        l.push(e(u, r[d], !0));
      return l.length === 0 ? "0x" : Ks(...l);
    }
    throw new PC(n);
  }
  t.encode = e;
})(kg || (kg = {}));
class vW extends Xe {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(`Array length mismatch for type \`${r}\`. Expected: \`${e}\`. Given: \`${n}\`.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}
class OC extends Xe {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${or(n)}) does not match expected size (bytes${e}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
}
class BC extends Xe {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}
class CW extends Xe {
  constructor(e) {
    super(`Value \`${e}\` is not a valid array.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidArrayError"
    });
  }
}
class PC extends Xe {
  constructor(e) {
    super(`Type \`${e}\` is not a valid ABI Type.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}
function UC(t, ...e) {
  const { overloads: n } = t, r = n ? SW([t, ...n], t.name, {
    args: e[0]
  }) : t, s = IW(r), a = e.length > 0 ? kW(r.inputs, e[0]) : void 0;
  return a ? Ks(s, a) : s;
}
function TW(t, e = {}) {
  return cW(t, e);
}
function SW(t, e, n) {
  const r = lW(t, e, n);
  if (r.type !== "function")
    throw new Ag({ name: e, type: "function" });
  return r;
}
function IW(t) {
  return SC(t);
}
class NC extends tw {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, nU(e);
    const r = rm(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), ri(a);
  }
  update(e) {
    return Rl(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Rl(this), Br(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const RC = (t, e, n) => new NC(t, e).update(n).digest();
RC.create = (t, e) => new NC(t, e);
function OW(t) {
  const e = _u(_l(t.from)), n = vC(Y2(t.salt) ? t.salt : _u(t.salt), 32), r = "bytecodeHash" in t ? Y2(t.bytecodeHash) ? t.bytecodeHash : _u(t.bytecodeHash) : kd(t.bytecode, { as: "Bytes" });
  return _l(wm(kd(AC(_u("0xff"), e, n, r), { as: "Hex" }), 12));
}
var Dre = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function BW(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Fre(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
function PW(t, e, n) {
  var a, i;
  const r = t.find(
    (o) => {
      var c;
      return o.chainId === e.toString() && ((c = o.data) == null ? void 0 : c.address);
    }
  ), s = t.find(
    (o) => {
      var c;
      return o.chainId === n.toString() && ((c = o.data) == null ? void 0 : c.address);
    }
  );
  return {
    originAddress: (a = r == null ? void 0 : r.data) == null ? void 0 : a.address,
    destinationAddress: (i = s == null ? void 0 : s.data) == null ? void 0 : i.address
  };
}
function UW(t, e) {
  return t.find(
    (r) => (r.type === "erc20-balance" || r.type === "native-balance") && r.chainId === (e == null ? void 0 : e.toString())
  ) ?? null;
}
var NW = class {
  constructor(t, e) {
    O(this, "hostname");
    O(this, "fetch");
    O(this, "path", "/rpc/Databeat/");
    O(this, "ping", (t, e) => this.fetch(
      this.url("Ping"),
      Tu({}, t, e)
    ).then((n) => Su(n).then((r) => ({
      status: r.status
    })), (n) => {
      throw nc.new({ cause: `fetch(): ${n.message || ""}` });
    }));
    O(this, "version", (t, e) => this.fetch(
      this.url("Version"),
      Tu({}, t, e)
    ).then((n) => Su(n).then((r) => ({
      version: r.version
    })), (n) => {
      throw nc.new({ cause: `fetch(): ${n.message || ""}` });
    }));
    O(this, "runtimeStatus", (t, e) => this.fetch(
      this.url("RuntimeStatus"),
      Tu({}, t, e)
    ).then((n) => Su(n).then((r) => ({
      status: r.status
    })), (n) => {
      throw nc.new({ cause: `fetch(): ${n.message || ""}` });
    }));
    O(this, "tick", (t, e, n) => this.fetch(
      this.url("Tick"),
      Tu(t, e, n)
    ).then((r) => Su(r).then((s) => ({
      ok: s.ok
    })), (r) => {
      throw nc.new({ cause: `fetch(): ${r.message || ""}` });
    }));
    O(this, "rawEvents", (t, e, n) => this.fetch(
      this.url("RawEvents"),
      Tu(t, e, n)
    ).then((r) => Su(r).then((s) => ({
      ok: s.ok
    })), (r) => {
      throw nc.new({ cause: `fetch(): ${r.message || ""}` });
    }));
    this.hostname = t, this.fetch = (n, r) => e(n, r);
  }
  url(t) {
    return this.hostname + this.path + t;
  }
}, Tu = (t = {}, e = {}, n = null) => ({
  method: "POST",
  headers: { ...e, "Content-Type": "application/json" },
  body: JSON.stringify(t || {}),
  signal: n
}), Su = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), $C.new(
      {
        status: t.status,
        cause: `JSON.parse(): ${s}: response text: ${e}`
      }
    );
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (JW[r] || mt).new(n);
  }
  return n;
}), mt = class DC extends Error {
  constructor(n, r, s, a, i) {
    super(s);
    O(this, "name");
    O(this, "code");
    O(this, "message");
    O(this, "status");
    O(this, "cause");
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    O(this, "msg");
    this.name = n || "WebrpcError", this.code = typeof r == "number" ? r : 0, this.message = s || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof a == "number" ? a : 0, this.cause = i, Object.setPrototypeOf(this, DC.prototype);
  }
  static new(n) {
    return new this(n.error, n.code, n.message || n.msg, n.status, n.cause);
  }
}, RW = class FC extends mt {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, FC.prototype);
  }
}, nc = class MC extends mt {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, MC.prototype);
  }
}, DW = class LC extends mt {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, LC.prototype);
  }
}, FW = class HC extends mt {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, HC.prototype);
  }
}, MW = class _C extends mt {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _C.prototype);
  }
}, $C = class GC extends mt {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, GC.prototype);
  }
}, LW = class zC extends mt {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, zC.prototype);
  }
}, HW = class jC extends mt {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, jC.prototype);
  }
}, _W = class VC extends mt {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, VC.prototype);
  }
}, $W = class qC extends mt {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qC.prototype);
  }
}, GW = class KC extends mt {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, KC.prototype);
  }
}, zW = class WC extends mt {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, WC.prototype);
  }
}, jW = class QC extends mt {
  constructor(e = "PermissionDenied", n = 2e3, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, QC.prototype);
  }
}, VW = class JC extends mt {
  constructor(e = "SessionExpired", n = 2001, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, JC.prototype);
  }
}, qW = class XC extends mt {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, XC.prototype);
  }
}, KW = class ZC extends mt {
  constructor(e = "InvalidAppKey", n = 4e3, r = "Invalid app key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ZC.prototype);
  }
}, WW = class YC extends mt {
  constructor(e = "QueryFailed", n = 4001, r = "DB query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, YC.prototype);
  }
}, QW = class eT extends mt {
  constructor(e = "InvalidProjectId", n = 4002, r = "Invalid project id", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, eT.prototype);
  }
}, JW = {
  0: RW,
  [-1]: nc,
  [-2]: DW,
  [-3]: FW,
  [-4]: MW,
  [-5]: $C,
  [-6]: LW,
  [-7]: HW,
  [-8]: _W,
  [-9]: $W,
  [-10]: GW,
  1e3: zW,
  2e3: jW,
  2001: VW,
  3e3: qW,
  4e3: KW,
  4001: WW,
  4002: QW
}, XW = class extends NW {
  constructor(e, n) {
    const r = globalThis.fetch.bind(globalThis);
    super(e.endsWith("/") ? e.slice(0, -1) : e, r);
    O(this, "_globalFetch");
    O(this, "_fetch", (e, n) => {
      var r;
      if (this.auth) {
        let s = {};
        ((r = this.auth.jwt) == null ? void 0 : r.length) > 0 && (s.Authorization = `BEARER ${this.auth.jwt}`), this.auth.headers && (s = { ...s, ...this.auth.headers }), n.headers = { ...n.headers, ...s };
      }
      return this._globalFetch(e, n);
    });
    this.auth = n, this._globalFetch = r, this.fetch = this._fetch;
  }
}, tA = 150, hi = {
  defaultEnabled: !0,
  noop: !1,
  privacy: { userIdHash: !0, userAgentSalt: !1 },
  userIdentTracking: !1,
  strictMode: !1,
  flushInterval: 500,
  initProps: () => ({})
}, ZW = class {
  constructor(t, e, n) {
    O(this, "rpc");
    O(this, "auth");
    O(this, "options");
    O(this, "enabled");
    O(this, "ident");
    O(this, "userId");
    O(this, "sessionId");
    O(this, "allowUserTracking");
    O(this, "projectId");
    O(this, "queue");
    O(this, "flushTimeout");
    O(this, "defaultProps");
    O(this, "dedupeIdentKey");
    O(this, "dedupeViewKey");
    O(this, "ts");
    O(this, "flush", async () => {
      if (this.flushTimeout !== null && (clearTimeout(this.flushTimeout), this.flushTimeout = null), !this.enabled || this.options.noop || this.options.strictMode && !this.allowUserTracking || this.queue.length === 0) return;
      const t = this.dedupedQueue();
      this.queue = [];
      try {
        await this.rpc.tick({ events: t });
      } catch (e) {
        console.warn(`databeat flush failed: ${e}`);
      }
    });
    O(this, "dedupedQueue", () => {
      const t = /* @__PURE__ */ new Map();
      for (let e = 0; e < this.queue.length; e++) {
        const n = this.queue[e], r = `${n.event}:${n.source}:${n.userId}:${n.sessionId}:${JSON.stringify(n.props)}:${JSON.stringify(n.nums)}`;
        t.has(r) || t.set(r, n);
      }
      return Array.from(t.values());
    });
    typeof e == "string" ? this.auth = { jwt: e } : this.auth = e, this.rpc = new XW(t, this.auth), this.options = hi, n && (this.options = {
      defaultEnabled: n.defaultEnabled || hi.defaultEnabled,
      projectId: n.projectId || null,
      privacy: n.privacy || hi.privacy,
      userIdentTracking: n.userIdentTracking || hi.userIdentTracking,
      strictMode: n.strictMode || hi.strictMode,
      flushInterval: n.flushInterval || hi.flushInterval,
      noop: n.noop || !1,
      initProps: n.initProps || hi.initProps
    }), this.init();
  }
  // init is called on load by the constructor and also by reset().
  init() {
    this.enabled = nA(this.options.defaultEnabled, this.auth), this.projectId = this.options.projectId || null, this.userId = null, this.sessionId = tQ(), this.queue = [], this.flushTimeout = null, this.defaultProps = { ...YW(), ...this.options.initProps() }, this.identify();
  }
  // reset will reset the user_id and session_id details. Similar to a "logout" action.
  reset(t) {
    this.enabled = nA(this.options.defaultEnabled, this.auth), this.userId && !this.isAnon() && (this.userId = null), this.ident = 0, this.ts = Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking }), t !== !0 && this.init();
  }
  // identify can be called to seed the userId, where the behaviour changes
  // depending on privacy or strict modes. identify is also called on init,
  // where we load the data from localStorage.
  identify(t, e) {
    if (!za()) return;
    if (e && e.allowTracking !== void 0 && this.allowTracking(e.allowTracking), !t) {
      const r = vg();
      r !== null && r.id !== null && (this.userId = r.id, this.ident = r.it, this.allowUserTracking = r.ut, r.it === void 0 ? (this.userId.startsWith("anon:") ? this.ident = 0 : this.ident = 1, this.ts = Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })) : this.ident = r.it);
    }
    if (t || this.userId === null) {
      const r = eQ(t, this.allowUserTracking, this.options);
      this.userId = r.userId, this.ident = r.ident, this.ts = Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    }
    const n = `${this.userId}:${this.sessionId}`;
    this.dedupeIdentKey !== n && (this.dedupeIdentKey = n, this.track({ event: "INIT", source: rA(), props: this.defaultProps }), this.flush());
  }
  // allowTracking is used by strict mode to enable/disable tracking.
  allowTracking(t) {
    this.allowUserTracking = t, Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking }), this.options.strictMode && (t ? this.enable() : this.disable());
  }
  async track(t, e) {
    if (za() && this.userId === null)
      throw new Error("databeat: init first");
    if (Array.isArray(t)) {
      for (let n = 0; n < t.length; n++)
        t[n].ident = this.ident, t[n].userId = this.userId, t[n].sessionId = this.sessionId, !t[n].projectId && this.projectId && (t[n].projectId = this.projectId);
      this.queue.push(...t);
    } else
      t.ident = this.ident, t.userId = this.userId, t.sessionId = this.sessionId, !t.projectId && this.projectId && (t.projectId = this.projectId), this.queue.push(t);
    this.queue.length > tA && (this.queue = this.queue.splice(this.queue.length - tA)), this.enabled && (e && e.flush ? await this.flush() : this.flushTimeout === null && (this.flushTimeout = setTimeout(() => {
      this.flush();
    }, this.options.flushInterval)));
  }
  trackView(t = {}) {
    const e = { ...this.defaultProps, ...t }, n = rA(), r = `${n}:${JSON.stringify(e)}:${this.userId}:${this.sessionId}`;
    this.dedupeViewKey !== r && (this.dedupeViewKey = r, this.track({ event: "VIEW", source: n, props: e }));
  }
  isEnabled() {
    return this.enabled;
  }
  isAnon() {
    return this.ident === 0;
  }
  getIdent() {
    return this.ident;
  }
  getUserId() {
    return this.userId;
  }
  getSessionId() {
    return this.sessionId;
  }
  getStorageTS() {
    if (this.ts)
      return this.ts;
    const t = vg();
    if (!(t == null || t.id === null))
      return this.ts = t.ts, this.ts;
  }
  enable() {
    if (!tT(this.auth)) {
      this.enabled = !1;
      return;
    }
    za() && (this.enabled = !0, this.ts = Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking }), this.identify());
  }
  disable() {
    za() && (this.enabled = !1, this.ts = Zo({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking }));
  }
}, za = () => typeof window == "object" && typeof window.localStorage == "object" && typeof window.localStorage.getItem == "function" && typeof window.localStorage.setItem == "function", nA = (t, e) => {
  if (!tT(e))
    return !1;
  if (!za())
    return !0;
  const n = vg();
  return n === null ? t ?? !0 : n.on;
}, tT = (t) => {
  var e;
  return !!(((e = t == null ? void 0 : t.jwt) == null ? void 0 : e.length) > 0 || t != null && t.headers && Object.keys(t.headers).length > 0);
}, rA = () => {
  try {
    return window.location.pathname;
  } catch {
    return "";
  }
}, YW = () => {
  if (!za()) return {};
  const t = new URL(window.location.href).searchParams, e = {};
  return e.origin = window.location.origin, t.get("ref") && t.get("ref") !== "" && (e.ref = t.get("ref") || ""), t.get("source") && t.get("source") !== "" && (e.source = t.get("source") || ""), t.get("utm_source") && t.get("utm_source") !== "" && (e.utmSource = t.get("utm_source") || ""), t.get("utm_campaign") && t.get("utm_campaign") !== "" && (e.utmCampaign = t.get("utm_campaign") || ""), t.get("utm_medium") && t.get("utm_medium") !== "" && (e.utmMedium = t.get("utm_medium") || ""), t.get("utm_content") && t.get("utm_content") !== "" && (e.utmContent = t.get("utm_content") || ""), t.get("utm_term") && t.get("utm_term") !== "" && (e.utmTerm = t.get("utm_term") || ""), document.referrer && document.referrer !== "" && (e.referrer = document.referrer), t.get("gclid") && t.get("gclid") !== "" && (e.gclid = t.get("gclid") || ""), t.get("wbraid") && t.get("wbraid") !== "" && (e.wbraid = t.get("wbraid") || ""), e;
}, dh = "_dbeat", vg = () => {
  try {
    return JSON.parse(window.localStorage.getItem(dh));
  } catch {
    return null;
  }
}, Zo = (t) => {
  try {
    return t.ts || (t.ts = Math.floor(Date.now() / 1e3)), window.localStorage.setItem(dh, JSON.stringify(t)), t.ts;
  } catch {
    return;
  }
}, eQ = (t, e, n) => {
  if (!t || t === null || t === "")
    return {
      userId: `${Math.floor(Math.random() * 1e14)}`,
      ident: 0
      /* ANON */
    };
  if (n.userIdentTracking && e)
    return {
      userId: t,
      ident: 2
      /* USER */
    };
  if (n.privacy.userIdHash === !0 || !n.userIdentTracking || !e)
    return za() && n.privacy.userAgentSalt === !0 && (t = t + ":" + navigator.userAgent), n.privacy.extraSalt && n.privacy.extraSalt.length > 0 && (t = t + ":" + n.privacy.extraSalt), {
      userId: Dl(nw(t)).substring(0, 50),
      ident: 1
      /* PRIVATE */
    };
  throw new Error("invalid configuration");
}, tQ = () => {
  if (za() && typeof window.sessionStorage == "object" && typeof window.sessionStorage.getItem == "function" && typeof window.sessionStorage.setItem == "function") {
    const e = window.sessionStorage.getItem(dh);
    if (e && e.length > 0)
      return e;
    {
      const n = sA(16);
      return window.sessionStorage.setItem(dh, n), n;
    }
  } else
    return sA(16);
}, sA = (t) => {
  let e = "";
  for (let n = 0; n < t; n++)
    e += Math.floor(Math.random() * 16).toString(16);
  return "0x" + e;
};
typeof process == "object" && process.version && process.version < "v18" && (console.error(`ERROR! expecting node v18+ but your node version is reporting ${process.version}`), process && process.exit && process.exit(1));
function Pw(t) {
  return typeof window > "u" ? null : new URLSearchParams(window.location.search).get(t);
}
function Mre() {
  const [t, e] = n6(
    typeof window < "u" ? new URLSearchParams(window.location.search) : new URLSearchParams()
  );
  return KS(() => {
    if (typeof window > "u")
      return;
    const i = () => {
      e(new URLSearchParams(window.location.search));
    };
    window.addEventListener("popstate", i);
    const o = window.history.pushState, c = window.history.replaceState;
    return window.history.pushState = function() {
      o.apply(this, arguments), i();
    }, window.history.replaceState = function() {
      c.apply(this, arguments), i();
    }, () => {
      window.removeEventListener("popstate", i), window.history.pushState = o, window.history.replaceState = c;
    };
  }, []), {
    queryParams: t,
    getParam: (i) => t.get(i),
    hasParam: (i, o) => o ? t.get(i) === o : t.has(i),
    setParam: (i, o) => {
      if (typeof window > "u")
        return;
      const c = new URLSearchParams(t);
      c.set(i, o);
      const u = new URL(window.location.href);
      u.search = c.toString(), window.history.pushState({}, "", u.toString()), e(c);
    },
    removeParam: (i) => {
      if (typeof window > "u")
        return;
      const o = new URLSearchParams(t);
      o.delete(i);
      const c = new URL(window.location.href);
      c.search = o.toString(), window.history.pushState({}, "", c.toString()), e(o);
    }
  };
}
function be(t) {
  var i;
  if (!t) return t;
  const e = ((i = t == null ? void 0 : t.toString()) == null ? void 0 : i.trim().toLowerCase()) || "", n = kC(e), r = nW(n);
  return `anon_${zu(r).replace("0x", "")}`;
}
const et = {
  PAGEVIEW: "PAGEVIEW",
  WIDGET_SCREEN: "WIDGET_SCREEN",
  PAYMENT_STARTED: "PAYMENT_STARTED",
  PAYMENT_COMPLETED: "PAYMENT_COMPLETED",
  PAYMENT_ERROR: "PAYMENT_ERROR",
  // Wallet events
  WALLET_CONNECTED: "WALLET_CONNECTED",
  WALLET_DISCONNECTED: "WALLET_DISCONNECTED",
  // Intent events
  INTENT_QUOTE_REQUESTED: "INTENT_QUOTE_REQUESTED",
  INTENT_QUOTE_RECEIVED: "INTENT_QUOTE_RECEIVED",
  INTENT_QUOTE_ERROR: "INTENT_QUOTE_ERROR",
  INTENT_COMMIT_STARTED: "INTENT_COMMIT_STARTED",
  INTENT_COMMIT_COMPLETED: "INTENT_COMMIT_COMPLETED",
  INTENT_COMMIT_ERROR: "INTENT_COMMIT_ERROR",
  // Transaction events
  TRANSACTION_STARTED: "TRANSACTION_STARTED",
  TRANSACTION_SIGNED: "TRANSACTION_SIGNED",
  TRANSACTION_SUBMITTED: "TRANSACTION_SUBMITTED",
  TRANSACTION_CONFIRMED: "TRANSACTION_CONFIRMED",
  TRANSACTION_ERROR: "TRANSACTION_ERROR",
  // Relayer events
  RELAYER_CALL_STARTED: "RELAYER_CALL_STARTED",
  RELAYER_CALL_COMPLETED: "RELAYER_CALL_COMPLETED",
  RELAYER_CALL_ERROR: "RELAYER_CALL_ERROR"
};
class nT {
  getCommonProps() {
    return {
      ...this.getNavigatorProps(),
      ...this.getDocumentProps(),
      ...this.getWindowProps(),
      sequenceProjectAccessKey: $o()
    };
  }
  getNavigatorProps() {
    return typeof navigator > "u" ? {
      userAgent: ""
    } : {
      userAgent: navigator.userAgent
    };
  }
  getDocumentProps() {
    return typeof window > "u" ? {
      userAgent: "",
      title: ""
    } : {
      title: document.title,
      referrer: document.referrer
    };
  }
  getWindowProps() {
    var e, n, r, s, a, i, o, c, u;
    return typeof window > "u" ? {
      url: "",
      screenWidth: "",
      screenHeight: "",
      screenPixelRatio: "",
      screenResolution: "",
      screenOrientation: ""
    } : {
      url: (e = window.location) == null ? void 0 : e.href,
      screenWidth: (n = window.innerWidth) == null ? void 0 : n.toString(),
      screenHeight: (r = window.innerHeight) == null ? void 0 : r.toString(),
      screenPixelRatio: (s = window.devicePixelRatio) == null ? void 0 : s.toString(),
      screenResolution: `${(a = window.screen) == null ? void 0 : a.width}x${(i = window.screen) == null ? void 0 : i.height}`,
      screenOrientation: (u = (c = (o = window.screen) == null ? void 0 : o.orientation) == null ? void 0 : c.type) == null ? void 0 : u.toString()
    };
  }
  trackPageview() {
    this.track({
      event: et.PAGEVIEW,
      props: this.getCommonProps()
    });
  }
  trackWidgetScreen(e) {
    this.track({
      event: et.WIDGET_SCREEN,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        }
      }
    });
  }
  trackPaymentStarted(e) {
    var n, r, s;
    this.track({
      event: et.PAYMENT_STARTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        },
        destinationChainId: (n = e.destinationChainId) == null ? void 0 : n.toString(),
        originChainId: (r = e.originChainId) == null ? void 0 : r.toString(),
        destinationTokenAmount: (s = e.destinationTokenAmount) == null ? void 0 : s.toString()
      }
    });
  }
  trackPaymentCompleted(e) {
    var n, r;
    this.track({
      event: et.PAYMENT_COMPLETED,
      props: {
        ...this.getCommonProps(),
        ...e,
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString(),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        }
      }
    });
  }
  trackPaymentError(e) {
    this.track({
      event: et.PAYMENT_ERROR,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        }
      }
    });
  }
  // Wallet tracking methods
  trackWalletConnected(e) {
    var n;
    this.track({
      event: et.WALLET_CONNECTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        address: be(e.address),
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
  trackWalletDisconnected(e) {
    this.track({
      event: et.WALLET_DISCONNECTED,
      props: {
        ...this.getCommonProps(),
        ...e || {}
      }
    });
  }
  // Intent tracking methods
  trackIntentQuoteRequested(e) {
    var n, r;
    this.track({
      event: et.INTENT_QUOTE_REQUESTED,
      props: {
        ...this.getCommonProps(),
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString(),
        originTokenAddress: e.originTokenAddress,
        destinationTokenAddress: e.destinationTokenAddress,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        }
      }
    });
  }
  trackIntentQuoteReceived(e) {
    var n, r, s, a, i, o, c, u, l;
    this.track({
      event: et.INTENT_QUOTE_RECEIVED,
      props: {
        ...this.getCommonProps(),
        quoteId: be(e.quoteId),
        totalFeeUSD: (n = e.totalFeeUSD) == null ? void 0 : n.toString(),
        trailsFixedFeeUSD: (r = e.trailsFixedFeeUSD) == null ? void 0 : r.toString(),
        crossChainFeeTotalUSD: (s = e.crossChainFeeTotalUSD) == null ? void 0 : s.toString(),
        takerFeeUSD: (a = e.takerFeeUSD) == null ? void 0 : a.toString(),
        providerFeeUSD: (i = e.providerFeeUSD) == null ? void 0 : i.toString(),
        trailsSwapFeeUSD: (o = e.trailsSwapFeeUSD) == null ? void 0 : o.toString(),
        gasFeesPerChainUSD: (c = e.gasFeesPerChainUSD) == null ? void 0 : c.map((d) => d == null ? void 0 : d.toString()).join(","),
        originTokenTotalAmount: (u = e.originTokenTotalAmount) == null ? void 0 : u.toString(),
        destinationTokenAmount: (l = e.destinationTokenAmount) == null ? void 0 : l.toString(),
        provider: e.provider,
        feeToken: e.feeToken,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        }
      }
    });
  }
  trackIntentQuoteError(e) {
    var n, r;
    this.track({
      event: et.INTENT_QUOTE_ERROR,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString()
      }
    });
  }
  trackIntentCommitStarted(e) {
    var n, r;
    this.track({
      event: et.INTENT_COMMIT_STARTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString(),
        intentAddress: be(e.intentAddress),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        }
      }
    });
  }
  trackIntentCommitCompleted(e) {
    var n, r;
    this.track({
      event: et.INTENT_COMMIT_COMPLETED,
      props: {
        ...this.getCommonProps(),
        ...e,
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString(),
        intentAddress: be(e.intentAddress),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        }
      }
    });
  }
  trackIntentCommitError(e) {
    var n, r;
    this.track({
      event: et.INTENT_COMMIT_ERROR,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        },
        originChainId: (n = e.originChainId) == null ? void 0 : n.toString(),
        destinationChainId: (r = e.destinationChainId) == null ? void 0 : r.toString()
      }
    });
  }
  // Transaction tracking methods
  trackTransactionStarted(e) {
    var n;
    this.track({
      event: et.TRANSACTION_STARTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        },
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
  trackTransactionSigned(e) {
    this.track({
      event: et.TRANSACTION_SIGNED,
      props: {
        ...this.getCommonProps(),
        ...e,
        transactionHash: be(e.transactionHash),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        }
      }
    });
  }
  trackTransactionSubmitted(e) {
    var n;
    this.track({
      event: et.TRANSACTION_SUBMITTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        transactionHash: be(e.transactionHash),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        },
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
  trackTransactionConfirmed(e) {
    var n, r;
    this.track({
      event: et.TRANSACTION_CONFIRMED,
      props: {
        ...this.getCommonProps(),
        ...e,
        chainId: (n = e.chainId) == null ? void 0 : n.toString(),
        transactionHash: be(e.transactionHash),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        },
        blockNumber: (r = e.blockNumber) == null ? void 0 : r.toString()
      }
    });
  }
  trackTransactionError(e) {
    this.track({
      event: et.TRANSACTION_ERROR,
      props: {
        ...this.getCommonProps(),
        ...e,
        transactionHash: be(e.transactionHash),
        ...e.userAddress && {
          userAddress: be(e.userAddress)
        },
        ...e.intentAddress && {
          intentAddress: be(e.intentAddress)
        }
      }
    });
  }
  // Relayer tracking methods
  trackRelayerCallStarted(e) {
    var n;
    this.track({
      event: et.RELAYER_CALL_STARTED,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.walletAddress && {
          walletAddress: be(e.walletAddress)
        },
        ...e.contractAddress && {
          contractAddress: be(e.contractAddress)
        },
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
  trackRelayerCallCompleted(e) {
    var n;
    this.track({
      event: et.RELAYER_CALL_COMPLETED,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.walletAddress && {
          walletAddress: be(e.walletAddress)
        },
        ...e.contractAddress && {
          contractAddress: be(e.contractAddress)
        },
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
  trackRelayerCallError(e) {
    var n;
    this.track({
      event: et.RELAYER_CALL_ERROR,
      props: {
        ...this.getCommonProps(),
        ...e,
        ...e.walletAddress && {
          walletAddress: be(e.walletAddress)
        },
        ...e.contractAddress && {
          contractAddress: be(e.contractAddress)
        },
        chainId: (n = e.chainId) == null ? void 0 : n.toString()
      }
    });
  }
}
class nQ extends nT {
  constructor(n, r) {
    super();
    O(this, "databeat");
    O(this, "loggingEnabled", !1);
    this.databeat = new ZW(n, r);
  }
  identifyUser({ address: n }) {
    this.databeat.identify(n == null ? void 0 : n.toLowerCase(), { userIdHash: !0 });
  }
  unidentifyUser() {
    this.databeat.identify(void 0, { userIdHash: !0 });
  }
  track(n) {
    return this.databeat.track(n).catch(() => {
    }).then(() => this.logEvent(n));
  }
  enable() {
    return this.databeat.enable();
  }
  allowTracking(n) {
    return this.databeat.allowTracking(n);
  }
  disable() {
    return this.databeat.disable();
  }
  logEvent(n) {
    this.loggingEnabled && console.log("[trails-sdk] Analytics track:", n);
  }
}
class rQ extends nT {
  constructor({ loggingEnabled: n }) {
    super();
    O(this, "loggingEnabled", !1);
    this.loggingEnabled = n;
  }
  identifyUser({ address: n }) {
    return console.log("[trails-sdk] MockAnalytics identifyUser:", n), this;
  }
  unidentifyUser() {
    return this;
  }
  enable() {
    return this;
  }
  allowTracking(n) {
    return this;
  }
  track(n) {
    return this.logEvent(n), this;
  }
  disable() {
    return this;
  }
  logEvent(n) {
    this.loggingEnabled && console.log("[trails-sdk] MockAnalytics track:", n);
  }
}
let G0 = null;
const kt = () => {
  const t = Pw("analyticsDebug") === "true";
  let e = !0;
  return typeof window < "u" && (e = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1"), t || e ? new rQ({ loggingEnabled: !0 }) : (G0 || (G0 = new nQ(w4, {
    jwt: E4
  })), G0);
}, Lre = (t) => {
  kt().trackWidgetScreen(t);
}, sQ = (t) => {
  kt().trackPaymentStarted(t);
}, Uw = (t) => {
  kt().trackPaymentCompleted(t);
}, vd = (t) => {
  kt().trackPaymentError(t);
}, Hre = (t) => {
  const e = kt();
  e.identifyUser({ address: t.address }), e.trackWalletConnected(t);
}, aQ = (t) => {
  kt().trackIntentQuoteRequested(t);
}, iQ = (t) => {
  kt().trackIntentQuoteReceived(t);
}, oQ = (t) => {
  kt().trackIntentQuoteError(t);
}, cQ = (t) => {
  kt().trackIntentCommitStarted(t);
}, lQ = (t) => {
  kt().trackIntentCommitCompleted(t);
}, uQ = (t) => {
  kt().trackIntentCommitError(t);
}, dQ = (t) => {
  kt().trackTransactionStarted(t);
}, fQ = (t) => {
  kt().trackTransactionSubmitted(t);
}, rT = (t) => {
  kt().trackTransactionConfirmed(t);
}, pQ = (t) => {
  kt().trackTransactionError(t);
}, hQ = (t) => {
  kt().trackRelayerCallStarted(t);
}, mQ = (t) => {
  kt().trackRelayerCallCompleted(t);
}, yQ = (t) => {
  kt().trackRelayerCallError(t);
};
async function bQ(t, e) {
  var n, r, s, a, i, o, c, u, l, d, p, f, b, y, g, w, k;
  aQ({
    originChainId: e.originChainId || 0,
    destinationChainId: e.destinationChainId || 0,
    originTokenAddress: e.originTokenAddress,
    destinationTokenAddress: e.destinationTokenAddress,
    userAddress: e.userAddress
  });
  try {
    console.log("[trails-sdk] getIntentCallsPayloads args:", e);
    const E = await t.getIntentCallsPayloads(e);
    if (!E)
      throw new Error("No result from getIntentCallsPayloads");
    return iQ({
      quoteId: E.originIntentAddress || "unknown",
      totalFeeUSD: (n = E.trailsFee) == null ? void 0 : n.totalFeeUSD,
      trailsFixedFeeUSD: (r = E.trailsFee) == null ? void 0 : r.trailsFixedFeeUSD,
      crossChainFeeTotalUSD: (a = (s = E.trailsFee) == null ? void 0 : s.crossChainFee) == null ? void 0 : a.totalFeeUSD,
      takerFeeUSD: (o = (i = E.trailsFee) == null ? void 0 : i.crossChainFee) == null ? void 0 : o.providerFeeUSD,
      providerFeeUSD: (u = (c = E.trailsFee) == null ? void 0 : c.crossChainFee) == null ? void 0 : u.providerFeeUSD,
      trailsSwapFeeUSD: (d = (l = E.trailsFee) == null ? void 0 : l.crossChainFee) == null ? void 0 : d.trailsSwapFeeUSD,
      gasFeesPerChainUSD: ((b = (f = (p = E.trailsFee) == null ? void 0 : p.executeQuote) == null ? void 0 : f.chainQuotes) == null ? void 0 : b.map(
        (T) => parseFloat(T.totalFeeUSD || "0")
      )) || [],
      originTokenTotalAmount: (y = E.trailsFee) == null ? void 0 : y.originTokenTotalAmount,
      destinationTokenAmount: (g = E.trailsFee) == null ? void 0 : g.totalFeeAmount,
      // Using available property
      provider: (w = E.trailsFee) == null ? void 0 : w.quoteProvider,
      feeToken: (k = E.trailsFee) == null ? void 0 : k.feeToken,
      userAddress: e.userAddress,
      intentAddress: E.originIntentAddress
    }), E;
  } catch (E) {
    throw oQ({
      error: E instanceof Error ? E.message : "Unknown error",
      userAddress: e.userAddress,
      originChainId: e.originChainId || 0,
      destinationChainId: e.destinationChainId || 0,
      originTokenAddress: e.originTokenAddress,
      destinationTokenAddress: e.destinationTokenAddress
    }), E;
  }
}
function aA(t, e) {
  console.log("[trails-sdk] calculateIntentAddress inputs:", {
    mainSigner: t,
    calls: JSON.stringify(e, null, 2)
  });
  const n = {
    factory: "0xBd0F8abD58B4449B39C57Ac9D5C67433239aC447",
    stage1: "0x53bA242E7C2501839DF2972c75075dc693176Cd0",
    creationCode: "0x603e600e3d39601e805130553df33d3d34601c57363d3d373d363d30545af43d82803e903d91601c57fd5bf3"
  }, r = e.map((a) => ({
    type: "call",
    chainId: a.chainId.toString(),
    space: a.space ? a.space.toString() : "0",
    nonce: a.nonce ? a.nonce.toString() : "0",
    calls: a.calls.map((i) => {
      var o, c;
      return {
        to: _l(i.to),
        value: ((o = i.value) == null ? void 0 : o.toString()) || "0",
        data: zu(Hl(i.data || "0x")),
        gasLimit: ((c = i.gasLimit) == null ? void 0 : c.toString()) || "0",
        delegateCall: !!i.delegateCall,
        onlyFallback: !!i.onlyFallback,
        behaviorOnError: i.behaviorOnError
      };
    })
  })), s = xQ(
    _l(t),
    r,
    n
  );
  return console.log(
    "[trails-sdk] Final calculated address:",
    s.toString()
  ), s;
}
function gQ(t, e) {
  var c, u;
  const n = (c = e[0]) == null ? void 0 : c.chainId, r = (u = e[1]) == null ? void 0 : u.chainId;
  console.log("[trails-sdk] originChainId:", n), console.log("[trails-sdk] destinationChainId:", r);
  const s = e.filter((l) => l.chainId === n), a = e.filter((l) => l.chainId === r);
  console.log("[trails-sdk] originCalls:", s), console.log("[trails-sdk] destinationCalls:", a);
  const i = aA(t, s), o = aA(
    t,
    a
  );
  return console.log("[trails-sdk] originIntentAddress:", i), console.log(
    "[trails-sdk] destinationIntentAddress:",
    o
  ), { originIntentAddress: i, destinationIntentAddress: o };
}
async function wQ(t, e, n, r) {
  var d, p;
  console.log("[trails-sdk] commitIntentConfig inputs:", {
    mainSignerAddress: e,
    calls: JSON.stringify(n, null, 2),
    preconditions: JSON.stringify(r, null, 2)
  });
  const { originIntentAddress: s, destinationIntentAddress: a } = gQ(e, n);
  console.log(
    "[trails-sdk] originIntentAddress:",
    s.toString()
  ), console.log(
    "[trails-sdk] destinationIntentAddress:",
    a.toString()
  );
  const i = (d = n[0]) == null ? void 0 : d.chainId, o = (p = n[1]) == null ? void 0 : p.chainId, { originAddress: c } = i && o ? PW(
    r,
    Number(i),
    Number(o)
  ) : { originAddress: void 0 };
  console.log("[trails-sdk] Address comparison:", {
    receivedAddress: c,
    calculatedAddress: s.toString(),
    match: c && QS(_l(c), s)
  });
  const u = {
    originIntentAddress: s.toString(),
    destinationIntentAddress: a.toString(),
    mainSigner: e,
    calls: n,
    preconditions: r
  }, l = {
    trailsLiFiSapientSignerAddress: l4,
    trailsRelaySapientSignerAddress: u4,
    trailsCCTPV2SapientSignerAddress: d4,
    ...u.addressOverrides
  };
  try {
    cQ({
      intentAddress: s.toString(),
      userAddress: e,
      originChainId: i ? Number(i) : void 0,
      destinationChainId: o ? Number(o) : void 0
    });
    const f = await t.commitIntentConfig({
      ...u,
      addressOverrides: l
    });
    return lQ({
      intentAddress: s.toString(),
      userAddress: e,
      originChainId: i ? Number(i) : void 0,
      destinationChainId: o ? Number(o) : void 0
    }), f;
  } catch (f) {
    throw uQ({
      error: f instanceof Error ? f.message : "Unknown error",
      userAddress: e,
      intentAddress: s.toString(),
      originChainId: i ? Number(i) : void 0,
      destinationChainId: o ? Number(o) : void 0
    }), f;
  }
}
async function sT(t, e, n) {
  const r = await e.getChainId();
  r.toString() !== n.chain.id.toString() && (console.log(
    "[trails-sdk] sendOriginTransaction: switching chain",
    "want:",
    n.chain.id,
    "current:",
    r
  ), await e.switchChain({ id: n.chain.id }), console.log(
    "[trails-sdk] sendOriginTransaction: switched chain to",
    n.chain.id
  )), dQ({
    transactionType: "origin_call",
    chainId: n.chain.id,
    userAddress: t.address
  });
  const a = await hn({
    chain: pe(n.chain.id),
    transport: Ge()
  }).estimateGas({
    account: t,
    to: n.to,
    data: n.data,
    value: BigInt(n.value)
  });
  console.log("[trails-sdk] estimated gasLimit:", a), console.log(
    "[trails-sdk] sending origin tx with walletClient.sendTransaction()"
  );
  const i = Date.now();
  console.time(`[trails-sdk] walletClient.sendTransaction-${i}`);
  try {
    const o = await e.sendTransaction({
      account: t,
      to: n.to,
      data: n.data,
      value: BigInt(n.value),
      chain: n.chain,
      gas: a
    });
    return console.timeEnd(`[trails-sdk] walletClient.sendTransaction-${i}`), console.log("[trails-sdk] done sending, origin tx hash", o), fQ({
      transactionHash: o,
      chainId: n.chain.id,
      userAddress: t.address
    }), o;
  } catch (o) {
    throw console.timeEnd(`[trails-sdk] walletClient.sendTransaction-${i}`), pQ({
      transactionHash: "",
      error: o instanceof Error ? o.message : "Unknown error",
      userAddress: t.address
    }), o;
  }
}
function EQ(t, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function xQ(t, e, n) {
  const r = AQ(t, e), s = t7.hashConfiguration(r);
  return OW({
    from: n.factory,
    bytecodeHash: kd(
      AC(
        Hl(n.creationCode),
        vC(Hl(n.stage1), 32)
      ),
      { as: "Bytes" }
    ),
    salt: s
  });
}
function AQ(t, e) {
  const n = {
    type: "signer",
    address: t,
    weight: 1n
  };
  console.log("[trails-sdk] mainSignerLeaf:", n);
  const r = e.map(
    (i) => {
      const o = n7.hash(
        _l("0x0000000000000000000000000000000000000000"),
        BigInt(i.chainId),
        {
          type: "call",
          space: BigInt(i.space || 0),
          nonce: BigInt(i.nonce || 0),
          calls: i.calls.map((c) => {
            var u, l;
            return {
              type: "call",
              to: c.to,
              value: BigInt(((u = c.value) == null ? void 0 : u.toString()) || "0"),
              data: zu(Hl(c.data || "0x")),
              gasLimit: BigInt(((l = c.gasLimit) == null ? void 0 : l.toString()) || "0"),
              delegateCall: !!c.delegateCall,
              onlyFallback: !!c.onlyFallback,
              behaviorOnError: c.behaviorOnError === 0 ? "ignore" : c.behaviorOnError === 1 ? "revert" : "abort"
            };
          })
        }
      );
      return console.log("[trails-sdk] digest:", zu(o)), {
        type: "any-address-subdigest",
        digest: zu(o)
      };
    }
  );
  console.log("[trails-sdk] calls:", e), console.log("[trails-sdk] subdigestLeaves:", r);
  const s = [...r];
  if (s.length === 0)
    throw new Error(
      "Intent configuration must have at least one call or LiFi information."
    );
  let a;
  return s.length === 1 ? a = s[0] : a = kQ(s), console.log(
    "[trails-sdk] Topology:",
    JSON.stringify([n, a], EQ, 2)
  ), {
    threshold: 1n,
    checkpoint: 0n,
    topology: [n, a]
  };
}
function kQ(t) {
  if (t.length === 0)
    throw new Error("Cannot create a tree from empty members");
  if (t.length === 1)
    return t[0];
  let e = [...t];
  for (; e.length > 1; ) {
    const n = [];
    for (let r = 0; r < e.length; r += 2) {
      const s = e[r];
      if (r + 1 < e.length) {
        const a = e[r + 1];
        n.push([s, a]);
      } else
        n.push(s);
    }
    e = n;
  }
  return e[0];
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Nw = /* @__PURE__ */ BigInt(0), Cg = /* @__PURE__ */ BigInt(1);
function fh(t, e) {
  if (typeof e != "boolean")
    throw new Error(t + " boolean expected, got " + e);
}
function up(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function aT(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Nw : BigInt("0x" + t);
}
function Em(t) {
  return aT(Dl(t));
}
function iT(t) {
  return Br(t), aT(Dl(Uint8Array.from(t).reverse()));
}
function Rw(t, e) {
  return ew(t.toString(16).padStart(e * 2, "0"));
}
function oT(t, e) {
  return Rw(t, e).reverse();
}
function Kn(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = ew(e);
    } catch (a) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + a);
    }
  else if (Y1(e))
    r = Uint8Array.from(e);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(t + " of length " + n + " expected, got " + s);
  return r;
}
const z0 = (t) => typeof t == "bigint" && Nw <= t;
function vQ(t, e, n) {
  return z0(t) && z0(e) && z0(n) && e <= t && t < n;
}
function CQ(t, e, n, r) {
  if (!vQ(e, n, r))
    throw new Error("expected valid " + t + ": " + n + " <= n < " + r + ", got " + e);
}
function TQ(t) {
  let e;
  for (e = 0; t > Nw; t >>= Cg, e += 1)
    ;
  return e;
}
const xm = (t) => (Cg << BigInt(t)) - Cg;
function SQ(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (f) => new Uint8Array(f), s = (f) => Uint8Array.of(f);
  let a = r(t), i = r(t), o = 0;
  const c = () => {
    a.fill(1), i.fill(0), o = 0;
  }, u = (...f) => n(i, a, ...f), l = (f = r(0)) => {
    i = u(s(0), f), a = u(), f.length !== 0 && (i = u(s(1), f), a = u());
  }, d = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const b = [];
    for (; f < e; ) {
      a = u();
      const y = a.slice();
      b.push(y), f += a.length;
    }
    return Ci(...b);
  };
  return (f, b) => {
    c(), l(f);
    let y;
    for (; !(y = b(d())); )
      l();
    return c(), y;
  };
}
function Dw(t, e, n = {}) {
  if (!t || typeof t != "object")
    throw new Error("expected valid options object");
  function r(s, a, i) {
    const o = t[s];
    if (i && o === void 0)
      return;
    const c = typeof o;
    if (c !== a || o === null)
      throw new Error(`param "${s}" is invalid: expected ${a}, got ${c}`);
  }
  Object.entries(e).forEach(([s, a]) => r(s, a, !1)), Object.entries(n).forEach(([s, a]) => r(s, a, !0));
}
function iA(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const s = e.get(n);
    if (s !== void 0)
      return s;
    const a = t(n, ...r);
    return e.set(n, a), a;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const An = BigInt(0), mn = BigInt(1), Si = /* @__PURE__ */ BigInt(2), IQ = /* @__PURE__ */ BigInt(3), cT = /* @__PURE__ */ BigInt(4), lT = /* @__PURE__ */ BigInt(5), uT = /* @__PURE__ */ BigInt(8);
function rr(t, e) {
  const n = t % e;
  return n >= An ? n : e + n;
}
function Gn(t, e, n) {
  let r = t;
  for (; e-- > An; )
    r *= r, r %= n;
  return r;
}
function oA(t, e) {
  if (t === An)
    throw new Error("invert: expected non-zero number");
  if (e <= An)
    throw new Error("invert: expected positive modulus, got " + e);
  let n = rr(t, e), r = e, s = An, a = mn;
  for (; n !== An; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== mn)
    throw new Error("invert: does not exist");
  return rr(s, e);
}
function dT(t, e) {
  const n = (t.ORDER + mn) / cT, r = t.pow(e, n);
  if (!t.eql(t.sqr(r), e))
    throw new Error("Cannot find square root");
  return r;
}
function OQ(t, e) {
  const n = (t.ORDER - lT) / uT, r = t.mul(e, Si), s = t.pow(r, n), a = t.mul(e, s), i = t.mul(t.mul(a, Si), s), o = t.mul(a, t.sub(i, t.ONE));
  if (!t.eql(t.sqr(o), e))
    throw new Error("Cannot find square root");
  return o;
}
function BQ(t) {
  if (t < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let e = t - mn, n = 0;
  for (; e % Si === An; )
    e /= Si, n++;
  let r = Si;
  const s = Am(t);
  for (; cA(s, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return dT;
  let a = s.pow(r, e);
  const i = (e + mn) / Si;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (cA(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, d = c.mul(c.ONE, a), p = c.pow(u, e), f = c.pow(u, i);
    for (; !c.eql(p, c.ONE); ) {
      if (c.is0(p))
        return c.ZERO;
      let b = 1, y = c.sqr(p);
      for (; !c.eql(y, c.ONE); )
        if (b++, y = c.sqr(y), b === l)
          throw new Error("Cannot find square root");
      const g = mn << BigInt(l - b - 1), w = c.pow(d, g);
      l = b, d = c.sqr(w), p = c.mul(p, d), f = c.mul(f, w);
    }
    return f;
  };
}
function PQ(t) {
  return t % cT === IQ ? dT : t % uT === lT ? OQ : BQ(t);
}
const UQ = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function NQ(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = UQ.reduce((r, s) => (r[s] = "function", r), e);
  return Dw(t, n), t;
}
function RQ(t, e, n) {
  if (n < An)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === An)
    return t.ONE;
  if (n === mn)
    return e;
  let r = t.ONE, s = e;
  for (; n > An; )
    n & mn && (r = t.mul(r, s)), s = t.sqr(s), n >>= mn;
  return r;
}
function fT(t, e, n = !1) {
  const r = new Array(e.length).fill(n ? t.ZERO : void 0), s = e.reduce((i, o, c) => t.is0(o) ? i : (r[c] = i, t.mul(i, o)), t.ONE), a = t.inv(s);
  return e.reduceRight((i, o, c) => t.is0(o) ? i : (r[c] = t.mul(i, r[c]), t.mul(i, o)), a), r;
}
function cA(t, e) {
  const n = (t.ORDER - mn) / Si, r = t.pow(e, n), s = t.eql(r, t.ONE), a = t.eql(r, t.ZERO), i = t.eql(r, t.neg(t.ONE));
  if (!s && !a && !i)
    throw new Error("invalid Legendre symbol result");
  return s ? 1 : a ? 0 : -1;
}
function DQ(t, e) {
  e !== void 0 && bd(e);
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function Am(t, e, n = !1, r = {}) {
  if (t <= An)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  let s, a;
  if (typeof e == "object" && e != null) {
    if (r.sqrt || n)
      throw new Error("cannot specify opts in two arguments");
    const l = e;
    l.BITS && (s = l.BITS), l.sqrt && (a = l.sqrt), typeof l.isLE == "boolean" && (n = l.isLE);
  } else
    typeof e == "number" && (s = e), r.sqrt && (a = r.sqrt);
  const { nBitLength: i, nByteLength: o } = DQ(t, s);
  if (o > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let c;
  const u = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: o,
    MASK: xm(i),
    ZERO: An,
    ONE: mn,
    create: (l) => rr(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof l);
      return An <= l && l < t;
    },
    is0: (l) => l === An,
    // is valid and invertible
    isValidNot0: (l) => !u.is0(l) && u.isValid(l),
    isOdd: (l) => (l & mn) === mn,
    neg: (l) => rr(-l, t),
    eql: (l, d) => l === d,
    sqr: (l) => rr(l * l, t),
    add: (l, d) => rr(l + d, t),
    sub: (l, d) => rr(l - d, t),
    mul: (l, d) => rr(l * d, t),
    pow: (l, d) => RQ(u, l, d),
    div: (l, d) => rr(l * oA(d, t), t),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, d) => l + d,
    subN: (l, d) => l - d,
    mulN: (l, d) => l * d,
    inv: (l) => oA(l, t),
    sqrt: a || ((l) => (c || (c = PQ(t)), c(u, l))),
    toBytes: (l) => n ? oT(l, o) : Rw(l, o),
    fromBytes: (l) => {
      if (l.length !== o)
        throw new Error("Field.fromBytes: expected " + o + " bytes, got " + l.length);
      return n ? iT(l) : Em(l);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (l) => fT(u, l),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (l, d, p) => p ? d : l
  });
  return Object.freeze(u);
}
function pT(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function hT(t) {
  const e = pT(t);
  return e + Math.ceil(e / 2);
}
function FQ(t, e, n = !1) {
  const r = t.length, s = pT(e), a = hT(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error("expected " + a + "-1024 bytes of input, got " + r);
  const i = n ? iT(t) : Em(t), o = rr(i, e - mn) + mn;
  return n ? oT(o, s) : Rw(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $l = BigInt(0), Ii = BigInt(1);
function ju(t, e) {
  const n = e.negate();
  return t ? n : e;
}
function MQ(t, e, n) {
  const r = (i) => i.pz, s = fT(t.Fp, n.map(r));
  return n.map((i, o) => i.toAffine(s[o])).map(t.fromAffine);
}
function mT(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function j0(t, e) {
  mT(t, e);
  const n = Math.ceil(e / t) + 1, r = 2 ** (t - 1), s = 2 ** t, a = xm(t), i = BigInt(t);
  return { windows: n, windowSize: r, mask: a, maxNumber: s, shiftBy: i };
}
function lA(t, e, n) {
  const { windowSize: r, mask: s, maxNumber: a, shiftBy: i } = n;
  let o = Number(t & s), c = t >> i;
  o > r && (o -= a, c += Ii);
  const u = e * r, l = u + Math.abs(o) - 1, d = o === 0, p = o < 0, f = e % 2 !== 0;
  return { nextN: c, offset: l, isZero: d, isNeg: p, isNegF: f, offsetF: u };
}
function LQ(t, e) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((n, r) => {
    if (!(n instanceof e))
      throw new Error("invalid point at index " + r);
  });
}
function HQ(t, e) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((n, r) => {
    if (!e.isValid(n))
      throw new Error("invalid scalar at index " + r);
  });
}
const V0 = /* @__PURE__ */ new WeakMap(), yT = /* @__PURE__ */ new WeakMap();
function q0(t) {
  return yT.get(t) || 1;
}
function uA(t) {
  if (t !== $l)
    throw new Error("invalid wNAF");
}
function _Q(t, e) {
  return {
    constTimeNegate: ju,
    hasPrecomputes(n) {
      return q0(n) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(n, r, s = t.ZERO) {
      let a = n;
      for (; r > $l; )
        r & Ii && (s = s.add(a)), a = a.double(), r >>= Ii;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(n, r) {
      const { windows: s, windowSize: a } = j0(r, e), i = [];
      let o = n, c = o;
      for (let u = 0; u < s; u++) {
        c = o, i.push(c);
        for (let l = 1; l < a; l++)
          c = c.add(o), i.push(c);
        o = c.double();
      }
      return i;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(n, r, s) {
      let a = t.ZERO, i = t.BASE;
      const o = j0(n, e);
      for (let c = 0; c < o.windows; c++) {
        const { nextN: u, offset: l, isZero: d, isNeg: p, isNegF: f, offsetF: b } = lA(s, c, o);
        s = u, d ? i = i.add(ju(f, r[b])) : a = a.add(ju(p, r[l]));
      }
      return uA(s), { p: a, f: i };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(n, r, s, a = t.ZERO) {
      const i = j0(n, e);
      for (let o = 0; o < i.windows && s !== $l; o++) {
        const { nextN: c, offset: u, isZero: l, isNeg: d } = lA(s, o, i);
        if (s = c, !l) {
          const p = r[u];
          a = a.add(d ? p.negate() : p);
        }
      }
      return uA(s), a;
    },
    getPrecomputes(n, r, s) {
      let a = V0.get(r);
      return a || (a = this.precomputeWindow(r, n), n !== 1 && (typeof s == "function" && (a = s(a)), V0.set(r, a))), a;
    },
    wNAFCached(n, r, s) {
      const a = q0(n);
      return this.wNAF(a, this.getPrecomputes(a, n, s), r);
    },
    wNAFCachedUnsafe(n, r, s, a) {
      const i = q0(n);
      return i === 1 ? this.unsafeLadder(n, r, a) : this.wNAFUnsafe(i, this.getPrecomputes(i, n, s), r, a);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(n, r) {
      mT(r, e), yT.set(n, r), V0.delete(n);
    }
  };
}
function $Q(t, e, n, r) {
  let s = e, a = t.ZERO, i = t.ZERO;
  for (; n > $l || r > $l; )
    n & Ii && (a = a.add(s)), r & Ii && (i = i.add(s)), s = s.double(), n >>= Ii, r >>= Ii;
  return { p1: a, p2: i };
}
function GQ(t, e, n, r) {
  LQ(n, t), HQ(r, e);
  const s = n.length, a = r.length;
  if (s !== a)
    throw new Error("arrays of points and scalars must have equal length");
  const i = t.ZERO, o = TQ(BigInt(s));
  let c = 1;
  o > 12 ? c = o - 3 : o > 4 ? c = o - 2 : o > 0 && (c = 2);
  const u = xm(c), l = new Array(Number(u) + 1).fill(i), d = Math.floor((e.BITS - 1) / c) * c;
  let p = i;
  for (let f = d; f >= 0; f -= c) {
    l.fill(i);
    for (let y = 0; y < a; y++) {
      const g = r[y], w = Number(g >> BigInt(f) & u);
      l[w] = l[w].add(n[y]);
    }
    let b = i;
    for (let y = l.length - 1, g = i; y > 0; y--)
      g = g.add(l[y]), b = b.add(g);
    if (p = p.add(b), f !== 0)
      for (let y = 0; y < c; y++)
        p = p.double();
  }
  return p;
}
function dA(t, e) {
  if (e) {
    if (e.ORDER !== t)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return NQ(e), e;
  } else
    return Am(t);
}
function zQ(t, e, n = {}) {
  if (!e || typeof e != "object")
    throw new Error(`expected valid ${t} CURVE object`);
  for (const o of ["p", "n", "h"]) {
    const c = e[o];
    if (!(typeof c == "bigint" && c > $l))
      throw new Error(`CURVE.${o} must be positive bigint`);
  }
  const r = dA(e.p, n.Fp), s = dA(e.n, n.Fn), i = ["Gx", "Gy", "a", "b"];
  for (const o of i)
    if (!r.isValid(e[o]))
      throw new Error(`CURVE.${o} must be valid field element of CURVE.Fp`);
  return { Fp: r, Fn: s };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function fA(t) {
  t.lowS !== void 0 && fh("lowS", t.lowS), t.prehash !== void 0 && fh("prehash", t.prehash);
}
class jQ extends Error {
  constructor(e = "") {
    super(e);
  }
}
const As = {
  // asn.1 DER encoding utils
  Err: jQ,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (t, e) => {
      const { Err: n } = As;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = e.length / 2, s = up(r);
      if (s.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const a = r > 127 ? up(s.length / 2 | 128) : "";
      return up(t) + a + s + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(t, e) {
      const { Err: n } = As;
      let r = 0;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length < 2 || e[r++] !== t)
        throw new n("tlv.decode: wrong tlv");
      const s = e[r++], a = !!(s & 128);
      let i = 0;
      if (!a)
        i = s;
      else {
        const c = s & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = e.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          i = i << 8 | l;
        if (r += c, i < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const o = e.subarray(r, r + i);
      if (o.length !== i)
        throw new n("tlv.decode: wrong value length");
      return { v: o, l: e.subarray(r + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(t) {
      const { Err: e } = As;
      if (t < Vu)
        throw new e("integer: negative integers are not allowed");
      let n = up(t);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(t) {
      const { Err: e } = As;
      if (t[0] & 128)
        throw new e("invalid signature integer: negative");
      if (t[0] === 0 && !(t[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return Em(t);
    }
  },
  toSig(t) {
    const { Err: e, _int: n, _tlv: r } = As, s = Kn("signature", t), { v: a, l: i } = r.decode(48, s);
    if (i.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: o, l: c } = r.decode(2, a), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: n.decode(o), s: n.decode(u) };
  },
  hexFromSig(t) {
    const { _tlv: e, _int: n } = As, r = e.encode(2, n.encode(t.r)), s = e.encode(2, n.encode(t.s)), a = r + s;
    return e.encode(48, a);
  }
}, Vu = BigInt(0), qu = BigInt(1), VQ = BigInt(2), dp = BigInt(3), qQ = BigInt(4);
function KQ(t, e, n) {
  function r(s) {
    const a = t.sqr(s), i = t.mul(a, s);
    return t.add(t.add(i, t.mul(s, e)), n);
  }
  return r;
}
function bT(t, e, n) {
  const { BYTES: r } = t;
  function s(a) {
    let i;
    if (typeof a == "bigint")
      i = a;
    else {
      let o = Kn("private key", a);
      if (e) {
        if (!e.includes(o.length * 2))
          throw new Error("invalid private key");
        const c = new Uint8Array(r);
        c.set(o, c.length - o.length), o = c;
      }
      try {
        i = t.fromBytes(o);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof a}`);
      }
    }
    if (n && (i = t.create(i)), !t.isValidNot0(i))
      throw new Error("invalid private key: out of range [1..N-1]");
    return i;
  }
  return s;
}
function WQ(t, e = {}) {
  const { Fp: n, Fn: r } = zQ("weierstrass", t, e), { h: s, n: a } = t;
  Dw(e, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: i } = e;
  if (i && (!n.is0(t.a) || typeof i.beta != "bigint" || typeof i.splitScalar != "function"))
    throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function o() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function c(P, C, S) {
    const { x: R, y: M } = C.toAffine(), _ = n.toBytes(R);
    if (fh("isCompressed", S), S) {
      o();
      const j = !n.isOdd(M);
      return Ci(gT(j), _);
    } else
      return Ci(Uint8Array.of(4), _, n.toBytes(M));
  }
  function u(P) {
    Br(P);
    const C = n.BYTES, S = C + 1, R = 2 * C + 1, M = P.length, _ = P[0], j = P.subarray(1);
    if (M === S && (_ === 2 || _ === 3)) {
      const I = n.fromBytes(j);
      if (!n.isValid(I))
        throw new Error("bad point: is not on curve, wrong x");
      const F = p(I);
      let $;
      try {
        $ = n.sqrt(F);
      } catch (Z) {
        const Y = Z instanceof Error ? ": " + Z.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Y);
      }
      o();
      const V = n.isOdd($);
      return (_ & 1) === 1 !== V && ($ = n.neg($)), { x: I, y: $ };
    } else if (M === R && _ === 4) {
      const I = n.fromBytes(j.subarray(C * 0, C * 1)), F = n.fromBytes(j.subarray(C * 1, C * 2));
      if (!f(I, F))
        throw new Error("bad point: is not on curve");
      return { x: I, y: F };
    } else
      throw new Error(`bad point: got length ${M}, expected compressed=${S} or uncompressed=${R}`);
  }
  const l = e.toBytes || c, d = e.fromBytes || u, p = KQ(n, t.a, t.b);
  function f(P, C) {
    const S = n.sqr(C), R = p(P);
    return n.eql(S, R);
  }
  if (!f(t.Gx, t.Gy))
    throw new Error("bad curve params: generator point");
  const b = n.mul(n.pow(t.a, dp), qQ), y = n.mul(n.sqr(t.b), BigInt(27));
  if (n.is0(n.add(b, y)))
    throw new Error("bad curve params: a or b");
  function g(P, C, S = !1) {
    if (!n.isValid(C) || S && n.is0(C))
      throw new Error(`bad point coordinate ${P}`);
    return C;
  }
  function w(P) {
    if (!(P instanceof A))
      throw new Error("ProjectivePoint expected");
  }
  const k = iA((P, C) => {
    const { px: S, py: R, pz: M } = P;
    if (n.eql(M, n.ONE))
      return { x: S, y: R };
    const _ = P.is0();
    C == null && (C = _ ? n.ONE : n.inv(M));
    const j = n.mul(S, C), I = n.mul(R, C), F = n.mul(M, C);
    if (_)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(F, n.ONE))
      throw new Error("invZ was invalid");
    return { x: j, y: I };
  }), E = iA((P) => {
    if (P.is0()) {
      if (e.allowInfinityPoint && !n.is0(P.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: C, y: S } = P.toAffine();
    if (!n.isValid(C) || !n.isValid(S))
      throw new Error("bad point: x or y not field elements");
    if (!f(C, S))
      throw new Error("bad point: equation left != right");
    if (!P.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function T(P, C, S, R, M) {
    return S = new A(n.mul(S.px, P), S.py, S.pz), C = ju(R, C), S = ju(M, S), C.add(S);
  }
  class A {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(C, S, R) {
      this.px = g("x", C), this.py = g("y", S, !0), this.pz = g("z", R), Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(C) {
      const { x: S, y: R } = C || {};
      if (!C || !n.isValid(S) || !n.isValid(R))
        throw new Error("invalid affine point");
      if (C instanceof A)
        throw new Error("projective point not allowed");
      return n.is0(S) && n.is0(R) ? A.ZERO : new A(S, R, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(C) {
      return MQ(A, "pz", C);
    }
    static fromBytes(C) {
      return Br(C), A.fromHex(C);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(C) {
      const S = A.fromAffine(d(Kn("pointHex", C)));
      return S.assertValidity(), S;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(C) {
      const S = bT(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return A.BASE.multiply(S(C));
    }
    /** Multiscalar Multiplication */
    static msm(C, S) {
      return GQ(A, r, C, S);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(C = 8, S = !0) {
      return D.setWindowSize(this, C), S || this.multiply(dp), this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(C) {
      this.precompute(C);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      E(this);
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(C);
    }
    /** Compare one point to another. */
    equals(C) {
      w(C);
      const { px: S, py: R, pz: M } = this, { px: _, py: j, pz: I } = C, F = n.eql(n.mul(S, I), n.mul(_, M)), $ = n.eql(n.mul(R, I), n.mul(j, M));
      return F && $;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new A(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: C, b: S } = t, R = n.mul(S, dp), { px: M, py: _, pz: j } = this;
      let I = n.ZERO, F = n.ZERO, $ = n.ZERO, V = n.mul(M, M), X = n.mul(_, _), Z = n.mul(j, j), Y = n.mul(M, _);
      return Y = n.add(Y, Y), $ = n.mul(M, j), $ = n.add($, $), I = n.mul(C, $), F = n.mul(R, Z), F = n.add(I, F), I = n.sub(X, F), F = n.add(X, F), F = n.mul(I, F), I = n.mul(Y, I), $ = n.mul(R, $), Z = n.mul(C, Z), Y = n.sub(V, Z), Y = n.mul(C, Y), Y = n.add(Y, $), $ = n.add(V, V), V = n.add($, V), V = n.add(V, Z), V = n.mul(V, Y), F = n.add(F, V), Z = n.mul(_, j), Z = n.add(Z, Z), V = n.mul(Z, Y), I = n.sub(I, V), $ = n.mul(Z, X), $ = n.add($, $), $ = n.add($, $), new A(I, F, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(C) {
      w(C);
      const { px: S, py: R, pz: M } = this, { px: _, py: j, pz: I } = C;
      let F = n.ZERO, $ = n.ZERO, V = n.ZERO;
      const X = t.a, Z = n.mul(t.b, dp);
      let Y = n.mul(S, _), W = n.mul(R, j), Q = n.mul(M, I), oe = n.add(S, R), te = n.add(_, j);
      oe = n.mul(oe, te), te = n.add(Y, W), oe = n.sub(oe, te), te = n.add(S, M);
      let ae = n.add(_, I);
      return te = n.mul(te, ae), ae = n.add(Y, Q), te = n.sub(te, ae), ae = n.add(R, M), F = n.add(j, I), ae = n.mul(ae, F), F = n.add(W, Q), ae = n.sub(ae, F), V = n.mul(X, te), F = n.mul(Z, Q), V = n.add(F, V), F = n.sub(W, V), V = n.add(W, V), $ = n.mul(F, V), W = n.add(Y, Y), W = n.add(W, Y), Q = n.mul(X, Q), te = n.mul(Z, te), W = n.add(W, Q), Q = n.sub(Y, Q), Q = n.mul(X, Q), te = n.add(te, Q), Y = n.mul(W, te), $ = n.add($, Y), Y = n.mul(ae, te), F = n.mul(oe, F), F = n.sub(F, Y), Y = n.mul(oe, W), V = n.mul(ae, V), V = n.add(V, Y), new A(F, $, V);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(A.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(C) {
      const { endo: S } = e;
      if (!r.isValidNot0(C))
        throw new Error("invalid scalar: out of range");
      let R, M;
      const _ = (j) => D.wNAFCached(this, j, A.normalizeZ);
      if (S) {
        const { k1neg: j, k1: I, k2neg: F, k2: $ } = S.splitScalar(C), { p: V, f: X } = _(I), { p: Z, f: Y } = _($);
        M = X.add(Y), R = T(S.beta, V, Z, j, F);
      } else {
        const { p: j, f: I } = _(C);
        R = j, M = I;
      }
      return A.normalizeZ([R, M])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(C) {
      const { endo: S } = e, R = this;
      if (!r.isValid(C))
        throw new Error("invalid scalar: out of range");
      if (C === Vu || R.is0())
        return A.ZERO;
      if (C === qu)
        return R;
      if (D.hasPrecomputes(this))
        return this.multiply(C);
      if (S) {
        const { k1neg: M, k1: _, k2neg: j, k2: I } = S.splitScalar(C), { p1: F, p2: $ } = $Q(A, R, _, I);
        return T(S.beta, F, $, M, j);
      } else
        return D.wNAFCachedUnsafe(R, C);
    }
    multiplyAndAddUnsafe(C, S, R) {
      const M = this.multiplyUnsafe(S).add(C.multiplyUnsafe(R));
      return M.is0() ? void 0 : M;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(C) {
      return k(this, C);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: C } = e;
      return s === qu ? !0 : C ? C(A, this) : D.wNAFCachedUnsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: C } = e;
      return s === qu ? this : C ? C(A, this) : this.multiplyUnsafe(s);
    }
    toBytes(C = !0) {
      return fh("isCompressed", C), this.assertValidity(), l(A, this, C);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(C = !0) {
      return this.toBytes(C);
    }
    toHex(C = !0) {
      return Dl(this.toBytes(C));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  A.BASE = new A(t.Gx, t.Gy, n.ONE), A.ZERO = new A(n.ZERO, n.ONE, n.ZERO), A.Fp = n, A.Fn = r;
  const N = r.BITS, D = _Q(A, e.endo ? Math.ceil(N / 2) : N);
  return A;
}
function gT(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function QQ(t, e, n = {}) {
  Dw(e, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const r = e.randomBytes || lU, s = e.hmac || ((R, ...M) => RC(e.hash, R, Ci(...M))), { Fp: a, Fn: i } = t, { ORDER: o, BITS: c } = i;
  function u(R) {
    const M = o >> qu;
    return R > M;
  }
  function l(R) {
    return u(R) ? i.neg(R) : R;
  }
  function d(R, M) {
    if (!i.isValidNot0(M))
      throw new Error(`invalid signature ${R}: out of range 1..CURVE.n`);
  }
  class p {
    constructor(M, _, j) {
      d("r", M), d("s", _), this.r = M, this.s = _, j != null && (this.recovery = j), Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(M) {
      const _ = i.BYTES, j = Kn("compactSignature", M, _ * 2);
      return new p(i.fromBytes(j.subarray(0, _)), i.fromBytes(j.subarray(_, _ * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(M) {
      const { r: _, s: j } = As.toSig(Kn("DER", M));
      return new p(_, j);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(M) {
      return new p(this.r, this.s, M);
    }
    // ProjPointType<bigint>
    recoverPublicKey(M) {
      const _ = a.ORDER, { r: j, s: I, recovery: F } = this;
      if (F == null || ![0, 1, 2, 3].includes(F))
        throw new Error("recovery id invalid");
      if (o * VQ < _ && F > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const V = F === 2 || F === 3 ? j + o : j;
      if (!a.isValid(V))
        throw new Error("recovery id 2 or 3 invalid");
      const X = a.toBytes(V), Z = t.fromHex(Ci(gT((F & 1) === 0), X)), Y = i.inv(V), W = E(Kn("msgHash", M)), Q = i.create(-W * Y), oe = i.create(I * Y), te = t.BASE.multiplyUnsafe(Q).add(Z.multiplyUnsafe(oe));
      if (te.is0())
        throw new Error("point at infinify");
      return te.assertValidity(), te;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return u(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new p(this.r, i.neg(this.s), this.recovery) : this;
    }
    toBytes(M) {
      if (M === "compact")
        return Ci(i.toBytes(this.r), i.toBytes(this.s));
      if (M === "der")
        return ew(As.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Dl(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Dl(this.toBytes("compact"));
    }
  }
  const f = bT(i, n.allowedPrivateKeyLengths, n.wrapPrivateKey), b = {
    isValidPrivateKey(R) {
      try {
        return f(R), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const R = o;
      return FQ(r(hT(R)), R);
    },
    precompute(R = 8, M = t.BASE) {
      return M.precompute(R, !1);
    }
  };
  function y(R, M = !0) {
    return t.fromPrivateKey(R).toBytes(M);
  }
  function g(R) {
    if (typeof R == "bigint")
      return !1;
    if (R instanceof t)
      return !0;
    const _ = Kn("key", R).length, j = a.BYTES, I = j + 1, F = 2 * j + 1;
    if (!(n.allowedPrivateKeyLengths || i.BYTES === I))
      return _ === I || _ === F;
  }
  function w(R, M, _ = !0) {
    if (g(R) === !0)
      throw new Error("first arg must be private key");
    if (g(M) === !1)
      throw new Error("second arg must be public key");
    return t.fromHex(M).multiply(f(R)).toBytes(_);
  }
  const k = e.bits2int || function(R) {
    if (R.length > 8192)
      throw new Error("input is too large");
    const M = Em(R), _ = R.length * 8 - c;
    return _ > 0 ? M >> BigInt(_) : M;
  }, E = e.bits2int_modN || function(R) {
    return i.create(k(R));
  }, T = xm(c);
  function A(R) {
    return CQ("num < 2^" + c, R, Vu, T), i.toBytes(R);
  }
  function N(R, M, _ = D) {
    if (["recovered", "canonical"].some((oe) => oe in _))
      throw new Error("sign() legacy options not supported");
    const { hash: j } = e;
    let { lowS: I, prehash: F, extraEntropy: $ } = _;
    I == null && (I = !0), R = Kn("msgHash", R), fA(_), F && (R = Kn("prehashed msgHash", j(R)));
    const V = E(R), X = f(M), Z = [A(X), A(V)];
    if ($ != null && $ !== !1) {
      const oe = $ === !0 ? r(a.BYTES) : $;
      Z.push(Kn("extraEntropy", oe));
    }
    const Y = Ci(...Z), W = V;
    function Q(oe) {
      const te = k(oe);
      if (!i.isValidNot0(te))
        return;
      const ae = i.inv(te), ue = t.BASE.multiply(te).toAffine(), Ie = i.create(ue.x);
      if (Ie === Vu)
        return;
      const Le = i.create(ae * i.create(W + Ie * X));
      if (Le === Vu)
        return;
      let Ze = (ue.x === Ie ? 0 : 2) | Number(ue.y & qu), vt = Le;
      return I && u(Le) && (vt = l(Le), Ze ^= 1), new p(Ie, vt, Ze);
    }
    return { seed: Y, k2sig: Q };
  }
  const D = { lowS: e.lowS, prehash: !1 }, P = { lowS: e.lowS, prehash: !1 };
  function C(R, M, _ = D) {
    const { seed: j, k2sig: I } = N(R, M, _);
    return SQ(e.hash.outputLen, i.BYTES, s)(j, I);
  }
  t.BASE.precompute(8);
  function S(R, M, _, j = P) {
    const I = R;
    M = Kn("msgHash", M), _ = Kn("publicKey", _), fA(j);
    const { lowS: F, prehash: $, format: V } = j;
    if ("strict" in j)
      throw new Error("options.strict was renamed to lowS");
    if (V !== void 0 && !["compact", "der", "js"].includes(V))
      throw new Error('format must be "compact", "der" or "js"');
    const X = typeof I == "string" || Y1(I), Z = !X && !V && typeof I == "object" && I !== null && typeof I.r == "bigint" && typeof I.s == "bigint";
    if (!X && !Z)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let Y, W;
    try {
      if (Z)
        if (V === void 0 || V === "js")
          Y = new p(I.r, I.s);
        else
          throw new Error("invalid format");
      if (X) {
        try {
          V !== "compact" && (Y = p.fromDER(I));
        } catch (vt) {
          if (!(vt instanceof As.Err))
            throw vt;
        }
        !Y && V !== "der" && (Y = p.fromCompact(I));
      }
      W = t.fromHex(_);
    } catch {
      return !1;
    }
    if (!Y || F && Y.hasHighS())
      return !1;
    $ && (M = e.hash(M));
    const { r: Q, s: oe } = Y, te = E(M), ae = i.inv(oe), ue = i.create(te * ae), Ie = i.create(Q * ae), Le = t.BASE.multiplyUnsafe(ue).add(W.multiplyUnsafe(Ie));
    return Le.is0() ? !1 : i.create(Le.x) === Q;
  }
  return Object.freeze({
    getPublicKey: y,
    getSharedSecret: w,
    sign: C,
    verify: S,
    utils: b,
    Point: t,
    Signature: p
  });
}
function JQ(t) {
  const e = {
    a: t.a,
    b: t.b,
    p: t.Fp.ORDER,
    n: t.n,
    h: t.h,
    Gx: t.Gx,
    Gy: t.Gy
  }, n = t.Fp, r = Am(e.n, t.nBitLength), s = {
    Fp: n,
    Fn: r,
    allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
    allowInfinityPoint: t.allowInfinityPoint,
    endo: t.endo,
    wrapPrivateKey: t.wrapPrivateKey,
    isTorsionFree: t.isTorsionFree,
    clearCofactor: t.clearCofactor,
    fromBytes: t.fromBytes,
    toBytes: t.toBytes
  };
  return { CURVE: e, curveOpts: s };
}
function XQ(t) {
  const { CURVE: e, curveOpts: n } = JQ(t), r = {
    hash: t.hash,
    hmac: t.hmac,
    randomBytes: t.randomBytes,
    lowS: t.lowS,
    bits2int: t.bits2int,
    bits2int_modN: t.bits2int_modN
  };
  return { CURVE: e, curveOpts: n, ecdsaOpts: r };
}
function ZQ(t, e) {
  return Object.assign({}, e, {
    ProjectivePoint: e.Point,
    CURVE: t
  });
}
function YQ(t) {
  const { CURVE: e, curveOpts: n, ecdsaOpts: r } = XQ(t), s = WQ(e, n), a = QQ(s, r, n);
  return ZQ(t, a);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function eJ(t, e) {
  const n = (r) => YQ({ ...t, hash: r });
  return { ...n(e), create: n };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ph = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const tJ = BigInt(1), Tg = BigInt(2), pA = (t, e) => (t + e / Tg) / e;
function nJ(t) {
  const e = ph.p, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = Gn(l, n, e) * l % e, p = Gn(d, n, e) * l % e, f = Gn(p, Tg, e) * u % e, b = Gn(f, s, e) * f % e, y = Gn(b, a, e) * b % e, g = Gn(y, o, e) * y % e, w = Gn(g, c, e) * g % e, k = Gn(w, o, e) * y % e, E = Gn(k, n, e) * l % e, T = Gn(E, i, e) * b % e, A = Gn(T, r, e) * u % e, N = Gn(A, Tg, e);
  if (!Sg.eql(Sg.sqr(N), t))
    throw new Error("Cannot find square root");
  return N;
}
const Sg = Am(ph.p, void 0, void 0, { sqrt: nJ }), km = eJ({
  ...ph,
  Fp: Sg,
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = ph.n, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -tJ * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = pA(a * t, e), c = pA(-r * t, e);
      let u = rr(t - o * n - c * s, e), l = rr(-o * r - c * a, e);
      const d = u > i, p = l > i;
      if (d && (u = e - u), p && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: p, k2: l };
    }
  }
}, Dv);
function Fw() {
  return Ue(km.utils.randomPrivateKey());
}
function wT(t) {
  if (typeof t == "string") {
    if (!ze(t, { strict: !1 }))
      throw new ot({ address: t });
    return {
      address: t,
      type: "json-rpc"
    };
  }
  if (!ze(t.address, { strict: !1 }))
    throw new ot({ address: t.address });
  return {
    address: t.address,
    nonceManager: t.nonceManager,
    sign: t.sign,
    signAuthorization: t.signAuthorization,
    signMessage: t.signMessage,
    signTransaction: t.signTransaction,
    signTypedData: t.signTypedData,
    source: "custom",
    type: "local"
  };
}
function rJ(t) {
  const e = nt(`0x${t.substring(4)}`).substring(26);
  return am(`0x${e}`);
}
function sJ({ r: t, s: e, to: n = "hex", v: r, yParity: s }) {
  const a = (() => {
    if (s === 0 || s === 1)
      return s;
    if (r && (r === 27n || r === 28n || r >= 35n))
      return r % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), i = `0x${new km.Signature(Fe(t), Fe(e)).toCompactHex()}${a === 0 ? "1b" : "1c"}`;
  return n === "hex" ? i : Cn(i);
}
let aJ = !1;
async function pf({ hash: t, privateKey: e, to: n = "object" }) {
  const { r, s, recovery: a } = km.sign(t.slice(2), e.slice(2), { lowS: !0, extraEntropy: aJ }), i = {
    r: J(r, { size: 32 }),
    s: J(s, { size: 32 }),
    v: a ? 28n : 27n,
    yParity: a
  };
  return n === "bytes" || n === "hex" ? sJ({ ...i, to: n }) : i;
}
function iJ(t) {
  const { chainId: e, nonce: n, to: r } = t, s = t.contractAddress ?? t.address, a = nt(cr([
    "0x05",
    os([
      e ? J(e) : "0x",
      s,
      n ? J(n) : "0x"
    ])
  ]));
  return r === "bytes" ? Cn(a) : a;
}
async function oJ(t) {
  const { chainId: e, nonce: n, privateKey: r, to: s = "object" } = t, a = t.contractAddress ?? t.address, i = await pf({
    hash: iJ({ address: a, chainId: e, nonce: n }),
    privateKey: r,
    to: s
  });
  return s === "object" ? {
    address: a,
    chainId: e,
    nonce: n,
    ...i
  } : i;
}
const cJ = `Ethereum Signed Message:
`;
function lJ(t) {
  const e = typeof t == "string" ? yd(t) : typeof t.raw == "string" ? t.raw : Jt(t.raw), n = yd(`${cJ}${it(e)}`);
  return Tn([n, e]);
}
function uJ(t, e) {
  return nt(lJ(t), e);
}
async function dJ({ message: t, privateKey: e }) {
  return await pf({ hash: uJ(t), privateKey: e, to: "hex" });
}
async function fJ(t) {
  const { privateKey: e, transaction: n, serializer: r = ow } = t, s = n.type === "eip4844" ? {
    ...n,
    sidecars: !1
  } : n, a = await pf({
    hash: nt(r(s)),
    privateKey: e
  });
  return r(n, a);
}
class pJ extends H {
  constructor({ domain: e }) {
    super(`Invalid domain "${Zl(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class hJ extends H {
  constructor({ primaryType: e, types: n }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(n))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class mJ extends H {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function yJ(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (c, u) => {
    const l = { ...u };
    for (const d of c) {
      const { name: p, type: f } = d;
      f === "address" && (l[p] = l[p].toLowerCase());
    }
    return l;
  }, i = s.EIP712Domain ? e ? a(s.EIP712Domain, e) : {} : {}, o = (() => {
    if (r !== "EIP712Domain")
      return a(s[r], n);
  })();
  return Zl({ domain: i, message: o, primaryType: r, types: s });
}
function ET(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (i, o) => {
    for (const c of i) {
      const { name: u, type: l } = c, d = o[u], p = l.match(w3);
      if (p && (typeof d == "number" || typeof d == "bigint")) {
        const [y, g, w] = p;
        J(d, {
          signed: g === "int",
          size: Number.parseInt(w) / 8
        });
      }
      if (l === "address" && typeof d == "string" && !ze(d))
        throw new ot({ address: d });
      const f = l.match(_H);
      if (f) {
        const [y, g] = f;
        if (g && it(d) !== Number.parseInt(g))
          throw new $L({
            expectedSize: Number.parseInt(g),
            givenSize: it(d)
          });
      }
      const b = s[l];
      b && (bJ(l), a(b, d));
    }
  };
  if (s.EIP712Domain && e) {
    if (typeof e != "object")
      throw new pJ({ domain: e });
    a(s.EIP712Domain, e);
  }
  if (r !== "EIP712Domain")
    if (s[r])
      a(s[r], n);
    else
      throw new hJ({ primaryType: r, types: s });
}
function xT({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    (typeof (t == null ? void 0 : t.chainId) == "number" || typeof (t == null ? void 0 : t.chainId) == "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function bJ(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new mJ({ type: t });
}
function AT(t) {
  const { domain: e = {}, message: n, primaryType: r } = t, s = {
    EIP712Domain: xT({ domain: e }),
    ...t.types
  };
  ET({
    domain: e,
    message: n,
    primaryType: r,
    types: s
  });
  const a = ["0x1901"];
  return e && a.push(gJ({
    domain: e,
    types: s
  })), r !== "EIP712Domain" && a.push(kT({
    data: n,
    primaryType: r,
    types: s
  })), nt(Tn(a));
}
function gJ({ domain: t, types: e }) {
  return kT({
    data: t,
    primaryType: "EIP712Domain",
    types: e
  });
}
function kT({ data: t, primaryType: e, types: n }) {
  const r = vT({
    data: t,
    primaryType: e,
    types: n
  });
  return nt(r);
}
function vT({ data: t, primaryType: e, types: n }) {
  const r = [{ type: "bytes32" }], s = [wJ({ primaryType: e, types: n })];
  for (const a of n[e]) {
    const [i, o] = TT({
      types: n,
      name: a.name,
      type: a.type,
      value: t[a.name]
    });
    r.push(i), s.push(o);
  }
  return Wa(r, s);
}
function wJ({ primaryType: t, types: e }) {
  const n = Ue(EJ({ primaryType: t, types: e }));
  return nt(n);
}
function EJ({ primaryType: t, types: e }) {
  let n = "";
  const r = CT({ primaryType: t, types: e });
  r.delete(t);
  const s = [t, ...Array.from(r).sort()];
  for (const a of s)
    n += `${a}(${e[a].map(({ name: i, type: o }) => `${o} ${i}`).join(",")})`;
  return n;
}
function CT({ primaryType: t, types: e }, n = /* @__PURE__ */ new Set()) {
  const r = t.match(/^\w*/u), s = r == null ? void 0 : r[0];
  if (n.has(s) || e[s] === void 0)
    return n;
  n.add(s);
  for (const a of e[s])
    CT({ primaryType: a.type, types: e }, n);
  return n;
}
function TT({ types: t, name: e, type: n, value: r }) {
  if (t[n] !== void 0)
    return [
      { type: "bytes32" },
      nt(vT({ data: r, primaryType: n, types: t }))
    ];
  if (n === "bytes")
    return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`, [{ type: "bytes32" }, nt(r)];
  if (n === "string")
    return [{ type: "bytes32" }, nt(Ue(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const s = n.slice(0, n.lastIndexOf("[")), a = r.map((i) => TT({
      name: e,
      type: s,
      types: t,
      value: i
    }));
    return [
      { type: "bytes32" },
      nt(Wa(a.map(([i]) => i), a.map(([, i]) => i)))
    ];
  }
  return [{ type: n }, r];
}
async function xJ(t) {
  const { privateKey: e, ...n } = t;
  return await pf({
    hash: AT(n),
    privateKey: e,
    to: "hex"
  });
}
function Cd(t, e = {}) {
  const { nonceManager: n } = e, r = Ue(km.getPublicKey(t.slice(2), !1)), s = rJ(r);
  return {
    ...wT({
      address: s,
      nonceManager: n,
      async sign({ hash: i }) {
        return pf({ hash: i, privateKey: t, to: "hex" });
      },
      async signAuthorization(i) {
        return oJ({ ...i, privateKey: t });
      },
      async signMessage({ message: i }) {
        return dJ({ message: i, privateKey: t });
      },
      async signTransaction(i, { serializer: o } = {}) {
        return fJ({ privateKey: t, transaction: i, serializer: o });
      },
      async signTypedData(i) {
        return xJ({ ...i, privateKey: t });
      }
    }),
    publicKey: r,
    source: "privateKey"
  };
}
async function AJ(t, { address: e, blockTag: n = "latest", blockNumber: r }) {
  const s = await t.request({
    method: "eth_getTransactionCount",
    params: [
      e,
      typeof r == "bigint" ? J(r) : n
    ]
  }, {
    dedupe: !!r
  });
  return ni(s);
}
function kJ(t) {
  const { source: e } = t, n = /* @__PURE__ */ new Map(), r = new sw(8192), s = /* @__PURE__ */ new Map(), a = ({ address: i, chainId: o }) => `${i}.${o}`;
  return {
    async consume({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o }), l = this.get({ address: i, chainId: o, client: c });
      this.increment({ address: i, chainId: o });
      const d = await l;
      return await e.set({ address: i, chainId: o }, d), r.set(u, d), d;
    },
    async increment({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o }), u = n.get(c) ?? 0;
      n.set(c, u + 1);
    },
    async get({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o });
      let l = s.get(u);
      return l || (l = (async () => {
        try {
          const p = await e.get({ address: i, chainId: o, client: c }), f = r.get(u) ?? 0;
          return f > 0 && p <= f ? f + 1 : (r.delete(u), p);
        } finally {
          this.reset({ address: i, chainId: o });
        }
      })(), s.set(u, l)), (n.get(u) ?? 0) + await l;
    },
    reset({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o });
      n.delete(c), s.delete(c);
    }
  };
}
async function Rr({
  walletClient: t,
  desiredChainId: e
}) {
  try {
    let n = await t.getChainId();
    if (n === e) {
      console.log("[trails-sdk] Chain already switched to:", e);
      return;
    }
    if (console.log(
      "[trails-sdk] Switching to chain:",
      e,
      "currentChainId",
      n
    ), await t.switchChain({ id: e }), n = await t.getChainId(), n !== e)
      throw new Error("Failed to switch chain");
    console.log("[trails-sdk] Chain switched to:", e);
  } catch (n) {
    if (n instanceof Error && n.message.includes("wallet_addEthereumChain")) {
      const r = pe(e, {
        usePublicRpc: !0
      });
      if (r)
        return await t.addChain({
          chain: r
        }), Rr({ walletClient: t, desiredChainId: e });
    }
    throw console.error("[trails-sdk] Chain switch failed:", n), new Error(
      `[trails-sdk] Failed to switch chain: ${n instanceof Error ? n.message : "Unknown error"}`
    );
  }
}
const vJ = {
  [$e.id]: 0,
  [ls.id]: 0,
  [pn.id]: 1,
  [ii.id]: 1,
  [Pt.id]: 2,
  [oi.id]: 2,
  [ut.id]: 3,
  [cs.id]: 3,
  [At.id]: 6,
  [zs.id]: 6,
  [ft.id]: 7,
  [ci.id]: 7,
  [Vs.id]: 10,
  [sf.id]: 10,
  [js.id]: 11,
  [rf.id]: 11,
  [qs.id]: 14,
  [af.id]: 14
}, ST = {
  [$e.id]: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  [ls.id]: "0x1c7d4b196cb0c7b01d743fbc6116a902379c7238",
  [pn.id]: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  [ii.id]: "0x5425890298aed601595a70AB815c96711a31Bc65",
  [Pt.id]: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
  [oi.id]: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
  [ut.id]: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  [cs.id]: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  [At.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
  [zs.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  [ft.id]: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
  [ci.id]: "0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582",
  [Vs.id]: "0x078D782b760474a361dDA0AF3839290b0EF57AD6",
  [sf.id]: "0x31d0220469e10c4E71834a79b1f276d740d3768F",
  [js.id]: "0x176211869cA2b568f2A7D4EE941E073a821EE1ff",
  [rf.id]: "0xFEce4462D57bD51A6A552365A011b95f0E16d9B7",
  [qs.id]: "0x79A02482A880bCe3F13E09da970dC34dB4cD24D1",
  [af.id]: "0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88"
}, CJ = {
  [$e.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [ls.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [pn.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [ii.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [Pt.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [oi.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [ut.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [cs.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [At.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [zs.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [ft.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [ci.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [Vs.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [sf.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [js.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [rf.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [qs.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [af.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA"
}, TJ = {
  [$e.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [ls.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [pn.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [ii.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [Pt.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [oi.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [ut.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [cs.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [At.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [zs.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [ft.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [ci.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [Vs.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [sf.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [js.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [rf.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [qs.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [af.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275"
}, IT = {
  //[chains.arbitrumSepolia.id]: "0x58FEFe8A057E736CD361272BA2283DAfD8646198",
  [cs.id]: "0x05F3AcC7a7BB0e888Bb1bDE014bD61AfAfaC6943"
};
function hh(t) {
  return vJ[t] ?? null;
}
function Mw(t) {
  return ST[t] ?? null;
}
function OT(t) {
  return CJ[t] ?? null;
}
function SJ(t) {
  return TJ[t] ?? null;
}
async function IJ({
  walletClient: t,
  originChain: e,
  destinationChain: n,
  amount: r
}) {
  var b, y;
  const s = Mw(e.id), a = hh(e.id), i = hh(n.id), o = OT(e.id), c = (b = t.account) == null ? void 0 : b.address;
  if (!s || a === null || !o || i === null || !c)
    throw console.error("[trails-sdk] cctpTransfer: Invalid origin chain config", {
      originToken: s,
      originDomain: a,
      originTokenMessenger: o,
      destinationDomain: i,
      destinationAddress: c
    }), new Error("Invalid origin chain config");
  const u = hn({
    chain: e,
    transport: Ge()
  });
  await Rr({
    walletClient: t,
    desiredChainId: e.id
  });
  const l = (y = t.account) == null ? void 0 : y.address;
  if (!l)
    throw new Error("No account found");
  if (await Lw({
    publicClient: u,
    token: s,
    account: l,
    spender: o,
    amount: r
  })) {
    const g = await Hw({
      walletClient: t,
      tokenAddress: s,
      spender: o,
      amount: Lh,
      chain: e
    });
    console.log("waiting for approve", g), await u.waitForTransactionReceipt({
      hash: g
    }), console.log("approve done");
  }
  const p = BT(), f = await BJ({
    walletClient: t,
    tokenMessenger: o,
    destinationDomain: i,
    destinationAddress: c,
    amount: r,
    burnToken: s,
    maxFee: p,
    chain: e
  });
  return {
    waitForAttestation: async () => {
      await u.waitForTransactionReceipt({
        hash: f
      });
      const g = hC(e.id), w = await PT({
        domain: a,
        transactionHash: f,
        testnet: g
      });
      if (!w)
        throw new Error("Failed to retrieve attestation");
      return w;
    },
    txHash: f
  };
}
function BT() {
  return 500n;
}
async function Lw({
  publicClient: t,
  token: e,
  account: n,
  spender: r,
  amount: s
}) {
  return await t.readContract({
    address: e,
    abi: vl,
    functionName: "allowance",
    args: [uo(n), uo(r)]
  }) < s;
}
async function Hw({
  walletClient: t,
  tokenAddress: e,
  spender: n,
  amount: r,
  chain: s
}) {
  var o;
  const a = await OJ({
    tokenAddress: e,
    spender: n,
    amount: r
  });
  console.log("[trails-sdk] approving ERC20 transfer", a), await Rr({
    walletClient: t,
    desiredChainId: s.id
  });
  const i = (o = t.account) == null ? void 0 : o.address;
  if (!i)
    throw new Error("No account found");
  return t.sendTransaction({
    ...a,
    account: i,
    chain: s
  });
}
async function OJ({
  tokenAddress: t,
  spender: e,
  amount: n
}) {
  return console.log("[trails-sdk] get approve ERC20 transfer data", {
    tokenAddress: t,
    spender: e,
    amount: n
  }), {
    to: t,
    value: BigInt(0),
    data: Kt({
      abi: [
        {
          type: "function",
          name: "approve",
          stateMutability: "nonpayable",
          inputs: [
            { name: "spender", type: "address" },
            { name: "amount", type: "uint256" }
          ],
          outputs: [{ name: "", type: "bool" }]
        }
      ],
      functionName: "approve",
      args: [e, n]
    })
  };
}
async function BJ({
  walletClient: t,
  tokenMessenger: e,
  destinationDomain: n,
  destinationAddress: r,
  amount: s,
  burnToken: a,
  maxFee: i,
  chain: o
}) {
  var l;
  const c = await PJ({
    tokenMessenger: e,
    destinationDomain: n,
    destinationAddress: r,
    amount: s,
    burnToken: a,
    maxFee: i
  });
  await Rr({
    walletClient: t,
    desiredChainId: o.id
  });
  const u = (l = t.account) == null ? void 0 : l.address;
  if (!u)
    throw new Error("No account found");
  return t.sendTransaction({
    ...c,
    account: u,
    chain: o
  });
}
async function PJ({
  tokenMessenger: t,
  destinationDomain: e,
  destinationAddress: n,
  amount: r,
  burnToken: s,
  maxFee: a
}) {
  console.log("[trails-sdk] get burn USDC data", {
    tokenMessenger: t,
    destinationDomain: e,
    destinationAddress: n,
    amount: r,
    burnToken: s,
    maxFee: a
  });
  const i = `0x000000000000000000000000${n.slice(2)}`;
  return {
    to: t,
    value: BigInt(0),
    data: Kt({
      abi: [
        {
          type: "function",
          name: "depositForBurn",
          stateMutability: "nonpayable",
          inputs: [
            { name: "amount", type: "uint256" },
            { name: "destinationDomain", type: "uint32" },
            { name: "mintRecipient", type: "bytes32" },
            { name: "burnToken", type: "address" },
            { name: "destinationCaller", type: "bytes32" },
            { name: "maxFee", type: "uint256" },
            { name: "minFinalityThreshold", type: "uint32" }
          ],
          outputs: []
        }
      ],
      functionName: "depositForBurn",
      args: [
        r,
        e,
        i,
        s,
        "0x0000000000000000000000000000000000000000000000000000000000000000",
        a,
        1e3
        // minFinalityThreshold (1000 or less for Fast Transfer)
      ]
    })
  };
}
async function UJ({
  domain: t,
  transactionHash: e,
  testnet: n
}) {
  var s, a;
  console.log("[trails-sdk] retrieving attestation", {
    domain: t,
    transactionHash: e
  });
  const r = `https://iris-api${n ? "-sandbox" : ""}.circle.com/v2/messages/${t}?transactionHash=${e}`;
  for (; ; )
    try {
      const i = await fetch(r), o = await i.json();
      if (i.status === 404 && console.log("[trails-sdk] waiting for attestation..."), ((a = (s = o == null ? void 0 : o.messages) == null ? void 0 : s[0]) == null ? void 0 : a.status) === "complete")
        return console.log("[trails-sdk] attestation retrieved successfully!"), o.messages[0];
      console.log("[trails-sdk] waiting for attestation..."), await new Promise((c) => setTimeout(c, 5e3));
    } catch (i) {
      console.error(
        "[trails-sdk] error fetching attestation:",
        i instanceof Error ? i.message : String(i)
      ), await new Promise((o) => setTimeout(o, 5e3));
    }
}
async function NJ({
  tokenMessenger: t,
  attestation: e
}) {
  return console.log("[trails-sdk] get mint USDC data", {
    tokenMessenger: t,
    attestation: e
  }), {
    to: t,
    value: BigInt(0),
    data: Kt({
      abi: [
        {
          type: "function",
          name: "receiveMessage",
          stateMutability: "nonpayable",
          inputs: [
            { name: "message", type: "bytes" },
            { name: "attestation", type: "bytes" }
          ],
          outputs: []
        }
      ],
      functionName: "receiveMessage",
      args: [e.message, e.attestation]
    })
  };
}
async function PT({
  domain: t,
  transactionHash: e,
  testnet: n
}) {
  for (; ; ) {
    const r = await UJ({
      domain: t,
      transactionHash: e,
      testnet: n
    });
    if (r)
      return r;
    console.log("[trails-sdk] waiting for attestation..."), await new Promise((s) => setTimeout(s, 1e3));
  }
}
function hA(t, e) {
  var n;
  return (t == null ? void 0 : t.toLowerCase()) === ((n = ST[e]) == null ? void 0 : n.toLowerCase());
}
async function RJ({
  walletClient: t,
  originChain: e,
  destinationChain: n,
  amount: r
}) {
  var b;
  const s = IT[n.id];
  if (!s)
    throw console.error(
      "[trails-sdk] cctpTransferWithCustomCall: No custom CCTP relayer address found for this chain",
      {
        originChain: e,
        destinationChain: n
      }
    ), new Error("No custom CCTP relayer address found for this chain");
  const a = Mw(e.id), i = hh(e.id), o = hh(n.id), c = OT(e.id);
  if (!a || i === null || !c || o === null)
    throw console.error(
      "[trails-sdk] cctpTransferWithCustomCall: Invalid origin chain config"
    ), new Error("Invalid origin chain config");
  const u = hn({
    chain: e,
    transport: Ge()
  });
  await Rr({
    walletClient: t,
    desiredChainId: e.id
  });
  const l = (b = t.account) == null ? void 0 : b.address;
  if (!l)
    throw new Error("No account found");
  if (await Lw({
    publicClient: u,
    token: a,
    account: l,
    spender: c,
    amount: r
  })) {
    const y = await Hw({
      walletClient: t,
      tokenAddress: a,
      spender: c,
      amount: Lh,
      chain: e
    });
    console.log("waiting for approve", y), await u.waitForTransactionReceipt({
      hash: y
    }), console.log("approve done");
  }
  const p = BT(), f = await DJ({
    walletClient: t,
    tokenMessenger: c,
    destinationDomain: o,
    destinationContract: s,
    // CCTPRelayer contract address
    amount: r,
    burnToken: a,
    maxFee: p,
    chain: e
  });
  return {
    waitForAttestation: async () => {
      await u.waitForTransactionReceipt({
        hash: f
      });
      const y = hC(e.id), g = await PT({
        domain: i,
        transactionHash: f,
        testnet: y
      });
      if (!g)
        throw new Error("Failed to retrieve attestation");
      return g;
    },
    txHash: f
  };
}
async function DJ({
  walletClient: t,
  tokenMessenger: e,
  destinationDomain: n,
  destinationContract: r,
  amount: s,
  burnToken: a,
  maxFee: i,
  chain: o
}) {
  var l;
  const c = await FJ({
    tokenMessenger: e,
    destinationDomain: n,
    destinationContract: r,
    amount: s,
    burnToken: a,
    maxFee: i
  });
  await Rr({
    walletClient: t,
    desiredChainId: o.id
  });
  const u = (l = t.account) == null ? void 0 : l.address;
  if (!u)
    throw new Error("No account found");
  return t.sendTransaction({
    ...c,
    account: u,
    chain: o
  });
}
async function FJ({
  tokenMessenger: t,
  destinationDomain: e,
  destinationContract: n,
  amount: r,
  burnToken: s,
  maxFee: a
}) {
  console.log("[trails-sdk] get burn USDC to contract data", {
    tokenMessenger: t,
    destinationDomain: e,
    destinationContract: n,
    amount: r,
    burnToken: s,
    maxFee: a
  });
  const i = `0x000000000000000000000000${n.slice(2)}`;
  return {
    to: t,
    value: BigInt(0),
    data: Kt({
      abi: [
        {
          type: "function",
          name: "depositForBurn",
          stateMutability: "nonpayable",
          inputs: [
            { name: "amount", type: "uint256" },
            { name: "destinationDomain", type: "uint32" },
            { name: "mintRecipient", type: "bytes32" },
            { name: "burnToken", type: "address" },
            { name: "destinationCaller", type: "bytes32" },
            { name: "maxFee", type: "uint256" },
            { name: "minFinalityThreshold", type: "uint32" }
          ],
          outputs: []
        }
      ],
      functionName: "depositForBurn",
      args: [
        r,
        e,
        i,
        s,
        "0x0000000000000000000000000000000000000000000000000000000000000000",
        a,
        1e3
        // minFinalityThreshold (1000 or less for Fast Transfer)
      ]
    })
  };
}
async function MJ({
  attestation: t,
  targetContract: e,
  calldata: n,
  gasLimit: r = 500000n,
  destinationChain: s
}) {
  const a = IT[s.id];
  if (!a)
    throw new Error("No custom CCTP relayer address found for this chain");
  console.log("[trails-sdk] get CCTP relayer call data", {
    cctpRelayerAddress: a,
    targetContract: e,
    gasLimit: r
  });
  const i = Kt({
    abi: [
      {
        type: "function",
        name: "relayWithCustomCall",
        inputs: [
          {
            type: "tuple",
            name: "request",
            components: [
              { name: "message", type: "bytes" },
              { name: "attestation", type: "bytes" },
              { name: "targetContract", type: "address" },
              { name: "data", type: "bytes" },
              { name: "gasLimit", type: "uint256" }
            ]
          }
        ]
      }
    ],
    functionName: "relayWithCustomCall",
    args: [
      {
        message: t.message,
        attestation: t.attestation,
        targetContract: e,
        data: n,
        gasLimit: r
      }
    ]
  });
  return {
    to: a,
    data: i,
    value: BigInt(0)
  };
}
function UT({
  recipient: t,
  amount: e
}) {
  const n = TW(
    "function transfer(address,uint256) returns (bool)"
  );
  return UC(n, [
    t,
    e
  ]);
}
function NT(t) {
  var n, r;
  const e = Object.values(cm);
  for (const s of e)
    if (s.id === t)
      return `${(r = (n = s.blockExplorers) == null ? void 0 : n.default) == null ? void 0 : r.url}`;
  return "";
}
function Ig({ txHash: t, chainId: e }) {
  return t ? `${NT(e)}/tx/${t}` : "";
}
function _re({
  address: t,
  chainId: e
}) {
  return t ? `${NT(e)}/address/${t}` : "";
}
const LJ = {
  name: "permit",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "owner", type: "address" },
    { name: "spender", type: "address" },
    { name: "value", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "v", type: "uint8" },
    { name: "r", type: "bytes32" },
    { name: "s", type: "bytes32" }
  ],
  outputs: []
}, HJ = {
  name: "transferFrom",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
}, _J = {
  name: "transfer",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
};
function _w(t) {
  const e = t.slice(2), n = `0x${e.slice(0, 64)}`, r = `0x${e.slice(64, 128)}`, s = parseInt(e.slice(128, 130), 16);
  return { r: n, s: r, v: s };
}
function RT({
  signer: t,
  spender: e,
  amount: n,
  deadline: r,
  signature: s
}) {
  const { r: a, s: i, v: o } = _w(s);
  return Kt({
    abi: [LJ],
    functionName: "permit",
    args: [t, e, n, r, o, a, i]
  });
}
function DT({
  signer: t,
  spender: e,
  amount: n
}) {
  return Kt({
    abi: [HJ],
    functionName: "transferFrom",
    args: [t, e, n]
  });
}
function FT({
  recipient: t,
  amount: e
}) {
  return Kt({
    abi: [_J],
    functionName: "transfer",
    args: [t, e]
  });
}
function $J(t, e, n, r, s, a, i) {
  const o = RT({
    signer: t,
    spender: e,
    amount: n,
    deadline: r,
    signature: s
  }), c = DT({
    signer: t,
    spender: e,
    amount: n
  }), u = FT({ recipient: a, amount: n });
  return [o, c, u].map(
    (l) => ({
      to: i,
      data: l,
      value: "0"
    })
  );
}
async function $w({
  publicClient: t,
  walletClient: e,
  signer: n,
  spender: r,
  tokenAddress: s,
  amount: a,
  chain: i,
  deadline: o = BigInt(Math.floor(Date.now() / 1e3) + 3600)
  // 1 hour from now
}) {
  if (!e.account)
    throw new Error("No account found");
  const c = await t.readContract({
    address: s,
    abi: [
      {
        name: "nonces",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "owner", type: "address" }],
        outputs: [{ name: "", type: "uint256" }]
      }
    ],
    functionName: "nonces",
    args: [n]
  }), u = await t.readContract({
    address: s,
    abi: [
      {
        name: "name",
        type: "function",
        stateMutability: "view",
        inputs: [],
        outputs: [{ name: "", type: "string" }]
      }
    ],
    functionName: "name"
  });
  let l = "1";
  try {
    l = await t.readContract({
      address: s,
      abi: [
        {
          name: "version",
          type: "function",
          stateMutability: "view",
          inputs: [],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "version"
    });
  } catch {
    console.warn(
      "[trails-sdk] Token does not implement version(), defaulting to '1'"
    );
  }
  const d = {
    name: u,
    version: l,
    chainId: i.id,
    verifyingContract: s
  }, p = {
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  }, f = {
    owner: n,
    spender: r,
    value: a,
    nonce: c,
    deadline: o
  };
  await Rr({
    walletClient: e,
    desiredChainId: i.id
  }), console.log("[trails-sdk] Requesting permit signature...");
  const b = await e.signTypedData({
    account: e.account,
    domain: d,
    types: p,
    primaryType: "Permit",
    message: f
  }), { v: y, r: g, s: w } = _w(b);
  return { signature: b, deadline: o, v: y, r: g, s: w };
}
function GJ({
  user: t,
  token: e,
  amount: n,
  intentAddress: r,
  deadline: s,
  permitAmount: a,
  v: i,
  r: o,
  s: c,
  sigV: u,
  sigR: l,
  sigS: d
}) {
  const p = s6([
    "function depositToIntentWithPermit(address user, address token, uint256 amount, uint256 permitAmount, address intentAddress, uint256 deadline, uint8 v, bytes32 r, bytes32 s, uint8 sigV, bytes32 sigR, bytes32 sigS)"
  ]);
  return Kt({
    abi: p,
    functionName: "depositToIntentWithPermit",
    args: [
      t,
      e,
      n,
      a,
      r,
      s,
      i,
      o,
      c,
      u,
      l,
      d
    ]
  });
}
function zJ({
  user: t,
  token: e,
  amount: n,
  intentAddress: r,
  deadline: s,
  sigV: a,
  sigR: i,
  sigS: o
}) {
  const c = s6([
    "function depositToIntent(address user, address token, uint256 amount, address intentAddress, uint256 deadline, uint8 sigV, bytes32 sigR, bytes32 sigS)"
  ]);
  return Kt({
    abi: c,
    functionName: "depositToIntent",
    args: [t, e, n, r, s, a, i, o]
  });
}
async function mA({
  publicClient: t,
  walletClient: e,
  account: n,
  intentEntrypoint: r,
  depositTokenAddress: s,
  depositTokenAmount: a,
  depositRecipient: i,
  chain: o
}) {
  const c = Lh, u = await jJ({
    client: t,
    token: s,
    account: n.address,
    entrypoint: r,
    amount: BigInt(a)
  }), l = BigInt(Math.floor(Date.now() / 1e3) + 3600);
  let d = null;
  u && (d = await $w({
    publicClient: t,
    walletClient: e,
    signer: n.address,
    spender: r,
    tokenAddress: s,
    amount: c,
    chain: o,
    deadline: l
  }));
  const {
    v: p,
    r: f,
    s: b
  } = await VJ({
    client: e,
    intentParams: {
      user: n.address,
      token: s,
      amount: BigInt(a),
      intentAddress: i,
      deadline: l,
      chainId: o.id,
      contractAddress: r
    }
  });
  let y = null;
  return d ? y = GJ({
    user: n.address,
    token: s,
    amount: BigInt(a),
    permitAmount: c,
    intentAddress: i,
    deadline: l,
    v: d.v,
    r: d.r,
    s: d.s,
    sigV: p,
    sigR: f,
    sigS: b
  }) : y = zJ({
    user: n.address,
    token: s,
    amount: BigInt(a),
    intentAddress: i,
    deadline: l,
    sigV: p,
    sigR: f,
    sigS: b
  }), [
    {
      to: r,
      data: y,
      value: "0"
    }
  ];
}
async function jJ({
  client: t,
  token: e,
  account: n,
  entrypoint: r,
  amount: s
}) {
  return await t.readContract({
    address: e,
    abi: vl,
    functionName: "allowance",
    args: [uo(n), uo(r)]
  }) < s;
}
async function VJ({
  client: t,
  intentParams: e
}) {
  const {
    user: n,
    token: r,
    amount: s,
    intentAddress: a,
    deadline: i,
    chainId: o,
    contractAddress: c
  } = e, u = {
    name: "IntentEntrypoint",
    version: "1",
    chainId: o,
    verifyingContract: c
    //  This fixes the signature mismatch
  }, l = {
    Intent: [
      { name: "user", type: "address" },
      { name: "token", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "intentAddress", type: "address" },
      { name: "deadline", type: "uint256" }
    ]
  }, d = {
    user: uo(n),
    token: uo(r),
    amount: BigInt(s),
    intentAddress: uo(a),
    deadline: BigInt(i)
  }, p = await t.signTypedData({
    account: t.account,
    domain: u,
    types: l,
    primaryType: "Intent",
    message: d
  }), { v: f, r: b, s: y } = _w(p);
  return { signature: p, v: f, r: b, s: y };
}
const yA = 3e3, qJ = async (t, e, n) => t.status(e, BigInt(n)), $re = (t, e) => {
  const n = O7({
    queries: (t || []).map((s) => {
      const a = s.id;
      return {
        queryKey: ["metaTxnStatus", s.chainId, s.id],
        queryFn: async () => {
          const i = e(parseInt(s.chainId));
          if (!a)
            return {
              status: "failed",
              reason: "Missing operation hash for monitoring."
            };
          if (!i)
            return {
              status: "failed",
              reason: `Relayer not available for chain ${s.chainId}.`
            };
          const o = await i.status(
            a,
            BigInt(s.chainId)
          );
          let c;
          if (o.status === "confirmed")
            c = {
              status: "confirmed",
              transactionHash: o.transactionHash,
              data: o.data
            };
          else if (o.status === "failed")
            c = {
              status: "failed",
              reason: o.reason,
              data: o.data
            };
          else if (o.status === "pending")
            c = {
              status: "pending"
            };
          else if (o.status === "unknown")
            c = {
              status: "unknown"
            };
          else {
            const u = o.status;
            console.warn(
              `[trails-sdk]  Unexpected relayer status "${u}" for ${a}:`,
              o
            ), c = {
              status: "unknown"
            };
          }
          return c;
        },
        refetchInterval: (i) => {
          const o = i.state.data;
          return o && o.status === "confirmed" ? !1 : yA;
        },
        enabled: !!s && !!s.id && !!s.chainId,
        retry: (i, o) => i >= 30 ? (console.error(
          `[trails-sdk]  Giving up on transaction ${a} after 3 failed API attempts:`,
          o
        ), !1) : !0
      };
    })
  });
  return Eo(() => {
    const s = {};
    return (t || []).forEach((a, i) => {
      var u;
      const o = `${a.chainId}-${a.id}`, c = n[i];
      c ? c.isLoading && c.fetchStatus !== "idle" && !c.data ? s[o] = {
        status: "pending"
      } : c.isError ? s[o] = {
        status: "failed",
        reason: ((u = c.error) == null ? void 0 : u.message) || "An unknown error occurred"
      } : c.data ? s[o] = c.data : s[o] = {
        status: "unknown"
      } : s[o] = {
        status: "failed",
        reason: "Query result unexpectedly missing"
      };
    }), s;
  }, [t, n]);
};
async function KJ(t, e, n) {
  const { opHash: r } = await t.sendMetaTxn(
    e.walletAddress,
    e.contract,
    e.input,
    BigInt(e.chainId),
    void 0,
    n
  );
  return r;
}
const WJ = "0.1.1";
function QJ() {
  return WJ;
}
class Td extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof Td) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof Td && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${QJ()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return MT(this, e);
  }
}
function MT(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? MT(t.cause, e) : e ? null : t;
}
function JJ(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new YJ({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function ks(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new ZJ({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? XJ(c, r) : c;
}
function XJ(t, e) {
  return JJ(t, { dir: "left", size: e });
}
class ZJ extends Td {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class YJ extends Td {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}
const K0 = "/docs/contract/decodeFunctionResult";
function LT(t) {
  const { abi: e, args: n, functionName: r, data: s } = t;
  let a = e[0];
  if (r) {
    const o = mw({ abi: e, args: n, name: r });
    if (!o)
      throw new rh(r, { docsPath: K0 });
    a = o;
  }
  if (a.type !== "function")
    throw new rh(void 0, { docsPath: K0 });
  if (!a.outputs)
    throw new HL(a.name, { docsPath: K0 });
  const i = E3(a.outputs, s);
  if (i && i.length > 1)
    return i;
  if (i && i.length === 1)
    return i[0];
}
const bA = "/docs/contract/encodeFunctionData";
function eX(t) {
  const { abi: e, args: n, functionName: r } = t;
  let s = e[0];
  if (r) {
    const a = mw({
      abi: e,
      args: n,
      name: r
    });
    if (!a)
      throw new rh(r, { docsPath: bA });
    s = a;
  }
  if (s.type !== "function")
    throw new rh(void 0, { docsPath: bA });
  return {
    abi: [s],
    functionName: dw(Ll(s))
  };
}
function Gw(t) {
  const { args: e } = t, { abi: n, functionName: r } = (() => {
    var o;
    return t.abi.length === 1 && ((o = t.functionName) != null && o.startsWith("0x")) ? t : eX(t);
  })(), s = n[0], a = r, i = "inputs" in s && s.inputs ? Wa(s.inputs, e ?? []) : void 0;
  return cr([a, i ?? "0x"]);
}
const tX = 3;
function nX(t, { abi: e, address: n, args: r, docsPath: s, functionName: a, sender: i }) {
  const o = t instanceof I3 ? t : t instanceof H ? t.walk((b) => "data" in b) || t.walk() : {}, { code: c, data: u, details: l, message: d, shortMessage: p } = o, f = t instanceof uw ? new S3({ functionName: a }) : [tX, om.code].includes(c) && (u || l || d || p) ? new T3({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: a,
    message: o instanceof O3 ? l : p ?? d
  }) : t;
  return new C3(f, {
    abi: e,
    args: r,
    contractAddress: n,
    docsPath: s,
    functionName: a,
    sender: i
  });
}
function at(t, e, n) {
  const r = t[e.name];
  if (typeof r == "function")
    return r;
  const s = t[n];
  return typeof s == "function" ? s : (a) => e(t, a);
}
function rX(t) {
  return {
    address: t.address,
    amount: ks(t.amount),
    index: ks(t.index),
    validatorIndex: ks(t.validatorIndex)
  };
}
function sX(t) {
  return {
    ...typeof t.baseFeePerGas == "bigint" && {
      baseFeePerGas: ks(t.baseFeePerGas)
    },
    ...typeof t.blobBaseFee == "bigint" && {
      blobBaseFee: ks(t.blobBaseFee)
    },
    ...typeof t.feeRecipient == "string" && {
      feeRecipient: t.feeRecipient
    },
    ...typeof t.gasLimit == "bigint" && {
      gasLimit: ks(t.gasLimit)
    },
    ...typeof t.number == "bigint" && {
      number: ks(t.number)
    },
    ...typeof t.prevRandao == "bigint" && {
      prevRandao: ks(t.prevRandao)
    },
    ...typeof t.time == "bigint" && {
      time: ks(t.time)
    },
    ...t.withdrawals && {
      withdrawals: t.withdrawals.map(rX)
    }
  };
}
const gA = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], Gre = [
  {
    name: "query",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "tuple[]",
        name: "queries",
        components: [
          {
            type: "address",
            name: "sender"
          },
          {
            type: "string[]",
            name: "urls"
          },
          {
            type: "bytes",
            name: "data"
          }
        ]
      }
    ],
    outputs: [
      {
        type: "bool[]",
        name: "failures"
      },
      {
        type: "bytes[]",
        name: "responses"
      }
    ]
  },
  {
    name: "HttpError",
    type: "error",
    inputs: [
      {
        type: "uint16",
        name: "status"
      },
      {
        type: "string",
        name: "message"
      }
    ]
  }
], aX = "0x82ad56cb", iX = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", oX = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", W0 = "/docs/contract/encodeDeployData";
function HT(t) {
  const { abi: e, args: n, bytecode: r } = t;
  if (!n || n.length === 0)
    return r;
  const s = e.find((i) => "type" in i && i.type === "constructor");
  if (!s)
    throw new RL({ docsPath: W0 });
  if (!("inputs" in s))
    throw new b2({ docsPath: W0 });
  if (!s.inputs || s.inputs.length === 0)
    throw new b2({ docsPath: W0 });
  const a = Wa(s.inputs, n);
  return cr([r, a]);
}
function cX() {
  let t = () => {
  }, e = () => {
  };
  return { promise: new Promise((r, s) => {
    t = r, e = s;
  }), resolve: t, reject: e };
}
const Q0 = /* @__PURE__ */ new Map();
function lX({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: s }) {
  const a = async () => {
    const l = c();
    i();
    const d = l.map(({ args: p }) => p);
    d.length !== 0 && t(d).then((p) => {
      s && Array.isArray(p) && p.sort(s);
      for (let f = 0; f < l.length; f++) {
        const { resolve: b } = l[f];
        b == null || b([p[f], p]);
      }
    }).catch((p) => {
      for (let f = 0; f < l.length; f++) {
        const { reject: b } = l[f];
        b == null || b(p);
      }
    });
  }, i = () => Q0.delete(e), o = () => c().map(({ args: l }) => l), c = () => Q0.get(e) || [], u = (l) => Q0.set(e, [...c(), l]);
  return {
    flush: i,
    async schedule(l) {
      const { promise: d, resolve: p, reject: f } = cX();
      return (n == null ? void 0 : n([...o(), l])) && a(), c().length > 0 ? (u({ args: l, resolve: p, reject: f }), d) : (u({ args: l, resolve: p, reject: f }), setTimeout(a, r), d);
    }
  };
}
function wA(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new s2({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new s2({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return e[n] = r, e;
    }, {});
}
function uX(t) {
  const { balance: e, nonce: n, state: r, stateDiff: s, code: a } = t, i = {};
  if (a !== void 0 && (i.code = a), e !== void 0 && (i.balance = J(e)), n !== void 0 && (i.nonce = J(n)), r !== void 0 && (i.state = wA(r)), s !== void 0) {
    if (i.state)
      throw new s_();
    i.stateDiff = wA(s);
  }
  return i;
}
function _T(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: n, ...r } of t) {
    if (!ze(n, { strict: !1 }))
      throw new ot({ address: n });
    if (e[n])
      throw new r_({ address: n });
    e[n] = uX(r);
  }
  return e;
}
async function $T(t, e) {
  var _, j, I, F;
  const { account: n = t.account, authorizationList: r, batch: s = !!((_ = t.batch) != null && _.multicall), blockNumber: a, blockTag: i = t.experimental_blockTag ?? "latest", accessList: o, blobs: c, blockOverrides: u, code: l, data: d, factory: p, factoryData: f, gas: b, gasPrice: y, maxFeePerBlobGas: g, maxFeePerGas: w, maxPriorityFeePerGas: k, nonce: E, to: T, value: A, stateOverride: N, ...D } = e, P = n ? ir(n) : void 0;
  if (l && (p || f))
    throw new H("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (l && T)
    throw new H("Cannot provide both `code` & `to` as parameters.");
  const C = l && d, S = p && f && T && d, R = C || S, M = C ? pX({
    code: l,
    data: d
  }) : S ? hX({
    data: d,
    factory: p,
    factoryData: f,
    to: T
  }) : d;
  try {
    U3(e);
    const V = (typeof a == "bigint" ? J(a) : void 0) || i, X = u ? sX(u) : void 0, Z = _T(N), Y = (F = (I = (j = t.chain) == null ? void 0 : j.formatters) == null ? void 0 : I.transactionRequest) == null ? void 0 : F.format, Q = (Y || J1)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...P3(D, { format: Y }),
      from: P == null ? void 0 : P.address,
      accessList: o,
      authorizationList: r,
      blobs: c,
      data: M,
      gas: b,
      gasPrice: y,
      maxFeePerBlobGas: g,
      maxFeePerGas: w,
      maxPriorityFeePerGas: k,
      nonce: E,
      to: R ? void 0 : T,
      value: A
    });
    if (s && dX({ request: Q }) && !Z && !X)
      try {
        return await fX(t, {
          ...Q,
          blockNumber: a,
          blockTag: i
        });
      } catch (ae) {
        if (!(ae instanceof $v) && !(ae instanceof ob))
          throw ae;
      }
    const oe = (() => {
      const ae = [
        Q,
        V
      ];
      return Z && X ? [...ae, Z, X] : Z ? [...ae, Z] : X ? [...ae, {}, X] : ae;
    })(), te = await t.request({
      method: "eth_call",
      params: oe
    });
    return te === "0x" ? { data: void 0 } : { data: te };
  } catch ($) {
    const V = mX($), { offchainLookup: X, offchainLookupSignature: Z } = await import("./ccip-B7PXFAS4.js");
    if (t.ccipRead !== !1 && (V == null ? void 0 : V.slice(0, 10)) === Z && T)
      return { data: await X(t, { data: V, to: T }) };
    throw R && (V == null ? void 0 : V.slice(0, 10)) === "0x101bb98d" ? new c_({ factory: p }) : B3($, {
      ...e,
      account: P,
      chain: t.chain
    });
  }
}
function dX({ request: t }) {
  const { data: e, to: n, ...r } = t;
  return !(!e || e.startsWith(aX) || !n || Object.values(r).filter((s) => typeof s < "u").length > 0);
}
async function fX(t, e) {
  var y;
  const { batchSize: n = 1024, wait: r = 0 } = typeof ((y = t.batch) == null ? void 0 : y.multicall) == "object" ? t.batch.multicall : {}, { blockNumber: s, blockTag: a = t.experimental_blockTag ?? "latest", data: i, multicallAddress: o, to: c } = e;
  let u = o;
  if (!u) {
    if (!t.chain)
      throw new $v();
    u = DD({
      blockNumber: s,
      chain: t.chain,
      contract: "multicall3"
    });
  }
  const d = (typeof s == "bigint" ? J(s) : void 0) || a, { schedule: p } = lX({
    id: `${t.uid}.${d}`,
    wait: r,
    shouldSplitBatch(g) {
      return g.reduce((k, { data: E }) => k + (E.length - 2), 0) > n * 2;
    },
    fn: async (g) => {
      const w = g.map((T) => ({
        allowFailure: !0,
        callData: T.data,
        target: T.to
      })), k = Gw({
        abi: gA,
        args: [w],
        functionName: "aggregate3"
      }), E = await t.request({
        method: "eth_call",
        params: [
          {
            data: k,
            to: u
          },
          d
        ]
      });
      return LT({
        abi: gA,
        args: [w],
        functionName: "aggregate3",
        data: E || "0x"
      });
    }
  }), [{ returnData: f, success: b }] = await p({ data: i, to: c });
  if (!b)
    throw new I3({ data: f });
  return f === "0x" ? { data: void 0 } : { data: f };
}
function pX(t) {
  const { code: e, data: n } = t;
  return HT({
    abi: im(["constructor(bytes, bytes)"]),
    bytecode: iX,
    args: [e, n]
  });
}
function hX(t) {
  const { data: e, factory: n, factoryData: r, to: s } = t;
  return HT({
    abi: im(["constructor(address, bytes, address, bytes)"]),
    bytecode: oX,
    args: [s, e, n, r]
  });
}
function mX(t) {
  var n;
  if (!(t instanceof H))
    return;
  const e = t.walk();
  return typeof (e == null ? void 0 : e.data) == "object" ? (n = e.data) == null ? void 0 : n.data : e.data;
}
async function GT(t, e) {
  const { abi: n, address: r, args: s, functionName: a, ...i } = e, o = Gw({
    abi: n,
    args: s,
    functionName: a
  });
  try {
    const { data: c } = await at(t, $T, "call")({
      ...i,
      data: o,
      to: r
    });
    return LT({
      abi: n,
      args: s,
      functionName: a,
      data: c || "0x"
    });
  } catch (c) {
    throw nX(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/readContract",
      functionName: a
    });
  }
}
const zre = [
  {
    inputs: [
      { name: "preOpGas", type: "uint256" },
      { name: "paid", type: "uint256" },
      { name: "validAfter", type: "uint48" },
      { name: "validUntil", type: "uint48" },
      { name: "targetSuccess", type: "bool" },
      { name: "targetResult", type: "bytes" }
    ],
    name: "ExecutionResult",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResult",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "aggregator", type: "address" },
          {
            components: [
              { name: "stake", type: "uint256" },
              {
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            name: "stakeInfo",
            type: "tuple"
          }
        ],
        name: "aggregatorInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResultWithAggregation",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "factory",
        type: "address"
      },
      {
        indexed: !1,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: !1, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !0,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      { indexed: !1, name: "success", type: "bool" },
      {
        indexed: !1,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "SIG_VALIDATION_FAILED",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "initCode", type: "bytes" },
      { name: "sender", type: "address" },
      { name: "paymasterAndData", type: "bytes" }
    ],
    name: "_validateSenderAndPaymaster",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint112" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint112" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "op",
        type: "tuple"
      },
      { name: "target", type: "address" },
      { name: "targetCallData", type: "bytes" }
    ],
    name: "simulateHandleOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], EA = [
  {
    inputs: [
      { name: "success", type: "bool" },
      { name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" },
      { name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "factory",
        type: "address"
      },
      {
        indexed: !1,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: !1, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !0,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      { indexed: !1, name: "success", type: "bool" },
      {
        indexed: !1,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint256" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint256" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "gasFees", type: "bytes32" },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
function zT(t) {
  const { authorization: e, factory: n, factoryData: r } = t;
  if (n === "0x7702" || n === "0x7702000000000000000000000000000000000000") {
    if (!e)
      return "0x7702000000000000000000000000000000000000";
    const s = e.address;
    return Tn([s, r ?? "0x"]);
  }
  return n ? Tn([n, r ?? "0x"]) : "0x";
}
async function xA(t) {
  return new Promise((e) => setTimeout(e, t));
}
function yX(t, e) {
  if (!ze(t, { strict: !1 }))
    throw new ot({ address: t });
  if (!ze(e, { strict: !1 }))
    throw new ot({ address: e });
  return t.toLowerCase() === e.toLowerCase();
}
const bX = "0x6492649264926492649264926492649264926492649264926492649264926492";
function J0(t) {
  const { address: e, data: n, signature: r, to: s = "hex" } = t, a = cr([
    Wa([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [e, n, r]),
    bX
  ]);
  return s === "hex" ? a : Cn(a);
}
function jT(t) {
  const { callGasLimit: e, callData: n, maxPriorityFeePerGas: r, maxFeePerGas: s, paymaster: a, paymasterData: i, paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, sender: u, signature: l = "0x", verificationGasLimit: d } = t, p = Tn([
    zt(J(d || 0n), { size: 16 }),
    zt(J(e || 0n), { size: 16 })
  ]), f = zT(t), b = Tn([
    zt(J(r || 0n), { size: 16 }),
    zt(J(s || 0n), { size: 16 })
  ]), y = t.nonce ?? 0n, g = a ? Tn([
    a,
    zt(J(c || 0n), {
      size: 16
    }),
    zt(J(o || 0n), {
      size: 16
    }),
    i || "0x"
  ]) : "0x", w = t.preVerificationGas ?? 0n;
  return {
    accountGasLimits: p,
    callData: n,
    initCode: f,
    gasFees: b,
    nonce: y,
    paymasterAndData: g,
    preVerificationGas: w,
    sender: u,
    signature: l
  };
}
const gX = {
  PackedUserOperation: [
    { type: "address", name: "sender" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "bytes32", name: "accountGasLimits" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "bytes32", name: "gasFees" },
    { type: "bytes", name: "paymasterAndData" }
  ]
};
function wX(t) {
  const { chainId: e, entryPointAddress: n, userOperation: r } = t, s = jT(r);
  return {
    types: gX,
    primaryType: "PackedUserOperation",
    domain: {
      name: "ERC4337",
      version: "1",
      chainId: e,
      verifyingContract: n
    },
    message: s
  };
}
function EX(t) {
  const { chainId: e, entryPointAddress: n, entryPointVersion: r } = t, s = t.userOperation, { authorization: a, callData: i = "0x", callGasLimit: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymasterAndData: d = "0x", preVerificationGas: p, sender: f, verificationGasLimit: b } = s;
  if (r === "0.8")
    return AT(wX({
      chainId: e,
      entryPointAddress: n,
      userOperation: s
    }));
  const y = (() => {
    var g, w;
    if (r === "0.6") {
      const k = (g = s.initCode) == null ? void 0 : g.slice(0, 42), E = (w = s.initCode) == null ? void 0 : w.slice(42), T = zT({
        authorization: a,
        factory: k,
        factoryData: E
      });
      return Wa([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        f,
        l,
        nt(T),
        nt(i),
        o,
        b,
        p,
        c,
        u,
        nt(d)
      ]);
    }
    if (r === "0.7") {
      const k = jT(s);
      return Wa([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        k.sender,
        k.nonce,
        nt(k.initCode),
        nt(k.callData),
        k.accountGasLimits,
        k.preVerificationGas,
        k.gasFees,
        nt(k.paymasterAndData)
      ]);
    }
    throw new Error(`entryPointVersion "${r}" not supported.`);
  })();
  return nt(Wa([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [nt(y), n, BigInt(e)]));
}
async function xX(t, { address: e, blockNumber: n, blockTag: r = "latest" }) {
  const s = n !== void 0 ? J(n) : void 0, a = await t.request({
    method: "eth_getCode",
    params: [e, s || r]
  }, { dedupe: !!s });
  if (a !== "0x")
    return a;
}
async function AX(t) {
  const { extend: e, nonceKeyManager: n = kJ({
    source: {
      get() {
        return Date.now();
      },
      set() {
      }
    }
  }), ...r } = t;
  let s = !1;
  const a = await t.getAddress();
  return {
    ...e,
    ...r,
    address: a,
    async getFactoryArgs() {
      return "isDeployed" in this && await this.isDeployed() ? { factory: void 0, factoryData: void 0 } : t.getFactoryArgs();
    },
    async getNonce(i) {
      const o = (i == null ? void 0 : i.key) ?? BigInt(await n.consume({
        address: a,
        chainId: t.client.chain.id,
        client: t.client
      }));
      return t.getNonce ? await t.getNonce({ ...i, key: o }) : await GT(t.client, {
        abi: im([
          "function getNonce(address, uint192) pure returns (uint256)"
        ]),
        address: t.entryPoint.address,
        functionName: "getNonce",
        args: [a, o]
      });
    },
    async isDeployed() {
      return s ? !0 : (s = !!await at(t.client, xX, "getCode")({
        address: a
      }), s);
    },
    ...t.sign ? {
      async sign(i) {
        const [{ factory: o, factoryData: c }, u] = await Promise.all([
          this.getFactoryArgs(),
          t.sign(i)
        ]);
        return o && c ? J0({
          address: o,
          data: c,
          signature: u
        }) : u;
      }
    } : {},
    async signMessage(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signMessage(i)
      ]);
      return o && c && o !== "0x7702" ? J0({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    async signTypedData(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signTypedData(i)
      ]);
      return o && c && o !== "0x7702" ? J0({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    type: "smart"
  };
}
async function kX(t, { account: e = t.account, message: n }) {
  if (!e)
    throw new Go({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const r = ir(e);
  if (r.signMessage)
    return r.signMessage({ message: n });
  const s = typeof n == "string" ? yd(n) : n.raw instanceof Uint8Array ? Ue(n.raw) : n.raw;
  return t.request({
    method: "personal_sign",
    params: [s, r.address]
  }, { retryCount: 0 });
}
async function vX(t, e) {
  const { account: n = t.account, domain: r, message: s, primaryType: a } = e;
  if (!n)
    throw new Go({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const i = ir(n), o = {
    EIP712Domain: xT({ domain: r }),
    ...e.types
  };
  if (ET({ domain: r, message: s, primaryType: a, types: o }), i.signTypedData)
    return i.signTypedData({ domain: r, message: s, primaryType: a, types: o });
  const c = yJ({ domain: r, message: s, primaryType: a, types: o });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [i.address, c]
  }, { retryCount: 0 });
}
class Og extends H {
  constructor({ cause: e }) {
    super("Smart Account is not deployed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.",
        "- An incorrect `sender` address is provided."
      ],
      name: "AccountNotDeployedError"
    });
  }
}
Object.defineProperty(Og, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa20/
});
class Gl extends H {
  constructor({ cause: e, data: n, message: r } = {}) {
    var a;
    const s = (a = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : a.replace("execution reverted", "");
    super(`Execution reverted ${s ? `with reason: ${s}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n;
  }
}
Object.defineProperty(Gl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32521
});
Object.defineProperty(Gl, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Bg extends H {
  constructor({ cause: e }) {
    super("Failed to send funds to beneficiary.", {
      cause: e,
      name: "FailedToSendToBeneficiaryError"
    });
  }
}
Object.defineProperty(Bg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa91/
});
class Pg extends H {
  constructor({ cause: e }) {
    super("Gas value overflowed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- one of the gas values exceeded 2**120 (uint120)"
      ].filter(Boolean),
      name: "GasValuesOverflowError"
    });
  }
}
Object.defineProperty(Pg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa94/
});
class Ug extends H {
  constructor({ cause: e }) {
    super("The `handleOps` function was called by the Bundler with a gas limit too low.", {
      cause: e,
      name: "HandleOpsOutOfGasError"
    });
  }
}
Object.defineProperty(Ug, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa95/
});
class Ng extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Failed to simulate deployment for Smart Account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- Invalid `factory`/`factoryData` or `initCode` properties are present",
        "- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)",
        `- Smart Account deployment execution reverted with an error
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeFailedError"
    });
  }
}
Object.defineProperty(Ng, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa13/
});
class Rg extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account initialization implementation did not create an account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- `factory`/`factoryData` or `initCode` properties are invalid",
        `- Smart Account initialization implementation is incorrect
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeMustCreateSenderError"
    });
  }
}
Object.defineProperty(Rg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa15/
});
class Dg extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s, sender: a }) {
    super("Smart Account initialization implementation does not return the expected sender.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        `Smart Account initialization implementation does not return a sender address
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`,
        a && `sender: ${a}`
      ].filter(Boolean),
      name: "InitCodeMustReturnSenderError"
    });
  }
}
Object.defineProperty(Dg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa14/
});
class Fg extends H {
  constructor({ cause: e }) {
    super("Smart Account does not have sufficient funds to execute the User Operation.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Smart Account does not have sufficient funds to cover the required prefund, or",
        "- a Paymaster was not provided"
      ].filter(Boolean),
      name: "InsufficientPrefundError"
    });
  }
}
Object.defineProperty(Fg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa21/
});
class Mg extends H {
  constructor({ cause: e }) {
    super("Bundler attempted to call an invalid function on the EntryPoint.", {
      cause: e,
      name: "InternalCallOnlyError"
    });
  }
}
Object.defineProperty(Mg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa92/
});
class Lg extends H {
  constructor({ cause: e }) {
    super("Bundler used an invalid aggregator for handling aggregated User Operations.", {
      cause: e,
      name: "InvalidAggregatorError"
    });
  }
}
Object.defineProperty(Lg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa96/
});
class Hg extends H {
  constructor({ cause: e, nonce: n }) {
    super("Invalid Smart Account nonce used for User Operation.", {
      cause: e,
      metaMessages: [n && `nonce: ${n}`].filter(Boolean),
      name: "InvalidAccountNonceError"
    });
  }
}
Object.defineProperty(Hg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa25/
});
class _g extends H {
  constructor({ cause: e }) {
    super("Bundler has not set a beneficiary address.", {
      cause: e,
      name: "InvalidBeneficiaryError"
    });
  }
}
Object.defineProperty(_g, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa90/
});
class mh extends H {
  constructor({ cause: e }) {
    super("Invalid fields set on User Operation.", {
      cause: e,
      name: "InvalidFieldsError"
    });
  }
}
Object.defineProperty(mh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class $g extends H {
  constructor({ cause: e, paymasterAndData: n }) {
    super("Paymaster properties provided are invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `paymasterAndData` property is of an incorrect length\n",
        n && `paymasterAndData: ${n}`
      ].filter(Boolean),
      name: "InvalidPaymasterAndDataError"
    });
  }
}
Object.defineProperty($g, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa93/
});
class Oi extends H {
  constructor({ cause: e }) {
    super("Paymaster deposit for the User Operation is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Paymaster has deposited less than the expected amount via the `deposit` function"
      ].filter(Boolean),
      name: "PaymasterDepositTooLowError"
    });
  }
}
Object.defineProperty(Oi, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32508
});
Object.defineProperty(Oi, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa31/
});
class Gg extends H {
  constructor({ cause: e }) {
    super("The `validatePaymasterUserOp` function on the Paymaster reverted.", {
      cause: e,
      name: "PaymasterFunctionRevertedError"
    });
  }
}
Object.defineProperty(Gg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa33/
});
class zg extends H {
  constructor({ cause: e }) {
    super("The Paymaster contract has not been deployed.", {
      cause: e,
      name: "PaymasterNotDeployedError"
    });
  }
}
Object.defineProperty(zg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa30/
});
class yh extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterRateLimitError"
    });
  }
}
Object.defineProperty(yh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32504
});
class bh extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterStakeTooLowError"
    });
  }
}
Object.defineProperty(bh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32505
});
class jg extends H {
  constructor({ cause: e }) {
    super("Paymaster `postOp` function reverted.", {
      cause: e,
      name: "PaymasterPostOpFunctionRevertedError"
    });
  }
}
Object.defineProperty(jg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa50/
});
class Vg extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account has already been deployed.", {
      cause: e,
      metaMessages: [
        "Remove the following properties and try again:",
        n && "`factory`",
        r && "`factoryData`",
        s && "`initCode`"
      ].filter(Boolean),
      name: "SenderAlreadyConstructedError"
    });
  }
}
Object.defineProperty(Vg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa10/
});
class gh extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).", {
      cause: e,
      name: "SignatureCheckFailedError"
    });
  }
}
Object.defineProperty(gh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32507
});
class qg extends H {
  constructor({ cause: e }) {
    super("The `validateUserOp` function on the Smart Account reverted.", {
      cause: e,
      name: "SmartAccountFunctionRevertedError"
    });
  }
}
Object.defineProperty(qg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa23/
});
class wh extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because account specified unsupported signature aggregator.", {
      cause: e,
      name: "UnsupportedSignatureAggregatorError"
    });
  }
}
Object.defineProperty(wh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32506
});
class Kg extends H {
  constructor({ cause: e }) {
    super("User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied"
      ].filter(Boolean),
      name: "UserOperationExpiredError"
    });
  }
}
Object.defineProperty(Kg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa22/
});
class Wg extends H {
  constructor({ cause: e }) {
    super("Paymaster for User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied"
      ].filter(Boolean),
      name: "UserOperationPaymasterExpiredError"
    });
  }
}
Object.defineProperty(Wg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa32/
});
class Qg extends H {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account"
      ].filter(Boolean),
      name: "UserOperationSignatureError"
    });
  }
}
Object.defineProperty(Qg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa24/
});
class Jg extends H {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster"
      ].filter(Boolean),
      name: "UserOperationPaymasterSignatureError"
    });
  }
}
Object.defineProperty(Jg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa34/
});
class Eh extends H {
  constructor({ cause: e }) {
    super("User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.", {
      cause: e,
      name: "UserOperationRejectedByEntryPointError"
    });
  }
}
Object.defineProperty(Eh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32500
});
class xh extends H {
  constructor({ cause: e }) {
    super("User Operation rejected by Paymaster's `validatePaymasterUserOp`.", {
      cause: e,
      name: "UserOperationRejectedByPaymasterError"
    });
  }
}
Object.defineProperty(xh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32501
});
class Ah extends H {
  constructor({ cause: e }) {
    super("User Operation rejected with op code validation error.", {
      cause: e,
      name: "UserOperationRejectedByOpCodeError"
    });
  }
}
Object.defineProperty(Ah, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32502
});
class kh extends H {
  constructor({ cause: e }) {
    super("UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).", {
      cause: e,
      name: "UserOperationOutOfTimeRangeError"
    });
  }
}
Object.defineProperty(kh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32503
});
class CX extends H {
  constructor({ cause: e }) {
    super(`An error occurred while executing user operation: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownBundlerError"
    });
  }
}
class Xg extends H {
  constructor({ cause: e }) {
    super("User Operation verification gas limit exceeded.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the gas used for verification exceeded the `verificationGasLimit`"
      ].filter(Boolean),
      name: "VerificationGasLimitExceededError"
    });
  }
}
Object.defineProperty(Xg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa40/
});
class Zg extends H {
  constructor({ cause: e }) {
    super("User Operation verification gas limit is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `verificationGasLimit` is too low to verify the User Operation"
      ].filter(Boolean),
      name: "VerificationGasLimitTooLowError"
    });
  }
}
Object.defineProperty(Zg, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa41/
});
class TX extends H {
  constructor(e, { callData: n, callGasLimit: r, docsPath: s, factory: a, factoryData: i, initCode: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymaster: d, paymasterAndData: p, paymasterData: f, paymasterPostOpGasLimit: b, paymasterVerificationGasLimit: y, preVerificationGas: g, sender: w, signature: k, verificationGasLimit: E }) {
    const T = nm({
      callData: n,
      callGasLimit: r,
      factory: a,
      factoryData: i,
      initCode: o,
      maxFeePerGas: typeof c < "u" && `${Hs(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Hs(u)} gwei`,
      nonce: l,
      paymaster: d,
      paymasterAndData: p,
      paymasterData: f,
      paymasterPostOpGasLimit: b,
      paymasterVerificationGasLimit: y,
      preVerificationGas: g,
      sender: w,
      signature: k,
      verificationGasLimit: E
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        T
      ].filter(Boolean),
      name: "UserOperationExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class SX extends H {
  constructor({ hash: e }) {
    super(`User Operation receipt with hash "${e}" could not be found. The User Operation may not have been processed yet.`, { name: "UserOperationReceiptNotFoundError" });
  }
}
class IX extends H {
  constructor({ hash: e }) {
    super(`User Operation with hash "${e}" could not be found.`, {
      name: "UserOperationNotFoundError"
    });
  }
}
class AA extends H {
  constructor({ hash: e }) {
    super(`Timed out while waiting for User Operation with hash "${e}" to be confirmed.`, { name: "WaitForUserOperationReceiptTimeoutError" });
  }
}
const OX = [
  Gl,
  mh,
  Oi,
  yh,
  bh,
  gh,
  wh,
  kh,
  Eh,
  xh,
  Ah
];
function BX(t, e) {
  const n = (t.details || "").toLowerCase();
  if (Og.message.test(n))
    return new Og({
      cause: t
    });
  if (Bg.message.test(n))
    return new Bg({
      cause: t
    });
  if (Pg.message.test(n))
    return new Pg({
      cause: t
    });
  if (Ug.message.test(n))
    return new Ug({
      cause: t
    });
  if (Ng.message.test(n))
    return new Ng({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Rg.message.test(n))
    return new Rg({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Dg.message.test(n))
    return new Dg({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode,
      sender: e.sender
    });
  if (Fg.message.test(n))
    return new Fg({
      cause: t
    });
  if (Mg.message.test(n))
    return new Mg({
      cause: t
    });
  if (Hg.message.test(n))
    return new Hg({
      cause: t,
      nonce: e.nonce
    });
  if (Lg.message.test(n))
    return new Lg({
      cause: t
    });
  if (_g.message.test(n))
    return new _g({
      cause: t
    });
  if ($g.message.test(n))
    return new $g({
      cause: t
    });
  if (Oi.message.test(n))
    return new Oi({
      cause: t
    });
  if (Gg.message.test(n))
    return new Gg({
      cause: t
    });
  if (zg.message.test(n))
    return new zg({
      cause: t
    });
  if (jg.message.test(n))
    return new jg({
      cause: t
    });
  if (qg.message.test(n))
    return new qg({
      cause: t
    });
  if (Vg.message.test(n))
    return new Vg({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Kg.message.test(n))
    return new Kg({
      cause: t
    });
  if (Wg.message.test(n))
    return new Wg({
      cause: t
    });
  if (Jg.message.test(n))
    return new Jg({
      cause: t
    });
  if (Qg.message.test(n))
    return new Qg({
      cause: t
    });
  if (Xg.message.test(n))
    return new Xg({
      cause: t
    });
  if (Zg.message.test(n))
    return new Zg({
      cause: t
    });
  const r = t.walk((s) => OX.some((a) => a.code === s.code));
  if (r) {
    if (r.code === Gl.code)
      return new Gl({
        cause: t,
        data: r.data,
        message: r.details
      });
    if (r.code === mh.code)
      return new mh({
        cause: t
      });
    if (r.code === Oi.code)
      return new Oi({
        cause: t
      });
    if (r.code === yh.code)
      return new yh({
        cause: t
      });
    if (r.code === bh.code)
      return new bh({
        cause: t
      });
    if (r.code === gh.code)
      return new gh({
        cause: t
      });
    if (r.code === wh.code)
      return new wh({
        cause: t
      });
    if (r.code === kh.code)
      return new kh({
        cause: t
      });
    if (r.code === Eh.code)
      return new Eh({
        cause: t
      });
    if (r.code === xh.code)
      return new xh({
        cause: t
      });
    if (r.code === Ah.code)
      return new Ah({
        cause: t
      });
  }
  return new CX({
    cause: t
  });
}
function VT(t, { calls: e, docsPath: n, ...r }) {
  const s = (() => {
    const a = BX(t, r);
    if (e && a instanceof Gl) {
      const i = PX(a), o = e == null ? void 0 : e.filter((c) => c.abi);
      if (i && o.length > 0)
        return UX({ calls: o, revertData: i });
    }
    return a;
  })();
  return new TX(s, {
    docsPath: n,
    ...r
  });
}
function PX(t) {
  let e;
  return t.walk((n) => {
    var s, a, i, o;
    const r = n;
    if (typeof r.data == "string" || typeof ((s = r.data) == null ? void 0 : s.revertData) == "string" || !(r instanceof H) && typeof r.message == "string") {
      const c = (o = (i = ((a = r.data) == null ? void 0 : a.revertData) || r.data || r.message).match) == null ? void 0 : o.call(i, /(0x[A-Za-z0-9]*)/);
      if (c)
        return e = c[1], !0;
    }
    return !1;
  }), e;
}
function UX(t) {
  const { calls: e, revertData: n } = t, { abi: r, functionName: s, args: a, to: i } = (() => {
    const c = e == null ? void 0 : e.filter((l) => !!l.abi);
    if (c.length === 1)
      return c[0];
    const u = c.filter((l) => {
      try {
        return !!x3({
          abi: l.abi,
          data: n
        });
      } catch {
        return !1;
      }
    });
    return u.length === 1 ? u[0] : {
      abi: [],
      functionName: c.reduce((l, d) => `${l ? `${l} | ` : ""}${d.functionName}`, ""),
      args: void 0,
      to: void 0
    };
  })(), o = n === "0x" ? new S3({ functionName: s }) : new T3({
    abi: r,
    data: n,
    functionName: s
  });
  return new C3(o, {
    abi: r,
    args: a,
    contractAddress: i,
    functionName: s
  });
}
function NX(t) {
  const e = {};
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), e;
}
function vm(t) {
  const e = {};
  return typeof t.callData < "u" && (e.callData = t.callData), typeof t.callGasLimit < "u" && (e.callGasLimit = J(t.callGasLimit)), typeof t.factory < "u" && (e.factory = t.factory), typeof t.factoryData < "u" && (e.factoryData = t.factoryData), typeof t.initCode < "u" && (e.initCode = t.initCode), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = J(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = J(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = J(t.nonce)), typeof t.paymaster < "u" && (e.paymaster = t.paymaster), typeof t.paymasterAndData < "u" && (e.paymasterAndData = t.paymasterAndData || "0x"), typeof t.paymasterData < "u" && (e.paymasterData = t.paymasterData), typeof t.paymasterPostOpGasLimit < "u" && (e.paymasterPostOpGasLimit = J(t.paymasterPostOpGasLimit)), typeof t.paymasterVerificationGasLimit < "u" && (e.paymasterVerificationGasLimit = J(t.paymasterVerificationGasLimit)), typeof t.preVerificationGas < "u" && (e.preVerificationGas = J(t.preVerificationGas)), typeof t.sender < "u" && (e.sender = t.sender), typeof t.signature < "u" && (e.signature = t.signature), typeof t.verificationGasLimit < "u" && (e.verificationGasLimit = J(t.verificationGasLimit)), typeof t.authorization < "u" && (e.eip7702Auth = RX(t.authorization)), e;
}
function RX(t) {
  return {
    address: t.address,
    chainId: J(t.chainId),
    nonce: J(t.nonce),
    r: t.r ? J(BigInt(t.r), { size: 32 }) : zt("0x", { size: 32 }),
    s: t.s ? J(BigInt(t.s), { size: 32 }) : zt("0x", { size: 32 }),
    yParity: t.yParity ? J(t.yParity, { size: 1 }) : zt("0x", { size: 32 })
  };
}
async function Cm(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return ni(e);
}
class DX extends H {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class qT extends H {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class FX extends H {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = "Block";
    e && (r = `Block at hash "${e}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
async function Yg(t, { blockHash: e, blockNumber: n, blockTag: r = t.experimental_blockTag ?? "latest", includeTransactions: s } = {}) {
  var u, l, d;
  const a = s ?? !1, i = n !== void 0 ? J(n) : void 0;
  let o = null;
  if (e ? o = await t.request({
    method: "eth_getBlockByHash",
    params: [e, a]
  }, { dedupe: !0 }) : o = await t.request({
    method: "eth_getBlockByNumber",
    params: [i || r, a]
  }, { dedupe: !!i }), !o)
    throw new FX({ blockHash: e, blockNumber: n });
  return (((d = (l = (u = t.chain) == null ? void 0 : u.formatters) == null ? void 0 : l.block) == null ? void 0 : d.format) || wv)(o);
}
async function KT(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function MX(t, e) {
  var a, i;
  const { block: n, chain: r = t.chain, request: s } = e || {};
  try {
    const o = ((a = r == null ? void 0 : r.fees) == null ? void 0 : a.maxPriorityFeePerGas) ?? ((i = r == null ? void 0 : r.fees) == null ? void 0 : i.defaultPriorityFee);
    if (typeof o == "function") {
      const u = n || await at(t, Yg, "getBlock")({}), l = await o({
        block: u,
        client: t,
        request: s
      });
      if (l === null)
        throw new Error();
      return l;
    }
    if (typeof o < "u")
      return o;
    const c = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Fe(c);
  } catch {
    const [o, c] = await Promise.all([
      n ? Promise.resolve(n) : at(t, Yg, "getBlock")({}),
      at(t, KT, "getGasPrice")({})
    ]);
    if (typeof o.baseFeePerGas != "bigint")
      throw new qT();
    const u = c - o.baseFeePerGas;
    return u < 0n ? 0n : u;
  }
}
async function LX(t, e) {
  return HX(t, e);
}
async function HX(t, e) {
  var p, f;
  const { block: n, chain: r = t.chain, request: s, type: a = "eip1559" } = e || {}, i = await (async () => {
    var b, y;
    return typeof ((b = r == null ? void 0 : r.fees) == null ? void 0 : b.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: t,
      request: s
    }) : ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.baseFeeMultiplier) ?? 1.2;
  })();
  if (i < 1)
    throw new DX();
  const c = 10 ** (((p = i.toString().split(".")[1]) == null ? void 0 : p.length) ?? 0), u = (b) => b * BigInt(Math.ceil(i * c)) / BigInt(c), l = n || await at(t, Yg, "getBlock")({});
  if (typeof ((f = r == null ? void 0 : r.fees) == null ? void 0 : f.estimateFeesPerGas) == "function") {
    const b = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: u,
      request: s,
      type: a
    });
    if (b !== null)
      return b;
  }
  if (a === "eip1559") {
    if (typeof l.baseFeePerGas != "bigint")
      throw new qT();
    const b = typeof (s == null ? void 0 : s.maxPriorityFeePerGas) == "bigint" ? s.maxPriorityFeePerGas : await MX(t, {
      block: l,
      chain: r,
      request: s
    }), y = u(l.baseFeePerGas);
    return {
      maxFeePerGas: (s == null ? void 0 : s.maxFeePerGas) ?? y + b,
      maxPriorityFeePerGas: b
    };
  }
  return {
    gasPrice: (s == null ? void 0 : s.gasPrice) ?? u(await at(t, KT, "getGasPrice")({}))
  };
}
const X0 = /* @__PURE__ */ new Map(), kA = /* @__PURE__ */ new Map();
let _X = 0;
function $X(t, e, n) {
  const r = ++_X, s = () => X0.get(t) || [], a = () => {
    const l = s();
    X0.set(t, l.filter((d) => d.id !== r));
  }, i = () => {
    const l = s();
    if (!l.some((p) => p.id === r))
      return;
    const d = kA.get(t);
    if (l.length === 1 && d) {
      const p = d();
      p instanceof Promise && p.catch(() => {
      });
    }
    a();
  }, o = s();
  if (X0.set(t, [
    ...o,
    { id: r, fns: e }
  ]), o && o.length > 0)
    return i;
  const c = {};
  for (const l in e)
    c[l] = (...d) => {
      var f, b;
      const p = s();
      if (p.length !== 0)
        for (const y of p)
          (b = (f = y.fns)[l]) == null || b.call(f, ...d);
    };
  const u = n(c);
  return typeof u == "function" && kA.set(t, u), i;
}
function GX(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let s = !0;
  const a = () => s = !1;
  return (async () => {
    let o;
    o = await t({ unpoll: a });
    const c = await (n == null ? void 0 : n(o)) ?? r;
    await xA(c);
    const u = async () => {
      s && (await t({ unpoll: a }), await xA(r), u());
    };
    u();
  })(), a;
}
async function zX(t, e) {
  var c;
  const { account: n = t.account, chainId: r, nonce: s } = e;
  if (!n)
    throw new Go({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const a = ir(n), i = (() => {
    if (e.executor)
      return e.executor === "self" ? e.executor : ir(e.executor);
  })(), o = {
    address: e.contractAddress ?? e.address,
    chainId: r,
    nonce: s
  };
  return typeof o.chainId > "u" && (o.chainId = ((c = t.chain) == null ? void 0 : c.id) ?? await at(t, Cm, "getChainId")({})), typeof o.nonce > "u" && (o.nonce = await at(t, AJ, "getTransactionCount")({
    address: a.address,
    blockTag: "pending"
  }), (i === "self" || i != null && i.address && yX(i.address, a.address)) && (o.nonce += 1)), o;
}
async function WT(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = vm(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      J(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Fe(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Fe(c)
    }
  };
}
async function QT(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = vm(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterStubData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      J(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Fe(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Fe(c)
    }
  };
}
const jX = [
  "factory",
  "fees",
  "gas",
  "paymaster",
  "nonce",
  "signature",
  "authorization"
];
async function Ec(t, e) {
  var N;
  const n = e, { account: r = t.account, parameters: s = jX, stateOverride: a } = n;
  if (!r)
    throw new Go();
  const i = ir(r), o = t, c = n.paymaster ?? (o == null ? void 0 : o.paymaster), u = typeof c == "string" ? c : void 0, { getPaymasterStubData: l, getPaymasterData: d } = (() => {
    if (c === !0)
      return {
        getPaymasterStubData: (D) => at(o, QT, "getPaymasterStubData")(D),
        getPaymasterData: (D) => at(o, WT, "getPaymasterData")(D)
      };
    if (typeof c == "object") {
      const { getPaymasterStubData: D, getPaymasterData: P } = c;
      return {
        getPaymasterStubData: P && D ? D : P,
        getPaymasterData: P && D ? P : void 0
      };
    }
    return {
      getPaymasterStubData: void 0,
      getPaymasterData: void 0
    };
  })(), p = n.paymasterContext ? n.paymasterContext : o == null ? void 0 : o.paymasterContext;
  let f = {
    ...n,
    paymaster: u,
    sender: i.address
  };
  const [b, y, g, w, k] = await Promise.all([
    (async () => n.calls ? i.encodeCalls(n.calls.map((D) => {
      const P = D;
      return P.abi ? {
        data: Gw(P),
        to: P.to,
        value: P.value
      } : P;
    })) : n.callData)(),
    (async () => {
      if (!s.includes("factory"))
        return;
      if (n.initCode)
        return { initCode: n.initCode };
      if (n.factory && n.factoryData)
        return {
          factory: n.factory,
          factoryData: n.factoryData
        };
      const { factory: D, factoryData: P } = await i.getFactoryArgs();
      return i.entryPoint.version === "0.6" ? {
        initCode: D && P ? Tn([D, P]) : void 0
      } : {
        factory: D,
        factoryData: P
      };
    })(),
    (async () => {
      var D;
      if (s.includes("fees")) {
        if (typeof n.maxFeePerGas == "bigint" && typeof n.maxPriorityFeePerGas == "bigint")
          return f;
        if ((D = o == null ? void 0 : o.userOperation) != null && D.estimateFeesPerGas) {
          const P = await o.userOperation.estimateFeesPerGas({
            account: i,
            bundlerClient: o,
            userOperation: f
          });
          return {
            ...f,
            ...P
          };
        }
        try {
          const P = o.client ?? t, C = await at(P, LX, "estimateFeesPerGas")({
            chain: P.chain,
            type: "eip1559"
          });
          return {
            maxFeePerGas: typeof n.maxFeePerGas == "bigint" ? n.maxFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxFeePerGas
            ),
            maxPriorityFeePerGas: typeof n.maxPriorityFeePerGas == "bigint" ? n.maxPriorityFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxPriorityFeePerGas
            )
          };
        } catch {
          return;
        }
      }
    })(),
    (async () => {
      if (s.includes("nonce"))
        return typeof n.nonce == "bigint" ? n.nonce : i.getNonce();
    })(),
    (async () => {
      if (s.includes("authorization")) {
        if (typeof n.authorization == "object")
          return n.authorization;
        if (i.authorization && !await i.isDeployed())
          return {
            ...await zX(i.client, i.authorization),
            r: "0xfffffffffffffffffffffffffffffff000000000000000000000000000000000",
            s: "0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            yParity: 1
          };
      }
    })()
  ]);
  typeof b < "u" && (f.callData = b), typeof y < "u" && (f = { ...f, ...y }), typeof g < "u" && (f = { ...f, ...g }), typeof w < "u" && (f.nonce = w), typeof k < "u" && (f.authorization = k), s.includes("signature") && (typeof n.signature < "u" ? f.signature = n.signature : f.signature = await i.getStubSignature(f)), i.entryPoint.version === "0.6" && !f.initCode && (f.initCode = "0x");
  let E;
  async function T() {
    return E || (t.chain ? t.chain.id : (E = await at(t, Cm, "getChainId")({}), E));
  }
  let A = !1;
  if (s.includes("paymaster") && l && !u && !n.paymasterAndData) {
    const { isFinal: D = !1, sponsor: P, ...C } = await l({
      chainId: await T(),
      entryPointAddress: i.entryPoint.address,
      context: p,
      ...f
    });
    A = D, f = {
      ...f,
      ...C
    };
  }
  if (i.entryPoint.version === "0.6" && !f.paymasterAndData && (f.paymasterAndData = "0x"), s.includes("gas")) {
    if ((N = i.userOperation) != null && N.estimateGas) {
      const D = await i.userOperation.estimateGas(f);
      f = {
        ...f,
        ...D
      };
    }
    if (typeof f.callGasLimit > "u" || typeof f.preVerificationGas > "u" || typeof f.verificationGasLimit > "u" || f.paymaster && typeof f.paymasterPostOpGasLimit > "u" || f.paymaster && typeof f.paymasterVerificationGasLimit > "u") {
      const D = await at(o, JT, "estimateUserOperationGas")({
        account: i,
        // Some Bundlers fail if nullish gas values are provided for gas estimation :') 
        // so we will need to set a default zeroish value.
        callGasLimit: 0n,
        preVerificationGas: 0n,
        verificationGasLimit: 0n,
        stateOverride: a,
        ...f.paymaster ? {
          paymasterPostOpGasLimit: 0n,
          paymasterVerificationGasLimit: 0n
        } : {},
        ...f
      });
      f = {
        ...f,
        callGasLimit: f.callGasLimit ?? D.callGasLimit,
        preVerificationGas: f.preVerificationGas ?? D.preVerificationGas,
        verificationGasLimit: f.verificationGasLimit ?? D.verificationGasLimit,
        paymasterPostOpGasLimit: f.paymasterPostOpGasLimit ?? D.paymasterPostOpGasLimit,
        paymasterVerificationGasLimit: f.paymasterVerificationGasLimit ?? D.paymasterVerificationGasLimit
      };
    }
  }
  if (s.includes("paymaster") && d && !u && !n.paymasterAndData && !A) {
    const D = await d({
      chainId: await T(),
      entryPointAddress: i.entryPoint.address,
      context: p,
      ...f
    });
    f = {
      ...f,
      ...D
    };
  }
  return delete f.calls, delete f.parameters, delete f.paymasterContext, typeof f.paymaster != "string" && delete f.paymaster, f;
}
async function JT(t, e) {
  var c;
  const { account: n = t.account, entryPointAddress: r, stateOverride: s } = e;
  if (!n && !e.sender)
    throw new Go();
  const a = n ? ir(n) : void 0, i = _T(s), o = a ? await at(t, Ec, "prepareUserOperation")({
    ...e,
    parameters: [
      "authorization",
      "factory",
      "nonce",
      "paymaster",
      "signature"
    ]
  }) : e;
  try {
    const u = [
      vm(o),
      r ?? ((c = a == null ? void 0 : a.entryPoint) == null ? void 0 : c.address)
    ], l = await t.request({
      method: "eth_estimateUserOperationGas",
      params: i ? [...u, i] : [...u]
    });
    return NX(l);
  } catch (u) {
    const l = e.calls;
    throw VT(u, {
      ...o,
      ...l ? { calls: l } : {}
    });
  }
}
function VX(t) {
  return t.request({ method: "eth_supportedEntryPoints" });
}
function qX(t) {
  const e = { ...t };
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.maxFeePerGas && (e.maxFeePerGas = BigInt(t.maxFeePerGas)), t.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = BigInt(t.maxPriorityFeePerGas)), t.nonce && (e.nonce = BigInt(t.nonce)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), e;
}
async function KX(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationByHash",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new IX({ hash: e });
  const { blockHash: r, blockNumber: s, entryPoint: a, transactionHash: i, userOperation: o } = n;
  return {
    blockHash: r,
    blockNumber: BigInt(s),
    entryPoint: a,
    transactionHash: i,
    userOperation: qX(o)
  };
}
function WX(t) {
  const e = { ...t };
  return t.actualGasCost && (e.actualGasCost = BigInt(t.actualGasCost)), t.actualGasUsed && (e.actualGasUsed = BigInt(t.actualGasUsed)), t.logs && (e.logs = t.logs.map((n) => Q1(n))), t.receipt && (e.receipt = Ev(e.receipt)), e;
}
async function XT(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationReceipt",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new SX({ hash: e });
  return WX(n);
}
async function QX(t, e) {
  var c, u;
  const { account: n = t.account, entryPointAddress: r } = e;
  if (!n && !e.sender)
    throw new Go();
  const s = n ? ir(n) : void 0, a = s ? await at(t, Ec, "prepareUserOperation")(e) : e, i = e.signature || await ((c = s == null ? void 0 : s.signUserOperation) == null ? void 0 : c.call(s, a)), o = vm({
    ...a,
    signature: i
  });
  try {
    return await t.request({
      method: "eth_sendUserOperation",
      params: [
        o,
        r ?? ((u = s == null ? void 0 : s.entryPoint) == null ? void 0 : u.address)
      ]
    }, { retryCount: 0 });
  } catch (l) {
    const d = e.calls;
    throw VT(l, {
      ...a,
      ...d ? { calls: d } : {},
      signature: i
    });
  }
}
function JX(t, e) {
  const { hash: n, pollingInterval: r = t.pollingInterval, retryCount: s, timeout: a = 12e4 } = e;
  let i = 0;
  const o = Zl([
    "waitForUserOperationReceipt",
    t.uid,
    n
  ]);
  return new Promise((c, u) => {
    const l = $X(o, { resolve: c, reject: u }, (d) => {
      const p = (b) => {
        f(), b(), l();
      }, f = GX(async () => {
        s && i >= s && p(() => d.reject(new AA({ hash: n })));
        try {
          const b = await at(t, XT, "getUserOperationReceipt")({ hash: n });
          p(() => d.resolve(b));
        } catch (b) {
          const y = b;
          y.name !== "UserOperationReceiptNotFoundError" && p(() => d.reject(y));
        }
        i++;
      }, {
        emitOnBegin: !0,
        interval: r
      });
      return a && setTimeout(() => p(() => d.reject(new AA({ hash: n }))), a), f;
    });
  });
}
function XX(t) {
  return {
    estimateUserOperationGas: (e) => JT(t, e),
    getChainId: () => Cm(t),
    getSupportedEntryPoints: () => VX(t),
    getUserOperation: (e) => KX(t, e),
    getUserOperationReceipt: (e) => XT(t, e),
    prepareUserOperation: (e) => Ec(t, e),
    sendUserOperation: (e) => QX(t, e),
    waitForUserOperationReceipt: (e) => JX(t, e)
  };
}
function ZX(t) {
  return {
    getPaymasterData: (e) => WT(t, e),
    getPaymasterStubData: (e) => QT(t, e)
  };
}
const e1 = 256;
let fp = e1, pp;
function YX(t = 11) {
  if (!pp || fp + t > e1 * 2) {
    pp = "", fp = 0;
    for (let e = 0; e < e1; e++)
      pp += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return pp.substring(fp, fp++ + t);
}
function ZT(t) {
  const { batch: e, chain: n, ccipRead: r, key: s = "base", name: a = "Base Client", type: i = "base" } = t, o = t.experimental_blockTag ?? (typeof (n == null ? void 0 : n.experimental_preconfirmationTime) == "number" ? "pending" : void 0), c = (n == null ? void 0 : n.blockTime) ?? 12e3, u = Math.min(Math.max(Math.floor(c / 2), 500), 4e3), l = t.pollingInterval ?? u, d = t.cacheTime ?? l, p = t.account ? ir(t.account) : void 0, { config: f, request: b, value: y } = t.transport({
    chain: n,
    pollingInterval: l
  }), g = { ...f, ...y }, w = {
    account: p,
    batch: e,
    cacheTime: d,
    ccipRead: r,
    chain: n,
    key: s,
    name: a,
    pollingInterval: l,
    request: b,
    transport: g,
    type: i,
    uid: YX(),
    ...o ? { experimental_blockTag: o } : {}
  };
  function k(E) {
    return (T) => {
      const A = T(E);
      for (const D in w)
        delete A[D];
      const N = { ...E, ...A };
      return Object.assign(N, { extend: k(N) });
    };
  }
  return Object.assign(w, { extend: k(w) });
}
function vA(t) {
  const { client: e, key: n = "bundler", name: r = "Bundler Client", paymaster: s, paymasterContext: a, transport: i, userOperation: o } = t;
  return Object.assign(ZT({
    ...t,
    chain: t.chain ?? (e == null ? void 0 : e.chain),
    key: n,
    name: r,
    transport: i,
    type: "bundlerClient"
  }), { client: e, paymaster: s, paymasterContext: a, userOperation: o }).extend(XX);
}
function eZ(t) {
  const { key: e = "bundler", name: n = "Bundler Client", transport: r } = t;
  return ZT({
    ...t,
    key: e,
    name: n,
    transport: r,
    type: "PaymasterClient"
  }).extend(ZX);
}
const jre = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789", tZ = "0x0000000071727De22E5E9d8BAf0edAc6f37da032", nZ = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      }
    ],
    name: "executeUserOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], CA = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";
async function rZ({
  userOp: t,
  relayerPrivateKey: e,
  chain: n
}) {
  console.log("[trails-sdk] userOp", t);
  const r = Cd(e), s = Kd({
    chain: n,
    transport: Ge(),
    account: r
  }), a = hn({
    chain: n,
    transport: Ge()
  }), i = YT(t), o = await cZ({
    userOperation: i,
    entryPointAddress: CA,
    chainId: n.id
  });
  console.log("[trails-sdk] opHash", o), console.log("[trails-sdk] packedOp", i), console.log("[trails-sdk] relayerAccount", r);
  const c = lZ({
    userOps: [t],
    beneficiary: r.address
  });
  console.log("[trails-sdk] handleOpsData", c);
  const u = await s.sendTransaction({
    to: CA,
    data: c,
    value: BigInt(0),
    gasLimit: 1e6,
    chain: n
  });
  console.log("[trails-sdk] Sent handleOps tx:", u);
  const l = await a.waitForTransactionReceipt({ hash: u });
  return console.log("[trails-sdk] Confirmed handleOps tx:", l.transactionHash), l.transactionHash;
}
function sZ(t) {
  if (!t.verificationGasLimit)
    throw new Error("verificationGasLimit is required");
  if (!t.callGasLimit)
    throw new Error("callGasLimit is required");
  return Wd([
    xo(Za(t.verificationGasLimit), { size: 16 }),
    xo(Za(t.callGasLimit), { size: 16 })
  ]);
}
function aZ(t) {
  if (!t.maxPriorityFeePerGas)
    throw new Error("maxPriorityFeePerGas is required");
  if (!t.maxFeePerGas)
    throw new Error("maxFeePerGas is required");
  return Wd([
    xo(Za(t.maxPriorityFeePerGas), { size: 16 }),
    xo(Za(t.maxFeePerGas), { size: 16 })
  ]);
}
function iZ(t) {
  return t.factory ? Wd([
    t.factory === "0x7702" ? xo(t.factory, { dir: "right", size: 20 }) : t.factory,
    t.factoryData || "0x"
  ]) : "0x";
}
function oZ(t) {
  if (!t.paymaster) return "0x";
  if (!t.paymasterVerificationGasLimit)
    throw new Error("paymasterVerificationGasLimit is required");
  if (!t.paymasterPostOpGasLimit)
    throw new Error("paymasterPostOpGasLimit is required");
  return Wd([
    t.paymaster,
    xo(Za(t.paymasterVerificationGasLimit || 0n), { size: 16 }),
    xo(Za(t.paymasterPostOpGasLimit || 0n), { size: 16 }),
    t.paymasterData || "0x"
  ]);
}
function YT(t) {
  return {
    sender: t.sender,
    nonce: t.nonce,
    initCode: iZ(t),
    callData: t.callData,
    accountGasLimits: sZ(t),
    preVerificationGas: t.preVerificationGas,
    gasFees: aZ(t),
    paymasterAndData: oZ(t),
    signature: t.signature
  };
}
const cZ = ({
  userOperation: t,
  entryPointAddress: e,
  chainId: n
}) => {
  const r = ou(
    RE(
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        t.sender,
        t.nonce,
        ou(t.initCode),
        ou(t.callData),
        t.accountGasLimits,
        t.preVerificationGas,
        t.gasFees,
        ou(t.paymasterAndData)
      ]
    )
  );
  return ou(
    RE(
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [r, e, BigInt(n)]
    )
  );
}, lZ = ({
  userOps: t,
  beneficiary: e
}) => {
  const n = uZ(t);
  return console.log(
    "[trails-sdk] encodeHandleOpsCalldata packedUserOps",
    n
  ), Kt({
    abi: nZ,
    functionName: "handleOps",
    args: [n, e]
  });
}, uZ = (t) => t.map(
  (n) => YT(n)
), dZ = async (t, e = BigInt(0)) => {
  if (!t) throw new Error("Owner account not found");
  return Kt({
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          }
        ],
        name: "createAccount",
        outputs: [
          {
            internalType: "contract SimpleAccount",
            name: "ret",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    functionName: "createAccount",
    args: [t, e]
  });
}, fZ = (t) => t || "0x91E60e0613810449d098b0b5Ec8b51A0FE8c8985";
async function pZ(t) {
  const {
    client: e,
    owner: n,
    factoryAddress: r,
    index: s = BigInt(0),
    address: a,
    nonceKey: i
    // accountLogicAddress = "0xe6Cae83BdE06E4c305530e199D7217f42808555B",
  } = t, o = await gZ({ owner: n }), c = t.entryPoint ? {
    address: t.entryPoint.address,
    abi: EA,
    version: "0.7"
  } : {
    address: tZ,
    abi: EA,
    version: "0.7"
  }, u = fZ(r);
  let l;
  const d = async () => l || (l = e.chain ? e.chain.id : await at(e, Cm, "getChainId")({}), l), p = () => async () => ({
    factory: u,
    factoryData: await dZ(o.address, s)
  }), { accountAddress: f, getFactoryArgs: b } = await (async () => {
    const y = p();
    if (a)
      return { accountAddress: a, getFactoryArgs: y };
    const { factory: g, factoryData: w } = await y();
    return { accountAddress: await bZ(e, {
      factory: g,
      factoryData: w,
      entryPointAddress: c.address
    }), getFactoryArgs: y };
  })();
  return AX({
    client: e,
    entryPoint: c,
    getFactoryArgs: b,
    async getAddress() {
      return f;
    },
    async encodeCalls(y) {
      if (y.length > 1)
        return Kt({
          abi: SA,
          functionName: "executeBatch",
          args: [
            y.map((w) => w.to),
            y.map((w) => w.value ?? 0n),
            y.map((w) => w.data ?? "0x")
          ]
        });
      const g = y.length === 0 ? void 0 : y[0];
      if (!g)
        throw new Error("No calls to encode");
      return Kt({
        abi: TA,
        functionName: "execute",
        args: [g.to, g.value ?? 0n, g.data ?? "0x"]
      });
    },
    decodeCalls: async (y) => {
      try {
        const g = [], w = sy({
          abi: SA,
          data: y
        }), k = w.args[0], E = w.args[1], T = w.args[2];
        for (let A = 0; A < k.length; A++)
          g.push({
            to: k[A],
            data: T[A],
            value: E[A]
          });
        return g;
      } catch {
        const w = sy({
          abi: TA,
          data: y
        });
        return [
          {
            to: w.args[0],
            value: w.args[1],
            data: w.args[2]
          }
        ];
      }
    },
    async getNonce(y) {
      return hZ(e, {
        address: await this.getAddress(),
        entryPointAddress: c.address,
        key: i ?? (y == null ? void 0 : y.key)
      });
    },
    async getStubSignature() {
      return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    },
    async sign({ hash: y }) {
      return this.signMessage({ message: y });
    },
    signMessage: async (y) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    signTypedData: async (y) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    async signUserOperation(y) {
      const { chainId: g = await d(), ...w } = y;
      return kX(e, {
        account: o,
        message: {
          raw: EX({
            userOperation: {
              ...w,
              sender: w.sender ?? await this.getAddress(),
              signature: "0x"
            },
            entryPointAddress: c.address,
            entryPointVersion: c.version,
            chainId: g
          })
        }
      });
    }
  });
}
const TA = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dest",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "func",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], SA = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "dest",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "value",
        type: "uint256[]"
      },
      {
        internalType: "bytes[]",
        name: "func",
        type: "bytes[]"
      }
    ],
    name: "executeBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], hZ = async (t, e) => {
  const { address: n, entryPointAddress: r, key: s = BigInt(0) } = e;
  return await at(
    t,
    GT,
    "readContract"
  )({
    address: r,
    abi: [
      {
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "getNonce",
    args: [n, s]
  });
}, mZ = "0x60806040526102a28038038091610015826100ae565b6080396040816080019112610093576080516001600160a01b03811681036100935760a0516001600160401b0381116100935782609f82011215610093578060800151610061816100fc565b9361006f60405195866100d9565b81855260a082840101116100935761008e9160a0602086019101610117565b610196565b600080fd5b634e487b7160e01b600052604160045260246000fd5b6080601f91909101601f19168101906001600160401b038211908210176100d457604052565b610098565b601f909101601f19168101906001600160401b038211908210176100d457604052565b6001600160401b0381116100d457601f01601f191660200190565b60005b83811061012a5750506000910152565b818101518382015260200161011a565b6040916020825261015a8151809281602086015260208686019101610117565b601f01601f1916010190565b3d15610191573d90610177826100fc565b9161018560405193846100d9565b82523d6000602084013e565b606090565b600091908291826040516101cd816101bf6020820195639b249f6960e01b87526024830161013a565b03601f1981018352826100d9565b51925af16101d9610166565b906102485760048151116000146101f7576024015160005260206000f35b60405162461bcd60e51b8152602060048201526024808201527f67657453656e64657241646472657373206661696c656420776974686f7574206044820152636461746160e01b6064820152608490fd5b60405162461bcd60e51b815260206004820152602b60248201527f67657453656e6465724164647265737320646964206e6f74207265766572742060448201526a185cc8195e1c1958dd195960aa1b6064820152608490fdfe", yZ = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_entryPoint",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "constructor"
  }
], bZ = async (t, e) => {
  const { initCode: n, entryPointAddress: r, factory: s, factoryData: a } = e;
  if (!n && !s && !a)
    throw new Error(
      "Either `initCode` or `factory` and `factoryData` must be provided"
    );
  const i = n || Wd([s, a]), { data: o } = await at(
    t,
    $T,
    "call"
  )({
    data: JS({
      abi: yZ,
      bytecode: mZ,
      args: [r, i]
    })
  });
  if (!o)
    throw new Error("Failed to get sender address");
  return XS([{ type: "address" }], o)[0];
};
async function gZ({
  owner: t,
  address: e
}) {
  if ("type" in t && t.type === "local")
    return t;
  let n;
  if ("request" in t) {
    if (!e)
      try {
        [e] = await t.request({
          method: "eth_requestAccounts"
        });
      } catch {
        [e] = await t.request({
          method: "eth_accounts"
        });
      }
    if (!e)
      throw new Error("address is required");
    n = Kd({
      account: e,
      transport: Ou(t)
    });
  }
  return n || (n = t), wT({
    address: n.account.address,
    async signMessage({ message: r }) {
      return n.signMessage({ message: r });
    },
    async signTypedData(r) {
      return at(
        n,
        vX,
        "signTypedData"
      )(r);
    },
    async signTransaction(r) {
      throw new Error("Smart account signer doesn't need to sign transactions");
    }
  });
}
const wZ = "0x0000000071727de22e5e9d8baf0edac6f37da032";
async function EZ({
  publicClient: t
}) {
  const e = Fw(), n = Cd(e);
  console.log("[trails-sdk] Delegator account:", n.address), console.log("Creating smart account...");
  const r = await pZ({
    client: t,
    entryPoint: {
      address: wZ,
      version: "0.7"
    },
    owner: Cd(e)
  });
  return console.log(
    "[trails-sdk] Smart account address:",
    r.address
  ), console.log(
    "[trails-sdk] delegatorSmartAccount.address",
    r.address
  ), r;
}
async function xZ({
  walletClient: t,
  chain: e,
  tokenAddress: n,
  amount: r,
  recipient: s,
  delegatorSmartAccount: a
}) {
  const i = hn({
    chain: e,
    transport: Ge()
  });
  if (!t.account)
    throw new Error("No account found");
  const o = t.account.address;
  console.log("[trails-sdk] Transfer amount:", r.toString());
  const { signature: c, deadline: u } = await $w({
    publicClient: i,
    walletClient: t,
    signer: o,
    spender: a.address,
    tokenAddress: n,
    amount: r,
    chain: e
  });
  console.log("[trails-sdk] Received signature:", c);
  const l = RT({
    signer: o,
    spender: a.address,
    amount: r,
    deadline: u,
    signature: c
  }), d = DT({
    signer: o,
    spender: a.address,
    amount: r
  }), p = FT({ recipient: s, amount: r });
  return [
    { to: Ne, data: "0x", value: "0x" },
    { to: n, data: l, value: "0x" },
    { to: n, data: d, value: "0x" },
    { to: n, data: p, value: "0x" }
  ];
}
async function AZ({
  walletClient: t,
  publicClient: e,
  chain: n,
  paymasterUrl: r,
  delegatorSmartAccount: s,
  calls: a
}) {
  try {
    if (!t.account)
      throw new Error("No account found");
    console.log("[trails-sdk] Estimating gas fees...");
    const i = await e.estimateFeesPerGas(), o = ZS("1"), c = i.maxFeePerGas + o;
    if (r)
      if (r.includes("alchemy")) {
        const u = vA({
          chain: n,
          transport: Ge(r)
        });
        console.log("[trails-sdk] preparing user op");
        const l = await Ec(e, {
          account: s,
          calls: a,
          maxFeePerGas: c,
          maxPriorityFeePerGas: o,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        }), d = await s.signUserOperation(l);
        l.signature = d, console.log("[trails-sdk] Signed user operation:", d), console.log("[trails-sdk] Sending user operation...");
        const p = await u.sendUserOperation(l);
        console.log("[trails-sdk] User operation sent! Hash:", p);
        const f = await u.waitForUserOperationReceipt({
          hash: p
        });
        return console.log("[trails-sdk] User operation receipt:", f), f.receipt.transactionHash;
      } else {
        const u = eZ({
          transport: Ge(r)
        }), l = vA({
          chain: n,
          paymaster: u,
          transport: Ge(r)
        });
        console.log("[trails-sdk] preparing user op");
        let d = await Ec(e, {
          account: s,
          calls: a,
          maxFeePerGas: c,
          maxPriorityFeePerGas: o,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        });
        d = await l.prepareUserOperation({
          ...d
        }), console.log("[trails-sdk] preparedUserOp", d);
        const p = await s.signUserOperation(d);
        d.signature = p, console.log("[trails-sdk] Signed user operation:", p), console.log("[trails-sdk] Sending user operation...");
        const f = await l.sendUserOperation(d);
        console.log("[trails-sdk] User operation sent! Hash:", f);
        const b = await l.waitForUserOperationReceipt({
          hash: f
        });
        return console.log("[trails-sdk] User operation receipt:", b), b.receipt.transactionHash;
      }
    else {
      const u = "";
      console.log("[trails-sdk] preparing user op");
      const l = await Ec(e, {
        account: s,
        calls: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: o,
        callGasLimit: 500000n,
        verificationGasLimit: 500000n,
        preVerificationGas: 500000n,
        paymasterAndData: "0x"
      });
      console.log("[trails-sdk] preparedUserOp", l);
      const d = kZ(l);
      console.log("[trails-sdk] Required prefund:", d);
      const p = await e.getBalance({
        address: s.address
      });
      console.log("[trails-sdk] Balance:", p);
      const f = await s.signUserOperation(l);
      l.signature = f, console.log("[trails-sdk] Signed user operation:", f);
      const b = await rZ({
        userOp: l,
        relayerPrivateKey: u,
        chain: n
      });
      return console.log("[trails-sdk] User operation submitted! Hash:", b), b;
    }
  } catch (i) {
    throw console.error("[trails-sdk] Gasless flow error:", i), i;
  }
}
const kZ = (t) => {
  const e = t;
  return (e.verificationGasLimit + e.callGasLimit + (e.paymasterVerificationGasLimit || 0n) + (e.paymasterPostOpGasLimit || 0n) + e.preVerificationGas) * e.maxFeePerGas;
}, gs = {
  // Time configurations
  staleTime: 3e4,
  // 30 seconds - prices change frequently
  gcTime: 12e4,
  // 2 minutes cache time
  refetchInterval: 6e4,
  // Background refetch every minute for prices
  // Retry configurations
  retry: 2,
  retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
  // Refetch behaviors
  refetchOnWindowFocus: !1,
  refetchOnReconnect: !0,
  refetchIntervalInBackground: !0,
  // Retry logic for specific error types
  shouldRetry: (t, e) => e && "status" in e && e.status === 404 ? !1 : t < 2
}, hf = {
  staleTime: gs.staleTime,
  gcTime: gs.gcTime,
  retry: gs.shouldRetry,
  retryDelay: gs.retryDelay,
  refetchOnWindowFocus: gs.refetchOnWindowFocus,
  refetchOnReconnect: gs.refetchOnReconnect,
  refetchInterval: gs.refetchInterval,
  refetchIntervalInBackground: gs.refetchIntervalInBackground
}, e5 = new E1({
  defaultOptions: {
    queries: {
      ...hf,
      // Override retry for QueryClient (use number instead of function)
      retry: gs.retry
    }
  }
}), t5 = (t) => `${t.contractAddress}-${t.chainId}-${t.tokenId}`, n5 = (t) => [
  "tokenPrices",
  "batch",
  t.length,
  t.map(t5).sort()
], r5 = (t) => ["tokenPrices", "single", t ? t5(t) : null], vZ = async (t, e) => {
  if (!t)
    throw new Error("API client is required");
  if (e.length === 0)
    return [];
  try {
    const n = await t.getCoinPrices({ tokens: e });
    return (n == null ? void 0 : n.tokenPrices) || [];
  } catch (n) {
    throw console.error("[trails-sdk] Failed to fetch token prices:", n), n;
  }
};
function s5(t) {
  return {
    chainId: t.chainId,
    contractAddress: t.contractAddress || Ne,
    tokenId: t.tokenId || t.tokenID || t.symbol
  };
}
const zw = async (t, e) => (e = e.map(s5), e5.fetchQuery({
  queryKey: n5(e),
  queryFn: () => vZ(t, e),
  ...hf
})), CZ = async (t, e) => e5.fetchQuery({
  queryKey: r5(e),
  queryFn: async () => {
    const n = await zw(t, [e]);
    return n != null && n.length ? n[0] : null;
  },
  ...hf
}), TZ = (t, e) => {
  t = t.map(s5);
  const { data: n, isLoading: r } = ar({
    queryKey: n5(t),
    queryFn: () => zw(e, t),
    enabled: t.length > 0 && !!e,
    ...hf
  });
  return {
    tokenPrices: n,
    isLoadingTokenPrices: r
  };
}, SZ = (t, e) => {
  const { data: n, isLoading: r } = ar({
    queryKey: r5(t),
    queryFn: () => t && e ? CZ(e, t) : null,
    enabled: !!t && !!e,
    ...hf
  });
  return {
    tokenPrice: n,
    isLoadingTokenPrice: r
  };
};
function lc({
  amount: t,
  usdPrice: e
}) {
  return IA(t) * IA(e);
}
function IA(t) {
  return Number((t == null ? void 0 : t.toString().replace(/[^0-9.-]/g, "")) || 0);
}
function Vre(t) {
  return t >= 1e9 ? `$${(t / 1e9).toFixed(1)}B` : t >= 1e6 ? `$${(t / 1e6).toFixed(1)}M` : t >= 1e3 ? `$${(t / 1e3).toFixed(1)}K` : `$${t.toFixed(0)}`;
}
var It = typeof globalThis < "u" && globalThis || typeof self < "u" && self || // eslint-disable-next-line no-undef
typeof global < "u" && global || {}, an = {
  searchParams: "URLSearchParams" in It,
  iterable: "Symbol" in It && "iterator" in Symbol,
  blob: "FileReader" in It && "Blob" in It && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in It,
  arrayBuffer: "ArrayBuffer" in It
};
function IZ(t) {
  return t && DataView.prototype.isPrototypeOf(t);
}
if (an.arrayBuffer)
  var OZ = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], BZ = ArrayBuffer.isView || function(t) {
    return t && OZ.indexOf(Object.prototype.toString.call(t)) > -1;
  };
function ru(t) {
  if (typeof t != "string" && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t) || t === "")
    throw new TypeError('Invalid character in header field name: "' + t + '"');
  return t.toLowerCase();
}
function jw(t) {
  return typeof t != "string" && (t = String(t)), t;
}
function Vw(t) {
  var e = {
    next: function() {
      var n = t.shift();
      return { done: n === void 0, value: n };
    }
  };
  return an.iterable && (e[Symbol.iterator] = function() {
    return e;
  }), e;
}
function pt(t) {
  this.map = {}, t instanceof pt ? t.forEach(function(e, n) {
    this.append(n, e);
  }, this) : Array.isArray(t) ? t.forEach(function(e) {
    if (e.length != 2)
      throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + e.length);
    this.append(e[0], e[1]);
  }, this) : t && Object.getOwnPropertyNames(t).forEach(function(e) {
    this.append(e, t[e]);
  }, this);
}
pt.prototype.append = function(t, e) {
  t = ru(t), e = jw(e);
  var n = this.map[t];
  this.map[t] = n ? n + ", " + e : e;
};
pt.prototype.delete = function(t) {
  delete this.map[ru(t)];
};
pt.prototype.get = function(t) {
  return t = ru(t), this.has(t) ? this.map[t] : null;
};
pt.prototype.has = function(t) {
  return this.map.hasOwnProperty(ru(t));
};
pt.prototype.set = function(t, e) {
  this.map[ru(t)] = jw(e);
};
pt.prototype.forEach = function(t, e) {
  for (var n in this.map)
    this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
};
pt.prototype.keys = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push(n);
  }), Vw(t);
};
pt.prototype.values = function() {
  var t = [];
  return this.forEach(function(e) {
    t.push(e);
  }), Vw(t);
};
pt.prototype.entries = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push([n, e]);
  }), Vw(t);
};
an.iterable && (pt.prototype[Symbol.iterator] = pt.prototype.entries);
function Z0(t) {
  if (!t._noBody) {
    if (t.bodyUsed)
      return Promise.reject(new TypeError("Already read"));
    t.bodyUsed = !0;
  }
}
function a5(t) {
  return new Promise(function(e, n) {
    t.onload = function() {
      e(t.result);
    }, t.onerror = function() {
      n(t.error);
    };
  });
}
function PZ(t) {
  var e = new FileReader(), n = a5(e);
  return e.readAsArrayBuffer(t), n;
}
function UZ(t) {
  var e = new FileReader(), n = a5(e), r = /charset=([A-Za-z0-9_-]+)/.exec(t.type), s = r ? r[1] : "utf-8";
  return e.readAsText(t, s), n;
}
function NZ(t) {
  for (var e = new Uint8Array(t), n = new Array(e.length), r = 0; r < e.length; r++)
    n[r] = String.fromCharCode(e[r]);
  return n.join("");
}
function OA(t) {
  if (t.slice)
    return t.slice(0);
  var e = new Uint8Array(t.byteLength);
  return e.set(new Uint8Array(t)), e.buffer;
}
function i5() {
  return this.bodyUsed = !1, this._initBody = function(t) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = t, t ? typeof t == "string" ? this._bodyText = t : an.blob && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : an.formData && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : an.searchParams && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : an.arrayBuffer && an.blob && IZ(t) ? (this._bodyArrayBuffer = OA(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : an.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(t) || BZ(t)) ? this._bodyArrayBuffer = OA(t) : this._bodyText = t = Object.prototype.toString.call(t) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof t == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : an.searchParams && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, an.blob && (this.blob = function() {
    var t = Z0(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }), this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var t = Z0(this);
      return t || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else {
      if (an.blob)
        return this.blob().then(PZ);
      throw new Error("could not read as ArrayBuffer");
    }
  }, this.text = function() {
    var t = Z0(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return UZ(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(NZ(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, an.formData && (this.formData = function() {
    return this.text().then(FZ);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var RZ = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function DZ(t) {
  var e = t.toUpperCase();
  return RZ.indexOf(e) > -1 ? e : t;
}
function Fo(t, e) {
  if (!(this instanceof Fo))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  e = e || {};
  var n = e.body;
  if (t instanceof Fo) {
    if (t.bodyUsed)
      throw new TypeError("Already read");
    this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new pt(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, !n && t._bodyInit != null && (n = t._bodyInit, t.bodyUsed = !0);
  } else
    this.url = String(t);
  if (this.credentials = e.credentials || this.credentials || "same-origin", (e.headers || !this.headers) && (this.headers = new pt(e.headers)), this.method = DZ(e.method || this.method || "GET"), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal || function() {
    if ("AbortController" in It) {
      var a = new AbortController();
      return a.signal;
    }
  }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && n)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(n), (this.method === "GET" || this.method === "HEAD") && (e.cache === "no-store" || e.cache === "no-cache")) {
    var r = /([?&])_=[^&]*/;
    if (r.test(this.url))
      this.url = this.url.replace(r, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var s = /\?/;
      this.url += (s.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
Fo.prototype.clone = function() {
  return new Fo(this, { body: this._bodyInit });
};
function FZ(t) {
  var e = new FormData();
  return t.trim().split("&").forEach(function(n) {
    if (n) {
      var r = n.split("="), s = r.shift().replace(/\+/g, " "), a = r.join("=").replace(/\+/g, " ");
      e.append(decodeURIComponent(s), decodeURIComponent(a));
    }
  }), e;
}
function MZ(t) {
  var e = new pt(), n = t.replace(/\r?\n[\t ]+/g, " ");
  return n.split("\r").map(function(r) {
    return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r;
  }).forEach(function(r) {
    var s = r.split(":"), a = s.shift().trim();
    if (a) {
      var i = s.join(":").trim();
      try {
        e.append(a, i);
      } catch (o) {
        console.warn("Response " + o.message);
      }
    }
  }), e;
}
i5.call(Fo.prototype);
function us(t, e) {
  if (!(this instanceof us))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  if (e || (e = {}), this.type = "default", this.status = e.status === void 0 ? 200 : e.status, this.status < 200 || this.status > 599)
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  this.ok = this.status >= 200 && this.status < 300, this.statusText = e.statusText === void 0 ? "" : "" + e.statusText, this.headers = new pt(e.headers), this.url = e.url || "", this._initBody(t);
}
i5.call(us.prototype);
us.prototype.clone = function() {
  return new us(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new pt(this.headers),
    url: this.url
  });
};
us.error = function() {
  var t = new us(null, { status: 200, statusText: "" });
  return t.ok = !1, t.status = 0, t.type = "error", t;
};
var LZ = [301, 302, 303, 307, 308];
us.redirect = function(t, e) {
  if (LZ.indexOf(e) === -1)
    throw new RangeError("Invalid status code");
  return new us(null, { status: e, headers: { location: t } });
};
var gi = It.DOMException;
try {
  new gi();
} catch {
  gi = function(e, n) {
    this.message = e, this.name = n;
    var r = Error(e);
    this.stack = r.stack;
  }, gi.prototype = Object.create(Error.prototype), gi.prototype.constructor = gi;
}
function o5(t, e) {
  return new Promise(function(n, r) {
    var s = new Fo(t, e);
    if (s.signal && s.signal.aborted)
      return r(new gi("Aborted", "AbortError"));
    var a = new XMLHttpRequest();
    function i() {
      a.abort();
    }
    a.onload = function() {
      var u = {
        statusText: a.statusText,
        headers: MZ(a.getAllResponseHeaders() || "")
      };
      s.url.indexOf("file://") === 0 && (a.status < 200 || a.status > 599) ? u.status = 200 : u.status = a.status, u.url = "responseURL" in a ? a.responseURL : u.headers.get("X-Request-URL");
      var l = "response" in a ? a.response : a.responseText;
      setTimeout(function() {
        n(new us(l, u));
      }, 0);
    }, a.onerror = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, a.ontimeout = function() {
      setTimeout(function() {
        r(new TypeError("Network request timed out"));
      }, 0);
    }, a.onabort = function() {
      setTimeout(function() {
        r(new gi("Aborted", "AbortError"));
      }, 0);
    };
    function o(u) {
      try {
        return u === "" && It.location.href ? It.location.href : u;
      } catch {
        return u;
      }
    }
    if (a.open(s.method, o(s.url), !0), s.credentials === "include" ? a.withCredentials = !0 : s.credentials === "omit" && (a.withCredentials = !1), "responseType" in a && (an.blob ? a.responseType = "blob" : an.arrayBuffer && (a.responseType = "arraybuffer")), e && typeof e.headers == "object" && !(e.headers instanceof pt || It.Headers && e.headers instanceof It.Headers)) {
      var c = [];
      Object.getOwnPropertyNames(e.headers).forEach(function(u) {
        c.push(ru(u)), a.setRequestHeader(u, jw(e.headers[u]));
      }), s.headers.forEach(function(u, l) {
        c.indexOf(l) === -1 && a.setRequestHeader(l, u);
      });
    } else
      s.headers.forEach(function(u, l) {
        a.setRequestHeader(l, u);
      });
    s.signal && (s.signal.addEventListener("abort", i), a.onreadystatechange = function() {
      a.readyState === 4 && s.signal.removeEventListener("abort", i);
    }), a.send(typeof s._bodyInit > "u" ? null : s._bodyInit);
  });
}
o5.polyfill = !0;
It.fetch || (It.fetch = o5, It.Headers = pt, It.Request = Fo, It.Response = us);
var HZ = self.fetch.bind(self);
const _Z = /* @__PURE__ */ BW(HZ);
function $Z(t, e) {
  const n = new Headers(e == null ? void 0 : e.headers);
  return n.set("x-access-key", $o()), _Z(t, {
    ...e,
    headers: n
  });
}
function GZ(t) {
  if (t === 42161)
    return new iy.Standard.Rpc.RpcRelayer(
      "https://a1b4a8c5d856.ngrok.app/",
      t,
      "https://nodes.sequence.app/arbitrum"
    );
  if (t === 8453)
    return new iy.Standard.Rpc.RpcRelayer(
      "https://644a6aeb891e.ngrok.app/",
      t,
      "https://nodes.sequence.app/base"
    );
}
function c5(t = {
  env: Kl(),
  useV3Relayers: ql()
}, e) {
  var s, a;
  let n = "";
  if (t.env === "local") {
    if (e === 1)
      n = "http://0.0.0.0:9969";
    else if (e === 42161)
      n = "http://0.0.0.0:9997";
    else if (e === 10 || e === 420)
      n = "http://0.0.0.0:9998";
    else if (e === 137)
      n = "http://0.0.0.0:9999";
    else if (e === 8453)
      n = "http://0.0.0.0:9996";
    else
      return "";
    return n;
  }
  const r = t.env === "cors-anywhere" ? "http://localhost:8080/https://" : t.env === "dev" && t.useV3Relayers ? "https://v3-" : t.env === "dev" ? "https://dev-relayer.sequence.app" : "https://";
  return t.env === "dev" && t.useV3Relayers ? (e === 42161 ? n = "https://v3-arbitrum-relayer.sequence.app" : e === 8453 ? n = "https://v3-base-relayer.sequence.app" : e === 84532 ? n = "https://base-sepolia-relayer.sequence.app" : e === 10 ? n = "https://v3-optimism-relayer.sequence.app" : e === 137 ? n = "https://v3-polygon-relayer.sequence.app" : e === 1 ? n = "https://v3-mainnet-relayer.sequence.app" : e === 33139 ? n = "https://v3-apechain-relayer.sequence.app" : e === 42170 ? n = "https://v3-arbitrum-nova-relayer.sequence.app" : e === 43114 ? n = "https://v3-avalanche-relayer.sequence.app" : e === 8333 ? n = "https://v3-b3-relayer.sequence.app" : e === 81457 ? n = "https://v3-blast-relayer.sequence.app" : e === 100 ? n = "https://v3-gnosis-relayer.sequence.app" : e === 1868 ? n = "https://v3-soneium-relayer.sequence.app" : e === 660279 ? n = "https://v3-xai-relayer.sequence.app" : e === 56 ? n = "https://v3-bsc-relayer.sequence.app" : n = `${r}${(s = pe(e).name) == null ? void 0 : s.replace(" ", "-")}-relayer.sequence.app`, n) : t.env === "dev" && !t.useV3Relayers ? (e === 42161 ? n = "https://dev-arbitrum-relayer.sequence.app" : e === 8453 ? n = "https://dev-base-relayer.sequence.app" : e === 84532 ? n = "https://dev-base-sepolia-relayer.sequence.app" : e === 10 ? n = "https://dev-optimism-relayer.sequence.app" : e === 137 ? n = "https://dev-polygon-relayer.sequence.app" : e === 1 ? n = "https://dev-mainnet-relayer.sequence.app" : e === 33139 ? n = "https://dev-apechain-relayer.sequence.app" : e === 42170 ? n = "https://dev-arbitrum-nova-relayer.sequence.app" : e === 43114 ? n = "https://dev-avalanche-relayer.sequence.app" : e === 8333 ? n = "https://dev-b3-relayer.sequence.app" : e === 81457 ? n = "https://dev-blast-relayer.sequence.app" : e === 100 ? n = "https://dev-gnosis-relayer.sequence.app" : e === 1868 ? n = "https://dev-soneium-relayer.sequence.app" : e === 660279 ? n = "https://dev-xai-relayer.sequence.app" : e === 56 ? n = "https://dev-bsc-relayer.sequence.app" : n = `${r}${(a = pe(e).name) == null ? void 0 : a.replace(" ", "-")}-relayer.sequence.app`, n) : (e === 42161 ? n = `${r}arbitrum-relayer.sequence.app` : e === 10 ? n = `${r}optimism-relayer.sequence.app` : e === 137 ? n = `${r}polygon-relayer.sequence.app` : e === 8453 ? n = `${r}base-relayer.sequence.app` : e === 43114 ? n = `${r}avalanche-relayer.sequence.app` : e === 56 ? n = `${r}bsc-relayer.sequence.app` : e === 1 ? n = `${r}mainnet-relayer.sequence.app` : n = `${r}relayer.sequence.app`, n);
}
function zZ(t = {
  env: Kl(),
  useV3Relayers: ql()
}, e) {
  const n = pe(e);
  if (!n)
    throw new Error(`Chain with id ${e} not found`);
  const r = n.rpcUrls.default.http[0];
  if (!r)
    throw new Error(`No RPC URL found for chain ${e}`);
  const s = c5(t, e);
  return new iy.Standard.Rpc.RpcRelayer(
    s,
    e,
    r,
    $Z
  );
}
function jZ(t = {
  env: Kl(),
  useV3Relayers: ql()
}) {
  const e = Eo(() => /* @__PURE__ */ new Map(), []);
  return {
    relayers: e,
    getRelayer: (r) => {
      let s = e.get(r);
      return s || (s = zZ(t, r), e.set(r, s)), s;
    },
    getBackupRelayer: GZ
  };
}
const VZ = [{
  type: "function",
  name: "isValidSignature",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }, {
    type: "bytes"
  }],
  outputs: [{
    type: "bytes4"
  }],
  payable: !1,
  stateMutability: "view"
}], qZ = {
  isValidSignatureBytes32: "0x1626ba7e"
};
var KZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: VZ,
  returns: qZ
});
const WZ = [{
  type: "function",
  name: "deploy",
  constant: !1,
  inputs: [{
    type: "address"
  }, {
    type: "bytes32"
  }],
  outputs: [],
  payable: !0,
  stateMutability: "payable"
}];
var QZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: WZ
});
const JZ = [{
  type: "function",
  name: "nonce",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "readNonce",
  constant: !0,
  inputs: [{
    type: "uint256"
  }],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "updateImplementation",
  constant: !1,
  inputs: [{
    type: "address"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "selfExecute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "execute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }, {
    type: "uint256"
  }, {
    type: "bytes"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "createContract",
  inputs: [{
    type: "bytes"
  }],
  payable: !0,
  stateMutability: "payable"
}, {
  type: "function",
  name: "setExtraImageHash",
  constant: !1,
  inputs: [{
    type: "bytes32",
    name: "imageHash"
  }, {
    type: "uint256",
    name: "expiration"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}];
var XZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: JZ
});
const ZZ = [{
  type: "function",
  name: "updateImageHash",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "imageHash",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "bytes32"
  }],
  payable: !1,
  stateMutability: "view"
}];
var YZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: ZZ
});
const eY = [{
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookAlreadyExists",
  type: "error"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookDoesNotExist",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "_sender",
    type: "address"
  }, {
    internalType: "address",
    name: "_self",
    type: "address"
  }],
  name: "OnlySelfAuth",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
    indexed: !1,
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    indexed: !1,
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "DefinedHook",
  type: "event"
}, {
  stateMutability: "payable",
  type: "fallback"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "addHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155BatchReceived",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "readHook",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "removeHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  stateMutability: "payable",
  type: "receive"
}];
var tY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: eY
});
const nY = [{
  type: "function",
  name: "PROXY_getImplementation",
  inputs: [],
  outputs: [{
    name: "",
    type: "address",
    internalType: "address"
  }],
  stateMutability: "view"
}];
var rY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: nY
});
const qt = {
  erc1271: KZ,
  factory: QZ,
  mainModule: XZ,
  mainModuleUpgradable: YZ,
  moduleHooks: tY,
  walletProxyHook: rY
};
function Ut() {
  return Ut = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Ut.apply(null, arguments);
}
function mf(t) {
  return ho(["bytes", "uint256", "address", "bytes32"], ["0x1901", t.chainId, t.address, t.digest]);
}
function l5(t) {
  return t.digest !== void 0 && t.chainId !== void 0 && t.address !== void 0;
}
var sY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  subdigestOf: mf,
  isSignedPayload: l5
});
const aY = "0x1626ba7e", iY = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }, {
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}];
async function u5(t, e, n, r) {
  return await new rs(t, iY, r).isValidSignature(e, n) === aY;
}
var oY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isValidEIP1271Signature: u5
});
let Qa = /* @__PURE__ */ function(t) {
  return t[t.EIP712 = 1] = "EIP712", t[t.ETH_SIGN = 2] = "ETH_SIGN", t[t.WALLET_BYTES32 = 3] = "WALLET_BYTES32", t;
}({});
function cY(t) {
  const e = ee(t), n = e[e.length - 1];
  return n === Qa.EIP712 || n === Qa.ETH_SIGN;
}
function yf(t, e) {
  const n = ee(e), r = ee(t), s = n[n.length - 1], a = z(n.slice(0, 32)), i = z(n.slice(32, 64)), o = Number(z(n.slice(64, 65))), c = {
    r: a,
    s: i,
    v: o
  };
  if (s === Qa.EIP712)
    return My(r, c);
  if (s === Qa.ETH_SIGN)
    return My(S8(r), c);
  throw new Error(`Unsupported signature type: ${s}`);
}
function qw(t, e, n, r) {
  const s = ee(n), a = s[s.length - 1];
  if (a === Qa.EIP712 || a === Qa.ETH_SIGN)
    return t === yf(e, n);
  if (a === Qa.WALLET_BYTES32)
    return u5(t, z(e), s.slice(0, -1), r);
  throw new Error(`Unsupported signature type: ${a}`);
}
function lY(t, e) {
  const n = ee(e);
  if (n.length === 66)
    try {
      return yf(t, n);
    } catch {
    }
}
var uY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigType: Qa,
  canRecover: cY,
  recoverSigner: yf,
  isValidSignature: qw,
  tryRecoverSigner: lY
});
let bo = /* @__PURE__ */ function(t) {
  return t[t.EOASignature = 0] = "EOASignature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t;
}({});
function Kw(t) {
  return t.address !== void 0 && !d5(t);
}
function d5(t) {
  return t.signature !== void 0 && t.weight !== void 0 && t.isDynamic !== void 0;
}
function f5(t) {
  return t.threshold !== void 0 && t.signers !== void 0;
}
function p5(t) {
  const e = ee(t), n = e[0] << 8 | e[1], r = [];
  for (let s = 2; s < e.length; ) {
    const a = e[s++], i = e[s++];
    switch (a) {
      case bo.EOASignature:
        r.push({
          unrecovered: !0,
          weight: i,
          signature: z(e.slice(s, s + 66)),
          isDynamic: !1
        }), s += 66;
        break;
      case bo.Address:
        r.push({
          weight: i,
          address: de(z(e.slice(s, s + 20)))
        }), s += 20;
        break;
      case bo.DynamicSignature:
        const o = de(z(e.slice(s, s + 20)));
        s += 20;
        const c = e[s] << 8 | e[s + 1];
        s += 2, r.push({
          unrecovered: !0,
          weight: i,
          signature: z(e.slice(s, s + c)),
          address: o,
          isDynamic: !0
        }), s += c;
        break;
      default:
        throw new Error(`Unknown signature part type: ${a}`);
    }
  }
  return {
    version: 1,
    threshold: n,
    signers: r
  };
}
function Ww(t) {
  if (ko(t))
    return z(t);
  const {
    signers: e,
    threshold: n
  } = f5(t) ? t : t.config, r = e.map((s) => {
    if (Kw(s))
      return Ae(["uint8", "uint8", "address"], [bo.Address, s.weight, s.address]);
    if (s.isDynamic) {
      const a = ee(s.signature);
      return Ae(["uint8", "uint8", "address", "uint16", "bytes"], [bo.DynamicSignature, s.weight, s.address, a.length, a]);
    }
    return Ae(["uint8", "uint8", "bytes"], [bo.EOASignature, s.weight, s.signature]);
  });
  return Ae(["uint16", ...new Array(r.length).fill("bytes")], [n, ...r]);
}
async function h5(t, e, n) {
  const r = mf(e), s = await Promise.all(t.signers.map(async (a) => {
    if (Kw(a))
      return a;
    if (a.isDynamic) {
      if (!a.address) throw new Error("Dynamic signature part must have address");
      if (!qw(a.address, r, a.signature, n))
        throw new Error(`Invalid dynamic signature part ${a.address}`);
      return {
        address: a.address,
        weight: a.weight,
        signature: a.signature
      };
    } else
      return {
        address: yf(r, a.signature),
        weight: a.weight,
        signature: a.signature
      };
  }));
  return {
    version: 1,
    payload: e,
    subdigest: r,
    config: {
      version: 1,
      threshold: t.threshold,
      signers: s
    }
  };
}
function Ku(t, e, n, r) {
  if (n.length !== 0)
    throw new Error("Explicit subdigests not supported on v1");
  let s = 0n;
  const a = t.signers.map((o) => {
    if (!e.has(o.address))
      return o;
    const c = e.get(o.address), u = ee(c.signature);
    return s += BigInt(o.weight), c.isDynamic || u.length !== 66 ? Ut({}, o, {
      isDynamic: !0,
      signature: c.signature,
      address: o.address
    }) : Ut({}, o, {
      isDynamic: !1,
      signature: c.signature
    });
  });
  return {
    encoded: Ww({
      version: 1,
      threshold: t.threshold,
      signers: a
    }),
    weight: s
  };
}
const Qw = {
  decode: (t) => p5(t),
  encode: (t) => Ww(t),
  trim: async (t) => t,
  supportsNoChainId: !0,
  recover: (t, e, n) => h5(t, e, n),
  encodeSigners: (t, e, n, r) => Ku(t, e, n),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = Qw.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    throw new Error("Signature chaining not supported on v1");
  },
  hashSetImageHash: function(t) {
    throw new Error("Image hash not supported on v1");
  },
  signaturesOf(t) {
    return t.signers.filter((e) => e.signature !== void 0).map((e) => ({
      address: e.address,
      signature: e.signature
    }));
  },
  signaturesOfDecoded: function(t) {
    return t.signers.map((e) => e.signature).filter((e) => e !== void 0);
  }
};
var dY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignaturePartType: bo,
  isAddressMember: Kw,
  isUnrecoveredSignatureMember: d5,
  isUnrecoveredSignature: f5,
  decodeSignature: p5,
  encodeSignature: Ww,
  recoverSignature: h5,
  encodeSigners: Ku,
  SignatureCoder: Qw
});
const Jw = {
  isWalletConfig: (t) => t.version === 1 && t.threshold !== void 0 && t.signers !== void 0,
  imageHashOf: (t) => t.signers.reduce((e, n) => ke(Wt.defaultAbiCoder().encode(["bytes32", "uint8", "address"], [e, n.weight, n.address])), Ae(["uint256"], [t.threshold])),
  hasSubdigest: (t, e) => !1,
  isComplete: (t) => !0,
  checkpointOf: (t) => 0n,
  signersOf: (t) => t.signers.map((e) => ({
    address: e.address,
    weight: Number(e.weight)
  })),
  fromSimple: (t) => {
    if (BigInt(t.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (t.subdigests && t.subdigests.length > 0)
      throw new Error("v1 wallet config does not support subdigests");
    return {
      version: 1,
      threshold: t.threshold,
      signers: t.signers
    };
  },
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Qt([...qt.mainModule.abi, ...qt.mainModuleUpgradable.abi]), a = [];
      return (!r || r === "first") && a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImplementation"), [n.mainModuleUpgradable]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImageHash"), [Jw.imageHashOf(e)]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), {
        entrypoint: t,
        transactions: a
      };
    },
    decodeTransaction: function(t) {
      throw new Error("Function not implemented.");
    }
  },
  toJSON: function(t) {
    const e = t.signers.map((n) => ({
      weight: BigInt(n.weight).toString(),
      address: n.address
    }));
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      signers: e
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t), n = e.signers.map((r) => ({
      weight: BigInt(r.weight),
      address: r.address
    }));
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      signers: n
    };
  },
  editConfig: function(t, e) {
    var n;
    const r = t.signers.slice();
    if (e.checkpoint && BigInt(e.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (e.add)
      for (const s of e.add)
        r.find((a) => a.address === s.address) || r.push({
          weight: s.weight,
          address: s.address
        });
    if (e.remove)
      for (const s of e.remove) {
        const a = r.findIndex((i) => i.address === s);
        a >= 0 && r.splice(a, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      signers: r
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = Ku(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = t.signers;
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => Number(a) - Number(i))) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = Ku(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return Ku(t, n, []).encoded;
  }
};
var fY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigCoder: Jw
}), pY = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const m5 = 1, y5 = {
  version: m5,
  factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
  guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
  mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
  mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var wi = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: fY,
  context: pY,
  signature: dY,
  version: m5,
  DeployedWalletContext: y5
});
const Xw = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function b5(t) {
  return ke(g5(t));
}
function g5(t) {
  return Ae(["bytes32", "bytes32"], [Xw, t]);
}
function w5(t) {
  const e = ee(t);
  if (e.length === 64 && z(e.slice(0, 32)) === Xw)
    return z(e.slice(32, 64));
}
function hY(t) {
  return w5(t) !== void 0;
}
var mY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SetImageHashPrefix: Xw,
  hashSetImageHash: b5,
  messageSetImageHash: g5,
  decodeMessageSetImageHash: w5,
  isMessageSetImageHash: hY
});
let Et = /* @__PURE__ */ function(t) {
  return t[t.Legacy = 0] = "Legacy", t[t.Dynamic = 1] = "Dynamic", t[t.NoChainIdDynamic = 2] = "NoChainIdDynamic", t[t.Chained = 3] = "Chained", t;
}({}), Qe = /* @__PURE__ */ function(t) {
  return t[t.Signature = 0] = "Signature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t[t.Node = 3] = "Node", t[t.Branch = 4] = "Branch", t[t.Subdigest = 5] = "Subdigest", t[t.Nested = 6] = "Nested", t;
}({});
const vh = 66;
function Mo(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function su(t) {
  return t.tree !== void 0;
}
function bf(t) {
  return t.unrecovered && t.signature !== void 0 && t.isDynamic !== void 0;
}
function Ch(t) {
  let e = ee(t), n;
  const r = (s, a) => s ? s.right ? {
    left: s,
    right: a
  } : {
    left: s.left,
    right: a
  } : {
    left: a
  };
  for (; e.length > 0; ) {
    const s = e[0];
    switch (e = e.slice(1), s) {
      case Qe.Signature:
        {
          const a = e[0], i = z(e.slice(1, vh + 1));
          n = r(n, {
            signature: i,
            weight: a,
            unrecovered: !0,
            isDynamic: !1
          }), e = e.slice(vh + 1);
        }
        break;
      case Qe.Address:
        {
          const a = e[0], i = de(z(e.slice(1, 21)));
          n = r(n, {
            address: i,
            weight: a
          }), e = e.slice(21);
        }
        break;
      case Qe.DynamicSignature:
        {
          const a = e[0], i = de(z(e.slice(1, 21))), o = e[21] << 16 | e[22] << 8 | e[23], c = z(e.slice(24, 24 + o));
          n = r(n, {
            address: i,
            signature: c,
            weight: a,
            unrecovered: !0,
            isDynamic: !0
          }), e = e.slice(24 + o);
        }
        break;
      case Qe.Node:
        {
          const a = z(e.slice(0, 32));
          n = r(n, {
            nodeHash: a
          }), e = e.slice(32);
        }
        break;
      case Qe.Branch:
        {
          const a = e[0] << 16 | e[1] << 8 | e[2], i = Ch(e.slice(3, 3 + a));
          n = r(n, i), e = e.slice(3 + a);
        }
        break;
      case Qe.Subdigest:
        {
          const a = z(e.slice(0, 32));
          n = r(n, {
            subdigest: a
          }), e = e.slice(32);
        }
        break;
      case Qe.Nested:
        {
          const a = e[0], i = e[1] << 8 | e[2], o = e[3] << 16 | e[4] << 8 | e[5], c = Ch(e.slice(6, 6 + o));
          n = r(n, {
            weight: a,
            threshold: i,
            tree: c
          }), e = e.slice(6 + o);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${s}: ${z(e)}`);
    }
  }
  if (!n)
    throw new Error("Empty signature tree");
  return n.right ? n : n.left;
}
class E5 extends Error {
  constructor(e) {
    super(`Invalid signature leaf: ${JSON.stringify(e)}`), this.leaf = e;
  }
}
async function go(t, e, n) {
  if (Mo(t)) {
    const [r, s] = await Promise.all([go(t.left, e, n), go(t.right, e, n)]);
    return {
      left: r,
      right: s
    };
  }
  if (su(t))
    return {
      weight: t.weight,
      threshold: t.threshold,
      tree: await go(t.tree, e, n)
    };
  if (bf(t))
    if (t.isDynamic) {
      if (!t.address)
        throw new Error("Dynamic signature leaf without address");
      if (!await qw(t.address, e, t.signature, n))
        throw new E5(t);
      return {
        weight: t.weight,
        address: t.address,
        signature: t.signature,
        subdigest: e
      };
    } else
      return {
        weight: t.weight,
        address: yf(e, t.signature),
        signature: t.signature,
        subdigest: e
      };
  return t;
}
const Lt = {
  concat: (t, e) => Ae(["bytes", "bytes"], [t, e]),
  node: (t) => Ae(["uint8", "bytes32"], [Qe.Node, t]),
  branch: (t) => {
    const e = ee(t);
    return Ae(["uint8", "uint24", "bytes"], [Qe.Branch, e.length, e]);
  },
  nested: (t, e, n) => {
    const r = ee(n);
    return Ae(["uint8", "uint8", "uint16", "uint24", "bytes"], [Qe.Nested, t, e, r.length, r]);
  },
  subdigest: (t) => Ae(["uint8", "bytes32"], [Qe.Subdigest, t]),
  signature: (t, e) => Ae(["uint8", "uint8", "bytes"], [Qe.Signature, t, e]),
  dynamicSignature: (t, e, n) => {
    const r = ee(n);
    return Ae(["uint8", "uint8", "address", "uint24", "bytes"], [Qe.DynamicSignature, t, e, r.length, r]);
  },
  address: (t, e) => Ae(["uint8", "uint8", "address"], [Qe.Address, t, e])
};
function Wu(t, e, n, r, s = {}) {
  const a = Qu(t.tree, e, n, s);
  return BigInt(r) === 0n ? {
    encoded: Ae(["uint8", "uint16", "uint32", "bytes"], [Et.NoChainIdDynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : BigInt(t.threshold) > 255n ? {
    encoded: Ae(["uint8", "uint16", "uint32", "bytes"], [Et.Dynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : {
    encoded: Ae(["uint8", "uint8", "uint32", "bytes"], [Et.Legacy, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  };
}
function Qu(t, e, n, r = {}) {
  const s = !r.disableTrim;
  if (Pr(t)) {
    const a = Qu(t.left, e, n), i = Qu(t.right, e, n), o = yn(t.left), c = yn(t.right);
    return s && a.weight === 0n && i.weight === 0n && !o && !c ? {
      // We don't need to include anything for this node
      // just the hash will be enough
      encoded: Lt.node(sr(t)),
      weight: 0n
    } : s && i.weight === 0n && !c ? {
      // The right node doesn't have any weight
      // but we still need to include the left node encoded
      encoded: Lt.concat(a.encoded, Lt.node(sr(t.right))),
      weight: a.weight
    } : s && a.weight === 0n && !o ? {
      // The left node doesn't have any weight
      // we can just append its hash, but for the right node
      // we need to create a new "branch"
      encoded: Lt.concat(Lt.node(sr(t.left)), Lt.branch(i.encoded)),
      weight: i.weight
    } : {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: Lt.concat(a.encoded, Lt.branch(i.encoded)),
      weight: a.weight + i.weight
    };
  }
  if (Xs(t)) {
    const a = Qu(t.tree, e, n);
    return s && a.weight === 0n ? {
      encoded: Lt.node(sr(t)),
      weight: 0n
    } : {
      encoded: Lt.nested(t.weight, t.threshold, a.encoded),
      weight: a.weight
    };
  }
  if (Zs(t))
    return {
      encoded: Lt.node(sr(t)),
      weight: 0n
    };
  if (Js(t)) {
    const a = n.includes(t.subdigest);
    return {
      encoded: Lt.subdigest(t.subdigest),
      weight: a ? JP : 0n
    };
  }
  if (yn(t))
    if (e.has(t.address)) {
      const i = e.get(t.address), o = i.signature;
      return r.forceDynamicEncoding || i.isDynamic ? {
        encoded: Lt.dynamicSignature(t.weight, t.address, o),
        weight: BigInt(t.weight)
      } : {
        encoded: Lt.signature(t.weight, o),
        weight: BigInt(t.weight)
      };
    } else
      return {
        encoded: Lt.address(t.weight, t.address),
        weight: 0n
      };
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(t)}`);
}
function Zw(t) {
  return eE(t) ? Zw(t.suffix[t.suffix.length - 1]) : t.config;
}
function Yw(t) {
  return t.type !== void 0 && t.decoded !== void 0 && t.version !== void 0 && t.version === 2;
}
function gf(t) {
  return t.suffix !== void 0 && Array.isArray(t.suffix) && t.suffix.every(Yw);
}
function x5(t) {
  return t.type !== void 0 && t.config !== void 0 && t.digest !== void 0 && t.version !== void 0 && t.version === 2;
}
function eE(t) {
  return t.chain !== void 0 && Array.isArray(t.chain) && t.chain.every(x5);
}
function Tm(t) {
  const e = ee(t), n = e[0];
  switch (n) {
    case Et.Legacy:
      return {
        version: 2,
        type: Et.Legacy,
        decoded: Bp(e)
      };
    case Et.Dynamic:
      return {
        version: 2,
        type: Et.Dynamic,
        decoded: Bp(e.slice(1))
      };
    case Et.NoChainIdDynamic:
      return {
        version: 2,
        type: Et.NoChainIdDynamic,
        decoded: Bp(e.slice(1))
      };
    case Et.Chained:
      return A5(e);
    default:
      throw new Error(`Invalid signature type: ${n}`);
  }
}
function Bp(t) {
  const e = ee(t), n = e[0] << 8 | e[1], r = e[2] << 24 | e[3] << 16 | e[4] << 8 | e[5], s = Ch(e.slice(6));
  return {
    threshold: n,
    checkpoint: r,
    tree: s
  };
}
function A5(t) {
  const e = ee(t), n = e[0];
  if (n !== Et.Chained)
    throw new Error(`Expected chained signature type: ${n}`);
  const r = [];
  let s = 1;
  for (; s < e.length; ) {
    const o = e[s] << 16 | e[s + 1] << 8 | e[s + 2];
    s += 3;
    const c = Tm(e.slice(s, s + o));
    r.push(c), s += o;
  }
  const a = r[0];
  if (gf(a))
    throw new Error("Expected first link of chained signature to be a simple signature (not chained)");
  const i = r.slice(1);
  return Ut({}, a, {
    suffix: i
  });
}
function k5(t) {
  return Ae(["bytes32", "bytes32"], [ho(["string"], ["SetImageHash(bytes32 imageHash)"]), t]);
}
async function tE(t, e, n) {
  const r = e.subdigest === void 0 ? e : void 0;
  t.type === Et.NoChainIdDynamic && r && (r.chainId = 0);
  const a = r ? mf(r) : e.subdigest;
  if (!gf(t)) {
    const l = await go(t.decoded.tree, a, n);
    return {
      version: 2,
      type: t.type,
      subdigest: a,
      config: Ut({
        version: 2
      }, t.decoded, {
        tree: l
      })
    };
  }
  if (!l5(r))
    throw new Error("Chained signature recovery requires detailed signed payload, subdigest is not enough");
  const i = [];
  let o = r;
  for (const l of [Ut({}, t, {
    suffix: void 0
  }), ...t.suffix]) {
    const d = await tE(l, o, n);
    i.unshift(d);
    const p = k5(rE(Zw(d)));
    o = Ut({}, o, {
      message: p,
      digest: ke(p)
    });
  }
  const c = i[0], u = i.slice(1);
  return Ut({}, c, {
    suffix: u
  });
}
function Sm(t, e) {
  const r = [t, ...e || []].map((a) => ee(Ja(a))), s = Ae(r.map(() => ["uint24", "bytes"]).flat(), r.map((a) => [a.length, a]).flat());
  return Ae(["uint8", "bytes"], [Et.Chained, s]);
}
function Ja(t) {
  if (ko(t)) return z(t);
  if (gf(t) || eE(t))
    return Sm(Ja(t), (t.suffix || []).map(Ja));
  const e = Yw(t) ? t.decoded : t.config;
  switch (t.type) {
    case Et.Legacy:
      if (BigInt(e.threshold) > 255n)
        throw new Error(`Legacy signature threshold is too large: ${e.threshold} (max 255)`);
      return t1(e);
    case Et.NoChainIdDynamic:
    case Et.Dynamic:
      return Ae(["uint8", "bytes"], [t.type, t1(e)]);
    case Et.Chained:
      throw new Error("Unreachable code: Chained signature should be handled above");
    default:
      throw new Error(`Invalid signature type: ${t.type}`);
  }
}
function t1(t) {
  return Ae(["uint16", "uint32", "bytes"], [t.threshold, t.checkpoint, Ju(t.tree)]);
}
function Ju(t) {
  if (Pr(t) || Mo(t)) {
    const e = ee(Ju(t.right)), n = ee(Ju(t.left));
    return Pr(t.right) || Mo(t.right) ? Ae(["bytes", "uint8", "uint24", "bytes"], [n, Qe.Branch, e.length, e]) : Ae(["bytes", "bytes"], [n, e]);
  }
  if (Xs(t) || su(t)) {
    const e = ee(Ju(t.tree));
    return Ae(["uint8", "uint8", "uint16", "uint24", "bytes"], [Qe.Nested, t.weight, t.threshold, e.length, e]);
  }
  if (bf(t) || yn(t) && t.signature !== void 0) {
    const e = ee(t.signature);
    if (t.isDynamic || e.length !== vh) {
      if (!t.address) throw new Error("Dynamic signature leaf must have address");
      return Ae(["uint8", "uint8", "address", "uint24", "bytes"], [Qe.DynamicSignature, t.weight, t.address, e.length, e]);
    } else
      return Ae(["uint8", "uint8", "bytes"], [Qe.Signature, t.weight, e]);
  }
  if (yn(t))
    return Ae(["uint8", "uint8", "address"], [Qe.Address, t.weight, t.address]);
  if (Zs(t))
    return Ae(["uint8", "bytes32"], [Qe.Node, t.nodeHash]);
  if (Js(t))
    return Ae(["uint8", "bytes32"], [Qe.Subdigest, t.subdigest]);
  throw new Error(`Unknown signature tree type: ${t}`);
}
function Xu(t) {
  return Pr(t) ? [...Xu(t.left), ...Xu(t.right)] : Xs(t) ? Xu(t.tree) : yn(t) && t.signature ? [{
    address: t.address,
    signature: t.signature
  }] : [];
}
function Zu(t) {
  return Mo(t) ? [...Zu(t.left), ...Zu(t.right)] : su(t) ? Zu(t.tree) : bf(t) ? [t.signature] : [];
}
function Pp(t) {
  return Mo(t) ? [...Pp(t.left), ...Pp(t.right)] : su(t) ? Pp(t.tree) : Js(t) ? [t.subdigest] : [];
}
async function Th(t) {
  const e = typeof t == "string" ? Tm(t) : t;
  if (gf(e)) {
    const r = await Promise.all([Th(Ut({}, e, {
      suffix: void 0
    })), ...e.suffix.map((s) => Th(s))]);
    return Sm(r[0], r.slice(1));
  }
  const {
    trimmed: n
  } = await Yu(e.decoded.tree);
  return Ja(Ut({}, e, {
    decoded: Ut({}, e.decoded, {
      tree: n
    })
  }));
}
async function Yu(t, e = !0) {
  if (Mo(t)) {
    const [n, r] = await Promise.all([Yu(t.left), Yu(t.right)]);
    if (n.weight === 0 && r.weight === 0)
      try {
        const s = await go(t, Gp, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: sr(s)
          }
        };
      } catch {
      }
    else
      return {
        weight: n.weight + r.weight,
        trimmed: {
          left: n.trimmed,
          right: r.trimmed
        }
      };
  }
  if (su(t)) {
    const n = await Yu(t.tree);
    if (n.weight === 0)
      try {
        const r = await go(t, Gp, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: sr(r)
          }
        };
      } catch {
      }
    return {
      weight: n.weight,
      trimmed: {
        weight: t.weight,
        threshold: t.threshold,
        tree: n.trimmed
      }
    };
  }
  return Zs(t) && T5(t.nodeHash) ? {
    weight: 0,
    trimmed: Ut({}, C5(t.nodeHash))
  } : bf(t) || yn(t) && t.signature !== void 0 ? {
    weight: Number(t.weight),
    trimmed: t
  } : !e && Js(t) ? {
    weight: 1 / 0,
    trimmed: t
  } : {
    weight: 0,
    trimmed: t
  };
}
const Im = {
  decode: (t) => Tm(t),
  encode: (t) => Ja(t),
  trim: (t) => Th(t),
  supportsNoChainId: !0,
  recover: (t, e, n) => tE(t, e, n),
  encodeSigners: (t, e, n, r) => Wu(t, e, n, r),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = Im.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    const n = e.reverse(), r = ko(t) ? t : Ja(t), s = n.map((a) => ko(a) ? a : Ja(a));
    return Sm(r, s);
  },
  hashSetImageHash: function(t) {
    return b5(t);
  },
  signaturesOf(t) {
    return Xu(t.tree);
  },
  signaturesOfDecoded: function(t) {
    return Zu(t.decoded.tree);
  }
};
var yY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignatureType: Et,
  SignaturePartType: Qe,
  SignaturePartTypeLength: vh,
  isUnrecoveredNode: Mo,
  isUnrecoveredNestedLeaf: su,
  isUnrecoveredSignatureLeaf: bf,
  decodeSignatureTree: Ch,
  InvalidSignatureLeafError: E5,
  recoverTopology: go,
  partEncoder: Lt,
  encodeSigners: Wu,
  encodeTree: Qu,
  deepestConfigOfSignature: Zw,
  isUnrecoveredSignature: Yw,
  isUnrecoveredChainedSignature: gf,
  isSignature: x5,
  isChainedSignature: eE,
  decodeSignature: Tm,
  decodeSignatureBody: Bp,
  decodeChainedSignature: A5,
  setImageHashStruct: k5,
  recoverSignature: tE,
  encodeChain: Sm,
  encodeSignature: Ja,
  encodeSignatureBody: t1,
  encodeSignatureTree: Ju,
  signaturesOf: Xu,
  signaturesOfDecoded: Zu,
  subdigestsOfDecoded: Pp,
  trimSignature: Th,
  trimUnrecoveredTree: Yu,
  SignatureCoder: Im
});
function yn(t) {
  return t.address !== void 0 && t.weight !== void 0;
}
function Js(t) {
  return t.subdigest !== void 0 && t.address === void 0;
}
function ed(t) {
  return Pr(t) ? JSON.stringify({
    left: ed(t.left),
    right: ed(t.right)
  }) : Xs(t) ? JSON.stringify({
    weight: BigInt(t.weight).toString(),
    threshold: BigInt(t.threshold).toString(),
    tree: ed(t.tree)
  }) : yn(t) ? JSON.stringify({
    address: t.address,
    weight: BigInt(t.weight).toString()
  }) : JSON.stringify(t);
}
function td(t) {
  const e = typeof t == "string" ? JSON.parse(t) : t;
  return e.left !== void 0 && e.right !== void 0 ? {
    left: td(e.left),
    right: td(e.right)
  } : e.weight !== void 0 && e.threshold !== void 0 && e.tree !== void 0 ? {
    weight: BigInt(e.weight),
    threshold: BigInt(e.threshold),
    tree: td(e.tree)
  } : e.address !== void 0 && e.weight !== void 0 ? {
    address: e.address,
    weight: BigInt(e.weight)
  } : e;
}
function Xs(t) {
  return t.tree !== void 0 && t.weight !== void 0 && t.threshold !== void 0;
}
function Zs(t) {
  return t.nodeHash !== void 0;
}
function nE(t) {
  return yn(t) || Js(t) || Xs(t) || Zs(t);
}
function Pr(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function bY(t) {
  return Pr(t) || nE(t);
}
function v5(t) {
  return Ae(["uint96", "address"], [t.weight, t.address]);
}
function C5(t) {
  const e = ee(t);
  if (e.length !== 32)
    throw new Error("Invalid encoded string length");
  const n = BigInt(z(e.slice(0, 12))), r = de(z(e.slice(12)));
  return {
    weight: n,
    address: r
  };
}
function T5(t) {
  const e = ee(t);
  return e.length !== 32 ? !1 : e.slice(0, 11).every((r) => r === 0);
}
function sr(t) {
  if (yn(t))
    return v5(t);
  if (Js(t))
    return ho(["string", "bytes32"], [`Sequence static digest:
`, t.subdigest]);
  if (Xs(t)) {
    const e = sr(t.tree);
    return ho(["string", "bytes32", "uint256", "uint256"], [`Sequence nested config:
`, e, t.threshold, t.weight]);
  }
  return Zs(t) ? t.nodeHash : ho(["bytes32", "bytes32"], [sr(t.left), sr(t.right)]);
}
function gY(t) {
  const e = [];
  let n = t;
  for (; !nE(n); )
    e.unshift(n.right), n = n.left;
  return e.unshift(n), e;
}
function wY(t) {
  return t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && t.version !== void 0 && t.version === 2;
}
function rE(t) {
  return ho(["bytes32", "uint256"], [ho(["bytes32", "uint256"], [sr(t.tree), t.threshold]), t.checkpoint]);
}
function S5(t) {
  return t.threshold !== void 0 && t.weight !== void 0 && t.members !== void 0;
}
function xc(t) {
  return yn(t) || Js(t) ? [t] : Xs(t) ? [{
    threshold: t.threshold,
    weight: t.weight,
    members: xc(t.tree)
  }] : Zs(t) ? [] : [...xc(t.left), ...xc(t.right)];
}
function n1(t) {
  return Zs(t) ? !0 : Pr(t) ? n1(t.left) || n1(t.right) : !1;
}
function EY(t) {
  return {
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    members: xc(t.tree)
  };
}
const I5 = (t, e) => t.map((n) => S5(n) ? {
  tree: e(n.members),
  threshold: n.threshold,
  weight: n.weight
} : n);
function sE(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  return I5(t, sE).reduce((n, r) => ({
    left: n,
    right: r
  }));
}
function aE(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  const e = I5(t, aE);
  for (let n = e.length; n > 1; n = n / 2)
    for (let r = 0; r < n / 2; r++) {
      const s = r * 2, a = s + 1;
      a >= n ? e[r] = e[s] : e[r] = {
        left: e[s],
        right: e[a]
      };
    }
  return e[0];
}
function iE(t) {
  return t.length > 8 ? aE(t) : sE(t);
}
function O5(t, e = iE) {
  return {
    version: 2,
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    tree: e(t.members)
  };
}
function Sh(t, e) {
  return Js(t) ? t.subdigest === e : Pr(t) ? Sh(t.left, e) || Sh(t.right, e) : !1;
}
function r1(t) {
  const e = [t], n = /* @__PURE__ */ new Set();
  for (; e.length > 0; ) {
    const r = e.pop();
    Xs(r) ? e.push(r.tree) : Pr(r) ? (e.push(r.left), e.push(r.right)) : yn(r) && n.add({
      address: r.address,
      weight: Number(r.weight)
    });
  }
  return Array.from(n);
}
function Ih(t) {
  return Pr(t) ? Ih(t.left) && Ih(t.right) : !Zs(t);
}
const Om = {
  isWalletConfig: (t) => t.version === 2 && t.threshold !== void 0 && t.tree !== void 0,
  imageHashOf: (t) => rE(t),
  hasSubdigest: (t, e) => Sh(t.tree, e),
  checkpointOf: (t) => BigInt(t.checkpoint),
  signersOf: (t) => r1(t.tree),
  fromSimple: (t) => {
    var e;
    return O5(Ut({}, t, {
      members: [...t.signers, ...((e = t.subdigests) != null ? e : []).map((n) => ({
        subdigest: n
      }))]
    }));
  },
  isComplete: (t) => Ih(t.tree),
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Qt(qt.mainModuleUpgradable.abi);
      return {
        entrypoint: t,
        transactions: [{
          to: t,
          data: s.encodeFunctionData(s.getFunction("updateImageHash"), [Om.imageHashOf(e)]),
          gasLimit: 0,
          delegateCall: !1,
          revertOnError: !0,
          value: 0
        }]
      };
    },
    decodeTransaction: function(t) {
      var e, n, r, s;
      const a = new Qt(qt.mainModuleUpgradable.abi);
      if (t.transactions.length !== 1)
        throw new Error("Invalid transaction bundle, expected 1 transaction");
      const i = t.transactions[0].data;
      if (!i)
        throw new Error("Invalid transaction bundle, expected data");
      const o = a.decodeFunctionData(a.getFunction("updateImageHash"), i);
      if (!o)
        throw new Error("Invalid transaction bundle, expected valid data");
      if (t.transactions[0].to !== t.entrypoint)
        throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
      if (t.transactions[0].delegateCall)
        throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
      if (!t.transactions[0].revertOnError)
        throw new Error("Invalid transaction bundle, expected revertOnError");
      if (BigInt((e = (n = t.transactions[0]) == null ? void 0 : n.value) != null ? e : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      if (BigInt((r = (s = t.transactions[0]) == null ? void 0 : s.gasLimit) != null ? r : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      return {
        address: t.entrypoint,
        newImageHash: o[0],
        kind: void 0
      };
    }
  },
  toJSON: function(t) {
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      checkpoint: BigInt(t.checkpoint).toString(),
      tree: ed(t.tree)
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t);
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      checkpoint: BigInt(e.checkpoint),
      tree: td(e.tree)
    };
  },
  editConfig: function(t, e) {
    var n, r;
    const s = xc(t.tree);
    if (e.add)
      for (const a of e.add)
        s.find((i) => yn(i) && i.address === a.address) || s.push({
          address: a.address,
          weight: a.weight
        });
    if (e.remove)
      for (const a of e.remove) {
        const i = s.findIndex((o) => yn(o) && o.address === a);
        i >= 0 && s.splice(i, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      checkpoint: (r = e.checkpoint) != null ? r : t.checkpoint,
      tree: iE(s)
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = Wu(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = r1(t.tree);
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => a - i)) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = Wu(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return Wu(t, n, [], 0).encoded;
  }
};
var xY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSignerLeaf: yn,
  isSubdigestLeaf: Js,
  topologyToJSON: ed,
  topologyFromJSON: td,
  isNestedLeaf: Xs,
  isNodeLeaf: Zs,
  isLeaf: nE,
  isNode: Pr,
  isTopology: bY,
  encodeSignerLeaf: v5,
  decodeSignerLeaf: C5,
  isEncodedSignerLeaf: T5,
  hashNode: sr,
  leftFace: gY,
  isWalletConfig: wY,
  imageHash: rE,
  isSimpleNestedMember: S5,
  topologyToMembers: xc,
  hasUnknownNodes: n1,
  toSimpleWalletConfig: EY,
  legacyTopologyBuilder: sE,
  merkleTopologyBuilder: aE,
  optimized2SignersTopologyBuilder: iE,
  toWalletConfig: O5,
  hasSubdigest: Sh,
  signersOf: r1,
  isComplete: Ih,
  ConfigCoder: Om
}), AY = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const kY = {
  config: Om,
  signature: Im
}, B5 = 2, P5 = {
  version: B5,
  factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
  guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
  mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
  mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3",
  proxyImplementationHook: "0x1f56dbAD5e8319F0DE9a323E24A31b5077dEB1a4"
};
var fe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: xY,
  signature: yY,
  context: AY,
  chained: mY,
  coders: kY,
  version: B5,
  DeployedWalletContext: P5
}), vY = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function s1(t, e) {
  const n = ke(Ae(["bytes", "bytes32"], [t.walletCreationCode, Mn(t.mainModule, 32)])), r = ke(Ae(["bytes1", "address", "bytes32", "bytes32"], ["0xff", t.factory, e, n]));
  return de(Ve(r, 12));
}
async function CY(t, e, n, r, s, a) {
  return (await Promise.all(KY.map(async (o) => {
    try {
      const c = o.signature.SignatureCoder.decode(z(n)), u = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: z(e),
        chainId: r
      }, s), l = o.config.ConfigCoder.imageHashOf(u.config);
      if (s1(a[o.version], l).toLowerCase() === t.toLowerCase())
        return !0;
      const p = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: z(e),
        chainId: r
      }, s), f = o.config.ConfigCoder.imageHashOf(p.config);
      return s1(a[o.version], f).toLowerCase() === t.toLowerCase();
    } catch {
    }
    return !1;
  }))).some((o) => o);
}
function TY(t) {
  const e = Object.keys(t).length;
  for (let n = 1; n <= e; n++) {
    const r = t[n];
    if (!r || r.version !== n)
      return !1;
  }
  return !0;
}
function SY(t) {
  const e = Object.keys(t).length;
  return t[e];
}
const IY = {
  1: y5,
  2: P5
};
var OY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addressOf: s1,
  isValidCounterfactual: CY,
  isValidVersionedContext: TY,
  latestContext: SY,
  defaultContexts: IY
});
const Bm = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function BY(t, e, n, r) {
  return Ut({}, t, {
    chainId: n,
    intent: {
      id: r,
      wallet: e
    }
  });
}
function PY(t) {
  return ke(Wt.defaultAbiCoder().encode(["address", "uint256", "bytes32"], [t.intent.wallet, t.chainId, t.intent.id]));
}
function UY(t) {
  const e = Wt.defaultAbiCoder().decode(["uint256", Bm], t);
  if (e.length !== 2 || !e[0] || !e[1]) throw new Error("Invalid meta transaction data");
  return [e[0], e[1]];
}
function U5(t, e) {
  return Wt.defaultAbiCoder().encode(["uint256", Bm], [t, Sd(e)]);
}
function N5(t, e) {
  return ke(U5(t, e));
}
function NY(t, e, n, r) {
  return mf({
    address: t,
    chainId: e,
    digest: N5(n, r)
  });
}
function RY(t, e, n) {
  return mf({
    address: t,
    chainId: e,
    digest: ke(Wt.defaultAbiCoder().encode(["string", Bm], ["guest:", Sd(n)]))
  });
}
function R5(t, e) {
  return e.map((n) => oE(t, n));
}
function oE(t, e) {
  if (e.to && e.to !== ti)
    return {
      nonce: nd(e.nonce) ? void 0 : BigInt(e.nonce),
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: nd(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise
        // Keeping this as is for now so we don't have to change everything to async
        to: e.to,
        value: BigInt(e.value || 0),
        data: e.data || "0x"
      }
    };
  {
    const n = new Qt(qt.mainModule.abi), r = n.encodeFunctionData(n.getFunction("createContract"), [e.data]);
    return {
      nonce: typeof e.nonce == "number" ? BigInt(e.nonce) : void 0,
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: nd(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        to: t,
        value: BigInt(e.value || 0),
        data: r
      }
    };
  }
}
function Pm(t) {
  return t.delegateCall !== void 0 || t.revertOnError !== void 0;
}
function D5(t) {
  return t.every(Pm);
}
function Sd(t) {
  return t.map((e) => {
    var n;
    return {
      delegateCall: e.delegateCall === !0,
      revertOnError: e.revertOnError === !0,
      gasLimit: nd(e.gasLimit) ? 0n : BigInt(e.gasLimit),
      target: (n = e.to) != null ? n : ti,
      value: nd(e.value) ? 0n : e.value,
      data: e.data || "0x"
    };
  });
}
function DY(t) {
  return t.map((e) => ({
    delegateCall: e.delegateCall,
    revertOnError: e.revertOnError,
    gasLimit: e.gasLimit,
    to: e.target,
    value: e.value,
    data: e.data
  }));
}
function FY(t, e) {
  const n = BigInt(t), r = BigInt(e), s = 2n ** 96n;
  if (r / s !== 0n)
    throw new Error("Space already encoded");
  return r + n * s;
}
function MY(t) {
  const e = BigInt(t), n = 2n ** 96n;
  return [e / n, e % n];
}
function LY(t, e) {
  return Array.isArray(e) ? D5(e) ? e : R5(t, e).map((r) => r.transaction) : Pm(e) ? [e] : [oE(t, e).transaction];
}
function F5(t) {
  return t !== void 0 && t.entrypoint !== void 0 && t.chainId !== void 0 && t.transactions !== void 0 && t.nonce !== void 0 && t.intent !== void 0 && t.intent.id !== void 0 && t.intent.wallet !== void 0 && Array.isArray(t.transactions) && t.transactions.reduce((e, n) => e && Pm(n), !0);
}
function M5(t) {
  return t !== void 0 && t.signature !== void 0 && t.signature !== "" && F5(t);
}
function HY(t) {
  const e = new Qt(qt.mainModule.abi);
  return e.encodeFunctionData(e.getFunction("execute"), M5(t) ? [
    // Signed transaction bundle has all 3 parameters
    Sd(t.transactions),
    t.nonce,
    t.signature
  ] : [
    // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
    Sd(t.transactions),
    0,
    new Uint8Array([])
  ]);
}
const L5 = "0x61c2926c", H5 = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`, a1 = (t, e) => {
  const n = [], r = new Qt(qt.mainModule.abi);
  for (const s of e) {
    const a = ee(s.data || "0x");
    if (s.to === t && z(a.slice(0, 4)) === L5) {
      const i = a.slice(4), o = Wt.defaultAbiCoder().decode([H5], i)[0];
      n.push(...a1(s.to, o.map((c) => Ut({}, c, {
        to: c.target
      }))));
    } else
      try {
        const i = r.decodeFunctionData("execute", a)[0], o = a1(t, i.map((c) => Ut({}, c.toObject(), {
          to: c.target
        })));
        n.push(...o);
      } catch {
        n.push(s);
      }
  }
  return n;
}, nd = (t) => t == null;
var _Y = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MetaTransactionsType: Bm,
  intendTransactionBundle: BY,
  intendedTransactionID: PY,
  unpackMetaTransactionsData: UY,
  packMetaTransactionsData: U5,
  digestOfTransactions: N5,
  subdigestOfTransactions: NY,
  subdigestOfGuestModuleTransactions: RY,
  toSequenceTransactions: R5,
  toSequenceTransaction: oE,
  isSequenceTransaction: Pm,
  hasSequenceTransactions: D5,
  sequenceTxAbiEncode: Sd,
  fromTxAbiEncode: DY,
  encodeNonce: FY,
  decodeNonce: MY,
  fromTransactionish: LY,
  isTransactionBundle: F5,
  isSignedTransactionBundle: M5,
  encodeBundleExecData: HY,
  selfExecuteSelector: L5,
  selfExecuteAbi: H5,
  unwind: a1
});
const _5 = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033", $Y = "0x6492649264926492649264926492649264926492649264926492649264926492";
async function $5(t, e, n, r) {
  try {
    return await t.call({
      data: _e([_5, Wt.defaultAbiCoder().encode(["address", "bytes32", "bytes"], [e, n, r])])
    }) === "0x01";
  } catch {
    return !1;
  }
}
var GY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE: _5,
  EIP_6492_SUFFIX: $Y,
  validateEIP6492Offchain: $5
});
class zY {
  constructor(e) {
    this.provider = e, this.isDeployedCache = /* @__PURE__ */ new Set();
  }
  module(e) {
    return new rs(e, [...qt.mainModuleUpgradable.abi, ...qt.mainModule.abi, ...qt.erc1271.abi], this.provider);
  }
  async isDeployed(e) {
    if (this.isDeployedCache.has(e))
      return !0;
    const r = (await this.provider.getCode(e).then((s) => ee(s))).length !== 0;
    return r && this.isDeployedCache.add(e), r;
  }
  async implementation(e) {
    const n = Wt.defaultAbiCoder().encode(["address"], [e]), r = await this.provider.getStorage(e, n).then((s) => ee(s));
    if (r.length === 20)
      return de(z(r));
    if (r.length === 32)
      return Wt.defaultAbiCoder().decode(["address"], r)[0];
  }
  async imageHash(e) {
    try {
      return await this.module(e).imageHash();
    } catch {
    }
  }
  async nonce(e, n = 0) {
    try {
      return await this.module(e).readNonce(n);
    } catch (r) {
      if (!await this.isDeployed(e))
        return 0;
      throw r;
    }
  }
  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(e, n, r) {
    return $5(this.provider, e, n, r);
  }
}
var jY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  OnChainReader: zY
});
function VY(t) {
  return t && t.address && t.digest && t.chainId !== void 0 && t.config;
}
var se = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: vY,
  signature: sY,
  context: OY,
  signer: uY,
  EIP1271: oY,
  transaction: _Y,
  reader: jY,
  EIP6492: GY,
  isWalletSignRequestMetadata: VY
});
const i1 = [{
  config: Jw,
  signature: Qw
}, {
  config: Om,
  signature: Im
}];
function G5(t) {
  const e = t - 1;
  if (e < 0 || e >= i1.length)
    throw new Error(`No coder for version: ${t}`);
  return i1[e];
}
function qY(t) {
  return G5(t);
}
var cn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALL_CODERS: i1,
  coderFor: G5,
  genericCoderFor: qY
});
const KY = [wi, fe];
function WY(t, e, n) {
  for (let r = 0; r < n.length; r++)
    if (se.context.addressOf(n[r], e) === t)
      return n[r].version;
  throw new Error("Could not find version for counterfactual address");
}
var QY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  counterfactualVersion: WY
});
class JY {
  constructor() {
    this.version = 2, this.configCoder = fe.config.ConfigCoder, this.signatureCoder = fe.signature.SignatureCoder;
  }
  buildTransaction(e, n, r) {
    if (!fe.config.ConfigCoder.isWalletConfig(r)) {
      const c = fe.config.toWalletConfig({
        threshold: r.threshold,
        members: r.signers,
        checkpoint: 0
      });
      return this.buildTransaction(e, n, c);
    }
    const s = n[2], a = new Qt(qt.mainModule.abi), i = fe.config.ConfigCoder.update.buildTransaction(e, r, s, "first");
    return {
      tx: {
        entrypoint: e,
        nonce: se.transaction.encodeNonce(o1, 0),
        transactions: [{
          to: e,
          value: 0,
          gasLimit: 0,
          revertOnError: !0,
          delegateCall: !1,
          data: a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable])
        }, ...i.transactions]
      },
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: r
    };
  }
  decodeTransaction(e, n) {
    const r = e.entrypoint;
    if (e.transactions.length < 2)
      throw new Error("Invalid transaction bundle size");
    if (!e.nonce || se.transaction.encodeNonce(o1, 0) !== BigInt(e.nonce))
      throw new Error("Invalid transaction bundle nonce");
    if (e.transactions[0].to !== r || e.transactions[1].to !== r || e.transactions[0].delegateCall || e.transactions[1].delegateCall || !e.transactions[0].revertOnError || !e.transactions[1].revertOnError || e.transactions[0].value && BigInt(e.transactions[0].value) !== 0n || e.transactions[1].value && BigInt(e.transactions[1].value) !== 0n || e.transactions[0].gasLimit && BigInt(e.transactions[0].gasLimit) !== 0n || e.transactions[1].gasLimit && BigInt(e.transactions[1].gasLimit) !== 0n)
      throw new Error("Invalid transaction bundle format");
    const s = n[2], a = new Qt(qt.mainModule.abi), i = z(e.transactions[0].data || new Uint8Array()), o = z(a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable]));
    if (i !== o)
      throw new Error("Invalid new implementation on transaction");
    const c = fe.config.ConfigCoder.update.decodeTransaction({
      entrypoint: r,
      transactions: [e.transactions[1]]
    });
    if (c.address !== r)
      throw new Error("Invalid transaction bundle address");
    return c;
  }
}
const o1 = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb", z5 = new JY();
var XY = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE: o1,
  v1v2: z5
});
function c1() {
  return c1 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, c1.apply(null, arguments);
}
function ZY(t) {
  for (const [e, n] of Object.entries(t))
    if (e !== String(n.version - 1))
      throw new Error(`Migration with key ${e} has version ${n.version}, expected version to be key + 1`);
}
class YY {
  constructor(e, n, r) {
    this.tracker = e, this.migrations = n, this.contexts = r, ZY(n);
  }
  lastMigration() {
    let e;
    for (const n of Object.values(this.migrations))
      (e === void 0 || n.version > e.version) && (e = n);
    if (e === void 0)
      throw new Error("No migrations");
    return e;
  }
  async getAllMigratePresignedTransaction(e) {
    const {
      address: n,
      fromImageHash: r,
      fromVersion: s,
      chainId: a
    } = e;
    let i = r, o = s;
    const c = Object.values(this.contexts), u = [];
    for (let l = 1; l < c.length; l++) {
      const d = await this.tracker.getMigration(n, i, o, a);
      if (!d) return {
        signedMigrations: u,
        missing: !0,
        lastImageHash: i,
        lastVersion: o
      };
      u.push(d);
      const p = this.migrations[o];
      if (!p)
        throw new Error(`No migration found for version ${o}`);
      const f = p.decodeTransaction(d.tx, this.contexts);
      if (f.address !== n)
        throw new Error("Migration transaction address does not match expected address");
      i = f.newImageHash, o += 1;
    }
    return {
      signedMigrations: u,
      missing: !1,
      lastImageHash: i,
      lastVersion: o
    };
  }
  async signNextMigration(e, n, r, s) {
    const a = this.migrations[n];
    if (!a)
      return;
    const i = a.buildTransaction(e, this.contexts, s), o = await r.signTransactionBundle(i.tx);
    return c1({}, i, {
      tx: o
    });
  }
}
var BA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Migrator: YY
});
const eee = {
  1: z5
};
var PA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultMigrations: eee
});
function Ac() {
  return Ac = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Ac.apply(null, arguments);
}
const cE = "Webrpc", j5 = "webrpc@v0.24.0;gen-typescript@v0.16.3;sequence-relayer@v0.4.1", tee = "v1", nee = "v0.4.1", ree = "fdce30970483936652aaeabaf9339a302ac52d32";
function see(t) {
  const e = t.get(cE);
  return e ? aee(e) : {
    webrpcGenVersion: "",
    codeGenName: "",
    codeGenVersion: "",
    schemaName: "",
    schemaVersion: ""
  };
}
function aee(t) {
  const e = t.split(";");
  if (e.length < 3)
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: ""
    };
  const [n, r] = e[0].split("@"), [s, a] = e[1].split("@"), [i, o] = e[2].split("@");
  return {
    webrpcGenVersion: r ?? "",
    codeGenName: s ?? "",
    codeGenVersion: a ?? "",
    schemaName: i ?? "",
    schemaVersion: o ?? ""
  };
}
let ja = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.DROPPED = "DROPPED", t.QUEUED = "QUEUED", t.SENT = "SENT", t.SUCCEEDED = "SUCCEEDED", t.PARTIALLY_FAILED = "PARTIALLY_FAILED", t.FAILED = "FAILED", t;
}({}), iee = /* @__PURE__ */ function(t) {
  return t.SEND = "SEND", t.RECEIVE = "RECEIVE", t.BRIDGE_DEPOSIT = "BRIDGE_DEPOSIT", t.BRIDGE_WITHDRAW = "BRIDGE_WITHDRAW", t.BURN = "BURN", t.UNKNOWN = "UNKNOWN", t;
}({}), oee = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.ERC20_TOKEN = "ERC20_TOKEN", t.ERC1155_TOKEN = "ERC1155_TOKEN", t;
}({}), cee = /* @__PURE__ */ function(t) {
  return t.DESC = "DESC", t.ASC = "ASC", t;
}({});
class V5 {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Relayer/", this.ping = (r, s) => this.fetch(this.url("Ping"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getSequenceContext = (r, s) => this.fetch(this.url("GetSequenceContext"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      data: i.data
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getChainID = (r, s) => this.fetch(this.url("GetChainID"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      chainID: i.chainID
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.sendMetaTxn = (r, s, a) => this.fetch(this.url("SendMetaTxn"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      txnHash: o.txnHash
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNonce = (r, s, a) => this.fetch(this.url("GetMetaTxnNonce"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnReceipt = (r, s, a) => this.fetch(this.url("GetMetaTxnReceipt"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      receipt: o.receipt
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.simulate = (r, s, a) => this.fetch(this.url("Simulate"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      results: o.results
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateMetaTxnGasLimits = (r, s, a) => this.fetch(this.url("UpdateMetaTxnGasLimits"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      payload: o.payload
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.feeTokens = (r, s) => this.fetch(this.url("FeeTokens"), Be({}, r, s)).then((a) => Pe(a).then((i) => ({
      isFeeRequired: i.isFeeRequired,
      tokens: i.tokens
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.feeOptions = (r, s, a) => this.fetch(this.url("FeeOptions"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      options: o.options,
      sponsored: o.sponsored,
      quote: o.quote
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNetworkFeeOptions = (r, s, a) => this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      options: o.options
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTransactions = (r, s, a) => this.fetch(this.url("GetMetaTransactions"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTransactionCost = (r, s, a) => this.fetch(this.url("GetTransactionCost"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      cost: o.cost
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.sentTransactions = (r, s, a) => this.fetch(this.url("SentTransactions"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.pendingTransactions = (r, s, a) => this.fetch(this.url("PendingTransactions"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTank = (r, s, a) => this.fetch(this.url("GetGasTank"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasTank = (r, s, a) => this.fetch(this.url("AddGasTank"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasTank = (r, s, a) => this.fetch(this.url("UpdateGasTank"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.nextGasTankBalanceAdjustmentNonce = (r, s, a) => this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustGasTankBalance = (r, s, a) => this.fetch(this.url("AdjustGasTankBalance"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      adjustment: o.adjustment
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTankBalanceAdjustment = (r, s, a) => this.fetch(this.url("GetGasTankBalanceAdjustment"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      adjustment: o.adjustment
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasTankBalanceAdjustments = (r, s, a) => this.fetch(this.url("ListGasTankBalanceAdjustments"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      adjustments: o.adjustments
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasSponsors = (r, s, a) => this.fetch(this.url("ListGasSponsors"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasSponsor = (r, s, a) => this.fetch(this.url("GetGasSponsor"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasSponsor = (r, s, a) => this.fetch(this.url("AddGasSponsor"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasSponsor = (r, s, a) => this.fetch(this.url("UpdateGasSponsor"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.removeGasSponsor = (r, s, a) => this.fetch(this.url("RemoveGasSponsor"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      status: o.status
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addressGasSponsors = (r, s, a) => this.fetch(this.url("AddressGasSponsors"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getProjectBalance = (r, s, a) => this.fetch(this.url("GetProjectBalance"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustProjectBalance = (r, s, a) => this.fetch(this.url("AdjustProjectBalance"), Be(r, s, a)).then((i) => Pe(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const Be = (t = {}, e = {}, n = null) => {
  const r = Ac({}, e, {
    "Content-Type": "application/json"
  });
  return r[cE] = j5, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, Pe = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), lE.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (bS[r] || ge).new(n);
  }
  return n;
});
let ge = class q5 extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, q5.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, K5 = class W5 extends ge {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, W5.prototype);
  }
}, Se = class Q5 extends ge {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Q5.prototype);
  }
}, J5 = class X5 extends ge {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, X5.prototype);
  }
}, Z5 = class Y5 extends ge {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Y5.prototype);
  }
}, eS = class tS extends ge {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, tS.prototype);
  }
}, lE = class nS extends ge {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, nS.prototype);
  }
}, rS = class sS extends ge {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, sS.prototype);
  }
}, aS = class iS extends ge {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, iS.prototype);
  }
}, oS = class cS extends ge {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, cS.prototype);
  }
}, lS = class uS extends ge {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, uS.prototype);
  }
}, dS = class fS extends ge {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, fS.prototype);
  }
};
class Um extends ge {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Um.prototype);
  }
}
class Nm extends ge {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Nm.prototype);
  }
}
class Rm extends ge {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Rm.prototype);
  }
}
class Dm extends ge {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Dm.prototype);
  }
}
class Fm extends ge {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Fm.prototype);
  }
}
class Mm extends ge {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Mm.prototype);
  }
}
class Lm extends ge {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Lm.prototype);
  }
}
class Hm extends ge {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Hm.prototype);
  }
}
class _m extends ge {
  constructor(e = "ProjectNotFound", n = 1008, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _m.prototype);
  }
}
class $m extends ge {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $m.prototype);
  }
}
class Gm extends ge {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Gm.prototype);
  }
}
class zm extends ge {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, zm.prototype);
  }
}
class jm extends ge {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, jm.prototype);
  }
}
class Vm extends ge {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Vm.prototype);
  }
}
class qm extends ge {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota request exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qm.prototype);
  }
}
class Km extends ge {
  constructor(e = "QuotaRateLimit", n = 1201, r = "Quota rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Km.prototype);
  }
}
class Wm extends ge {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Wm.prototype);
  }
}
class Qm extends ge {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Qm.prototype);
  }
}
class Jm extends ge {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Jm.prototype);
  }
}
class Xm extends ge {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Xm.prototype);
  }
}
let pS = class hS extends ge {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, hS.prototype);
  }
};
class Zm extends ge {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Zm.prototype);
  }
}
class Ym extends ge {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ym.prototype);
  }
}
let mS = class yS extends ge {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, yS.prototype);
  }
};
class e0 extends ge {
  constructor(e = "InsufficientFee", n = 3004, r = "Insufficient fee", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, e0.prototype);
  }
}
class t0 extends ge {
  constructor(e = "NotEnoughBalance", n = 3005, r = "Not enough balance", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, t0.prototype);
  }
}
let lee = /* @__PURE__ */ function(t) {
  return t.WebrpcEndpoint = "WebrpcEndpoint", t.WebrpcRequestFailed = "WebrpcRequestFailed", t.WebrpcBadRoute = "WebrpcBadRoute", t.WebrpcBadMethod = "WebrpcBadMethod", t.WebrpcBadRequest = "WebrpcBadRequest", t.WebrpcBadResponse = "WebrpcBadResponse", t.WebrpcServerPanic = "WebrpcServerPanic", t.WebrpcInternalError = "WebrpcInternalError", t.WebrpcClientDisconnected = "WebrpcClientDisconnected", t.WebrpcStreamLost = "WebrpcStreamLost", t.WebrpcStreamFinished = "WebrpcStreamFinished", t.Unauthorized = "Unauthorized", t.PermissionDenied = "PermissionDenied", t.SessionExpired = "SessionExpired", t.MethodNotFound = "MethodNotFound", t.RequestConflict = "RequestConflict", t.Aborted = "Aborted", t.Geoblocked = "Geoblocked", t.RateLimited = "RateLimited", t.ProjectNotFound = "ProjectNotFound", t.AccessKeyNotFound = "AccessKeyNotFound", t.AccessKeyMismatch = "AccessKeyMismatch", t.InvalidOrigin = "InvalidOrigin", t.InvalidService = "InvalidService", t.UnauthorizedUser = "UnauthorizedUser", t.QuotaExceeded = "QuotaExceeded", t.QuotaRateLimit = "QuotaRateLimit", t.NoDefaultKey = "NoDefaultKey", t.MaxAccessKeys = "MaxAccessKeys", t.AtLeastOneKey = "AtLeastOneKey", t.Timeout = "Timeout", t.InvalidArgument = "InvalidArgument", t.Unavailable = "Unavailable", t.QueryFailed = "QueryFailed", t.NotFound = "NotFound", t.InsufficientFee = "InsufficientFee", t.NotEnoughBalance = "NotEnoughBalance", t;
}({}), uee = /* @__PURE__ */ function(t) {
  return t[t.WebrpcEndpoint = 0] = "WebrpcEndpoint", t[t.WebrpcRequestFailed = -1] = "WebrpcRequestFailed", t[t.WebrpcBadRoute = -2] = "WebrpcBadRoute", t[t.WebrpcBadMethod = -3] = "WebrpcBadMethod", t[t.WebrpcBadRequest = -4] = "WebrpcBadRequest", t[t.WebrpcBadResponse = -5] = "WebrpcBadResponse", t[t.WebrpcServerPanic = -6] = "WebrpcServerPanic", t[t.WebrpcInternalError = -7] = "WebrpcInternalError", t[t.WebrpcClientDisconnected = -8] = "WebrpcClientDisconnected", t[t.WebrpcStreamLost = -9] = "WebrpcStreamLost", t[t.WebrpcStreamFinished = -10] = "WebrpcStreamFinished", t[t.Unauthorized = 1e3] = "Unauthorized", t[t.PermissionDenied = 1001] = "PermissionDenied", t[t.SessionExpired = 1002] = "SessionExpired", t[t.MethodNotFound = 1003] = "MethodNotFound", t[t.RequestConflict = 1004] = "RequestConflict", t[t.Aborted = 1005] = "Aborted", t[t.Geoblocked = 1006] = "Geoblocked", t[t.RateLimited = 1007] = "RateLimited", t[t.ProjectNotFound = 1008] = "ProjectNotFound", t[t.AccessKeyNotFound = 1101] = "AccessKeyNotFound", t[t.AccessKeyMismatch = 1102] = "AccessKeyMismatch", t[t.InvalidOrigin = 1103] = "InvalidOrigin", t[t.InvalidService = 1104] = "InvalidService", t[t.UnauthorizedUser = 1105] = "UnauthorizedUser", t[t.QuotaExceeded = 1200] = "QuotaExceeded", t[t.QuotaRateLimit = 1201] = "QuotaRateLimit", t[t.NoDefaultKey = 1300] = "NoDefaultKey", t[t.MaxAccessKeys = 1301] = "MaxAccessKeys", t[t.AtLeastOneKey = 1302] = "AtLeastOneKey", t[t.Timeout = 1900] = "Timeout", t[t.InvalidArgument = 2001] = "InvalidArgument", t[t.Unavailable = 2002] = "Unavailable", t[t.QueryFailed = 2003] = "QueryFailed", t[t.NotFound = 3e3] = "NotFound", t[t.InsufficientFee = 3004] = "InsufficientFee", t[t.NotEnoughBalance = 3005] = "NotEnoughBalance", t;
}({});
const bS = {
  0: K5,
  [-1]: Se,
  [-2]: J5,
  [-3]: Z5,
  [-4]: eS,
  [-5]: lE,
  [-6]: rS,
  [-7]: aS,
  [-8]: oS,
  [-9]: lS,
  [-10]: dS,
  1e3: Um,
  1001: Nm,
  1002: Rm,
  1003: Dm,
  1004: Fm,
  1005: Mm,
  1006: Lm,
  1007: Hm,
  1008: _m,
  1101: $m,
  1102: Gm,
  1103: zm,
  1104: jm,
  1105: Vm,
  1200: qm,
  1201: Km,
  1300: Wm,
  1301: Qm,
  1302: Jm,
  1900: Xm,
  2001: pS,
  2002: Zm,
  2003: Ym,
  3e3: mS,
  3004: e0,
  3005: t0
};
var Oh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WebrpcHeader: cE,
  WebrpcHeaderValue: j5,
  WebRPCVersion: tee,
  WebRPCSchemaVersion: nee,
  WebRPCSchemaHash: ree,
  VersionFromHeader: see,
  ETHTxnStatus: ja,
  TransferType: iee,
  FeeTokenType: oee,
  SortOrder: cee,
  Relayer: V5,
  WebrpcError: ge,
  WebrpcEndpointError: K5,
  WebrpcRequestFailedError: Se,
  WebrpcBadRouteError: J5,
  WebrpcBadMethodError: Z5,
  WebrpcBadRequestError: eS,
  WebrpcBadResponseError: lE,
  WebrpcServerPanicError: rS,
  WebrpcInternalErrorError: aS,
  WebrpcClientDisconnectedError: oS,
  WebrpcStreamLostError: lS,
  WebrpcStreamFinishedError: dS,
  UnauthorizedError: Um,
  PermissionDeniedError: Nm,
  SessionExpiredError: Rm,
  MethodNotFoundError: Dm,
  RequestConflictError: Fm,
  AbortedError: Mm,
  GeoblockedError: Lm,
  RateLimitedError: Hm,
  ProjectNotFoundError: _m,
  AccessKeyNotFoundError: $m,
  AccessKeyMismatchError: Gm,
  InvalidOriginError: zm,
  InvalidServiceError: jm,
  UnauthorizedUserError: Vm,
  QuotaExceededError: qm,
  QuotaRateLimitError: Km,
  NoDefaultKeyError: Wm,
  MaxAccessKeysError: Qm,
  AtLeastOneKeyError: Jm,
  TimeoutError: Xm,
  InvalidArgumentError: pS,
  UnavailableError: Zm,
  QueryFailedError: Ym,
  NotFoundError: mS,
  InsufficientFeeError: e0,
  NotEnoughBalanceError: t0,
  errors: lee,
  WebrpcErrorCodes: uee,
  webrpcErrorByCode: bS
});
const dee = [ja.DROPPED, ja.SUCCEEDED, ja.PARTIALLY_FAILED, ja.FAILED], fee = [ja.DROPPED, ja.PARTIALLY_FAILED, ja.FAILED];
class pee {
  constructor(e) {
    if (this.options = e, this.service = void 0, this.provider = void 0, this._fetch = (n, r) => {
      const s = {}, {
        jwtAuth: a,
        projectAccessKey: i
      } = this.options;
      return a && a.length > 0 && (s.Authorization = `BEARER ${a}`), i && i.length > 0 && (s["X-Access-Key"] = i), r.headers = Ac({}, s, r.headers), fetch(n, r);
    }, this.service = new V5(e.url, this._fetch), mee(e.provider))
      this.provider = e.provider;
    else {
      const {
        jwtAuth: n,
        projectAccessKey: r
      } = this.options, s = ov(e.provider.url, r, n);
      this.provider = new V1(s, void 0, {
        staticNetwork: !0
      });
    }
  }
  async waitReceipt(e, n = 1e3, r = 5, s) {
    typeof e != "string" && (e = se.transaction.intendedTransactionID(e)), dr.info(`[rpc-relayer/waitReceipt] waiting for ${e}`);
    let a = 0;
    for (; s === void 0 || !s(); ) {
      try {
        const {
          receipt: i
        } = await this.service.getMetaTxnReceipt({
          metaTxID: e
        });
        if (i && i.txnReceipt && i.txnReceipt !== "null" && dee.includes(i.status))
          return {
            receipt: i
          };
      } catch (i) {
        if (a++, a === r)
          throw i;
      }
      (s === void 0 || !s()) && await new Promise((i) => setTimeout(i, n));
    }
    throw new Error(`Cancelled waiting for transaction receipt ${e}`);
  }
  async simulate(e, ...n) {
    const s = Wt.defaultAbiCoder().encode([se.transaction.MetaTransactionsType], [se.transaction.sequenceTxAbiEncode(n)]);
    return (await this.service.simulate({
      wallet: e,
      transactions: s
    })).results;
  }
  async getFeeOptions(e, ...n) {
    const r = await this.service.feeTokens();
    if (r.isFeeRequired) {
      const s = r.tokens.map((c) => c.symbol).join(", ");
      dr.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${s}`);
      const a = await this.getNonce(e);
      if (!this.provider)
        throw dr.warn("[rpc-relayer/getFeeOptions] provider not set, needed for stub signature"), new Error("provider is not set");
      const {
        options: i,
        quote: o
      } = await this.service.feeOptions({
        wallet: e,
        to: e,
        data: se.transaction.encodeBundleExecData({
          entrypoint: e,
          transactions: n,
          nonce: a
        })
      });
      return dr.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(i, Mu)}`), {
        options: i,
        quote: {
          _tag: "FeeQuote",
          _quote: o
        }
      };
    } else
      return dr.info("[rpc-relayer/getFeeOptions] relayer fees are not required"), {
        options: []
      };
  }
  async getFeeOptionsRaw(e, n, r) {
    const {
      options: s,
      quote: a
    } = await this.service.feeOptions({
      wallet: e,
      to: e,
      data: z(n),
      simulate: r == null ? void 0 : r.simulate
    }, Ac({}, r != null && r.projectAccessKey ? {
      "X-Access-Key": r.projectAccessKey
    } : void 0));
    return {
      options: s,
      quote: {
        _tag: "FeeQuote",
        _quote: a
      }
    };
  }
  async gasRefundOptions(e, ...n) {
    const {
      options: r
    } = await this.getFeeOptions(e, ...n);
    return r;
  }
  async getNonce(e, n) {
    dr.info(`[rpc-relayer/getNonce] get nonce for wallet ${e} space: ${n}`);
    const r = n !== void 0 ? ab(BigInt(n)) : void 0, s = await this.service.getMetaTxnNonce({
      walletContractAddress: e,
      space: r
    }), a = BigInt(s.nonce), [i, o] = se.transaction.decodeNonce(a);
    return dr.info(`[rpc-relayer/getNonce] got next nonce for wallet ${e} ${o} space: ${i}`), a;
  }
  async relay(e, n, r = !0, s) {
    var a = this;
    dr.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(e, Mu)} with quote ${JSON.stringify(n, Mu)}`);
    let i;
    if (n !== void 0 && (typeof n._quote == "string" ? i = n._quote : dr.warn("[rpc-relayer/relay] ignoring invalid fee quote")), !this.provider)
      throw dr.warn("[rpc-relayer/relay] provider not set, failed relay"), new Error("provider is not set");
    const o = se.transaction.encodeBundleExecData(e), c = await this.service.sendMetaTxn({
      call: {
        walletAddress: e.intent.wallet,
        contract: e.entrypoint,
        input: o
      },
      quote: i
    }, Ac({}, s ? {
      "X-Access-Key": s
    } : void 0));
    if (dr.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(c, Mu)}`), r)
      return this.wait(e.intent.id);
    {
      const u = {
        hash: e.intent.id,
        confirmations: 0,
        from: e.intent.wallet,
        wait: (d) => Promise.reject(new Error("impossible"))
      }, l = async function(p) {
        var f;
        if (!a.provider)
          throw new Error("cannot wait for receipt, relayer has no provider set");
        const b = await a.wait(e.intent.id), y = (f = b.receipt) == null ? void 0 : f.transactionHash;
        if (!y)
          throw new Error("cannot wait for receipt, unknown native transaction hash");
        return Object.assign(u, b), a.provider.waitForTransaction(y, p);
      };
      return u.wait = l, u;
    }
  }
  async wait(e, n, r = 1e3, s = 5) {
    var a = this;
    let i = !1;
    const {
      receipt: o
    } = await (n !== void 0 ? Promise.race([this.waitReceipt(e, r, s, () => i), new Promise((u, l) => setTimeout(() => {
      i = !0, l(`Timeout waiting for transaction receipt ${e}`);
    }, n))]) : this.waitReceipt(e, r, s));
    if (!o.txnReceipt || fee.includes(o.status))
      throw new hee(o);
    const c = JSON.parse(o.txnReceipt);
    return {
      blockHash: c.blockHash,
      blockNumber: Number(c.blockNumber),
      confirmations: 1,
      from: typeof e == "string" ? void 0 : e.intent.wallet,
      hash: c.transactionHash,
      raw: o.txnReceipt,
      receipt: c,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function(u) {
        return a.provider.waitForTransaction(c.transactionHash, u);
      }
    };
  }
  async getMetaTransactions(e, n) {
    return this.service.getMetaTransactions({
      projectId: e,
      page: n
    });
  }
  async getTransactionCost(e, n, r) {
    return this.service.getTransactionCost({
      projectId: e,
      from: n,
      to: r
    });
  }
  async listGasSponsors(e) {
    return this.service.listGasSponsors(e);
  }
  async addGasSponsor(e) {
    return this.service.addGasSponsor(e);
  }
  async updateGasSponsor(e) {
    return this.service.updateGasSponsor(e);
  }
  async removeGasSponsor(e) {
    return this.service.removeGasSponsor(e);
  }
}
class hee {
  constructor(e) {
    this.receipt = e;
  }
}
function mee(t) {
  return t && typeof t == "object" && typeof t.getNetwork == "function" && typeof t.getBlockNumber == "function";
}
function yee(t) {
  return typeof t == "object" && typeof t.simulate == "function" && typeof t.getFeeOptions == "function" && typeof t.gasRefundOptions == "function" && typeof t.getNonce == "function" && typeof t.relay == "function" && typeof t.wait == "function";
}
function bee(t) {
  return t.getAddress !== void 0 && t.buildDeployTransaction !== void 0 && t.predecorateSignedTransactions !== void 0 && t.decorateTransactions !== void 0 && t.sign !== void 0 && t.notifyStatusChange !== void 0;
}
class gee {
  constructor(e, n = !0) {
    this.signer = e, this.eoa = n;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(e) {
  }
  async predecorateSignedTransactions(e) {
    return [];
  }
  async decorateTransactions(e, n) {
    return e;
  }
  sign(e) {
    return this.signer.signMessage(e);
  }
  notifyStatusChange(e, n, r) {
  }
  suffix() {
    return new Uint8Array([2]);
  }
}
let Bi = /* @__PURE__ */ function(t) {
  return t[t.INITIAL = 0] = "INITIAL", t[t.SIGNING = 1] = "SIGNING", t[t.SIGNED = 2] = "SIGNED", t[t.ERROR = 3] = "ERROR", t;
}({});
function wee(t) {
  return t === void 0 || t.state === Bi.INITIAL || t.state === Bi.SIGNING;
}
class n0 {
  constructor(e, n = n0.randomTag()) {
    this.tag = n, this.observers = [], this.signers = [], this.count = 0, this.setSigners(e);
  }
  static randomTag() {
    return `default-${z(ei(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(e) {
    this.signers = e.map((n) => bee(n) ? n : new gee(n));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function(e) {
      return e.getAddress();
    }));
  }
  subscribe(e) {
    return this.observers.push(e), () => {
      this.observers = this.observers.filter((n) => n !== e);
    };
  }
  async notifyObservers(e, n, r) {
    await Promise.all([...this.signers.map(async function(s) {
      return s.notifyStatusChange(e, n, r);
    }), ...this.observers.map(async function(s) {
      return s(n, r);
    })]);
  }
  async buildDeployTransaction(e) {
    let n;
    for (const r of this.signers) {
      const s = await r.buildDeployTransaction(e);
      n === void 0 ? n = s : s != null && s.transactions && (n.transactions = s.transactions.concat(n.transactions));
    }
    return n;
  }
  async predecorateSignedTransactions(e) {
    const n = [];
    for (const r of this.signers)
      n.push(...await r.predecorateSignedTransactions(e ?? {}));
    return n;
  }
  async decorateTransactions(e, n) {
    for (const r of this.signers)
      e = await r.decorateTransactions(e, n ?? {});
    return e;
  }
  signMessage(e) {
    var n = this;
    const r = this.pullId();
    return new Promise(async function(s) {
      const {
        message: a,
        metadata: i,
        callback: o,
        candidates: c
      } = e, u = {
        ended: !1,
        message: a,
        signers: {}
      };
      let l = i ?? {};
      const d = (y) => {
        l = y, n.notifyObservers(r, u, l);
      }, p = () => {
        try {
          n.notifyObservers(r, u, l);
          const y = Object.entries(u.signers).filter(([g, w]) => wee(w));
          if (o && o(u, d) || y.length === 0) {
            u.ended = !0, s(u), n.notifyObservers(r, u, l);
            return;
          }
        } catch (y) {
          console.error("Error while notifying observers", y);
        }
      };
      let f = n.signers;
      if (c) {
        const y = await Promise.all(n.signers.map(async function(g) {
          return g.getAddress();
        }));
        f = n.signers.filter((g, w) => c.includes(y[w]));
      }
      const b = await Promise.allSettled(f.map(async function(y) {
        const g = await y.getAddress();
        u.signers[g] = {
          state: Bi.SIGNING,
          request: y.sign(a, i ?? {}).then((w) => {
            const k = y.suffix();
            return u.signers[g] = {
              state: Bi.SIGNED,
              signature: w,
              suffix: k
            }, p(), w;
          }).catch((w) => {
            throw u.signers[g] = {
              state: Bi.ERROR,
              error: w
            }, p(), w;
          })
        };
      }));
      for (let y = 0; y < b.length; y++) {
        const g = n.signers[y], w = b[y];
        if (w.status === "rejected") {
          const k = await g.getAddress();
          console.warn(`signer ${k} rejected the request: ${w.reason}`), u.signers[k] = {
            state: Bi.ERROR,
            error: new Error(`signer ${k} rejected the request: ${w.reason}`)
          };
        }
      }
      p();
    });
  }
}
function ma() {
  return ma = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, ma.apply(null, arguments);
}
async function UA(t) {
  return Array.isArray(t) ? Promise.all(t.map((e) => Tt(e))) : Tt(t);
}
const NA = (t) => {
  const e = /* @__PURE__ */ new Map();
  for (const n of Object.keys(t.signers)) {
    const r = t.signers[n];
    if (r.state === Bi.SIGNED) {
      const s = ee(r.suffix), a = Ae(["bytes", "bytes"], [r.signature, s]);
      e.set(n, {
        signature: a,
        isDynamic: s.length !== 1 || s[0] !== 2
      });
    }
  }
  return e;
};
class kc extends sv {
  constructor(e) {
    var n;
    const r = BigInt(e.chainId);
    if (r === 0n && !e.coders.signature.supportsNoChainId)
      throw new Error(`Sequence version ${e.config.version} doesn't support chainId 0`);
    super((n = e.provider) != null ? n : null), this.context = void 0, this.config = void 0, this.address = void 0, this.chainId = void 0, this.relayer = void 0, this.coders = void 0, this.orchestrator = void 0, this._reader = void 0, this.context = e.context, this.config = e.config, this.orchestrator = e.orchestrator, this.coders = e.coders, this.address = e.address, this.chainId = r, this.relayer = e.relayer, this._reader = e.reader;
  }
  static newWallet(e) {
    const n = se.context.addressOf(e.context, e.coders.config.imageHashOf(e.config));
    return new kc(ma({}, e, {
      address: n
    }));
  }
  reader() {
    if (this._reader) return this._reader;
    if (!this.provider) throw new Error("Wallet status provider requires a provider");
    return new se.reader.OnChainReader(this.provider);
  }
  setConfig(e) {
    this.config = e;
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setAddress(e) {
    this.address = e;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(e) {
    const n = await this.orchestrator.decorateTransactions(e);
    if (await this.reader().isDeployed(this.address))
      return n;
    const r = [{
      to: n.entrypoint,
      data: se.transaction.encodeBundleExecData(n),
      revertOnError: !0
    }], s = await this.buildDeployTransaction();
    return s && r.unshift(...s.transactions), {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: n.intent,
      transactions: r
    };
  }
  async buildDeployTransaction(e) {
    if (e != null && e.ignoreDeployed && await this.reader().isDeployed(this.address))
      return;
    const n = this.coders.config.imageHashOf(this.config);
    if (se.context.addressOf(this.context, n) !== this.address)
      throw new Error(`First address of config ${n} doesn't match wallet address ${this.address}`);
    let r;
    switch (this.chainId) {
      case BigInt(v.SKALE_NEBULA):
        r = 10000000n;
        break;
      case BigInt(v.SOMNIA_TESTNET):
        r = 10000000n;
        break;
      case BigInt(v.SOMNIA):
        r = 10000000n;
        break;
    }
    const s = kc.buildDeployTransaction(this.context, n, r);
    if (e != null && e.includeChildren) {
      const a = await this.orchestrator.buildDeployTransaction(e);
      a && (s.transactions = a.transactions.concat(s.transactions));
    }
    return s;
  }
  async deploy(e) {
    const n = await this.buildDeployTransaction(e);
    if (n !== void 0) {
      if (!this.relayer) throw new Error("Wallet deploy requires a relayer");
      return this.relayer.relay(ma({}, n, {
        chainId: this.chainId,
        intent: {
          id: z(ei(32)),
          wallet: this.address
        }
      }));
    }
  }
  static buildDeployTransaction(e, n, r = 100000n) {
    const s = new Qt(qt.factory.abi);
    return {
      entrypoint: e.guestModule,
      transactions: [{
        to: e.factory,
        data: s.encodeFunctionData(s.getFunction("deploy"), [e.mainModule, n]),
        gasLimit: r,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(e) {
    if (this.coders.config.update.isKindUsed) {
      const n = await this.reader().implementation(this.address), r = n && n === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, e, this.context, r ? "later" : "first");
    }
    return this.coders.config.update.buildTransaction(this.address, e, this.context);
  }
  async getNonce(e = 0) {
    const n = await this.reader().nonce(this.address, e);
    if (n === void 0) throw new Error("Unable to determine nonce");
    return Number(n);
  }
  async signDigest(e, n) {
    const r = r2(this.address, this.chainId, e);
    if (this.coders.config.hasSubdigest(this.config, r))
      return this.coders.signature.encodeSigners(this.config, /* @__PURE__ */ new Map(), [r], this.chainId).encoded;
    const s = ma({}, n, {
      // Keep other metadata fields
      digest: e,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    }), a = ee(r), i = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map((c) => c.address),
      message: a,
      metadata: s,
      callback: (c, u) => {
        const l = NA(c), d = ma({}, s, {
          parts: l
        });
        return u(d), this.coders.signature.hasEnoughSigningPower(this.config, l);
      }
    }), o = NA(i);
    return this.coders.signature.encodeSigners(this.config, o, [], this.chainId).encoded;
  }
  signMessage(e) {
    return this.signDigest(ke(e), {
      message: e
    });
  }
  // XXX This method is not implemented in the original code but required by the AbstractSigner interface
  signTypedData(e, n, r) {
    const s = cv({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(s);
  }
  signTransactionBundle(e) {
    if (e.entrypoint !== this.address)
      throw new Error(`Invalid entrypoint: ${e.entrypoint} !== ${this.address}`);
    return this.signTransactions(e.transactions, e.nonce);
  }
  async fetchNonceOrSpace(e) {
    let n;
    if (e && e.space !== void 0)
      n = BigInt(e.space);
    else {
      if (e === void 0)
        return this.randomNonce();
      if (e && e.serial === !0)
        n = 0;
      else
        return e;
    }
    const r = await this.reader().nonce(this.address, n);
    if (r === void 0) throw new Error("Unable to determine nonce");
    return se.transaction.encodeNonce(n, r);
  }
  // Generate nonce with random space
  randomNonce() {
    const e = BigInt(z(ei(12)));
    return se.transaction.encodeNonce(e, 0);
  }
  async signTransactions(e, n, r) {
    const s = await UA(e), a = se.transaction.fromTransactionish(this.address, s);
    a.length === 0 && a.push({
      to: this.address,
      data: "0x",
      value: 0,
      gasLimit: 0,
      delegateCall: !1,
      revertOnError: !0
    });
    const i = await this.fetchNonceOrSpace(n), o = se.transaction.digestOfTransactions(i, a), c = ma({
      digest: o,
      transactions: a
    }, r), u = await this.signDigest(o, c);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: r2(this.address, this.chainId, o),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions: a,
      entrypoint: this.address,
      nonce: i,
      signature: u
    };
  }
  async sendSignedTransaction(e, n) {
    if (!this.relayer) throw new Error("Wallet sendTransaction requires a relayer");
    return this.relayer.relay(e, n);
  }
  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(e, n) {
    let r;
    (n == null ? void 0 : n.nonce) !== void 0 ? r = n.nonce : n != null && n.serial ? r = {
      serial: !0
    } : r = this.randomNonce();
    const s = await this.signTransactions(e, r), a = await this.decorateTransactions(s);
    return this.sendSignedTransaction(a, n == null ? void 0 : n.quote);
  }
  async fillGasLimits(e) {
    const n = await UA(e), r = se.transaction.fromTransactionish(this.address, n), s = this.relayer;
    if (!s) throw new Error("Wallet fillGasLimits requires a relayer");
    const a = await s.simulate(this.address, ...r);
    return r.map((i, o) => {
      const c = i.gasLimit ? Number(i.gasLimit) : a[o].gasLimit;
      return ma({}, i, a[o], {
        gasLimit: c
      });
    });
  }
  connect(e, n) {
    return new kc({
      // Sequence version configurator
      coders: this.coders,
      context: this.context,
      config: this.config,
      chainId: this.chainId,
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this._reader,
      provider: e,
      relayer: n ?? this.relayer
    });
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
}
function Gr() {
  return Gr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Gr.apply(null, arguments);
}
function Eee(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case Oh.FeeTokenType.UNKNOWN:
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.to,
        value: ab(e),
        data: "0x"
      }];
    case Oh.FeeTokenType.ERC20_TOKEN:
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.token.contractAddress,
        value: 0,
        data: new Qt([{
          constant: !1,
          inputs: [{
            type: "address"
          }, {
            type: "uint256"
          }],
          name: "transfer",
          outputs: [],
          type: "function"
        }]).encodeFunctionData("transfer", [t.to, ab(e)])
      }];
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
class xee {
  constructor(e, n, r) {
    this.account = e, this.chainId = n, this.options = r;
  }
  get provider() {
    return this.account.providerFor(this.chainId);
  }
  async getAddress() {
    return this.account.address;
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. The message is already being prefixed with the EIP-191 prefix.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @returns A Promise that resolves to the signature as a hexadecimal string
   *
   * @example
   * ```typescript
   * const signer = account.getSigner(chainId)
   *
   * const message = "Hello, Sequence!";
   * const signature = await signer.signMessage(message);
   * console.log(signature);
   * // => "0x123abc..." (hexadecimal signature)
   */
  signMessage(e) {
    var n, r;
    return this.account.signMessage(e, this.chainId, (n = (r = this.options) == null ? void 0 : r.cantValidateBehavior) != null ? n : "throw");
  }
  signTypedData(e, n, r) {
    var s, a;
    return this.account.signTypedData(e, n, r, this.chainId, (s = (a = this.options) == null ? void 0 : a.cantValidateBehavior) != null ? s : "throw");
  }
  async defaultSelectFee(e, n) {
    if (n.length === 0) return;
    const r = [{
      constant: !0,
      inputs: [{
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        type: "uint256"
      }],
      type: "function"
    }];
    for (const s of n)
      if (s.token.type === Oh.FeeTokenType.UNKNOWN) {
        if (await this.getBalance() >= BigInt(s.value))
          return s;
      } else if (s.token.contractAddress && s.token.type === Oh.FeeTokenType.ERC20_TOKEN && await new rs(s.token.contractAddress, r, this.provider).balanceOf(this.account.address) >= BigInt(s.value))
        return s;
    throw new Error("No fee option available - not enough balance");
  }
  async sendTransaction(e, n) {
    var r, s, a, i, o;
    const c = await this.account.prepareTransactions({
      txs: e,
      chainId: this.chainId,
      stubSignatureOverrides: (r = (s = this.options) == null ? void 0 : s.stubSignatureOverrides) != null ? r : /* @__PURE__ */ new Map(),
      simulateForFeeOptions: n == null ? void 0 : n.simulateForFeeOptions
    }), l = await ((a = (i = this.options) == null ? void 0 : i.selectFee) != null ? a : this.defaultSelectFee.bind(this))(e, c.feeOptions), d = [...c.transactions, ...Eee(l)];
    return this.account.sendTransaction(d, this.chainId, c.feeQuote, void 0, void 0, ((o = this.options) == null ? void 0 : o.nonceSpace) !== void 0 ? {
      nonceSpace: this.options.nonceSpace
    } : void 0);
  }
  getBalance(e) {
    return this.provider.getBalance(this.account.address, e);
  }
  call(e, n) {
    return this.provider.call(Gr({}, e, {
      blockTag: n
    }));
  }
  async resolveName(e) {
    const n = await this.provider.resolveName(e);
    if (!n) throw new Error(`Could not resolve name ${e}`);
    return n;
  }
  connect(e) {
    throw new Error("Method not implemented.");
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
  getTransactionCount(e) {
    throw new Error("Method not implemented.");
  }
  estimateGas(e) {
    throw new Error("Method not implemented.");
  }
  getChainId() {
    return Promise.resolve(Number(this.chainId));
  }
  getGasPrice() {
    throw new Error("Method not implemented.");
  }
  getFeeData() {
    throw new Error("Method not implemented.");
  }
  getNonce(e) {
    throw new Error("Method not implemented.");
  }
  populateCall(e) {
    throw new Error("Method not implemented.");
  }
  checkTransaction(e) {
    throw new Error("Method not implemented.");
  }
  async populateTransaction(e) {
    throw new Error("Method not implemented.");
  }
  _checkProvider(e) {
    throw new Error("Method not implemented.");
  }
}
class Aee {
  async isDeployed(e) {
    return !1;
  }
  async implementation(e) {
  }
  async imageHash(e) {
  }
  async nonce(e, n) {
    return 0n;
  }
  async isValidSignature(e, n, r) {
    throw new Error("Method not supported.");
  }
}
class r0 {
  constructor(e) {
    this.address = void 0, this.networks = void 0, this.tracker = void 0, this.contexts = void 0, this.migrator = void 0, this.migrations = void 0, this.orchestrator = void 0, this.jwt = void 0, this.projectAccessKey = void 0, this.address = de(e.address), this.contexts = e.contexts, this.tracker = e.tracker, this.networks = e.networks, this.orchestrator = e.orchestrator, this.jwt = e.jwt, this.projectAccessKey = e.projectAccessKey, this.migrations = e.migrations || PA.DefaultMigrations, this.migrator = new BA.Migrator(e.tracker, this.migrations, this.contexts);
  }
  getSigner(e, n) {
    return new xee(this, e, n);
  }
  static async new(e) {
    var n;
    const s = new BA.Migrator(e.tracker, (n = e.migrations) != null ? n : PA.DefaultMigrations, e.contexts).lastMigration(), a = s.configCoder, i = a.fromSimple(e.config), o = a.imageHashOf(i), c = e.contexts[s.version], u = se.context.addressOf(c, o);
    return await e.tracker.saveCounterfactualWallet({
      config: i,
      context: Object.values(e.contexts)
    }), new r0({
      address: u,
      tracker: e.tracker,
      contexts: e.contexts,
      networks: e.networks,
      orchestrator: e.orchestrator,
      migrations: e.migrations,
      projectAccessKey: e.projectAccessKey
    });
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  get version() {
    return this.migrator.lastMigration().version;
  }
  get coders() {
    const e = this.migrator.lastMigration();
    return {
      signature: e.signatureCoder,
      config: e.configCoder
    };
  }
  network(e) {
    const n = BigInt(e), r = this.networks.find((s) => n === BigInt(s.chainId));
    if (!r) throw new Error(`Network not found for chainId ${e}`);
    return r;
  }
  providerFor(e) {
    const n = this.network(e);
    if (!n.provider && !n.rpcUrl)
      throw new Error(`Provider not found for chainId ${e}`);
    const r = new Sr(n.name, n.chainId);
    return n.provider || new V1(ov(n.rpcUrl, this.projectAccessKey, this.jwt), r, {
      staticNetwork: r
    });
  }
  reader(e) {
    return BigInt(e) === 0n ? new Aee() : new se.reader.OnChainReader(this.providerFor(e));
  }
  relayer(e) {
    const n = this.network(e);
    if (!n.relayer) throw new Error(`Relayer not found for chainId ${e}`);
    return yee(n.relayer) ? n.relayer : new pee(Gr({}, n.relayer, {
      projectAccessKey: this.projectAccessKey,
      jwtAuth: this.jwt
    }));
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setJwt(e) {
    this.jwt = e;
  }
  contextFor(e) {
    const n = this.contexts[e];
    if (!n) throw new Error(`Context not found for version ${e}`);
    return n;
  }
  walletForStatus(e, n) {
    const r = cn.coderFor(n.version);
    return this.walletFor(e, this.contextFor(n.version), n.config, r);
  }
  walletFor(e, n, r, s) {
    const a = BigInt(e) === 0n;
    return new kc({
      config: r,
      context: n,
      chainId: e,
      coders: s,
      relayer: a ? void 0 : this.relayer(e),
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this.reader(e)
    });
  }
  // Get the status of the account on a given network
  // this does the following process:
  // 1. Get the current on-chain status of the wallet (version + imageHash)
  // 2. Get any pending migrations that have been signed by the wallet
  // 3. Get any pending configuration updates that have been signed by the wallet
  // 4. Fetch reverse lookups for both on-chain and pending configurations
  async status(e, n = !1) {
    var r = this;
    const s = this.reader(e).isDeployed(this.address), a = this.tracker.imageHashOfCounterfactualWallet({
      wallet: this.address
    }).then((A) => {
      if (!A) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
      return A;
    }), i = a.then((A) => QY.counterfactualVersion(this.address, A.imageHash, Object.values(this.contexts))), o = async function() {
      if (!await s) return i;
      const N = await r.reader(e).implementation(r.address);
      if (!N) throw new Error(`Implementation not found for wallet ${r.address}`);
      const D = Object.values(r.contexts);
      for (let P = 0; P < D.length; P++)
        if (D[P].mainModule === N || D[P].mainModuleUpgradable === N)
          return D[P].version;
      throw new Error(`Version not found for implementation ${N}`);
    }(), c = async function() {
      const A = await r.reader(e).imageHash(r.address);
      if (A) return A;
      const N = await a;
      if (N) return N.imageHash;
      throw new Error(`On-chain imageHash not found for wallet ${r.address}`);
    }(), u = async function() {
      const A = await c, N = await r.tracker.configOfImageHash({
        imageHash: A
      });
      if (N) return N;
      throw new Error(`On-chain config not found for imageHash ${A}`);
    }(), l = await o, d = await c;
    let p = d, f = l, b = [];
    if (l !== this.version) {
      const A = await this.migrator.getAllMigratePresignedTransaction({
        address: this.address,
        fromImageHash: d,
        fromVersion: l,
        chainId: e
      });
      p = A.lastImageHash, f = A.lastVersion, b = A.signedMigrations;
    }
    const y = await this.tracker.loadPresignedConfiguration({
      wallet: this.address,
      fromImageHash: p,
      longestPath: n
    }), g = y && y.length > 0 ? y[y.length - 1].nextImageHash : p, w = await this.tracker.configOfImageHash({
      imageHash: g
    });
    if (!w)
      throw new Error(`Config not found for imageHash ${g}`);
    const k = await s, E = await a, T = cn.coderFor(f).config.checkpointOf(w);
    return {
      original: Gr({}, E, {
        version: await i
      }),
      onChain: {
        imageHash: d,
        config: await u,
        version: l,
        deployed: k
      },
      fullyMigrated: f === this.version,
      signedMigrations: b,
      version: f,
      presignedConfigurations: y,
      imageHash: g,
      config: w,
      checkpoint: T,
      canOnchainValidate: l === this.version && k
    };
  }
  mustBeFullyMigrated(e) {
    if (!e.fullyMigrated)
      throw new Error(`Wallet ${this.address} is not fully migrated`);
  }
  async predecorateSignedTransactions(e, n) {
    const r = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), s = await this.predecorateTransactions([], e, n);
    return se.transaction.fromTransactionish(this.address, s).length > 0 && r.push(await this.signTransactions(s, n)), r;
  }
  async predecorateTransactions(e, n, r) {
    if (e = Array.isArray(e) ? e : [e], n.onChain.imageHash !== n.imageHash) {
      const i = await this.walletForStatus(r, n).buildUpdateConfigurationTransaction(n.config);
      e = [...e, ...i.transactions];
    }
    const {
      proxyImplementationHook: s
    } = this.contexts[n.config.version];
    if (s && (r === v.IMMUTABLE_ZKEVM || r === v.IMMUTABLE_ZKEVM_TESTNET)) {
      const a = this.providerFor(r);
      if (a) {
        const i = new rs(this.address, qt.walletProxyHook.abi, a);
        let o;
        try {
          o = await i.PROXY_getImplementation();
        } catch (c) {
          console.log("Error getting implementation address", c);
        }
        if (!o || o === ti) {
          console.log("Adding wallet proxy hook");
          const c = new Qt(qt.moduleHooks.abi);
          e = [{
            to: this.address,
            data: c.encodeFunctionData(c.getFunction("addHook"), ["0x90611127", s]),
            gasLimit: 5e4,
            // Expected ~28k gas. Buffer added
            delegateCall: !1,
            revertOnError: !1,
            value: 0
          }, ...e];
        }
      }
    }
    return e;
  }
  async decorateTransactions(e, n, r) {
    var s, a;
    if (!Array.isArray(e))
      return this.decorateTransactions([e], n, r);
    r = (s = r) != null ? s : e[0].chainId;
    const i = await this.buildBootstrapTransactions(n, r), o = i.transactions.length > 0;
    if (!o && e.length === 1)
      return e[0];
    const {
      entrypoint: c
    } = o ? i : e[0], u = {
      entrypoint: c,
      chainId: r,
      // Intent of the first bundle is used
      intent: (a = e[0]) == null ? void 0 : a.intent,
      transactions: [...i.transactions, ...e.map((l) => ({
        to: l.entrypoint,
        data: se.transaction.encodeBundleExecData(l),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }))]
    };
    if (!n.onChain.deployed) {
      const l = se.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, r, u.transactions);
      u.intent === void 0 ? u.intent = {
        id: l,
        wallet: this.address
      } : u.intent.id = l;
    }
    return u;
  }
  async decorateSignature(e, n) {
    if (!n.presignedConfigurations || n.presignedConfigurations.length === 0)
      return e;
    const r = this.coders.signature, s = n.presignedConfigurations.map((i) => i.signature), a = r.chainSignatures(e, s);
    return r.trim(a);
  }
  async publishWitnessFor(e, n = 0) {
    const r = is(`This is a Sequence account woo! ${Date.now()}`), s = await this.status(n), a = this.coders.config.fromSimple({
      threshold: e.length,
      checkpoint: 0,
      signers: e.map((l) => ({
        address: l,
        weight: 1
      }))
    }), o = await this.walletFor(n, s.original.context, a, this.coders).signDigest(r), c = this.coders.signature.decode(o), u = this.coders.signature.signaturesOfDecoded(c);
    if (u.length === 0)
      throw new Error("No signatures found");
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: r,
      chainId: n,
      signatures: u
    });
  }
  async publishWitness() {
    const e = is(`This is a Sequence account woo! ${Date.now()}`), n = await this.signDigest(e, 0, !1), r = this.coders.signature.decode(n), s = this.coders.signature.signaturesOfDecoded(r);
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: e,
      chainId: 0,
      signatures: s
    });
  }
  async signDigest(e, n, r = !0, s = "ignore", a) {
    const i = BigInt(n) === 0n ? this.networks[0].chainId : n, o = await this.status(i);
    if (this.mustBeFullyMigrated(o), !o.canOnchainValidate && s === "throw")
      throw new Error("Wallet cannot validate onchain");
    const u = await this.walletForStatus(n, o).signDigest(e, a), l = r ? this.decorateSignature(u, o) : u;
    if (!o.canOnchainValidate)
      switch (s) {
        case "ignore":
          return l;
        case "eip6492":
          return this.buildEIP6492Signature(await l, o, n);
      }
    return l;
  }
  buildOnChainSignature(e) {
    const n = se.signature.subdigestOf({
      digest: z(e),
      chainId: 0,
      address: this.address
    }), r = z(n), s = this.coders.config.fromSimple({
      // Threshold *only* needs to be > 0, this is not a magic number
      // we only use 2 ** 15 because it may lead to lower gas costs in some chains
      threshold: 32768,
      checkpoint: 0,
      signers: [],
      subdigests: [r]
    }), a = new Qt(qt.mainModule.abi), i = {
      entrypoint: this.address,
      transactions: [{
        to: this.address,
        data: a.encodeFunctionData(
          // *NEVER* use updateImageHash here, as it would effectively destroy the wallet
          // setExtraImageHash sets an additional imageHash, without changing the current one
          "setExtraImageHash",
          [
            this.coders.config.imageHashOf(s),
            // 2 ** 255 instead of max uint256, to have more zeros in the calldata
            "57896044618658097711785492504343953926634992332820282019728792003956564819968"
          ]
        ),
        // Conservative gas limit, used because the current relayer
        // has trouble estimating gas for this transaction
        gasLimit: 25e4
      }]
    };
    this.tracker.saveWalletConfig({
      config: s
    });
    const o = this.coders.signature.encodeSigners(s, /* @__PURE__ */ new Map(), [r], 0).encoded;
    return {
      bundle: i,
      signature: o
    };
  }
  async buildEIP6492Signature(e, n, r) {
    const s = await this.buildBootstrapTransactions(n, r);
    if (s.transactions.length === 0)
      throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
    const a = Wt.defaultAbiCoder().encode(["address", "bytes", "bytes"], [s.entrypoint, se.transaction.encodeBundleExecData(s), e]);
    return Ae(["bytes", "bytes32"], [a, se.EIP6492.EIP_6492_SUFFIX]);
  }
  async editConfig(e) {
    const n = await this.status(0).then((s) => s.config), r = this.coders.config.editConfig(n, Gr({}, e, {
      checkpoint: this.coders.config.checkpointOf(n) + 1n
    }));
    return this.updateConfig(r);
  }
  async updateConfig(e) {
    if (!this.coders.config.isWalletConfig(e))
      throw new Error(`Invalid config for wallet ${this.address}`);
    const n = this.coders.config.imageHashOf(e), r = this.coders.signature.hashSetImageHash(n), s = await this.signDigest(r, 0, !1);
    await this.tracker.savePresignedConfiguration({
      wallet: this.address,
      nextConfig: e,
      signature: s,
      referenceChainId: 1
    });
    const a = await this.tracker.configOfImageHash({
      imageHash: n,
      noCache: !0
    });
    if (!a || this.coders.config.imageHashOf(a) !== n)
      throw Error(`Reverse lookup failed for imageHash ${n}`);
  }
  /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */
  async buildBootstrapTransactions(e, n) {
    var r;
    const s = await this.orchestrator.buildDeployTransaction({
      chainId: n
    }), a = (r = s == null ? void 0 : s.transactions) != null ? r : [];
    if (!e.onChain.deployed) {
      let c;
      switch (BigInt(n)) {
        case BigInt(v.SKALE_NEBULA):
          c = 10000000n;
          break;
        case BigInt(v.SOMNIA_TESTNET):
          c = 10000000n;
          break;
        case BigInt(v.SOMNIA):
          c = 10000000n;
          break;
      }
      const u = kc.buildDeployTransaction(e.original.context, e.original.imageHash, c);
      a.push(...u.transactions);
    }
    a.push(...e.signedMigrations.map((c) => ({
      to: c.tx.entrypoint,
      data: se.transaction.encodeBundleExecData(c.tx),
      value: 0,
      gasLimit: 0,
      revertOnError: !0,
      delegateCall: !1
    })));
    const i = e.signedMigrations.length > 0 ? e.signedMigrations[0].tx.intent.id : se.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, n, a), {
      guestModule: o
    } = this.contextFor(e.version);
    return {
      entrypoint: o,
      transactions: a,
      chainId: n,
      intent: {
        id: i,
        wallet: this.address
      }
    };
  }
  async bootstrapTransactions(e, n) {
    const r = n || await this.status(e);
    return this.buildBootstrapTransactions(r, e);
  }
  async doBootstrap(e, n, r) {
    const s = await this.bootstrapTransactions(e, r);
    return this.relayer(e).relay(Gr({}, s, {
      chainId: e
    }), n);
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. If the message is already prefixed with the EIP-191
   * prefix, it will be hashed directly. Otherwise, it will be prefixed before hashing.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @param chainId - The chain ID to use for signing
   * @param cantValidateBehavior - Behavior when the wallet cannot validate on-chain
   * @returns A Promise that resolves to the signature as a hexadecimal string
   */
  signMessage(e, n, r = "ignore") {
    const s = z(e), a = z(kn(e8));
    let i;
    return s.substring(2).startsWith(a.substring(2)) ? i = ke(e) : i = S8(e), this.signDigest(i, n, !0, r);
  }
  async signTransactions(e, n, r, s) {
    const a = r || await this.status(n);
    this.mustBeFullyMigrated(a);
    const i = this.walletForStatus(n, a), o = {
      address: this.address,
      digest: "",
      // Set in wallet.signTransactions
      chainId: n,
      config: {
        version: this.version
      },
      decorate: !0,
      cantValidateBehavior: "ignore"
    }, c = s != null && s.serial ? {
      serial: !0
    } : (s == null ? void 0 : s.nonceSpace) !== void 0 ? {
      space: s.nonceSpace
    } : void 0, u = await i.signTransactions(e, c, o);
    return Gr({}, u, {
      signature: await this.decorateSignature(u.signature, a)
    });
  }
  async signMigrations(e, n) {
    const r = await this.status(e);
    if (r.fullyMigrated) return !1;
    const s = this.walletForStatus(e, r), a = n(s.config), i = await this.migrator.signNextMigration(this.address, r.version, s, a);
    if (!i) return !1;
    await this.tracker.saveWalletConfig({
      config: a
    });
    const o = cn.coderFor(a.version).config, c = o.imageHashOf(a), u = await this.tracker.configOfImageHash({
      imageHash: c,
      noCache: !0
    });
    if (!u || o.imageHashOf(u) !== c)
      throw Error(`Reverse lookup failed for imageHash ${c}`);
    return await this.tracker.saveMigration(this.address, i, this.contexts), !0;
  }
  async signAllMigrations(e) {
    var n = this;
    const r = [];
    return {
      signedMigrations: (await Promise.all(this.networks.map(async function(i) {
        try {
          return await n.signMigrations(i.chainId, e);
        } catch (o) {
          return console.warn(`Failed to sign migrations for chain ${i.chainId}`, o), r.push(i.chainId), null;
        }
      }))).filter((i) => i !== null),
      failedChains: r
    };
  }
  async isMigratedAllChains() {
    var e = this;
    const n = [];
    return {
      migratedAllChains: (await Promise.all(this.networks.map(async function(a) {
        try {
          return await e.status(a.chainId);
        } catch (i) {
          return n.push(a.chainId), console.warn(`Failed to get status for chain ${a.chainId}`, i), {
            fullyMigrated: !0
          };
        }
      }))).every((a) => a.fullyMigrated),
      failedChains: n
    };
  }
  async sendSignedTransactions(e, n, r, s, a, i) {
    if (!Array.isArray(e))
      return this.sendSignedTransactions([e], n, r, s, a, i);
    const o = s || await this.status(n);
    this.mustBeFullyMigrated(o);
    const c = await this.decorateTransactions(e, o, n);
    return a == null || a(c), this.relayer(n).relay(c, r, void 0, i);
  }
  async fillGasLimits(e, n, r) {
    return this.walletForStatus(n, r || await this.status(n)).fillGasLimits(e);
  }
  async gasRefundQuotes(e, n, r, s, a) {
    const i = s || await this.status(n), o = this.walletForStatus(n, i), c = await this.predecorateTransactions(e, i, n), u = se.transaction.fromTransactionish(this.address, c), l = o.coders.config.buildStubSignature(o.config, r), d = z(ei(32)), p = {
      chainId: n,
      intent: {
        id: d,
        wallet: this.address
      },
      signature: l,
      transactions: u,
      entrypoint: this.address,
      nonce: 0
      // The relayer also ignored the nonce
    }, f = await this.decorateTransactions(p, i), b = se.transaction.encodeBundleExecData(f), y = await this.relayer(n).getFeeOptionsRaw(f.entrypoint, b, a);
    return Gr({}, y, {
      decorated: f
    });
  }
  async prepareTransactions(e) {
    const n = await this.status(e.chainId), r = await this.fillGasLimits(e.txs, e.chainId, n), s = await this.gasRefundQuotes(r, e.chainId, e.stubSignatureOverrides, n, {
      simulate: e.simulateForFeeOptions,
      projectAccessKey: e.projectAccessKey
    }), a = se.transaction.unwind(this.address, s.decorated.transactions);
    return {
      transactions: r,
      flatDecorated: a,
      feeOptions: s.options,
      feeQuote: s.quote
    };
  }
  async sendTransaction(e, n, r, s = !1, a, i) {
    const o = await this.status(n), c = s ? e : await this.predecorateTransactions(e, o, n), l = se.transaction.fromTransactionish(this.address, c).length > 0 ? await this.signTransactions(c, n, void 0, i) : void 0, d = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), p = [];
    return l !== void 0 && l.transactions.length > 0 && p.push(l), p.push(...d.filter((f) => f.transactions.length > 0)), this.sendSignedTransactions(p, n, r, void 0, a, i == null ? void 0 : i.projectAccessKey);
  }
  async signTypedData(e, n, r, s, a = "ignore") {
    const i = cv({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(i, s, !0, a);
  }
  async getSigners() {
    var e = this;
    const n = (r) => r.length ? r[r.length - 1] : void 0;
    return (await Promise.all(this.networks.map(async function({
      chainId: r,
      name: s
    }) {
      try {
        var a;
        const i = await e.status(r);
        let o = (a = n(i.presignedConfigurations)) == null ? void 0 : a.nextImageHash;
        if (!o && i.onChain.version !== i.version) {
          const d = n(i.signedMigrations);
          if (d) {
            const {
              toVersion: p,
              toConfig: f
            } = d;
            o = cn.genericCoderFor(p).config.imageHashOf(f);
          }
        }
        o || (o = i.onChain.imageHash);
        const c = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!c)
          throw new Error(`unable to find config for image hash ${o}`);
        return cn.genericCoderFor(c.version).config.signersOf(c).map((d) => Gr({}, d, {
          network: r
        }));
      } catch (i) {
        return console.warn(`unable to get signers on network ${r} ${s}`, i), [];
      }
    }))).flat();
  }
  async getAllSigners() {
    var e = this;
    const n = [];
    return await Promise.all(this.networks.map(async function(r) {
      const s = r.chainId, a = await e.status(s, !0), i = [a.onChain.imageHash, ...a.onChain.version !== a.version ? a.signedMigrations.map((o) => cn.coderFor(o.toVersion).config.imageHashOf(o.toConfig)) : [], ...a.presignedConfigurations.map((o) => o.nextImageHash)];
      return Promise.all(i.map(async function(o, c) {
        const u = c === i.length - 1, l = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!l) {
          console.warn(`AllSigners may be incomplete, config not found for imageHash ${o}`);
          return;
        }
        cn.genericCoderFor(l.version).config.signersOf(l).forEach((f) => {
          const b = n.find((y) => y.address === f.address && y.network === s);
          if (b && u && b.flaggedForRemoval) {
            b.flaggedForRemoval = !1;
            return;
          }
          b || n.push({
            address: f.address,
            weight: f.weight,
            network: s,
            flaggedForRemoval: !u
          });
        });
      }));
    })), n;
  }
}
function kee(t, e) {
  const n = t.replace("ipfs://ipfs/", "").replace("ipfs://", "");
  return t.startsWith("ipfs://") ? `${e}${n}` : t;
}
function vee(t) {
  return t.startsWith("ipfs://");
}
class gS {
  constructor(e, n, r = 1e3) {
    this.provider = e, this.solver = n, this.window = r, this.pending = /* @__PURE__ */ new Map();
  }
  async runByEIP5719(e, n, r) {
    const s = `${e}-${n}-${r}`, a = Date.now();
    if (this.pending.has(s) && a - this.pending.get(s).timestamp < this.window)
      return this.pending.get(s).promise;
    const i = wS(e, this.provider, n, r, this.solver);
    return this.pending.set(s, {
      timestamp: a,
      promise: i
    }), i;
  }
}
function Cee(t, e) {
  const n = [{
    inputs: [{
      internalType: "bytes32",
      type: "bytes32"
    }],
    name: "getAlternativeSignature",
    outputs: [{
      internalType: "string",
      type: "string"
    }],
    stateMutability: "view",
    type: "function"
  }];
  return new rs(t, n, e);
}
async function Tee(t) {
  try {
    return await t;
  } catch {
    return;
  }
}
async function wS(t, e, n, r, s, a = 0) {
  if (a > 10) throw new Error("EIP5719 - Too many tries");
  if (se.signer.canRecover(r)) {
    const c = se.signer.recoverSigner(n, r);
    if (c && c.toLowerCase() === t.toLowerCase()) return r;
  }
  try {
    if (await se.signer.isValidSignature(t, n, r, e))
      return r;
  } catch {
  }
  const i = await Tee(Cee(t, e).getAlternativeSignature(n));
  if (!i || i === "") throw new Error("EIP5719 - Invalid signature and no alternative signature");
  const o = z(await (s || new See()).resolve(i));
  if (!o || o === "") throw new Error("EIP5719 - Empty alternative signature");
  if (o === z(r))
    throw new Error("EIP5719 - Alternative signature is invalid or the same");
  return wS(t, e, n, o, s, a + 1);
}
class See {
  constructor(e = "https://cloudflare-ipfs.com/ipfs/") {
    var n = this;
    this.gateway = e, this.uri = (r) => vee(r) ? kee(r, this.gateway) : r, this.resolve = async function(r) {
      const s = n.uri(r), a = await fetch(s);
      if (!a.ok) throw new Error(`URISolverIPFS - Failed to fetch ${s}`);
      return await a.text();
    };
  }
}
const Iee = (t, e) => e.some((n) => t instanceof n);
let RA, DA;
function Oee() {
  return RA || (RA = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function Bee() {
  return DA || (DA = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const ES = /* @__PURE__ */ new WeakMap(), l1 = /* @__PURE__ */ new WeakMap(), xS = /* @__PURE__ */ new WeakMap(), Y0 = /* @__PURE__ */ new WeakMap(), uE = /* @__PURE__ */ new WeakMap();
function Pee(t) {
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("success", a), t.removeEventListener("error", i);
    }, a = () => {
      n(Xa(t.result)), s();
    }, i = () => {
      r(t.error), s();
    };
    t.addEventListener("success", a), t.addEventListener("error", i);
  });
  return e.then((n) => {
    n instanceof IDBCursor && ES.set(n, t);
  }).catch(() => {
  }), uE.set(e, t), e;
}
function Uee(t) {
  if (l1.has(t))
    return;
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("complete", a), t.removeEventListener("error", i), t.removeEventListener("abort", i);
    }, a = () => {
      n(), s();
    }, i = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), s();
    };
    t.addEventListener("complete", a), t.addEventListener("error", i), t.addEventListener("abort", i);
  });
  l1.set(t, e);
}
let u1 = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return l1.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || xS.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Xa(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function Nee(t) {
  u1 = t(u1);
}
function Ree(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(ey(this), e, ...n);
    return xS.set(r, e.sort ? e.sort() : [e]), Xa(r);
  } : Bee().includes(t) ? function(...e) {
    return t.apply(ey(this), e), Xa(ES.get(this));
  } : function(...e) {
    return Xa(t.apply(ey(this), e));
  };
}
function Dee(t) {
  return typeof t == "function" ? Ree(t) : (t instanceof IDBTransaction && Uee(t), Iee(t, Oee()) ? new Proxy(t, u1) : t);
}
function Xa(t) {
  if (t instanceof IDBRequest)
    return Pee(t);
  if (Y0.has(t))
    return Y0.get(t);
  const e = Dee(t);
  return e !== t && (Y0.set(t, e), uE.set(e, t)), e;
}
const ey = (t) => uE.get(t);
function Fee(t, e, { blocked: n, upgrade: r, blocking: s, terminated: a } = {}) {
  const i = indexedDB.open(t, e), o = Xa(i);
  return r && i.addEventListener("upgradeneeded", (c) => {
    r(Xa(i.result), c.oldVersion, c.newVersion, Xa(i.transaction), c);
  }), n && i.addEventListener("blocked", (c) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    c.oldVersion,
    c.newVersion,
    c
  )), o.then((c) => {
    a && c.addEventListener("close", () => a()), s && c.addEventListener("versionchange", (u) => s(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
const Mee = ["get", "getKey", "getAll", "getAllKeys", "count"], Lee = ["put", "add", "delete", "clear"], ty = /* @__PURE__ */ new Map();
function FA(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (ty.get(e))
    return ty.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, s = Lee.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(s || Mee.includes(n))
  )
    return;
  const a = async function(i, ...o) {
    const c = this.transaction(i, s ? "readwrite" : "readonly");
    let u = c.store;
    return r && (u = u.index(o.shift())), (await Promise.all([
      u[n](...o),
      s && c.done
    ]))[0];
  };
  return ty.set(e, a), a;
}
Nee((t) => ({
  ...t,
  get: (e, n, r) => FA(e, n) || t.get(e, n, r),
  has: (e, n) => !!FA(e, n) || t.has(e, n)
}));
function ds() {
  return ds = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, ds.apply(null, arguments);
}
const Hee = ["function execute((bool delegateCall, bool revertOnError, uint256 gasLimit, address target, uint256 value, bytes data)[] calldata transactions, uint256 nonce, bytes calldata signature)"], wo = {
  namespace: "Sequence-Sessions",
  owners: ["AZ6R2mG8zxW9q7--iZXGrBknjegHoPzmG5IG-nxvMaM"],
  arweaveUrl: "https://arweave.net",
  graphqlUrl: "https://arweave.net/graphql",
  eip5719Provider: void 0,
  rateLimitRetryDelayMs: 5 * 60 * 1e3
};
class _ee {
  constructor(e = wo) {
    this.options = e, this.configs = /* @__PURE__ */ new Map(), this.eip5719 = void 0, e.eip5719Provider && (this.eip5719 = new gS(e.eip5719Provider));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = de(e.wallet), s = await this.configOfImageHash({
      imageHash: e.fromImageHash
    });
    if (!s)
      throw new Error(`unable to find from config ${e.fromImageHash}`);
    if (!fe.config.isWalletConfig(s))
      throw new Error(`from config ${e.fromImageHash} is not v2`);
    const a = BigInt(s.checkpoint), i = Object.entries(await Iu({
      Type: "config update",
      Wallet: r
    }, this.options)).flatMap(([l, d]) => {
      try {
        const {
          Signer: p,
          Subdigest: f,
          Digest: b,
          "To-Config": y
        } = d;
        let g;
        switch (d["Signature-Type"]) {
          case "eip-712":
          case "eth_sign":
          case "erc-1271":
            g = d["Signature-Type"];
            break;
          default:
            throw new Error(`unknown signature type ${d["Signature-Type"]}`);
        }
        let w;
        try {
          w = BigInt(d["To-Checkpoint"]);
        } catch {
          throw new Error(`to checkpoint is not a number: ${d["To-Checkpoint"]}`);
        }
        if (w <= a)
          return [];
        if (!Ex(p))
          throw new Error(`signer is not an address: ${p}`);
        if (!Re(f, 32))
          throw new Error(`subdigest is not a hash: ${f}`);
        if (!Re(b, 32))
          throw new Error(`digest is not a hash: ${b}`);
        let k;
        try {
          k = BigInt(d["Chain-ID"]);
        } catch {
          throw new Error(`chain id is not a number: ${d["Chain-ID"]}`);
        }
        if (!Re(y, 32))
          throw new Error(`to config is not a hash: ${y}`);
        return [{
          id: l,
          signatureType: g,
          signer: p,
          subdigest: f,
          digest: b,
          chainId: k,
          toImageHash: y,
          toCheckpoint: w
        }];
      } catch (p) {
        return console.warn(`invalid wallet ${r} config update ${l}:`, p), [];
      }
    }), o = /* @__PURE__ */ new Map();
    let c = [];
    for (const l of i) {
      let d = o.get(l.toImageHash);
      d || (d = /* @__PURE__ */ new Map(), o.set(l.toImageHash, d), c.push(l)), d.set(l.signer, l);
    }
    e.longestPath ? c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? -1 : 1) : c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? 1 : -1);
    const u = [];
    for (let l = s; c.length; ) {
      const d = fe.config.imageHash(l);
      let p, f, b = [];
      for (const g of c) {
        f = o.get(g.toImageHash), b = Array.from(f.keys());
        const {
          weight: w
        } = fe.signature.encodeSigners(l, new Map(b.map((k) => [k, {
          signature: "0x",
          isDynamic: !1
        }])), [], 0);
        if (w >= BigInt(l.threshold)) {
          p = g;
          break;
        }
      }
      if (!p) {
        console.warn(`unreachable configs with checkpoint > ${l.checkpoint} from config ${d}`);
        break;
      }
      const y = p.toImageHash;
      try {
        const g = await this.configOfImageHash({
          imageHash: y
        });
        if (!g)
          throw new Error(`unable to find config ${y}`);
        if (!fe.config.isWalletConfig(g))
          throw new Error(`config ${y} is not v2`);
        const w = new Map((await Promise.all(b.map(async function(T) {
          const {
            id: A,
            subdigest: N,
            signatureType: D
          } = f.get(T);
          try {
            let P = await (await hp(A, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).text();
            switch (D) {
              case "eip-712":
                P += "01";
                break;
              case "eth_sign":
                P += "02";
                break;
              case "erc-1271":
                P += "03";
                break;
            }
            if (n.eip5719)
              try {
                P = z(await n.eip5719.runByEIP5719(T, N, P));
              } catch {
                console.warn(`unable to run eip-5719 on config update ${A}`);
              }
            const C = se.signer.tryRecoverSigner(N, P);
            return [[T, {
              signature: P,
              isDynamic: C !== T
            }]];
          } catch (P) {
            return console.warn(`unable to fetch signer ${T} config update ${A}:`, P), [];
          }
        }))).flat()), {
          encoded: k,
          weight: E
        } = fe.signature.encodeSigners(l, w, [], 0);
        if (E < BigInt(l.threshold))
          throw new Error(`insufficient signing power ${E.toString()} < ${l.threshold}`);
        u.push({
          wallet: r,
          signature: k,
          nextImageHash: y
        }), l = g, c = c.filter(({
          toCheckpoint: T
        }) => T > BigInt(l.checkpoint));
      } catch (g) {
        console.warn(`unable to reconstruct wallet ${r} update from config ${d} to config ${y}:`, g), c = c.filter(({
          toImageHash: w
        }) => w !== y);
      }
    }
    return u;
  }
  savePresignedConfiguration(e) {
    throw new Error("arweave backend does not support saving config updates");
  }
  saveWitnesses(e) {
    throw new Error("arweave backend does not support saving signatures");
  }
  async configOfImageHash(e) {
    var n = this;
    if (!e.noCache) {
      const s = this.configs.get(e.imageHash);
      if (s)
        try {
          return await s;
        } catch {
          const i = this.configs.get(e.imageHash);
          if (i)
            return i;
        }
    }
    const r = async function(s) {
      const a = Object.entries(await Iu({
        Type: "config",
        Config: s
      }, n.options)).flatMap(([i, o]) => {
        try {
          const c = Number(o.Version);
          if (!c)
            throw new Error(`invalid version: ${o.Version}`);
          return [{
            id: i,
            version: c
          }];
        } catch (c) {
          return console.warn(`config ${s} at ${i} invalid:`, c), [];
        }
      });
      switch (a.length) {
        case 0:
          n.configs.set(s, Promise.resolve(void 0));
          return;
        case 1:
          break;
        default:
          console.warn(`multiple configs ${s} at ${a.map(({
            id: i
          }) => i).join(", ")}`);
          break;
      }
      for (const {
        id: i,
        version: o
      } of a)
        try {
          const c = ds({}, await (await hp(i, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).json(), {
            version: o
          });
          c.tree && (c.tree = rc(c.tree));
          const u = cn.coderFor(o).config.imageHashOf(c);
          if (u !== s)
            throw new Error(`image hash is ${u}, expected ${s}`);
          return n.configs.set(s, Promise.resolve(c)), c;
        } catch (c) {
          console.warn(`config at ${i} invalid:`, c);
        }
      n.configs.set(s, Promise.resolve(void 0));
    }(e.imageHash);
    return e.noCache || this.configs.set(e.imageHash, r), r;
  }
  saveWalletConfig(e) {
    throw new Error("arweave backend does not support saving configs");
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = de(e.wallet), r = Object.entries(await Iu({
      Type: "wallet",
      Wallet: n
    }, this.options)).flatMap(([s, a]) => {
      try {
        const {
          "Deploy-Config": i
        } = a, o = Number(a["Deploy-Version"]);
        if (!o)
          throw new Error(`invalid version: ${a["Deploy-Version"]}`);
        if (!i)
          throw new Error("no deploy config");
        const c = se.context.defaultContexts[o];
        if (!c)
          throw new Error(`unknown version: ${o}`);
        if (se.context.addressOf(c, i) !== n)
          throw new Error(`incorrect v${o} deploy config: ${i}`);
        return [{
          id: s,
          imageHash: i,
          context: c
        }];
      } catch (i) {
        return console.warn(`wallet ${n} at ${s} invalid:`, i), [];
      }
    });
    switch (r.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple deploy configs for wallet ${n} at ${r.map(({
          id: s
        }) => s).join(", ")}, using first`);
        break;
    }
    return r[0];
  }
  saveCounterfactualWallet(e) {
    throw new Error("arweave backend does not support saving wallets");
  }
  async walletsOfSigner(e) {
    var n = this;
    const r = de(e.signer), s = /* @__PURE__ */ new Map();
    for (const [a, i] of Object.entries(await Iu({
      Type: ["signature", "config update"],
      Signer: r,
      Witness: e.allSignatures ? void 0 : "true"
    }, this.options))) {
      const {
        Wallet: o,
        Subdigest: c,
        Digest: u,
        "Chain-ID": l
      } = i;
      try {
        if (s.has(o))
          continue;
        let d;
        switch (i["Signature-Type"]) {
          case "eip-712":
            d = "01";
            break;
          case "eth_sign":
            d = "02";
            break;
          case "erc-1271":
            d = "03";
            break;
          default:
            throw new Error(`unknown signature type ${i["Signature-Type"]}`);
        }
        if (c !== se.signature.subdigestOf({
          digest: u,
          chainId: l,
          address: o
        }))
          throw new Error("incorrect subdigest");
        const p = hp(a, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then(async function(f) {
          const b = await f.text() + d;
          if (n.eip5719)
            try {
              return z(await n.eip5719.runByEIP5719(r, c, b));
            } catch {
              console.warn(`unable to run eip-5719 on signature ${a}`);
            }
          return b;
        });
        s.set(o, {
          digest: u,
          chainId: BigInt(l),
          signature: p
        });
      } catch (d) {
        console.warn(`signer ${r} signature ${a} of wallet ${o} invalid:`, d);
      }
    }
    return Promise.all([...s.entries()].map(async function([a, {
      digest: i,
      chainId: o,
      signature: c
    }]) {
      return {
        wallet: a,
        proof: {
          digest: i,
          chainId: o,
          signature: await c
        }
      };
    }));
  }
  async getMigration(e, n, r, s) {
    const a = de(e), i = Object.entries(await Iu({
      Type: "migration",
      Migration: a,
      "Chain-ID": BigInt(s).toString(),
      "From-Version": `${r}`,
      "From-Config": n
    }, this.options)).flatMap(([E, T]) => {
      try {
        const {
          "To-Config": A,
          Executor: N
        } = T, D = Number(T["To-Version"]);
        if (!D)
          throw new Error(`invalid version: ${T["To-Version"]}`);
        if (!Re(A, 32))
          throw new Error(`to config is not a hash: ${A}`);
        if (!Ex(N))
          throw new Error(`executor is not an address: ${N}`);
        return {
          id: E,
          toVersion: D,
          toImageHash: A,
          executor: N
        };
      } catch (A) {
        return console.warn(`chain ${s} migration ${E} for v${r} wallet ${a} from config ${n} invalid:`, A), [];
      }
    });
    switch (i.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple chain ${s} migrations for v${r} wallet ${a} from config ${n} at ${i.map(({
          id: E
        }) => E).join(", ")}, using first`);
        break;
    }
    const {
      id: o,
      toVersion: c,
      toImageHash: u,
      executor: l
    } = i[0], [d, p] = await Promise.all([hp(o, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then((E) => E.text()), this.configOfImageHash({
      imageHash: u
    })]);
    if (!p)
      throw new Error(`unable to find to config ${u} for migration`);
    const f = new Qt(Hee), [b, y, g] = f.decodeFunctionData("execute", d), w = se.transaction.fromTxAbiEncode(b), k = se.transaction.subdigestOfTransactions(a, s, y, w);
    return {
      tx: {
        entrypoint: l,
        transactions: w,
        nonce: y,
        chainId: s,
        intent: {
          id: k,
          wallet: a
        },
        signature: g
      },
      fromVersion: r,
      toVersion: Number(c),
      toConfig: p
    };
  }
  saveMigration(e, n, r) {
    throw new Error("arweave backend does not support saving migrations");
  }
}
async function Iu(t, e) {
  var n, r, s, a;
  const i = (n = e == null ? void 0 : e.namespace) != null ? n : wo.namespace, o = e == null ? void 0 : e.owners, c = (r = e == null ? void 0 : e.graphqlUrl) != null ? r : wo.graphqlUrl, u = (s = e == null ? void 0 : e.rateLimitRetryDelayMs) != null ? s : wo.rateLimitRetryDelayMs, l = (a = e == null ? void 0 : e.pageSize) != null ? a : 100, d = e == null ? void 0 : e.maxResults, p = Object.entries(t).flatMap(([b, y]) => y === void 0 ? [] : [`{ name: "${i ? `${i}-${b}` : b}", values: [${typeof y == "string" ? `"${y}"` : y.map((g) => `"${g}"`).join(", ")}] }`]), f = [];
  for (let b = !0; b && (d === void 0 || f.length < d); ) {
    const y = `
      query {
        transactions(sort: HEIGHT_DESC, ${f.length ? `first: ${l}, after: "${f[f.length - 1].cursor}"` : `first: ${l}`}, tags: [${p.join(", ")}]${o === void 0 ? "" : `, owners: [${o.map((k) => `"${k}"`).join(", ")}]`}) {
          pageInfo {
            hasNextPage
          }
          edges {
            cursor
            node {
              id
              tags {
                name
                value
              }
            }
          }
        }
      }
    `;
    let g;
    for (; g = await fetch(c, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: y
      }),
      redirect: "follow"
    }), g.status === 429; )
      console.warn(`rate limited by ${c}, trying again in ${u / 1e3} seconds at ${new Date(Date.now() + u).toLocaleTimeString()}`), await new Promise((k) => setTimeout(k, u));
    const {
      data: {
        transactions: w
      }
    } = await g.json();
    f.push(...w.edges), b = w.pageInfo.hasNextPage;
  }
  return Object.fromEntries(f.map(({
    node: {
      id: b,
      tags: y
    }
  }) => [b, Object.fromEntries(y.map(({
    name: g,
    value: w
  }) => [i && g.startsWith(`${i}-`) ? g.slice(i.length + 1) : g, w]))]));
}
async function hp(t, e = wo.rateLimitRetryDelayMs, n = wo.arweaveUrl) {
  for (; ; ) {
    const r = await fetch(`${n}/${t}`, {
      redirect: "follow"
    });
    if (r.status !== 429)
      return r;
    console.warn(`rate limited by ${n}, trying again in ${e / 1e3} seconds at ${new Date(Date.now() + e).toLocaleTimeString()}`), await new Promise((s) => setTimeout(s, e));
  }
}
function rc(t) {
  return typeof t == "string" ? {
    nodeHash: t
  } : typeof t == "object" && (t == null ? void 0 : t.node) !== void 0 ? {
    nodeHash: t.node
  } : t instanceof Array && t.length === 2 ? {
    left: rc(t[0]),
    right: rc(t[1])
  } : fe.config.isNode(t) ? {
    left: rc(t.left),
    right: rc(t.right)
  } : fe.config.isNestedLeaf(t) ? ds({}, t, {
    tree: rc(t.tree)
  }) : t;
}
var $ee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaults: wo,
  ArweaveReader: _ee
});
class Gee {
  constructor(e) {
    this.tracker = e;
  }
  async loadPresignedConfiguration(e) {
    return console.debug("? loadPresignedConfiguration"), en(e, "? "), en(await this.tracker.loadPresignedConfiguration(e), "! ");
  }
  savePresignedConfiguration(e) {
    return console.debug("? savePresignedConfiguration"), en(e, "? "), this.tracker.savePresignedConfiguration(e);
  }
  saveWitnesses(e) {
    return console.debug("? saveWitnesses"), en(e, "? "), this.tracker.saveWitnesses(e);
  }
  async configOfImageHash(e) {
    return console.debug("? configOfImageHash"), en(e, "? "), en(await this.tracker.configOfImageHash(e), "! ");
  }
  saveWalletConfig(e) {
    return console.debug("? saveWalletConfig"), en(e, "? "), this.tracker.saveWalletConfig(e);
  }
  async imageHashOfCounterfactualWallet(e) {
    return console.debug("? imageHashOfCounterfactualWallet"), en(e, "? "), en(await this.tracker.imageHashOfCounterfactualWallet(e), "! ");
  }
  saveCounterfactualWallet(e) {
    return console.debug("? saveCounterfactualWallet"), en(e, "? "), this.tracker.saveCounterfactualWallet(e);
  }
  async walletsOfSigner(e) {
    return console.debug("? walletsOfSigner"), en(e, "? "), en(await this.tracker.walletsOfSigner(e), "! ");
  }
  async getMigration(e, n, r, s) {
    return console.debug("? getMigration"), en({
      address: e,
      fromImageHash: n,
      fromVersion: r,
      chainId: s
    }, "? "), en(await this.tracker.getMigration(e, n, r, s), "! ");
  }
  saveMigration(e, n, r) {
    return console.debug("? saveMigration"), en({
      address: e,
      signed: n,
      contexts: r
    }, "? "), this.tracker.saveMigration(e, n, r);
  }
}
function en(t, e = "") {
  switch (t) {
    case void 0:
      console.debug(e + "undefined");
      break;
    default:
      JSON.stringify(t, Mu, 2).split(`
`).map((n) => e + n).forEach((n) => console.debug(n));
      break;
  }
  return t;
}
var zee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DebugConfigTracker: Gee
});
class AS {
  constructor() {
    this.configs = {}, this.v2Nodes = {}, this.counterfactualWallets = {}, this.payloads = {}, this.signatures = {}, this.migrations = {}, this.loadConfig = (e) => Promise.resolve(this.configs[e]), this.saveConfig = (e, n) => (this.configs[e] = n, Promise.resolve()), this.loadV2Node = (e) => Promise.resolve(this.v2Nodes[e]), this.saveV2Node = (e, n) => (this.v2Nodes[e] = n, Promise.resolve()), this.loadCounterfactualWallet = (e) => Promise.resolve(this.counterfactualWallets[e]), this.saveCounterfactualWallet = (e, n, r) => (this.counterfactualWallets[e] = {
      imageHash: n,
      context: r
    }, Promise.resolve()), this.loadPayloadOfSubdigest = (e) => Promise.resolve(this.payloads[e]), this.savePayloadOfSubdigest = (e, n) => (this.payloads[e] = n, Promise.resolve()), this.loadSubdigestsOfSigner = (e) => Promise.resolve(Object.keys(this.signatures[e] || {})), this.loadSignatureOfSubdigest = (e, n) => {
      var r;
      return Promise.resolve((r = this.signatures[e]) == null ? void 0 : r[n]);
    }, this.saveSignatureOfSubdigest = (e, n, r) => (this.signatures[e] || (this.signatures[e] = {}), this.signatures[e][n] = r, Promise.resolve()), this.loadMigrationsSubdigest = (e, n, r) => {
      var s;
      return Promise.resolve(((s = this.migrations[e]) == null || (s = s[n]) == null ? void 0 : s[r]) || []);
    }, this.saveMigrationsSubdigest = (e, n, r, s, a) => (this.migrations[e] || (this.migrations[e] = {}), this.migrations[e][n] || (this.migrations[e][n] = {}), this.migrations[e][n][r] || (this.migrations[e][n][r] = []), this.migrations[e][n][r].push({
      subdigest: s,
      toImageHash: a
    }), Promise.resolve());
  }
}
function vc(t) {
  if (t === void 0) return;
  const e = {};
  for (const n of Object.keys(t)) {
    const r = t[n];
    r._isBigNumber === !0 && r._hex !== void 0 && typeof r._hex == "string" && r._hex.length !== "" ? e[n] = BigInt(r._hex) : Array.isArray(r) ? e[n] = r.map((s) => vc(s)) : typeof r == "object" && r !== null ? e[n] = vc(r) : e[n] = r;
  }
  return e;
}
class jee {
  constructor(e) {
    var n = this;
    this.dbName = e, this._lazyDb = void 0, this.loadConfig = async function(r) {
      return (await n.getDb()).get("configs", r).then((a) => vc(a));
    }, this.saveConfig = async function(r, s) {
      await (await n.getDb()).put("configs", s, r);
    }, this.loadV2Node = async function(r) {
      return (await n.getDb()).get("v2Nodes", r).then((a) => vc(a));
    }, this.saveV2Node = async function(r, s) {
      await (await n.getDb()).put("v2Nodes", s, r);
    }, this.loadCounterfactualWallet = async function(r) {
      return (await n.getDb()).get("counterfactualWallets", r);
    }, this.saveCounterfactualWallet = async function(r, s, a) {
      await (await n.getDb()).put("counterfactualWallets", {
        imageHash: s,
        context: a
      }, r);
    }, this.loadPayloadOfSubdigest = async function(r) {
      return (await n.getDb()).get("payloads", r).then((a) => vc(a));
    }, this.savePayloadOfSubdigest = async function(r, s) {
      await (await n.getDb()).put("payloads", s, r);
    }, this.loadSubdigestsOfSigner = async function(r) {
      return (await (await n.getDb()).getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(r))).map((i) => i.split("-")[0]);
    }, this.loadSignatureOfSubdigest = async function(r, s) {
      const i = await (await n.getDb()).get("signatures", [s, r].join("-"));
      return i == null ? void 0 : i.signature;
    }, this.saveSignatureOfSubdigest = async function(r, s, a) {
      await (await n.getDb()).put("signatures", {
        signature: a,
        signer: r
      }, [s, r].join("-"));
    }, this.loadMigrationsSubdigest = async function(r, s, a) {
      return (await (await n.getDb()).getAllFromIndex("migrations", "jump", IDBKeyRange.only([r, s, a]))).map((c) => ({
        subdigest: c.subdigest,
        toImageHash: c.toImageHash
      }));
    }, this.saveMigrationsSubdigest = async function(r, s, a, i, o) {
      await (await n.getDb()).put("migrations", {
        wallet: r,
        fromVersion: s,
        toVersion: a,
        subdigest: i,
        toImageHash: o
      }, i);
    };
  }
  async getDb() {
    if (this._lazyDb) return this._lazyDb;
    const e = this.dbName;
    return this._lazyDb = await Fee(e, 1, {
      upgrade(n, r, s, a) {
        console.log(`upgrading ${e} from ${r} to ${s} - ${a}`), r === 0 && (n.createObjectStore("configs"), n.createObjectStore("v2Nodes"), n.createObjectStore("counterfactualWallets"), n.createObjectStore("payloads"), n.createObjectStore("signatures").createIndex("signer", "signer", {
          unique: !1
        }), n.createObjectStore("migrations").createIndex("jump", ["wallet", "fromVersion", "toVersion"]));
      }
    }), this._lazyDb;
  }
}
function kS(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function vS(t) {
  return t.weight !== void 0 && t.threshold !== void 0 && t.tree !== void 0;
}
function d1(t) {
  return t.version === 2 && t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && typeof t.tree == "string";
}
var Vee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainNode: kS,
  isPlainNested: vS,
  isPlainV2Config: d1,
  MemoryTrackerStore: AS,
  recreateBigNumbers: vc,
  IndexedDBStore: jee
});
class dE {
  constructor(e, n = new AS(), r = !1) {
    var s = this;
    this.provider = e, this.store = n, this.useEIP5719 = r, this.cachedEIP5719 = void 0, this.loadTopology = async function(a) {
      const i = await s.store.loadV2Node(a);
      if (!i) return {
        nodeHash: a
      };
      if (kS(i)) {
        const [o, c] = await Promise.all([s.loadTopology(i.left), s.loadTopology(i.right)]);
        return {
          left: o,
          right: c
        };
      }
      return vS(i) ? {
        weight: BigInt(i.weight),
        threshold: BigInt(i.threshold),
        tree: await s.loadTopology(i.tree)
      } : i;
    }, this.saveTopology = async function(a) {
      if (fe.config.isNodeLeaf(a))
        return;
      const i = fe.config.hashNode(a);
      if (fe.config.isNode(a)) {
        const o = s.saveTopology(a.left), c = s.saveTopology(a.right), u = s.store.saveV2Node(i, {
          left: fe.config.hashNode(a.left),
          right: fe.config.hashNode(a.right)
        });
        await Promise.all([o, c, u]);
        return;
      }
      if (fe.config.isNestedLeaf(a)) {
        const o = s.saveTopology(a.tree), c = s.store.saveV2Node(i, {
          weight: BigInt(a.weight).toString(),
          threshold: BigInt(a.threshold).toString(),
          tree: fe.config.hashNode(a.tree)
        });
        await Promise.all([o, c]);
        return;
      }
      if (fe.config.isSignerLeaf(a))
        return s.store.saveV2Node(i, {
          address: a.address,
          weight: a.weight
        });
      if (fe.config.isSubdigestLeaf(a))
        return s.store.saveV2Node(i, {
          subdigest: a.subdigest
        });
      throw new Error(`Unknown topology type: ${a}`);
    }, this.saveWalletConfig = async function(a) {
      const {
        config: i
      } = a;
      if (wi.config.ConfigCoder.isWalletConfig(i)) {
        const o = wi.config.ConfigCoder.imageHashOf(i);
        return s.store.saveConfig(o, i);
      }
      if (fe.config.ConfigCoder.isWalletConfig(i)) {
        const o = fe.config.ConfigCoder.imageHashOf(i);
        if (fe.config.isComplete(i.tree))
          return s.store.saveConfig(o, i);
      }
    }, this.configOfImageHashCache = {}, this.configOfImageHash = async function(a) {
      const {
        imageHash: i
      } = a;
      if (s.configOfImageHashCache[a.imageHash])
        return s.configOfImageHashCache[a.imageHash];
      const o = await s.store.loadConfig(i);
      if (o) {
        if (o.version === 1 || o.version === 2 && !d1(o))
          return s.configOfImageHashCache[a.imageHash] = o, o;
        if (d1(o)) {
          const c = {
            version: 2,
            threshold: BigInt(o.threshold),
            checkpoint: BigInt(o.checkpoint),
            tree: await s.loadTopology(o.tree)
          };
          return s.configOfImageHashCache[a.imageHash] = c, c;
        }
        throw new Error(`Unknown config type: ${o}`);
      }
    }, this.saveCounterfactualWallet = async function(a) {
      const {
        config: i,
        context: o
      } = a, c = cn.genericCoderFor(i.version).config.imageHashOf(i);
      await Promise.all([s.saveWalletConfig({
        config: i
      }), ...o.map((u) => {
        const l = se.context.addressOf(u, c);
        return s.store.saveCounterfactualWallet(l, c, u);
      })]);
    }, this.imageHashOfCounterfactualWallet = async function(a) {
      const {
        wallet: i
      } = a, o = await s.store.loadCounterfactualWallet(i);
      if (o)
        return {
          imageHash: o.imageHash,
          context: o.context
        };
    }, this.savePayload = async function(a) {
      const {
        payload: i
      } = a, o = se.signature.subdigestOf(i);
      await s.store.savePayloadOfSubdigest(o, i);
    }, this.payloadOfSubdigestCache = {}, this.payloadOfSubdigest = async function(a) {
      if (s.payloadOfSubdigestCache[a.subdigest])
        return s.payloadOfSubdigestCache[a.subdigest];
      const {
        subdigest: i
      } = a, o = await s.store.loadPayloadOfSubdigest(i);
      return o && (s.payloadOfSubdigestCache[i] = o), o;
    }, this.savePresignedConfiguration = async function(a) {
      const i = fe.signature.SignatureCoder.decode(a.signature), o = cn.genericCoderFor(a.nextConfig.version).config.imageHashOf(a.nextConfig), c = fe.chained.messageSetImageHash(o), u = ke(c), l = {
        message: c,
        address: a.wallet,
        chainId: 0,
        digest: u
      }, d = s.savePayload({
        payload: l
      }), p = s.saveWalletConfig({
        config: a.nextConfig
      }), f = await fe.signature.SignatureCoder.recover(i, l, s.provider), b = fe.signature.signaturesOf(f.config.tree);
      await Promise.all([d, p, s.saveWalletConfig({
        config: f.config
      }), ...b.map((y) => s.store.saveSignatureOfSubdigest(y.address, f.subdigest, y.signature))]);
    }, this.loadPresignedConfiguration = async function(a) {
      const {
        wallet: i,
        fromImageHash: o,
        longestPath: c
      } = a, u = await s.configOfImageHash({
        imageHash: o
      });
      if (!u || !fe.config.ConfigCoder.isWalletConfig(u))
        return [];
      const l = fe.config.signersOf(u.tree).map((E) => E.address), d = await Promise.all(l.map((E) => s.store.loadSubdigestsOfSigner(E))), p = [...new Set(d.flat())], b = (await Promise.all([...new Set(p)].map(async function(E) {
        return ds({}, await s.payloadOfSubdigest({
          subdigest: E
        }), {
          subdigest: E
        });
      }))).filter((E) => (E == null ? void 0 : E.message) && (E == null ? void 0 : E.address) && E.address === i).map((E) => ({
        payload: E,
        nextImageHash: fe.chained.decodeMessageSetImageHash(E.message)
      })).filter((E) => E == null ? void 0 : E.nextImageHash);
      let y;
      const w = (await Promise.all(b.map(async function({
        nextImageHash: E,
        payload: T
      }) {
        const A = await s.configOfImageHash({
          imageHash: E
        });
        if (!A || !fe.config.isWalletConfig(A)) return;
        const N = BigInt(A.checkpoint);
        return {
          nextConfig: A,
          nextCheckpoint: N,
          nextImageHash: E,
          payload: T
        };
      }))).filter((E) => E !== void 0).filter((E) => E.nextCheckpoint > BigInt(u.checkpoint)).sort((E, T) => (
        // If we are looking for the longest path, sort by ascending checkpoint
        // because we want to find the smalles jump, and we should start with the
        // closest one. If we are not looking for the longest path, sort by
        // descending checkpoint, because we want to find the largest jump.
        //
        // We don't have a guarantee that all "next configs" will be valid
        // so worst case scenario we will need to try all of them.
        // But we can try to optimize for the most common case.
        E.nextCheckpoint > T.nextCheckpoint ? c ? 1 : -1 : c ? -1 : 1
      ));
      for (const E of w) {
        const {
          nextConfig: T,
          nextCheckpoint: A,
          nextImageHash: N,
          payload: D
        } = E;
        if (y) {
          const S = y.checkpoint;
          if (c) {
            if (A >= S) continue;
          } else if (A <= S) continue;
        }
        const P = new Map((await Promise.all(l.map(async function(S) {
          const R = await s.store.loadSignatureOfSubdigest(S, D.subdigest);
          if (!R)
            return [S, void 0];
          const M = z(s.useEIP5719 ? await s.cachedEIP5719.runByEIP5719(S, D.subdigest, R) : R), _ = se.signer.tryRecoverSigner(D.subdigest, M) !== S;
          return [S, {
            isDynamic: _,
            signature: M
          }];
        }))).filter((S) => !!S[1]));
        if (P.size === 0) continue;
        const C = fe.signature.SignatureCoder.encodeSigners(u, P, [], 0);
        C.weight < BigInt(u.threshold) || (y = {
          nextImageHash: N,
          checkpoint: BigInt(T.checkpoint),
          signature: C.encoded
        });
      }
      if (!y)
        return [];
      const k = await s.loadPresignedConfiguration({
        wallet: i,
        fromImageHash: y.nextImageHash,
        longestPath: c
      });
      return [{
        wallet: i,
        nextImageHash: y.nextImageHash,
        signature: y.signature
      }, ...k];
    }, this.saveWitnesses = async function(a) {
      const i = {
        digest: a.digest,
        address: a.wallet,
        chainId: a.chainId
      }, o = se.signature.subdigestOf(i);
      await Promise.all([s.savePayload({
        payload: i
      }), ...a.signatures.filter((c) => se.signer.canRecover(c)).map((c) => {
        const u = se.signer.recoverSigner(o, c);
        return s.store.saveSignatureOfSubdigest(u, o, c);
      })]);
    }, this.walletsOfSigner = async function(a) {
      const i = await s.store.loadSubdigestsOfSigner(a.signer), o = await Promise.all(i.map((u) => s.payloadOfSubdigest({
        subdigest: u
      }))).then((u) => u.filter((l) => l !== void 0)), c = [];
      for (const u of o) {
        const l = u.address;
        if (c.find((f) => f.wallet === l)) continue;
        const d = se.signature.subdigestOf(u), p = await s.store.loadSignatureOfSubdigest(a.signer, d);
        p && c.push({
          wallet: l,
          proof: {
            digest: u.digest,
            chainId: BigInt(u.chainId),
            signature: z(p)
          }
        });
      }
      return c;
    }, this.cachedEIP5719 = new gS(e);
  }
  async saveMigration(e, n, r) {
    const s = n.fromVersion;
    if (s !== 1) throw new Error("Migration not supported");
    if (!fe.config.isWalletConfig(n.toConfig)) throw new Error("Invalid to config");
    const {
      newImageHash: a,
      address: i
    } = XY.v1v2.decodeTransaction(n.tx, r);
    if (i !== e) throw new Error("Invalid migration transaction - address");
    if (fe.config.ConfigCoder.imageHashOf(n.toConfig) != a) throw new Error("Invalid migration transaction - config");
    const o = se.transaction.packMetaTransactionsData(n.tx.nonce, n.tx.transactions), c = ke(o), u = {
      chainId: n.tx.chainId,
      message: o,
      address: e,
      digest: c
    }, l = se.signature.subdigestOf(u), d = this.savePayload({
      payload: u
    }), p = this.saveWalletConfig({
      config: n.toConfig
    }), f = wi.signature.SignatureCoder.decode(n.tx.signature), b = await wi.signature.SignatureCoder.recover(f, u, this.provider), y = wi.signature.SignatureCoder.signaturesOf(b.config);
    await Promise.all([d, p, this.saveWalletConfig({
      config: b.config
    }), this.store.saveMigrationsSubdigest(e, s, s + 1, l, a), ...y.map((g) => this.store.saveSignatureOfSubdigest(g.address, b.subdigest, g.signature))]);
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const [i, o] = await Promise.all([this.configOfImageHash({
      imageHash: n
    }), this.store.loadMigrationsSubdigest(e, r, r + 1)]), c = cn.coderFor(r);
    return !i || !c.config.isWalletConfig(i) ? void 0 : (await Promise.all(o.map(async function(l) {
      const {
        subdigest: d,
        toImageHash: p
      } = l, f = await a.payloadOfSubdigest({
        subdigest: d
      });
      if (!f || !f.message || BigInt(s) !== BigInt(f.chainId)) return;
      const b = c.config.signersOf(i).map((E) => E.address), y = new Map((await Promise.all(b.map(async function(E) {
        const T = await a.store.loadSignatureOfSubdigest(E, d);
        if (!T)
          return [E, void 0];
        const A = z(a.useEIP5719 ? await a.cachedEIP5719.runByEIP5719(E, d, T) : T), N = se.signer.tryRecoverSigner(d, A) !== E;
        return [E, {
          isDynamic: N,
          signature: A
        }];
      }))).filter((E) => !!E[1])), g = c.signature.encodeSigners(i, y, [], s);
      if (!g || g.weight < BigInt(i.threshold)) return;
      const [w, k] = se.transaction.unpackMetaTransactionsData(f.message);
      return {
        tx: {
          entrypoint: e,
          transactions: se.transaction.fromTxAbiEncode(k),
          chainId: s,
          nonce: w,
          signature: g.encoded,
          intent: {
            id: d,
            wallet: e
          }
        },
        toConfig: await a.configOfImageHash({
          imageHash: p
        }),
        fromVersion: r,
        toVersion: r + 1
      };
    })).then((l) => l.filter((d) => d !== void 0)))[0];
  }
  updateProvider(e) {
    this.provider = e;
  }
}
var qee = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LocalConfigTracker: dE
});
const Kee = "Webrpc", Wee = "webrpc@v0.22.1;gen-typescript@v0.16.2;sessions@v0.0.1";
let ny = /* @__PURE__ */ function(t) {
  return t.EIP712 = "EIP712", t.EthSign = "EthSign", t.EIP1271 = "EIP1271", t;
}({});
class Qee {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Sessions/", this.ping = (r, s) => this.fetch(this.url("Ping"), zn({}, r, s)).then((a) => jn(a).then((i) => ({})), (a) => {
      throw tn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.config = (r, s, a) => this.fetch(this.url("Config"), zn(r, s, a)).then((i) => jn(i).then((o) => ({
      version: o.version,
      config: o.config
    })), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.wallets = (r, s, a) => this.fetch(this.url("Wallets"), zn(r, s, a)).then((i) => jn(i).then((o) => ({
      wallets: o.wallets,
      cursor: o.cursor
    })), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.deployHash = (r, s, a) => this.fetch(this.url("DeployHash"), zn(r, s, a)).then((i) => jn(i).then((o) => ({
      deployHash: o.deployHash,
      context: o.context
    })), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.configUpdates = (r, s, a) => this.fetch(this.url("ConfigUpdates"), zn(r, s, a)).then((i) => jn(i).then((o) => ({
      updates: o.updates
    })), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.migrations = (r, s, a) => this.fetch(this.url("Migrations"), zn(r, s, a)).then((i) => jn(i).then((o) => ({
      migrations: o.migrations
    })), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveConfig = (r, s, a) => this.fetch(this.url("SaveConfig"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveWallet = (r, s, a) => this.fetch(this.url("SaveWallet"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignature = (r, s, a) => this.fetch(this.url("SaveSignature"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures = (r, s, a) => this.fetch(this.url("SaveSignerSignatures"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures2 = (r, s, a) => this.fetch(this.url("SaveSignerSignatures2"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveMigration = (r, s, a) => this.fetch(this.url("SaveMigration"), zn(r, s, a)).then((i) => jn(i).then((o) => ({})), (i) => {
      throw tn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const zn = (t = {}, e = {}, n = null) => {
  const r = ds({}, e, {
    "Content-Type": "application/json"
  });
  return r[Kee] = Wee, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, jn = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), s0.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (Jee[r] || Zt).new(n);
  }
  return n;
});
class Zt extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, Zt.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}
class fE extends Zt {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, fE.prototype);
  }
}
class tn extends Zt {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, tn.prototype);
  }
}
class pE extends Zt {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, pE.prototype);
  }
}
class hE extends Zt {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, hE.prototype);
  }
}
class mE extends Zt {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, mE.prototype);
  }
}
class s0 extends Zt {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, s0.prototype);
  }
}
class yE extends Zt {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, yE.prototype);
  }
}
class bE extends Zt {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, bE.prototype);
  }
}
class gE extends Zt {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, gE.prototype);
  }
}
class wE extends Zt {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, wE.prototype);
  }
}
class EE extends Zt {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, EE.prototype);
  }
}
class xE extends Zt {
  constructor(e = "InvalidArgument", n = 1, r = "invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, xE.prototype);
  }
}
class AE extends Zt {
  constructor(e = "NotFound", n = 2, r = "not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, AE.prototype);
  }
}
const Jee = {
  0: fE,
  [-1]: tn,
  [-2]: pE,
  [-3]: hE,
  [-4]: mE,
  [-5]: s0,
  [-6]: yE,
  [-7]: bE,
  [-8]: gE,
  [-9]: wE,
  [-10]: EE,
  1: xE,
  2: AE
};
class Xee {
  constructor(e, n = !0) {
    this.onlyRecoverable = n, this.sessions = void 0, this.sessions = new Qee(e, fetch);
  }
  async loadPresignedConfiguration(e) {
    try {
      const {
        updates: n
      } = await this.sessions.configUpdates({
        wallet: e.wallet,
        fromImageHash: e.fromImageHash,
        allUpdates: e.longestPath
      });
      return n.map(({
        toImageHash: r,
        signature: s
      }) => ({
        wallet: e.wallet,
        nextImageHash: r,
        signature: s
      }));
    } catch (n) {
      if (ry(n))
        return [];
      throw n;
    }
  }
  async savePresignedConfiguration(e) {
    const n = e.nextConfig, r = cn.genericCoderFor(n.version).config.imageHashOf(n), s = fe.signature.setImageHashStruct(r), a = ke(s);
    await this.sessions.saveSignature({
      wallet: e.wallet,
      digest: a,
      chainID: "0",
      signature: e.signature,
      toConfig: mp(n),
      referenceChainID: e.referenceChainId !== void 0 ? BigInt(e.referenceChainId).toString() : void 0
    });
  }
  async saveWitnesses(e) {
    let n = e.signatures;
    this.onlyRecoverable && (n = n.filter((r) => se.signer.canRecover(r))), await this.sessions.saveSignerSignatures({
      wallet: e.wallet,
      digest: e.digest,
      chainID: uc(e.chainId),
      signatures: n
    });
  }
  async configOfImageHash(e) {
    try {
      const {
        version: n,
        config: r
      } = await this.sessions.config(e);
      return Zee(n, r);
    } catch (n) {
      if (ry(n))
        return;
      throw n;
    }
  }
  async saveWalletConfig(e) {
    const n = mp(e.config);
    await this.sessions.saveConfig({
      version: e.config.version,
      config: n
    });
  }
  async imageHashOfCounterfactualWallet(e) {
    try {
      const {
        deployHash: n,
        context: r
      } = await this.sessions.deployHash(e);
      return {
        imageHash: n,
        context: r
      };
    } catch (n) {
      if (ry(n))
        return;
      throw n;
    }
  }
  async saveCounterfactualWallet(e) {
    const n = mp(e.config);
    await this.sessions.saveWallet({
      version: e.config.version,
      deployConfig: n
    });
  }
  async walletsOfSigner(e) {
    const {
      wallets: n
    } = await this.sessions.wallets(e);
    return Object.entries(n).map(([r, {
      digest: s,
      chainID: a,
      type: i,
      signature: o
    }]) => {
      switch (i) {
        case ny.EIP712:
          o += Ir(se.signer.SigType.EIP712).slice(2);
          break;
        case ny.EthSign:
          o += Ir(se.signer.SigType.ETH_SIGN).slice(2);
          break;
        case ny.EIP1271:
          o += Ir(se.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet: r,
        proof: {
          digest: s,
          signature: o,
          chainId: BigInt(a)
        }
      };
    });
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const i = uc(s), {
      migrations: o
    } = await this.sessions.migrations({
      wallet: e,
      fromVersion: r,
      fromImageHash: n,
      chainID: i
    }), c = async function(d) {
      const p = o[d];
      if (p) {
        const f = Object.keys(p).map(Number).sort((b, y) => y - b);
        for (const b of f)
          for (const [y, g] of Object.entries(p[b]))
            try {
              const w = await a.configOfImageHash({
                imageHash: y
              });
              if (w)
                return {
                  fromVersion: r,
                  toVersion: b,
                  toConfig: w,
                  tx: {
                    entrypoint: g.executor,
                    transactions: g.transactions,
                    nonce: g.nonce,
                    signature: g.signature,
                    chainId: d,
                    intent: {
                      id: se.transaction.subdigestOfTransactions(e, d, g.nonce, g.transactions),
                      wallet: e
                    }
                  }
                };
            } catch (w) {
              console.error(w);
            }
      }
    }, u = await c(i);
    if (u)
      return u;
    for (const l in o)
      if (l !== i) {
        const d = await c(l);
        if (d)
          return d;
      }
  }
  async saveMigration(e, n, r) {
    await this.sessions.saveMigration({
      wallet: e,
      fromVersion: n.fromVersion,
      toVersion: n.toVersion,
      toConfig: mp(n.toConfig),
      executor: n.tx.entrypoint,
      transactions: n.tx.transactions.map(Yee),
      nonce: uc(n.tx.nonce),
      signature: n.tx.signature,
      chainID: uc(n.tx.chainId)
    });
  }
}
function mp(t) {
  switch (t.version) {
    case 1:
      if (wi.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Pi(t.threshold),
          signers: t.signers.map(({
            weight: e,
            address: n
          }) => ({
            weight: Pi(e),
            address: n
          }))
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    case 2:
      if (fe.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Pi(t.threshold),
          checkpoint: Pi(t.checkpoint),
          tree: Up(t.tree)
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    default:
      throw new Error(`unknown version ${t.version}`);
  }
}
function Up(t) {
  return fe.config.isNode(t) ? {
    left: Up(t.left),
    right: Up(t.right)
  } : fe.config.isSignerLeaf(t) ? {
    weight: Pi(t.weight),
    address: t.address
  } : fe.config.isNestedLeaf(t) ? {
    weight: Pi(t.weight),
    threshold: Pi(t.threshold),
    tree: Up(t.tree)
  } : fe.config.isNodeLeaf(t) ? {
    node: t.nodeHash
  } : ds({}, t);
}
function Zee(t, e) {
  switch (t) {
    case 1:
      return ds({}, e, {
        version: t
      });
    case 2:
      return ds({}, e, {
        version: t,
        tree: Np(e.tree)
      });
    default:
      throw new Error(`unknown version ${t}`);
  }
}
function Np(t) {
  switch (typeof t) {
    case "object":
      const e = ds({}, t);
      return e.left !== void 0 && (e.left = Np(e.left)), e.right !== void 0 && (e.right = Np(e.right)), e.tree !== void 0 && (e.tree = Np(e.tree)), e.node !== void 0 && (e.nodeHash = e.node, delete e.node), e;
    default:
      throw new Error(`v2 config tree ${t} is not an object`);
  }
}
function Yee(t) {
  return {
    to: t.to,
    value: t.value !== void 0 ? uc(t.value) : void 0,
    data: t.data !== void 0 ? z(t.data) : void 0,
    gasLimit: t.gasLimit !== void 0 ? uc(t.gasLimit) : void 0,
    delegateCall: t.delegateCall,
    revertOnError: t.revertOnError
  };
}
function Pi(t) {
  return Number(t);
}
function uc(t) {
  return BigInt(t).toString();
}
function ry(t) {
  return typeof t == "object" && t.status === 404;
}
var ete = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  RemoteConfigTracker: Xee
});
function f1(t, e, n) {
  return new Promise((r) => {
    let s = 0;
    t.forEach((a) => a.then((i) => {
      n(i) ? r(i) : (s++, s === t.length && r(e));
    }).catch(() => {
      s++, s === t.length && r(e);
    }));
  });
}
async function $u(t, e) {
  return Promise.all(t.map((n) => n.catch(() => e)));
}
class tte {
  constructor(e) {
    this.trackers = e;
  }
  async configOfImageHash(e) {
    const n = this.trackers.map(async function(o, c) {
      return {
        res: await o.configOfImageHash(e),
        i: c
      };
    }), r = await f1(n, void 0, (o) => (o == null ? void 0 : o.res) === void 0 ? !1 : cn.genericCoderFor(o.res.version).config.isComplete(o.res));
    if (r != null && r.res)
      return this.saveWalletConfig({
        config: r.res,
        skipTracker: r.i
      }), r.res;
    const s = new dE(void 0), a = await $u(n, void 0);
    for (const o of a)
      o != null && o.res && await s.saveWalletConfig({
        config: o.res
      });
    const i = await s.configOfImageHash(e);
    return i && this.saveWalletConfig({
      config: i
    }), i;
  }
  async saveWalletConfig(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveWalletConfig(e);
    }));
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = await f1(this.trackers.map((r) => r.imageHashOfCounterfactualWallet(e)), void 0, (r) => !!r);
    return n && this.configOfImageHash({
      imageHash: n.imageHash
    }).then((r) => {
      r && this.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }), n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveCounterfactualWallet(e);
    }));
  }
  async walletsOfSigner(e) {
    const n = await $u(this.trackers.map((i) => i.walletsOfSigner(e)), []).then((i) => i.flat()), r = {};
    for (const i of n)
      r[i.wallet] = i.proof;
    const s = Object.keys(r).map((i) => ({
      wallet: i,
      proof: r[i]
    })), a = /* @__PURE__ */ new Map();
    return s.forEach(({
      wallet: i,
      proof: {
        digest: o,
        chainId: c,
        signature: u
      }
    }) => {
      const l = `${i}-${o}-${c}`;
      let d = a.get(l);
      d || (d = {
        wallet: i,
        digest: o,
        chainId: c,
        signatures: []
      }, a.set(l, d)), d.signatures.push(u);
    }), a.forEach((i) => this.saveWitnesses(i)), s;
  }
  async saveWitnesses(e) {
    await Promise.all(this.trackers.map((n) => n.saveWitnesses(e)));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = await $u(this.trackers.map((c) => c.loadPresignedConfiguration(e)), []), a = (await $u(r.map(async function(c) {
      const u = c[c.length - 1], l = await n.configOfImageHash({
        imageHash: u.nextImageHash
      });
      if (l)
        return {
          checkpoint: cn.genericCoderFor(l.version).config.checkpointOf(l),
          result: c
        };
    }), void 0)).reduce((c, u) => u && (!c || u.checkpoint > c.checkpoint) ? u : c);
    if (!a) return [];
    const i = /* @__PURE__ */ new Map(), o = (c) => (i.has(c) || i.set(c, this.configOfImageHash({
      imageHash: c
    })), i.get(c));
    return a.result.forEach(async function(c) {
      const u = await o(c.nextImageHash);
      u && n.savePresignedConfiguration({
        wallet: e.wallet,
        nextConfig: u,
        signature: c.signature
      });
    }), a.result;
  }
  async savePresignedConfiguration(e) {
    await Promise.all(this.trackers.map((n) => n.savePresignedConfiguration(e)));
  }
  async getMigration(e, n, r, s) {
    return (await Promise.all(this.trackers.map((i) => i.getMigration(e, n, r, s)))).find((i) => !!i);
  }
  async saveMigration(e, n, r) {
    await Promise.all(this.trackers.map((s) => s.saveMigration(e, n, r)));
  }
}
class nte {
  constructor(e, n, r) {
    this.tracker = e, this.cache = n, this.contexts = r;
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = [this.tracker.loadPresignedConfiguration(e), this.cache.loadPresignedConfiguration(e)];
    let s;
    const [a, i] = await Promise.all(r);
    if (a.length > 0 && i.length > 0 && a[a.length - 1].nextImageHash === i[i.length - 1].nextImageHash)
      s = e.longestPath === !0 ? a.length > i.length ? a : i : a.length < i.length ? a : i;
    else {
      var o, c;
      s = (o = (c = (await Promise.all(r.map(async function(l) {
        const d = await l, p = d[d.length - 1];
        if (!p) return;
        const f = await n.configOfImageHash({
          imageHash: p.nextImageHash
        });
        if (f)
          return {
            checkpoint: cn.genericCoderFor(f.version).config.checkpointOf(f),
            result: d
          };
      }))).reduce((l, d) => d && (!l || d.checkpoint > l.checkpoint) ? d : l)) == null ? void 0 : c.result) != null ? o : [];
    }
    return s || [];
  }
  async savePresignedConfiguration(e) {
    await Promise.all([this.tracker.savePresignedConfiguration(e), this.cache.savePresignedConfiguration(e)]);
  }
  async configOfImageHash(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.configOfImageHash(e);
      if (r) return r;
    }
    const n = await this.tracker.configOfImageHash(e);
    return n && await this.cache.saveWalletConfig({
      config: n
    }), n;
  }
  async saveWalletConfig(e) {
    await Promise.all([this.tracker.saveWalletConfig(e), this.cache.saveWalletConfig(e)]);
  }
  async imageHashOfCounterfactualWallet(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.imageHashOfCounterfactualWallet(e);
      if (r) return r;
    }
    const n = await this.tracker.imageHashOfCounterfactualWallet(e);
    if (n) {
      const r = await this.configOfImageHash({
        imageHash: n.imageHash
      });
      r && await this.cache.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }
    return n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all([this.tracker.saveCounterfactualWallet(e), this.cache.saveCounterfactualWallet(e)]);
  }
  async walletsOfSigner(e) {
    if (e.noCache)
      return this.tracker.walletsOfSigner(e);
    const n = await Promise.all([this.tracker.walletsOfSigner(e), this.cache.walletsOfSigner(e)]), r = /* @__PURE__ */ new Map();
    for (const s of n)
      for (const a of s)
        r.set(a.wallet, a);
    return Array.from(r.values());
  }
  async saveWitnesses(e) {
    await Promise.all([this.tracker.saveWitnesses(e), this.cache.saveWitnesses(e)]);
  }
  async getMigration(e, n, r, s) {
    const a = await this.cache.getMigration(e, n, r, s);
    if (a) return a;
    const i = await this.tracker.getMigration(e, n, r, s);
    return i && await this.cache.saveMigration(e, i, this.contexts), i;
  }
  async saveMigration(e, n, r) {
    await Promise.all([this.tracker.saveMigration(e, n, r), this.cache.saveMigration(e, n, r)]);
  }
}
class MA {
  constructor() {
    this.cache = void 0, this.cache = /* @__PURE__ */ new Map();
  }
  do(e, n, r, ...s) {
    e = `${e}:${is(JSON.stringify(s, rte))}`;
    let a = this.cache.get(e);
    if (a && a.expiration && /* @__PURE__ */ new Date() >= a.expiration && (a = void 0, this.cache.delete(e)), !a) {
      const i = {
        promise: r(...s)
      };
      n !== void 0 && (i.promise = i.promise.then((o) => (i.expiration = new Date(Date.now() + n), o))), a = i, this.cache.set(e, a);
    }
    return a.promise;
  }
}
function rte(t, e) {
  return typeof e == "object" && e !== null && !Array.isArray(e) ? Object.fromEntries(Object.entries(e).sort()) : typeof e == "bigint" ? e.toString() : e;
}
function ste(t) {
  return t instanceof CS;
}
class CS {
  constructor(e, n = 50, r = !1) {
    this.tracker = e, this.window = n, this.verbose = r, this.cache = new MA();
  }
  invalidateCache() {
    this.cache = new MA();
  }
  configOfImageHash(e) {
    return this.cache.do("configOfImageHash", this.window, (n) => this.tracker.configOfImageHash(n), e);
  }
  getMigration(e, n, r, s) {
    return this.cache.do("getMigration", this.window, (...a) => this.tracker.getMigration(...a), e, n, r, s);
  }
  saveMigration(e, n, r) {
    return this.cache.do("saveMigration", void 0, (...s) => this.tracker.saveMigration(...s), e, n, r);
  }
  loadPresignedConfiguration(e) {
    return this.cache.do("loadPresignedConfiguration", this.window, (n) => this.tracker.loadPresignedConfiguration(n), e);
  }
  savePresignedConfiguration(e) {
    return this.cache.do("savePresignedConfiguration", void 0, (n) => this.tracker.savePresignedConfiguration(n), e);
  }
  saveWitnesses(e) {
    return this.cache.do("saveWitnesses", void 0, (n) => this.tracker.saveWitnesses(n), e);
  }
  saveWalletConfig(e) {
    return this.cache.do("saveWalletConfig", void 0, (n) => this.tracker.saveWalletConfig(n), e);
  }
  imageHashOfCounterfactualWallet(e) {
    return this.cache.do("imageHashOfCounterfactualWallet", void 0, (n) => this.tracker.imageHashOfCounterfactualWallet(n), e);
  }
  saveCounterfactualWallet(e) {
    return this.cache.do("saveCounterfactualWallet", void 0, (n) => this.tracker.saveCounterfactualWallet(n), e);
  }
  walletsOfSigner(e) {
    return this.cache.do("walletsOfSigner", this.window, (n) => this.tracker.walletsOfSigner(n), e);
  }
  updateProvider(e) {
    this.tracker instanceof dE && this.tracker.updateProvider(e);
  }
}
var ate = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arweave: $ee,
  debug: zee,
  local: qee,
  remote: ete,
  stores: Vee,
  raceUntil: f1,
  allSafe: $u,
  MultipleTracker: tte,
  CachedTracker: nte,
  isDedupedTracker: ste,
  DedupedTracker: CS
});
const Rp = new ate.remote.RemoteConfigTracker(
  "https://sessions.sequence.app"
);
function TS(t) {
  return c4.map((e) => {
    try {
      const n = c5(t.relayerConfig, e.chainId);
      if (n) {
        const r = {
          provider: new V1(e.rpcUrl),
          url: n,
          projectAccessKey: t.sequenceProjectAccessKey
        };
        return {
          ...e,
          relayer: r
        };
      }
    } catch {
    }
    return e;
  });
}
async function ite(t, e, n, r) {
  const s = await r0.new({
    config: {
      threshold: t,
      // By default a random checkpoint is generated every second
      checkpoint: Math.floor(Date.now() / 1e3),
      signers: e
    },
    tracker: Rp,
    contexts: se.context.defaultContexts,
    orchestrator: new n0([]),
    networks: TS({ relayerConfig: n, sequenceProjectAccessKey: r })
  }), a = await Rp.imageHashOfCounterfactualWallet({
    wallet: s.address
  });
  if (!a)
    throw new Error("Failed to fetch imageHash from the tracker");
  if (!await Rp.configOfImageHash({
    imageHash: a.imageHash
  }))
    throw new Error("Failed to fetch config from the tracker");
  return s;
}
function SS(t) {
  return t.map(ote);
}
function ote(t) {
  return {
    to: t.to,
    value: t.value ? BigInt(t.value) : void 0,
    data: t.data,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    delegateCall: t.delegateCall || !1,
    revertOnError: t.revertOnError || !1
  };
}
function cte(t) {
  const e = [];
  if (t.signatures)
    for (const { signer: n, signature: r } of t.signatures) {
      const s = b1(r);
      s.length === 66 && (s[64] === 0 || s[64] === 1) && (s[64] = s[64] + 27), e.push(new dte(n, YS(s)));
    }
  return console.log("[trails-sdk] signers", e), new r0({
    address: t.address,
    tracker: Rp,
    contexts: se.context.defaultContexts,
    orchestrator: new n0(e),
    networks: TS({
      relayerConfig: t.relayerConfig,
      sequenceProjectAccessKey: t.sequenceProjectAccessKey
    })
  });
}
function lte(t) {
  return se.transaction.digestOfTransactions(
    se.transaction.encodeNonce(t.space, t.nonce),
    SS(t.transactions)
  );
}
function ute(t) {
  const e = lte(t);
  return se.signature.subdigestOf({
    digest: e,
    chainId: t.chainId,
    address: t.wallet
  });
}
async function IS(t, e = {
  env: Kl(),
  useV3Relayers: ql()
}, n = $o()) {
  const r = t.address;
  return (await ite(
    1,
    [{ address: r, weight: 1 }],
    e,
    n
  )).address;
}
async function OS(t, e) {
  const n = await (e == null ? void 0 : e.getCode({
    address: t
  }));
  return n !== void 0 && n !== "0x";
}
async function LA(t, e) {
  for (; !await OS(t, e); )
    console.log("[trails-sdk] waiting for wallet deployment"), await new Promise((r) => setTimeout(r, 500));
}
async function BS(t, e, n, r, s, a = {
  env: Kl(),
  useV3Relayers: ql()
}, i = $o()) {
  var S, R;
  const o = s.id;
  if (!((S = e == null ? void 0 : e.account) != null && S.address) || !t)
    throw new Error("Privy signer or sequence wallet address not available");
  const c = r.map((M) => ({
    to: M.to,
    data: M.data,
    value: M.value || "0",
    revertOnError: !0
  })), u = {
    wallet: t,
    space: Math.floor(Date.now()).toString(),
    nonce: "0",
    chainId: o.toString(),
    transactions: c
  }, l = ute(u), d = b1(l), f = `${await e.signMessage({
    account: e.account,
    message: { raw: d }
  })}02`, b = cte({
    address: t,
    signatures: [
      {
        signer: (R = e.account) == null ? void 0 : R.address,
        signature: f
      }
    ],
    relayerConfig: a,
    sequenceProjectAccessKey: i
  }), y = SS(c), g = await b.status(o), w = b.walletForStatus(o, g);
  if (console.log("[trails-sdk] sequence wallet", w), !await OS(
    w.address,
    n
  )) {
    console.log("[trails-sdk] deploying sequence wallet");
    const M = await w.buildDeployTransaction();
    if (!w.relayer) throw new Error("Wallet deploy requires a relayer");
    console.log("[trails-sdk] deploy Tx", M), console.log("[trails-sdk] deployTx entrypoint:", M.entrypoint), console.log("[trails-sdk] deployTx transactions:", M.transactions), console.log("[trails-sdk] getting fee options 0");
    const _ = await w.relayer.getFeeOptions(
      w.address,
      ...M.transactions
    ), j = _ == null ? void 0 : _.quote;
    if (console.log("[trails-sdk] feeOptions", _), (_ == null ? void 0 : _.options.length) === 0) {
      console.log("[trails-sdk] Deployment is whitelisted - no fees required");
      const I = new Uint8Array(32);
      crypto.getRandomValues(I), w.relayer.relay(
        {
          entrypoint: M.entrypoint,
          transactions: M.transactions,
          chainId: w.chainId,
          intent: {
            id: Za(I),
            wallet: w.address
          }
        },
        j
      ), console.log("[trails-sdk] Deployment relayed"), await LA(
        w.address,
        n
      ), console.log("[trails-sdk] sequence wallet deployed");
    } else {
      const I = _ == null ? void 0 : _.options[0];
      if (!I)
        throw new Error("fee option not found");
      if (console.log("[trails-sdk] option", I), I) {
        console.log("[trails-sdk] Using native token for deployment fee");
        const F = HA(I);
        console.log("[trails-sdk] Fee transactions:", F);
        const $ = [...M.transactions];
        console.log(
          "[trails-sdk] All transactions (deployment + fees):",
          $
        );
        const V = await b.predecorateTransactions(
          $,
          g,
          o
        ), X = await b.signTransactions(
          V,
          o
        );
        console.log(
          "[trails-sdk] signed transactions with fees:",
          X.transactions
        ), console.log(
          "[trails-sdk] signed entrypoint with fees:",
          X.entrypoint
        );
        const Z = new Uint8Array(32);
        crypto.getRandomValues(Z), w.relayer.relay(
          {
            entrypoint: M.entrypoint,
            transactions: M.transactions,
            chainId: w.chainId,
            intent: {
              id: Za(Z),
              wallet: w.address
            }
          },
          j
        ), console.log("[trails-sdk] relayed deployment"), await LA(
          w.address,
          n
        ), console.log("[trails-sdk] sequence wallet deployed");
      } else
        throw new Error(
          "ERC20 fee payment for deployment is not supported yet. Please use native token or a relayer with free wallet deployments."
        );
    }
  }
  console.log("[trails-sdk] getting fee options 1");
  const E = await w.relayer.getFeeOptions(
    w.address,
    ...y
  ), T = E == null ? void 0 : E.options.find(
    (M) => M.token.symbol === "USDC"
  ), A = E == null ? void 0 : E.quote, N = HA(T);
  console.log("[trails-sdk] Fee transactions:", N);
  const D = await w.signTransactions(
    [...N, ...y],
    se.transaction.encodeNonce(u.space, u.nonce)
  ), C = await b.relayer(o).relay(D, A);
  return (C == null ? void 0 : C.hash) || null;
}
class dte {
  constructor(e, n) {
    O(this, "signatureBytes");
    O(this, "savedSuffix");
    this.address = e, this.signature = n;
    const r = b1(this.signature);
    this.savedSuffix = r.slice(-1), this.signatureBytes = r.slice(0, -1);
  }
  async buildDeployTransaction() {
  }
  async predecorateSignedTransactions() {
    return [];
  }
  async decorateTransactions(e) {
    return e;
  }
  async sign() {
    return this.signatureBytes;
  }
  notifyStatusChange() {
  }
  suffix() {
    return this.savedSuffix;
  }
  async getAddress() {
    return this.address;
  }
}
async function fte(t, e, n, r) {
  return await t.feeOptions(
    e,
    BigInt(n),
    r
  );
}
function HA(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case "UNKNOWN":
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.to,
          value: e.toString(),
          data: "0x"
        }
      ];
    case "ERC20_TOKEN": {
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      const [n] = MK([
        {
          inputs: [{ type: "address" }, { type: "uint256" }],
          name: "transfer",
          outputs: [{ type: "bool" }],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]);
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.token.contractAddress,
          value: "0",
          data: UC(n, [
            t.to,
            e
          ])
        }
      ];
    }
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
const pte = new E1({
  defaultOptions: {
    queries: {
      staleTime: 6e4,
      // 1 minute
      gcTime: 3e5,
      // 5 minutes
      retry: 2,
      retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
      refetchOnWindowFocus: !1,
      refetchOnReconnect: !0
    }
  }
}), hte = { page: 1, pageSize: 10, more: !1 };
function dc(t) {
  return !("contractAddress" in t);
}
function mte(t, e) {
  const n = t.balanceUsd ?? 0, r = e.balanceUsd ?? 0;
  if (n !== r)
    return r - n;
  if (dc(t) && !dc(e)) return -1;
  if (!dc(t) && dc(e)) return 1;
  try {
    const s = BigInt(t.balance), a = BigInt(e.balance);
    if (s > a) return -1;
    if (s < a) return 1;
  } catch {
    return 0;
  }
  return 0;
}
function qre(t, e, n) {
  var b;
  const r = df(), s = ef(), a = e ?? r, i = n ?? s, {
    data: o,
    isLoading: c,
    error: u
  } = ar({
    queryKey: ["tokenBalances", "summary", t],
    queryFn: async () => {
      if (!t)
        return console.warn("[trails-sdk] No account address or indexer client"), {
          balances: [],
          nativeBalances: [],
          page: hte
        };
      try {
        const y = await US({
          account: t,
          indexerGatewayClient: a
        });
        return {
          page: y.page,
          balances: y.balances.flatMap((g) => g.results),
          nativeBalances: y.nativeBalances.flatMap((g) => g.results)
        };
      } catch (y) {
        throw console.error("[trails-sdk] Failed to fetch token balances:", y), y;
      }
    },
    enabled: !!t && !!a,
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5,
    // 5 minutes cache time
    retry: (y, g) => g && "status" in g && g.status === 404 ? !1 : y < 3,
    retryDelay: (y) => Math.min(1e3 * 2 ** y, 3e4),
    // Exponential backoff
    refetchOnWindowFocus: !1,
    // Prevent refetch on window focus
    refetchOnReconnect: !0,
    // Refetch on reconnect
    refetchInterval: 3e5,
    // Background refetch every 5 minutes
    refetchIntervalInBackground: !0
  }), { tokenPrices: l, isLoadingTokenPrices: d } = TZ(
    ((o == null ? void 0 : o.balances) ?? []).map((y) => {
      var g, w;
      return {
        tokenId: (g = y.contractInfo) == null ? void 0 : g.symbol,
        contractAddress: y.contractAddress,
        chainId: (w = y.contractInfo) == null ? void 0 : w.chainId
      };
    }).concat(
      ((o == null ? void 0 : o.nativeBalances) ?? []).map((y) => ({
        tokenId: y.symbol,
        contractAddress: Ne,
        chainId: y.chainId
      }))
    ) ?? [],
    i
  ), { data: p = [], isLoading: f } = ar({
    queryKey: [
      "tokenBalances",
      "sorted",
      t,
      (b = o == null ? void 0 : o.page) == null ? void 0 : b.page,
      l == null ? void 0 : l.length
    ],
    queryFn: () => !o || !l ? [] : [
      ...o.nativeBalances,
      ...o.balances
    ].filter((w) => {
      try {
        return BigInt(w.balance) > 0n;
      } catch {
        return !1;
      }
    }).map((w) => {
      const k = dc(w), E = l.find(
        (T) => {
          var A;
          return T.token.contractAddress === (k ? Ne : w.contractAddress) && T.token.chainId === (k ? w.chainId : (A = w.contractInfo) == null ? void 0 : A.chainId);
        }
      );
      if (E != null && E.price) {
        const T = { ...w, price: E.price };
        return T.balanceUsd = kE(
          w,
          E.price
        ), T.balanceUsdFormatted = PS(
          w,
          E.price
        ), T;
      }
      return w;
    }).sort(mte),
    enabled: !c && !d && !!o && !!l,
    staleTime: 3e4,
    // 30 seconds for sorted tokens
    gcTime: 12e4,
    // 2 minutes cache time
    refetchOnWindowFocus: !1
  });
  return {
    tokenBalancesData: o,
    isLoadingBalances: c,
    isLoadingPrices: d,
    isLoadingSortedTokens: f || c || d,
    balanceError: u,
    sortedTokens: p
  };
}
function Ui(t, e = 18) {
  try {
    const n = sc(BigInt(t), e);
    return Ni(n);
  } catch (n) {
    return console.error("[trails-sdk] Error formatting balance:", n), t.toString();
  }
}
function kE(t, e) {
  var a;
  const n = dc(t), r = Ui(
    t.balance,
    n ? 18 : (a = t.contractInfo) == null ? void 0 : a.decimals
  ), s = Number(e.value) ?? 0;
  return Number(r) * s;
}
function Ni(t, {
  maxFractionDigits: e = 8,
  minFractionDigits: n = 2
} = {}) {
  t || (t = 0);
  try {
    return Number(t).toLocaleString(void 0, {
      maximumFractionDigits: e,
      minimumFractionDigits: n,
      useGrouping: !1
    });
  } catch (r) {
    console.error("[trails-sdk] Error formatting value:", r);
  }
  return t.toString();
}
function fc(t, {
  maxFractionDigits: e = 8,
  minFractionDigits: n = 2
} = {}) {
  t || (t = 0);
  try {
    return Number(t).toLocaleString(void 0, {
      maximumFractionDigits: e,
      minimumFractionDigits: n,
      useGrouping: !0
    });
  } catch (r) {
    console.error("[trails-sdk] Error formatting value:", r);
  }
  return t.toString();
}
function vr(t = 0) {
  t || (t = 0);
  const e = Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2,
    minimumFractionDigits: 2
  }).format(Number(t));
  return e === "$0.00" && Number(t) > 0 && Number(t) < 0.01 ? "<$0.01" : e;
}
function PS(t, e) {
  const n = kE(t, e);
  return vr(n);
}
async function yte({
  account: t,
  indexerGatewayClient: e
}) {
  if (!t || !e)
    throw new Error("Account address and indexer client are required");
  try {
    return await e.getTokenBalancesSummary({
      filter: {
        accountAddresses: [t],
        contractStatus: P7.VERIFIED,
        contractTypes: ["ERC20"],
        omitNativeBalances: !1
      }
    });
  } catch (n) {
    throw console.error("[trails-sdk] Failed to fetch token balances summary:", n), n;
  }
}
async function US({
  account: t,
  indexerGatewayClient: e
}) {
  return pte.fetchQuery({
    queryKey: ["tokenBalances", "summary", t],
    queryFn: () => yte({ account: t, indexerGatewayClient: e }),
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5
    // 5 minutes
  });
}
async function bte({
  account: t,
  indexerGatewayClient: e
}) {
  const n = await US({
    account: t,
    indexerGatewayClient: e
  }), r = /* @__PURE__ */ new Map();
  for (const a of n.balances)
    a.results.forEach((i) => {
      var o, c, u;
      r.set(
        `${i.contractAddress}-${(o = i.contractInfo) == null ? void 0 : o.chainId}-${(c = i.contractInfo) == null ? void 0 : c.symbol}`,
        {
          ...i,
          contractAddress: i.contractAddress ?? Ne,
          tokenId: (u = i.contractInfo) == null ? void 0 : u.symbol
        }
      );
    });
  for (const a of n.nativeBalances)
    a.results.forEach((i) => {
      r.set(`${i.contractAddress}-${i.chainId}-${i.symbol}`, {
        ...i,
        contractAddress: i.contractAddress ?? Ne,
        tokenId: i.symbol
      });
    });
  return Array.from(r.values());
}
async function vE({
  account: t,
  indexerGatewayClient: e,
  apiClient: n
}) {
  const r = await bte({
    account: t,
    indexerGatewayClient: e
  }), s = await zw(n, r);
  return {
    balances: r.map((i) => {
      const o = s.find((c) => {
        const u = c.token.chainId === i.chainId;
        let l = c.token.contractAddress === i.contractAddress;
        return i.contractAddress || (l = c.token.contractAddress === Ne || !c.token.contractAddress), u && l;
      });
      return {
        ...i,
        price: o == null ? void 0 : o.price,
        balanceUsd: o != null && o.price ? kE(i, o == null ? void 0 : o.price) : void 0,
        balanceUsdFormatted: o != null && o.price ? PS(i, o == null ? void 0 : o.price) : void 0
      };
    })
  };
}
function gte({
  account: t,
  token: e,
  chainId: n,
  indexerGatewayClient: r,
  apiClient: s
}) {
  const { data: a, isLoading: i } = ar({
    queryKey: ["tokenBalances", "balances", t],
    queryFn: async () => {
      if (!t || !r || !s || !e || !n)
        return null;
      const { balances: o } = await vE({
        account: t,
        indexerGatewayClient: r,
        apiClient: s
      });
      return o.find(
        (u) => {
          var l;
          return u.chainId === n && (((l = u.contractAddress) == null ? void 0 : l.toLowerCase()) === e.toLowerCase() || !u.contractAddress && e === Ne);
        }
      );
    }
  });
  return {
    tokenBalance: a,
    isLoadingTokenBalance: i
  };
}
async function wte({
  account: t,
  token: e,
  amount: n,
  chainId: r,
  indexerGatewayClient: s,
  apiClient: a
}) {
  var u;
  const { balances: i } = await vE({
    account: t,
    indexerGatewayClient: s,
    apiClient: a
  }), o = i.find(
    (l) => {
      var d;
      return l.chainId === r && (((d = l.contractAddress) == null ? void 0 : d.toLowerCase()) === e.toLowerCase() || !l.contractAddress && e === Ne);
    }
  );
  if (!o)
    return !1;
  const c = ((u = o == null ? void 0 : o.contractInfo) == null ? void 0 : u.decimals) ?? 18;
  return o != null && o.balance ? BigInt(o.balance) >= ay(n, c) : !1;
}
function Kre(t, e, n, r) {
  const s = df(), a = ef(), {
    data: i,
    isLoading: o
  } = ar({
    queryKey: ["tokenBalances", "sufficient", t, e, n, r],
    queryFn: () => t ? wte({
      account: t,
      token: e,
      amount: n,
      chainId: r,
      indexerGatewayClient: s,
      apiClient: a
    }) : null,
    enabled: !!t && !!e && !!n && !!r,
    staleTime: 45e3,
    // 45 seconds
    gcTime: 18e4,
    // 3 minutes cache time
    retry: (c, u) => u && "status" in u && u.status === 404 ? !1 : c < 2,
    retryDelay: (c) => Math.min(1e3 * 2 ** c, 3e4),
    refetchOnWindowFocus: !1
  });
  return {
    hasSufficientBalanceToken: i || !1,
    isLoadingHasSufficientBalanceToken: o
  };
}
async function Ete({
  account: t,
  targetAmountUsd: e,
  indexerGatewayClient: n,
  apiClient: r
}) {
  return await NS({
    account: t,
    indexerGatewayClient: n,
    apiClient: r
  }) >= Number(e);
}
function Wre(t, e) {
  const n = df(), r = ef(), {
    data: s,
    isLoading: a,
    error: i
  } = ar({
    queryKey: ["tokenBalances", "sufficientUsd", t, e],
    queryFn: () => t && e ? Ete({
      account: t,
      targetAmountUsd: e,
      indexerGatewayClient: n,
      apiClient: r
    }) : !1,
    enabled: !!t && !!e,
    staleTime: 45e3,
    // 45 seconds
    gcTime: 18e4,
    // 3 minutes cache time
    retry: (o, c) => c && "status" in c && c.status === 404 ? !1 : o < 2,
    retryDelay: (o) => Math.min(1e3 * 2 ** o, 3e4),
    refetchOnWindowFocus: !1
  });
  return {
    hasSufficientBalanceUsd: s || !1,
    isLoadingHasSufficientBalanceUsd: a || !e || !t,
    hasSufficientBalanceUsdError: i
  };
}
async function NS({
  account: t,
  indexerGatewayClient: e,
  apiClient: n
}) {
  const { balances: r } = await vE({
    account: t,
    indexerGatewayClient: e,
    apiClient: n
  });
  return r.reduce((s, a) => s + (a.balanceUsd ?? 0), 0);
}
function Qre(t) {
  const e = df(), n = ef(), { data: r, isLoading: s } = ar({
    queryKey: ["tokenBalances", "totalUsd", t],
    queryFn: () => t ? NS({
      account: t,
      indexerGatewayClient: e,
      apiClient: n
    }) : null,
    enabled: !!t,
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5,
    // 5 minutes cache time
    retry: (a, i) => i && "status" in i && i.status === 404 ? !1 : a < 2,
    retryDelay: (a) => Math.min(1e3 * 2 ** a, 3e4),
    refetchOnWindowFocus: !1,
    refetchOnReconnect: !0,
    refetchInterval: 3e5,
    // Background refetch every 5 minutes
    refetchIntervalInBackground: !0
  });
  return {
    totalBalanceUsd: r || 0,
    isLoadingTotalBalanceUsd: s,
    totalBalanceUsdFormatted: vr(r || 0)
  };
}
const RS = "01", DS = `trails-sdk:token-image-cache:${RS}`, xte = 7 * 24 * 60 * 60 * 1e3, FS = `trails-sdk:token-info-cache:${RS}`, Ate = 24 * 60 * 60 * 1e3, p1 = /* @__PURE__ */ new Map();
function MS() {
  if (typeof window > "u") return {};
  try {
    const t = localStorage.getItem(FS);
    if (!t) return {};
    const e = JSON.parse(t), n = Date.now(), r = Object.entries(e).filter(([s, a]) => n - a.timestamp < Ate);
    return Object.fromEntries(r);
  } catch {
    return {};
  }
}
function h1(t, e) {
  if (!(typeof window > "u"))
    try {
      const n = MS();
      n[t] = {
        ...e,
        timestamp: Date.now()
      }, localStorage.setItem(FS, JSON.stringify(n)), p1.set(t, n[t]);
    } catch (n) {
      console.warn("[trails-sdk] Failed to cache token info:", n);
    }
}
function LS(t, e) {
  const n = `${t}:${e.toLowerCase()}`, r = p1.get(n);
  if (r)
    return r;
  const a = MS()[n];
  return a ? (p1.set(n, a), a) : null;
}
function CE() {
  if (typeof window > "u") return {};
  try {
    const t = localStorage.getItem(DS);
    if (!t) return {};
    const e = JSON.parse(t), n = Date.now(), r = Object.entries(e).filter(([s, a]) => n - a.timestamp < xte);
    return Object.fromEntries(r);
  } catch {
    return {};
  }
}
function _A(t, e, n) {
  if (!(typeof window > "u"))
    try {
      const r = CE();
      r[t] = {
        imageUrl: e,
        timestamp: Date.now(),
        found: n
      }, localStorage.setItem(DS, JSON.stringify(r));
    } catch (r) {
      console.warn("[trails-sdk] Failed to cache token image:", r);
    }
}
const kte = new E1({
  defaultOptions: {
    queries: {
      staleTime: 24 * 60 * 60 * 1e3,
      // 24 hours
      gcTime: 7 * 24 * 60 * 60 * 1e3,
      // 7 days
      retry: 2,
      retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
      refetchOnWindowFocus: !1,
      refetchOnReconnect: !1
    }
  }
}), $A = [
  "ETH",
  "WETH",
  "AVAX",
  "WAVAX",
  "xDAI",
  "POL",
  "USDC",
  "USDT",
  "DAI",
  "MATIC",
  "ARB",
  "OP",
  "BAT",
  "WBTC",
  "cbBTC",
  "XAI"
];
function vte(t) {
  return t.sort((e, n) => {
    const r = $A.indexOf(e.symbol), s = $A.indexOf(n.symbol);
    if (r !== -1 && s !== -1)
      return r - s;
    if (r !== -1) return -1;
    if (s !== -1) return 1;
    const a = !!e.imageUrl, i = !!n.imageUrl;
    if (a && !i) return -1;
    if (!a && i) return 1;
    const o = e.symbol.localeCompare(n.symbol);
    return o !== 0 ? o : e.chainName.localeCompare(n.chainName);
  });
}
function Cte(t, e, n) {
  const r = `${t}:${e}:${n}`, a = CE()[r];
  return (a == null ? void 0 : a.imageUrl) || "";
}
async function Tte({
  chainId: t,
  contractAddress: e,
  symbol: n
}) {
  const r = `${t}:${e}:${n}`, s = a0({ chainId: t, contractAddress: e, symbol: n }), i = CE()[r];
  if (i)
    return i.found ? i.imageUrl : "";
  try {
    return await kte.fetchQuery({
      queryKey: ["tokenImage", t, e],
      queryFn: async () => {
        const u = (await fetch(s, {
          method: "HEAD",
          // Only fetch headers to check if image exists
          cache: "no-cache"
          // Don't cache the fetch request itself
        })).ok, l = u ? s : "";
        return _A(r, l, u), l;
      },
      staleTime: 864e5,
      // 24 hours
      gcTime: 6048e5
      // 7 days
    });
  } catch (o) {
    return console.error("[trails-sdk] Error fetching token image:", o), _A(r, "", !1), "";
  }
}
async function TE() {
  const t = await vK();
  for (const i of t)
    i.imageUrl || (i.imageUrl = a0({
      chainId: i.chainId,
      contractAddress: i.contractAddress,
      symbol: i.symbol
    })), Tte({
      chainId: i.chainId,
      contractAddress: i.contractAddress,
      symbol: i.symbol
    }).then((o) => {
      i.imageUrl = o;
    }).catch((o) => {
      console.error("[trails-sdk] Error getting token image url:", o);
    });
  const e = [];
  for (const i of _S) {
    const o = i.contractAddress;
    t.some(
      (u) => u.chainId === i.chainId && u.contractAddress.toLowerCase() === o.toLowerCase()
    ) || e.push(i);
  }
  const n = await pC(), a = [...t, ...e].filter(
    (i) => n.some((o) => o.id === i.chainId)
  ).filter(
    (i, o, c) => o === c.findIndex(
      (u) => u.chainId === i.chainId && u.contractAddress.toLowerCase() === i.contractAddress.toLowerCase()
    )
  );
  return vte(a);
}
function HS({ chainId: t } = {}) {
  const { data: e = [], isLoading: n } = ar({
    queryKey: ["supportedTokens"],
    queryFn: TE,
    staleTime: 36e5,
    // 1 hour - tokens rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return {
    supportedTokens: Eo(() => t ? e.filter((s) => s.chainId === t) : e, [e, t]) || [],
    isLoadingTokens: n
  };
}
const Ste = {
  ETH: "Ethereum",
  WETH: "Wrapped ETH",
  USDC: "USDC",
  USDT: "Tether",
  DAI: "Dai Stablecoin",
  OP: "Optimism",
  ARB: "Arbitrum",
  POL: "POL",
  MATIC: "Matic Token",
  BAT: "Basic Attention Token"
}, Ite = {
  USDC: "USDC",
  ETH: "ETH",
  POL: "POL"
}, Ote = {
  [Pt.id]: "Optimistic",
  [ut.id]: "Arbitrum",
  [ft.id]: "Polygon"
};
function Jre(t, e, n) {
  let r = Ste[e] || t || e;
  if (n)
    try {
      const s = pe(n);
      if (s && Ite[e]) {
        n !== $e.id && (r = `${s == null ? void 0 : s.name} ${e}`);
        const a = Ote[n];
        a && (r = `${a} ${e}`);
      }
    } catch (s) {
      console.error("[trails-sdk] Error getting chain info:", s);
    }
  return r;
}
async function GA(t, e) {
  const n = e.toLowerCase(), r = LS(t, n);
  if (r)
    return {
      id: r.id,
      symbol: r.symbol,
      name: r.name,
      contractAddress: r.contractAddress,
      decimals: r.decimals,
      chainId: r.chainId,
      chainName: r.chainName,
      imageUrl: r.imageUrl
    };
  const s = pe(t);
  if (n === Ne.toLowerCase()) {
    const o = {
      id: `${(s == null ? void 0 : s.nativeCurrency.symbol) || "ETH"}-${(s == null ? void 0 : s.name) || "ethereum"}`,
      symbol: (s == null ? void 0 : s.nativeCurrency.symbol) || "ETH",
      name: (s == null ? void 0 : s.nativeCurrency.name) || "Ethereum",
      contractAddress: Ne,
      decimals: (s == null ? void 0 : s.nativeCurrency.decimals) || 18,
      chainId: t,
      chainName: (s == null ? void 0 : s.name) || "Ethereum",
      imageUrl: a0({
        chainId: t,
        contractAddress: Ne,
        symbol: (s == null ? void 0 : s.nativeCurrency.symbol) || "ETH"
      })
    };
    return h1(`${t}:${n}`, o), o;
  }
  const i = (await TE()).find(
    (o) => o.chainId === t && o.contractAddress.toLowerCase() === n
  );
  return i ? (h1(`${t}:${n}`, i), i) : null;
}
async function Bte(t, e) {
  const n = pe(t);
  if (e === (n == null ? void 0 : n.nativeCurrency.symbol))
    return Ne;
  const s = (await TE()).find(
    (a) => a.symbol === e && a.chainId === t
  );
  if (s != null && s.contractAddress)
    return s.contractAddress;
  throw new Error(
    `Unsupported token symbol: ${e} for chainId: ${t}`
  );
}
function Xre({
  chainId: t,
  tokenSymbol: e
}) {
  const { data: n } = ar({
    queryKey: ["tokenAddress", t, e],
    queryFn: () => t && e ? Bte(t, e) : null,
    enabled: !!t && !!e,
    staleTime: 36e5,
    // 1 hour - token addresses rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return n || null;
}
function Pte({
  symbol: t,
  contractAddress: e,
  chainId: n
}) {
  if (!t || !e || !n)
    return "";
  if (!t) {
    const s = _S.find(
      (a) => {
        var i;
        return a.chainId === n && ((i = a.contractAddress) == null ? void 0 : i.toLowerCase()) === e.toLowerCase();
      }
    );
    s && (t = s.symbol);
  }
  if (!t)
    return "";
  const r = Ute[t] ?? t;
  return tt[r] ? tt[r] : "";
}
function a0({
  chainId: t,
  contractAddress: e,
  symbol: n
}) {
  if (!t || !e || !n)
    return "";
  const r = Cte(
    t,
    e,
    n
  );
  if (r)
    return r;
  if (n) {
    const a = Pte({
      symbol: n,
      contractAddress: e,
      chainId: t
    });
    if (a)
      return a;
  }
  return `https://assets.sequence.info/images/tokens/large/${t}/${e.toLowerCase()}.webp`;
}
function Zre() {
  const { supportedTokens: t, isLoadingTokens: e } = HS();
  return {
    tokens: t,
    isLoadingTokens: e
  };
}
function Yre({
  address: t,
  chainId: e
}) {
  var p, f;
  const n = (t == null ? void 0 : t.startsWith("0x")) ?? !1, r = Eo(() => !n || !e ? null : LS(e, t), [n, e, t]), s = {
    address: t,
    abi: vl,
    chainId: e
  }, a = r7({
    contracts: n && e && !r ? [
      { ...s, functionName: "name" },
      { ...s, functionName: "symbol" },
      { ...s, functionName: "decimals" }
    ] : []
  }), i = (a == null ? void 0 : a.error) ?? ((f = (p = a == null ? void 0 : a.data) == null ? void 0 : p.find((b) => b.error)) == null ? void 0 : f.error) ?? null, [o, c, u] = a.data ?? [], l = pe(e), d = Eo(() => {
    if (r)
      return {
        id: r.id,
        name: r.name,
        symbol: r.symbol,
        decimals: r.decimals,
        chainId: r.chainId,
        contractAddress: r.contractAddress,
        chainName: r.chainName,
        imageUrl: r.imageUrl
      };
    if (c != null && c.result && (o != null && o.result) && (u == null ? void 0 : u.result) != null) {
      const b = {
        id: c.result,
        name: o.result,
        symbol: c.result,
        decimals: u.result,
        chainId: e,
        contractAddress: t,
        chainName: (l == null ? void 0 : l.name) ?? "",
        imageUrl: a0({
          chainId: e,
          contractAddress: t,
          symbol: c.result
        })
      };
      return h1(`${e}:${t.toLowerCase()}`, b), b;
    }
    return null;
  }, [
    r,
    t,
    e,
    l == null ? void 0 : l.name,
    o == null ? void 0 : o.result,
    c == null ? void 0 : c.result,
    u == null ? void 0 : u.result
  ]);
  return !n || !e ? {
    tokenInfo: null,
    isLoading: !1,
    error: null
  } : {
    tokenInfo: d,
    isLoading: !r && a.isLoading,
    error: i
  };
}
const tt = {
  ETH: "https://assets.sequence.info/images/tokens/large/1/0x0000000000000000000000000000000000000000.webp",
  POL: "https://assets.sequence.info/images/tokens/large/137/0x0000000000000000000000000000000000000000.webp",
  USDC: "https://assets.sequence.info/images/tokens/large/1/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.webp",
  USDT: "https://assets.sequence.info/images/tokens/large/1/0xdac17f958d2ee523a2206206994597c13d831ec7.webp",
  DAI: "https://assets.sequence.info/images/tokens/large/1/0x6b175474e89094c44da98b954eedeac495271d0f.webp",
  WBTC: "https://assets.sequence.info/images/tokens/large/1/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599.webp",
  BAT: "https://assets.sequence.info/images/tokens/large/1/0x0d8775f648430679a709e98d2b0cb6250d2887ef.webp",
  ARB: "https://assets.sequence.info/images/tokens/large/42161/0x912ce59144191c1204e64559fe8253a0e49e6548.webp",
  LINK: "https://assets.sequence.info/images/tokens/large/1/0x514910771af9ca656af840dff83e8264ecf986ca.webp"
}, Ute = {
  ETH: "ETH",
  WETH: "ETH",
  cbETH: "ETH",
  POL: "POL",
  WPOL: "POL",
  USDC: "USDC",
  "USDC.e": "USDC",
  USDT: "USDT",
  DAI: "DAI",
  xDAI: "DAI",
  WBTC: "WBTC",
  cbBTC: "WBTC",
  BAT: "BAT",
  ARB: "ARB",
  LINK: "LINK"
}, _S = [
  // Native tokens
  {
    id: "ETH-ethereum",
    symbol: "ETH",
    name: "Ethereum",
    contractAddress: "0x0000000000000000000000000000000000000000",
    decimals: 18,
    chainId: $e.id,
    chainName: $e.name,
    imageUrl: tt.ETH
  },
  {
    id: "ETH-arbitrum",
    symbol: "ETH",
    name: "ETH Arbitrum",
    contractAddress: "0x0000000000000000000000000000000000000000",
    decimals: 18,
    chainId: ut.id,
    chainName: ut.name,
    imageUrl: tt.ETH
  },
  {
    id: "ETH-optimism",
    symbol: "ETH",
    name: "ETH Optimism",
    contractAddress: "0x0000000000000000000000000000000000000000",
    decimals: 18,
    chainId: Pt.id,
    chainName: Pt.name,
    imageUrl: tt.ETH
  },
  {
    id: "ETH-base",
    symbol: "ETH",
    name: "ETH Base",
    contractAddress: "0x0000000000000000000000000000000000000000",
    decimals: 18,
    chainId: At.id,
    chainName: At.name,
    imageUrl: tt.ETH
  },
  {
    id: "POL-polygon",
    symbol: "POL",
    name: "Polygon",
    contractAddress: "0x0000000000000000000000000000000000000000",
    decimals: 18,
    chainId: ft.id,
    chainName: ft.name,
    imageUrl: tt.POL
  },
  // USDC
  {
    id: "USDC-ethereum",
    symbol: "USDC",
    name: "USDC",
    contractAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    decimals: 6,
    chainId: $e.id,
    chainName: $e.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-arbitrum",
    symbol: "USDC",
    name: "USDC Arbitrum",
    contractAddress: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    decimals: 6,
    chainId: ut.id,
    chainName: ut.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-avalanche",
    symbol: "USDC",
    name: "USDC Avalanche",
    contractAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    decimals: 6,
    chainId: pn.id,
    chainName: pn.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-base",
    symbol: "USDC",
    name: "USDC Base",
    contractAddress: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    decimals: 6,
    chainId: At.id,
    chainName: At.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-linea",
    symbol: "USDC",
    name: "USDC Linea",
    contractAddress: "0x176211869cA2b568f2A7D4EE941E073a821EE1ff",
    decimals: 6,
    chainId: js.id,
    chainName: js.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-optimism",
    symbol: "USDC",
    name: "USDC Optimism",
    contractAddress: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
    decimals: 6,
    chainId: Pt.id,
    chainName: Pt.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-polygon",
    symbol: "USDC",
    name: "USDC Polygon",
    contractAddress: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
    decimals: 6,
    chainId: ft.id,
    chainName: ft.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-unichain",
    symbol: "USDC",
    name: "USDC Unichain",
    contractAddress: "0x078D782b760474a361dDA0AF3839290b0EF57AD6",
    decimals: 6,
    chainId: Vs.id,
    chainName: Vs.name,
    imageUrl: tt.USDC
  },
  {
    id: "USDC-worldchain",
    symbol: "USDC",
    name: "USDC WorldChain",
    contractAddress: "0x79A02482A880bCe3F13E09da970dC34dB4cD24D1",
    decimals: 6,
    chainId: qs.id,
    chainName: qs.name,
    imageUrl: tt.USDC
  },
  // Basic Attention Token
  {
    id: "BAT-ethereum",
    symbol: "BAT",
    name: "Basic Attention Token",
    contractAddress: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF",
    decimals: 18,
    chainId: $e.id,
    chainName: $e.name,
    imageUrl: tt.BAT
  },
  {
    id: "BAT-polygon",
    symbol: "BAT",
    name: "Basic Attention Token",
    contractAddress: "0x3Cef98bb43d732E2F285eE605a8158cDE967D219",
    decimals: 18,
    chainId: ft.id,
    chainName: ft.name,
    imageUrl: tt.BAT
  },
  {
    id: "BAT-avalanche",
    symbol: "BAT",
    name: "Basic Attention Token",
    contractAddress: "0x98443B96EA4b0858FDF3219Cd13e98C7A4690588",
    decimals: 18,
    chainId: pn.id,
    chainName: pn.name,
    imageUrl: tt.BAT
  },
  // ARB
  {
    id: "ARB-arbitrum",
    symbol: "ARB",
    name: "Arbitrum",
    contractAddress: "0x912CE59144191C1204E64559FE8253a0e49E6548",
    decimals: 18,
    chainId: ut.id,
    chainName: ut.name,
    imageUrl: tt.ARB
  },
  // Chainlink
  {
    id: "LINK-ethereum",
    symbol: "LINK",
    name: "Chainlink",
    contractAddress: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    decimals: 18,
    chainId: $e.id,
    chainName: $e.name,
    imageUrl: tt.LINK
  }
], Nte = {
  1: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  10: "0x4200000000000000000000000000000000000006",
  8453: "0x4200000000000000000000000000000000000006",
  42161: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
  137: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
  100: "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1"
};
function ese(t) {
  return Nte[t] ?? null;
}
async function Rte(t, e) {
  if (!(t != null && t.chainId) || !(e != null && e.chainId) || !t || !e || !(t.blockNumber || t.transactionHash) || !(e.blockNumber || e.transactionHash) || t.blockNumber === e.blockNumber && t.transactionHash === e.transactionHash)
    return 0;
  const n = pe(t.chainId), r = pe(e.chainId);
  if (!n || !r) return 0;
  const s = hn({
    chain: n,
    transport: Ge()
  }), a = hn({
    chain: r,
    transport: Ge()
  });
  async function i(c, u) {
    return u.blockNumber ? BigInt(u.blockNumber) : (await c.getTransactionReceipt({
      hash: u.transactionHash
    })).blockNumber;
  }
  async function o(c, u) {
    const l = await c.getBlock({ blockNumber: u });
    return typeof l.timestamp == "bigint" ? Number(l.timestamp) : l.timestamp;
  }
  try {
    const [c, u] = await Promise.all([
      i(s, t),
      i(a, e)
    ]), [l, d] = await Promise.all([
      o(s, c),
      o(a, u)
    ]), p = d - l;
    return p < 1 ? 1 : p;
  } catch (c) {
    return console.error(
      "[trails-sdk] Error calculating transaction time difference:",
      c
    ), 0;
  }
}
const Dte = {
  42161: "https://arbitrum-indexer.sequence.app",
  8453: "https://base-indexer.sequence.app",
  84532: "https://base-sepolia-indexer.sequence.app",
  10: "https://optimism-indexer.sequence.app",
  137: "https://polygon-indexer.sequence.app",
  1: "https://mainnet-indexer.sequence.app",
  33139: "https://apechain-indexer.sequence.app",
  42170: "https://arbitrum-nova-indexer.sequence.app",
  43114: "https://avalanche-indexer.sequence.app",
  8333: "https://b3-indexer.sequence.app",
  81457: "https://blast-indexer.sequence.app",
  100: "https://gnosis-indexer.sequence.app",
  1868: "https://soneium-indexer.sequence.app",
  660279: "https://xai-indexer.sequence.app",
  56: "https://bsc-indexer.sequence.app",
  421613: "https://arbitrum-nova-sepolia-indexer.sequence.app"
};
async function Fte({
  chainId: t,
  accountAddress: e,
  pageSize: n = 10,
  includeMetadata: r = !0
}) {
  const s = lv(), a = Dte[t];
  if (!a)
    throw new Error(`Unsupported chain ID: ${t}`);
  const i = `${a}/rpc/Indexer/GetTransactionHistory`, o = {
    filter: {
      accountAddress: e.toLowerCase()
    },
    includeMetadata: r,
    page: {
      pageSize: n
    }
  };
  try {
    const c = await fetch(i, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Access-Key": s
      },
      body: JSON.stringify(o)
    });
    if (!c.ok)
      throw new Error(`HTTP error! status: ${c.status}`);
    return await c.json();
  } catch (c) {
    throw console.error("[trails-sdk] Error fetching transaction history:", c), c;
  }
}
function tse(t) {
  const e = [];
  let n = t;
  for (; n; )
    n.message && e.push(n.message), n = n.cause ?? n.originalError ?? n.error ?? null;
  return e.join(" | Caused by: ");
}
function $S(t) {
  return t instanceof Error ? t.message : (t == null ? void 0 : t.toString()) ?? "";
}
function nse(t) {
  return /rejected|denied/gi.test($S(t).toLowerCase());
}
function rse(t) {
  return /have enough balance|not enough balance|insufficient balance|insufficient funds|not enough funds|too low/gi.test(
    $S(t).toLowerCase()
  );
}
class Mte extends Error {
  constructor(e) {
    super(e), this.name = "InsufficientBalanceError";
  }
}
async function Lte(t, e = 100000n) {
  try {
    const n = await t.getGasPrice();
    return e * n;
  } catch (n) {
    throw new Error(`Failed to estimate gas cost: ${n}`);
  }
}
async function Hte(t, e, n = 100000n) {
  const r = await Lte(t, n);
  return parseFloat(sc(r, 18)) * e;
}
const m1 = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefn, _te = {
  [At.id]: "0x4F54Dc2C6bCa2D01e066fa36f4CFdA96B544DD20",
  [ut.id]: "0x8c070e800D0e0c33A0A4ceef7A91677410ed9444"
};
function $te(t) {
  return _te[t];
}
function Gte(t, e) {
  const r = e.toString(16).padStart(64, "0").toLowerCase(), s = t.toLowerCase().indexOf(r);
  if (s === -1) throw new Error("Placeholder not found");
  const a = (s - 2) / 2;
  if (a < 0 || a % 1 !== 0) throw new Error("Invalid offset");
  return a;
}
const zte = [
  {
    type: "function",
    name: "sweepAndCall",
    stateMutability: "nonpayable",
    inputs: [
      { name: "token", type: "address" },
      { name: "target", type: "address" },
      { name: "callData", type: "bytes" },
      { name: "amountOffset", type: "uint256" },
      { name: "placeholder", type: "bytes32" }
    ],
    outputs: []
  }
];
function jte({
  token: t,
  target: e,
  calldata: n,
  amountOffset: r
}) {
  const s = `0x${m1.toString(16).padStart(64, "0")}`;
  return Kt({
    abi: zte,
    functionName: "sweepAndCall",
    args: [t, e, n, r, s]
  });
}
function Vte({
  token: t,
  target: e,
  calldata: n,
  originChainId: r,
  destinationChainId: s,
  amount: a,
  originTokenAddress: i,
  destinationTokenAddress: o
}) {
  const c = (i == null ? void 0 : i.toLowerCase()) === (o == null ? void 0 : o.toLowerCase());
  if (r === s && c) {
    const p = BigInt(a).toString(16).padStart(64, "0"), f = m1.toString(
      16
    ).padStart(64, "0");
    return n.includes(f) ? {
      encodedCalldata: n.replace(f, p),
      proxyCallerAddress: e
    } : null;
  }
  const u = $te(s);
  if (!u)
    return null;
  const l = Gte(
    n,
    BigInt(m1)
  );
  return l === -1 ? null : {
    encodedCalldata: jte({
      token: t,
      target: e,
      calldata: n,
      amountOffset: l
    }),
    proxyCallerAddress: u
  };
}
const qte = async (t) => {
  const e = uv(), n = $o(), r = {
    "Content-Type": "application/json"
  };
  n && (r["X-Access-Key"] = n), await fetch(`${e.replace(/\/*$/, "")}/rpc/API/QueueCCTPTransfer`, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t)
  });
};
function Kte(t) {
  const e = t;
  return typeof (e == null ? void 0 : e.queueCCTPTransfer) == "function";
}
async function Wte({
  apiClient: t,
  sourceTxHash: e,
  sourceChainId: n,
  destinationChainId: r
}) {
  Kte(t) ? await t.queueCCTPTransfer({
    sourceTxHash: e,
    sourceChainId: n,
    destinationChainId: r
  }) : await qte({
    sourceTxHash: e,
    sourceChainId: n,
    destinationChainId: r
  });
}
var Qte = /* @__PURE__ */ ((t) => (t.EXACT_INPUT = "EXACT_INPUT", t.EXACT_OUTPUT = "EXACT_OUTPUT", t))(Qte || {});
function Jte(t, e) {
  return (t == null ? void 0 : t.toString()) === (e == null ? void 0 : e.toString());
}
function Xte(t, e) {
  return (t == null ? void 0 : t.toLowerCase()) === (e == null ? void 0 : e.toLowerCase());
}
function Zte(t, e, n, r) {
  return hA(t, n) && hA(e, r);
}
function y1() {
  return Pw("testnet") === "true";
}
function GS(t) {
  return Mw(t);
}
function Yte(t, e, n, r, s, a, i, o, c, u, l = Date.now().toString(), d, p, f) {
  const b = au(u);
  return (!f || f === "auto") && (f = void 0), {
    userAddress: t,
    originChainId: e,
    originTokenAddress: n,
    originTokenAmount: r,
    // max amount for exact_output
    destinationChainId: s,
    destinationToAddress: c,
    destinationTokenAddress: a,
    destinationTokenAmount: i,
    destinationTokenSymbol: o,
    destinationCallData: b ? u : "0x",
    destinationCallValue: "0",
    destinationSalt: l,
    slippageTolerance: Number(d),
    tradeType: p,
    provider: f
  };
}
async function ene(t) {
  const {
    account: e,
    originTokenAddress: n,
    originChainId: r,
    originTokenBalance: s,
    // account balance
    destinationChainId: a,
    recipient: i,
    destinationTokenAddress: o,
    swapAmount: c,
    tradeType: u = "EXACT_OUTPUT",
    destinationTokenSymbol: l,
    fee: d,
    client: p,
    dryMode: f = !1,
    apiClient: b,
    originRelayer: y,
    destinationRelayer: g,
    destinationCalldata: w,
    onTransactionStateChange: k,
    sourceTokenPriceUsd: E,
    destinationTokenPriceUsd: T,
    sourceTokenDecimals: A,
    destinationTokenDecimals: N,
    paymasterUrl: D,
    gasless: P = !1,
    slippageTolerance: C = T4(),
    originNativeTokenPriceUsd: S,
    quoteProvider: R,
    fundMethod: M
  } = t, _ = au(w), j = e.address, I = [];
  let F = i, $ = w;
  if (_ && o !== Ne && u === "EXACT_INPUT") {
    const W = Vte({
      token: o,
      target: F,
      calldata: $,
      amount: c,
      originChainId: r,
      destinationChainId: a,
      originTokenAddress: n,
      destinationTokenAddress: o
    });
    W && (F = W.proxyCallerAddress, $ = W.encodedCalldata);
  }
  if (sQ({
    userAddress: e.address,
    originChainId: r,
    destinationChainId: a,
    originTokenAddress: n,
    destinationTokenAddress: o,
    destinationTokenAmount: c
  }), s === "0")
    throw new Error("Origin token amount must be greater than 0");
  if (!p)
    throw vd({
      error: "Wallet client not provided",
      userAddress: e.address
    }), new Error("Wallet client not provided");
  const V = pe(r);
  if (!V)
    throw vd({
      error: `Chain ${r} not found`,
      userAddress: e.address
    }), new Error(`Chain ${r} not found`);
  const X = Jte(r, a), Z = Xte(
    n,
    o
  );
  console.log("[trails-sdk] isToSameChain", X), console.log("[trails-sdk] isToSameToken", Z);
  const Y = hn({
    chain: V,
    transport: Ge()
  });
  return I.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending",
    label: X && Z ? "Execute" : X && !Z ? "Swap" : "Transfer"
  }), X || (I.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending",
    label: Z ? "Bridge" : "Swap & Bridge"
  }), I.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: a,
    state: "pending",
    label: _ ? "Execute" : "Receive"
  })), k(I), X && !Z ? await rne({
    originTokenAddress: n,
    swapAmount: c,
    tradeType: u,
    destinationTokenAddress: o,
    destinationCalldata: $,
    recipient: F,
    originChainId: r,
    walletClient: p,
    publicClient: Y,
    account: e,
    slippageTolerance: C,
    onTransactionStateChange: k,
    transactionStates: I,
    sourceTokenPriceUsd: E,
    destinationTokenPriceUsd: T,
    originNativeTokenPriceUsd: S
  }) : Z && X ? await nne({
    originTokenAddress: n,
    swapAmount: c,
    destinationCalldata: $,
    recipient: F,
    walletClient: p,
    onTransactionStateChange: k,
    dryMode: f,
    account: e,
    chain: V,
    transactionStates: I,
    sourceTokenPriceUsd: E,
    destinationTokenPriceUsd: T,
    originNativeTokenPriceUsd: S,
    slippageTolerance: C
  }) : await tne({
    mainSignerAddress: j,
    originChainId: r,
    originTokenAddress: n,
    originTokenBalance: s,
    destinationChainId: a,
    destinationTokenAddress: o,
    swapAmount: c,
    destinationTokenSymbol: l,
    recipient: F,
    destinationCalldata: $,
    apiClient: b,
    sourceTokenPriceUsd: E,
    destinationTokenPriceUsd: T,
    sourceTokenDecimals: A,
    destinationTokenDecimals: N,
    gasless: P,
    paymasterUrl: D,
    originRelayer: y,
    destinationRelayer: g,
    walletClient: p,
    publicClient: Y,
    chain: V,
    account: e,
    fee: d,
    dryMode: f,
    onTransactionStateChange: k,
    transactionStates: I,
    slippageTolerance: C,
    tradeType: u,
    originNativeTokenPriceUsd: S,
    quoteProvider: R,
    fundMethod: M
  });
}
async function tne({
  mainSignerAddress: t,
  originChainId: e,
  originTokenAddress: n,
  originTokenBalance: r,
  destinationChainId: s,
  destinationTokenAddress: a,
  swapAmount: i,
  destinationTokenSymbol: o,
  recipient: c,
  destinationCalldata: u,
  apiClient: l,
  sourceTokenPriceUsd: d,
  destinationTokenPriceUsd: p,
  sourceTokenDecimals: f,
  destinationTokenDecimals: b,
  gasless: y,
  paymasterUrl: g,
  originRelayer: w,
  destinationRelayer: k,
  walletClient: E,
  publicClient: T,
  chain: A,
  account: N,
  fee: D,
  dryMode: P,
  onTransactionStateChange: C,
  transactionStates: S,
  slippageTolerance: R,
  tradeType: M,
  originNativeTokenPriceUsd: _,
  quoteProvider: j,
  fundMethod: I
}) {
  var Yt, Ys, ea, bt, wf;
  const F = y1(), $ = Zte(
    n,
    a,
    e,
    s
  ), V = Pw("cctp") === "true", X = au(u);
  if ($ && V)
    return console.log("[trails-sdk] using cctp"), {
      quote: await Bh({
        destinationAddress: c,
        destinationCalldata: u,
        originAmount: i,
        originTokenPriceUsd: (d == null ? void 0 : d.toString()) || null,
        destinationAmount: i,
        destinationTokenPriceUsd: (p == null ? void 0 : p.toString()) || null,
        originTokenAddress: n,
        destinationTokenAddress: a,
        originChainId: e,
        destinationChainId: s,
        transactionStates: S,
        originNativeTokenPriceUsd: _,
        slippageTolerance: R,
        quoteProvider: "cctp"
      }),
      send: async (ta) => {
        const _n = F ? Op(A) : A, Ye = F ? Op(s) : pe(s);
        if (!_n || !Ye)
          throw console.error("[trails-sdk] Invalid chain", {
            originChain: _n,
            destinationChain: Ye,
            originChainId: e,
            destinationChainId: s,
            chain: A,
            testnet: F
          }), new Error("Invalid chain");
        console.log("[trails-sdk] originChain", _n), console.log("[trails-sdk] destinationChain", Ye);
        const Dt = hn({
          chain: _n,
          transport: Ge()
        });
        let Bn, di;
        if (X) {
          const na = await RJ({
            walletClient: E,
            originChain: _n,
            destinationChain: Ye,
            amount: BigInt(i)
          });
          Bn = na.txHash, di = na.waitForAttestation;
        } else {
          const na = await IJ({
            walletClient: E,
            originChain: _n,
            destinationChain: Ye,
            amount: BigInt(i)
          });
          Bn = na.txHash, di = na.waitForAttestation;
        }
        ta && ta(), console.log("[trails-sdk] waiting for tx", Bn);
        const fi = await Dt.waitForTransactionReceipt({
          hash: Bn
        });
        console.log("[trails-sdk] tx receipt", fi), S[0] = _r(
          fi,
          _n.id,
          "Transfer"
        ), S[1] = _r(
          fi,
          _n.id,
          "Bridge"
        ), C(S);
        const iu = await di();
        if (!iu)
          throw new Error("Failed to retrieve attestation");
        const Ef = SJ(Ye.id);
        console.log("[trails-sdk] tokenMessenger", Ef);
        const zo = [];
        X ? zo.push(
          await MJ({
            attestation: iu,
            targetContract: c,
            calldata: u,
            gasLimit: 300000n,
            destinationChain: Ye
          })
        ) : zo.push(
          await NJ({
            tokenMessenger: Ef,
            attestation: iu
          })
        ), console.log("[trails-sdk] calls", zo);
        const i0 = Fw(), xf = Cd(i0), jo = Kd({
          account: xf,
          chain: Ye,
          transport: Ge()
        }), o0 = hn({
          chain: Ye,
          transport: Ge()
        });
        console.log("[trails-sdk] delegatorClient", jo);
        const ct = await IS(
          xf
        );
        console.log("[trails-sdk] sequenceWalletAddress", ct);
        const lr = await BS(
          ct,
          jo,
          o0,
          zo,
          Ye
        ), ur = await o0.waitForTransactionReceipt({
          hash: lr
        });
        return console.log("[trails-sdk] destinationReceipt", ur), S[2] = _r(
          ur,
          Ye.id,
          "Receive"
        ), C(S), {
          originUserTxReceipt: fi,
          originMetaTxnReceipt: null,
          destinationMetaTxnReceipt: null,
          totalCompletionSeconds: 0
        };
      }
    };
  const Z = Date.now().toString(), Y = Yte(
    t,
    e,
    n,
    M === "EXACT_OUTPUT" ? r : i,
    // originTokenAmount
    s,
    a,
    M === "EXACT_OUTPUT" ? i : "0",
    // destinationTokenAmount
    o,
    c,
    u,
    Z,
    R,
    M,
    j
  );
  console.log("[trails-sdk] Creating intent with args:", Y);
  const W = await bQ(l, Y);
  if (console.log("[trails-sdk] Got intent:", W), !((Yt = W.preconditions) != null && Yt.length) || !((Ys = W.calls) != null && Ys.length))
    throw new Error("Invalid intent");
  const Q = W.originIntentAddress;
  console.log("[trails-sdk] intent address:", Q.toString()), await wQ(
    l,
    t,
    W.calls,
    W.preconditions
  );
  const oe = UW(
    W.preconditions,
    e
  );
  if (!oe)
    throw new Error("No precondition found for origin chain");
  const te = (bt = (ea = oe == null ? void 0 : oe.data) == null ? void 0 : ea.min) == null ? void 0 : bt.toString(), ae = te, ue = W.quote.toAmount, Ie = W.quote.toAmountMin, Le = Ui(
    ae,
    f
  ), Ze = lc({
    amount: Le,
    usdPrice: d
  });
  console.log("[trails-sdk] depositAmountUsd", Ze, {
    amount: Le,
    usdPrice: d
  });
  const yt = Ui(
    ue,
    b
  ), Ke = lc({
    amount: yt,
    usdPrice: p
  });
  return console.log(
    "[trails-sdk] effectiveDestinationTokenAmountUsd",
    Ke,
    {
      amount: yt,
      usdPrice: p
    }
  ), {
    quote: await Bh({
      originAddress: Q,
      destinationAddress: c,
      destinationCalldata: u,
      originAmount: ae,
      destinationAmount: ue,
      originAmountMin: ae,
      destinationAmountMin: Ie,
      originTokenAddress: n,
      destinationTokenAddress: a,
      originTokenPriceUsd: (d == null ? void 0 : d.toString()) || null,
      destinationTokenPriceUsd: (p == null ? void 0 : p.toString()) || null,
      fees: cne(W, {
        tradeType: M,
        fromAmountUsd: Ze,
        toAmountUsd: Ke
      }),
      originChainId: e,
      destinationChainId: s,
      slippageTolerance: R,
      priceImpact: lne(W),
      priceImpactUsd: une(W),
      transactionStates: S,
      originNativeTokenPriceUsd: _,
      quoteProvider: (wf = W == null ? void 0 : W.quote) == null ? void 0 : wf.quoteProvider
    }),
    send: async (ta) => {
      if (!(I === "qr-code" || I === "exchange")) {
        const { hasEnoughBalance: ct, balanceError: lr } = await SE({
          account: N,
          tokenAddress: n,
          depositAmount: ae,
          publicClient: T
        });
        if (!ct)
          throw lr;
      }
      console.log("[trails-sdk] sending origin transaction"), console.log("[trails-sdk] needsNativeFee", !1), console.log("[trails-sdk] sourceTokenPriceUsd", d), console.log(
        "[trails-sdk] destinationTokenPriceUsd",
        p
      ), console.log("[trails-sdk] sourceTokenDecimals", f), console.log(
        "[trails-sdk] destinationTokenDecimals",
        b
      );
      let Ye = null, Dt = null, Bn = null;
      const di = y1(), fi = di ? Op(A) : A, iu = di ? GS(fi.id) : n;
      console.log("[trails-sdk] testnet", di);
      const Ef = async () => {
        if (I === "qr-code" || I === "exchange") {
          console.log("[trails-sdk] Skipping wallet deposit for QR code mode");
          return;
        }
        if (Ye = await ine({
          originTokenAddress: iu,
          gasless: y,
          paymasterUrl: g,
          chain: fi,
          account: N,
          originRelayer: w,
          firstPreconditionMin: te,
          intentAddress: Q,
          onOriginSend: ta,
          publicClient: T,
          walletClient: E,
          destinationTokenDecimals: b,
          sourceTokenDecimals: f,
          fee: D,
          dryMode: P,
          sourceTokenPriceUsd: d ?? null,
          destinationTokenPriceUsd: p ?? null,
          swapAmount: i,
          onTransactionStateChange: C,
          transactionStates: S,
          fundMethod: I
        }), !Ye)
          throw new Error("Failed to send origin transaction");
        S[0] = _r(
          Ye,
          e,
          "Transfer"
        ), C(S);
      }, zo = async () => {
        for (; ; ) {
          try {
            const ct = await Fte({
              chainId: e,
              accountAddress: Q
            });
            if (console.log(
              "[trails-sdk] getAccountTransactionHistory response",
              ct
            ), ct.transactions.length > 0) {
              const lr = ct.transactions[0];
              if (!lr) {
                await new Promise((na) => setTimeout(na, 1e3));
                continue;
              }
              const ur = await T.getTransactionReceipt({
                hash: lr.txnHash
              });
              Ye = ur, S[0] = _r(
                ur,
                e,
                "Transfer"
              ), C(S), ta && ta();
              break;
            }
          } catch (ct) {
            console.error("Error checking for deposit tx", ct);
          }
          await new Promise((ct) => setTimeout(ct, 1e3));
        }
      }, i0 = async () => {
        W.metaTxns[0] && W.preconditions[0] && (Dt = await zA({
          metaTx: W.metaTxns[0],
          relayer: w,
          precondition: W.preconditions[0]
        }), Dt && S[1] && (S[1] = _r(
          Dt,
          e,
          "Swap & Bridge"
        ), C(S)));
      }, xf = async () => {
        var ct, lr;
        if (W.quote.quoteProvider === "relay" && W.quote.quoteProviderRequestId && !W.preconditions[1] && !W.metaTxns[1]) {
          console.log("[trails-sdk] waitForRelayDestinationTx");
          try {
            const ur = await IK(
              W.quote.quoteProviderRequestId
            );
            if (console.log("[trails-sdk] waitForRelayDestinationTx txHash", ur), ur) {
              const PE = await hn({
                chain: pe(s),
                transport: Ge()
              }).getTransactionReceipt({
                hash: ur
              });
              console.log(
                "[trails-sdk] relay destinationTxnReceipt",
                PE
              ), S[2] = _r(
                PE,
                s,
                (ct = S[2]) == null ? void 0 : ct.label
              ), C(S);
            }
          } catch (ur) {
            console.error("Error waiting for relay destination tx", ur), S != null && S[2] && (S[2].state = "failed", C(S));
          }
        } else
          W.metaTxns[1] && W.preconditions[1] && (Bn = await zA({
            metaTx: W.metaTxns[1],
            relayer: k,
            precondition: W.preconditions[1]
          }), Bn && S[2] && (S[2] = _r(
            Bn,
            s,
            (lr = S == null ? void 0 : S[2]) == null ? void 0 : lr.label
          ), C(S)));
      };
      let jo = null;
      return W.quote.quoteProvider === "cctp" ? jo = async () => {
        for (; ; ) {
          const ct = Dt == null ? void 0 : Dt.txnHash;
          if (ct) {
            await Wte({
              apiClient: l,
              sourceTxHash: ct,
              sourceChainId: e,
              destinationChainId: s
            });
            break;
          }
          await new Promise((lr) => setTimeout(lr, 1e3));
        }
      } : jo = () => Promise.resolve(), zo().catch((ct) => {
        console.error("Error checking for deposit tx", ct);
      }), await Promise.all([
        Ef(),
        jo(),
        i0(),
        xf()
      ]), Ye && Bn ? Uw({
        userAddress: N.address,
        intentAddress: Q,
        originTxHash: Ye.transactionHash,
        destinationTxHash: Bn == null ? void 0 : Bn.txnHash,
        originChainId: e,
        destinationChainId: s
      }) : vd({
        error: "Payment transactions did not complete successfully",
        userAddress: N.address,
        intentAddress: Q
      }), {
        originUserTxReceipt: Ye,
        originMetaTxnReceipt: Dt,
        destinationMetaTxnReceipt: Bn,
        totalCompletionSeconds: await Rte(
          S[0],
          S[2]
        )
      };
    }
  };
}
async function nne({
  originTokenAddress: t,
  swapAmount: e,
  destinationCalldata: n,
  recipient: r,
  walletClient: s,
  onTransactionStateChange: a,
  dryMode: i,
  account: o,
  chain: c,
  transactionStates: u,
  sourceTokenPriceUsd: l,
  destinationTokenPriceUsd: d,
  originNativeTokenPriceUsd: p,
  slippageTolerance: f
}) {
  console.log("[trails-sdk] isToSameToken && isToSameChain");
  const b = y1(), y = b ? Op(c) : c, g = y.id, w = b ? GS(g) : t, k = hn({
    chain: y,
    transport: Ge()
  });
  return {
    quote: await Bh({
      originAddress: r,
      destinationAddress: r,
      destinationCalldata: n,
      originAmount: e,
      // fromAmount is same as toAmount for same chain same token
      destinationAmount: e,
      originTokenPriceUsd: (l == null ? void 0 : l.toString()) || null,
      destinationTokenPriceUsd: (d == null ? void 0 : d.toString()) || null,
      originTokenAddress: w,
      destinationTokenAddress: w,
      transactionStates: u,
      originChainId: g,
      destinationChainId: g,
      originNativeTokenPriceUsd: p,
      slippageTolerance: f,
      quoteProvider: ""
    }),
    send: async (E) => {
      const { hasEnoughBalance: T, balanceError: A } = await SE({
        account: o,
        tokenAddress: w,
        depositAmount: e,
        publicClient: k
      });
      if (!T)
        throw A;
      const N = au(n), D = {
        to: N || w === Ne ? r : w,
        data: N ? n : w === Ne ? "0x" : UT({
          recipient: r,
          amount: BigInt(e)
        }),
        value: w === Ne ? BigInt(e) : "0",
        chainId: g,
        chain: y
      };
      console.log("[trails-sdk] origin call params", D);
      let P = null;
      const C = null, S = null;
      if (await Rr({
        walletClient: s,
        desiredChainId: g
      }), !i) {
        if (a([
          {
            transactionHash: "",
            explorerUrl: "",
            chainId: g,
            state: "pending",
            label: "Execute"
          }
        ]), N)
          try {
            if (await Lw({
              publicClient: k,
              token: w,
              account: o.address,
              spender: r,
              amount: BigInt(e)
            })) {
              const j = await Hw({
                walletClient: s,
                tokenAddress: w,
                spender: r,
                amount: Lh,
                chain: y
              });
              console.log("waiting for approve", j), await k.waitForTransactionReceipt({
                hash: j
              }), console.log("approve done");
            }
          } catch (_) {
            console.error("[trails-sdk] Error approving ERC20", _);
          }
        console.log("[trails-sdk] origin call params", D);
        const R = await sT(
          o,
          s,
          D
        );
        console.log("[trails-sdk] origin tx", R), E && E();
        const M = await k.waitForTransactionReceipt({
          hash: R
        });
        console.log("[trails-sdk] receipt", M), P = M, rT({
          transactionHash: R,
          chainId: g,
          userAddress: o.address,
          blockNumber: Number(M.blockNumber)
        }), a([
          _r(
            P,
            g,
            "Swap"
          )
        ]), P && P.status === "success" ? Uw({
          userAddress: o.address,
          originTxHash: P.transactionHash,
          originChainId: g,
          destinationChainId: g
          // Same chain
        }) : P && vd({
          error: "Transaction failed",
          userAddress: o.address
        });
      }
      return {
        originUserTxReceipt: P,
        originMetaTxnReceipt: C,
        destinationMetaTxnReceipt: S,
        totalCompletionSeconds: 0
      };
    }
  };
}
async function rne({
  originTokenAddress: t,
  swapAmount: e,
  destinationTokenAddress: n,
  destinationCalldata: r,
  recipient: s,
  originChainId: a,
  walletClient: i,
  publicClient: o,
  account: c,
  tradeType: u = "EXACT_OUTPUT",
  slippageTolerance: l,
  onTransactionStateChange: d,
  transactionStates: p,
  sourceTokenPriceUsd: f,
  destinationTokenPriceUsd: b,
  originNativeTokenPriceUsd: y
}) {
  var N, D, P, C, S, R, M, _, j, I, F, $, V, X, Z, Y, W, Q, oe, te, ae, ue, Ie, Le, Ze, vt, yt, Ke, Yt, Ys, ea;
  const g = [], w = au(r);
  w && u === "EXACT_OUTPUT" ? g.push({
    to: s,
    value: n === Ne ? e : "0",
    data: r
  }) : w && u === "EXACT_INPUT" && g.push({
    to: s,
    value: "0",
    data: r
  });
  const k = await gK({
    wallet: i,
    chainId: a,
    amount: e,
    currency: t,
    toCurrency: n,
    txs: g,
    tradeType: u,
    slippageTolerance: l,
    recipient: w ? s : void 0
  });
  console.log("[trails-sdk] relaysdk quote", k);
  let E = "0", T = "0";
  if (u === "EXACT_INPUT")
    E = e, T = (P = (D = (N = k == null ? void 0 : k.details) == null ? void 0 : N.currencyOut) == null ? void 0 : D.amount) == null ? void 0 : P.toString();
  else
    try {
      if (T = e, E = (_ = (M = (R = (S = (C = k.steps) == null ? void 0 : C[0]) == null ? void 0 : S.items) == null ? void 0 : R[0]) == null ? void 0 : M.data) == null ? void 0 : _.value, t !== Ne) {
        const bt = sy({
          abi: vl,
          data: (V = ($ = (F = (I = (j = k.steps) == null ? void 0 : j[0]) == null ? void 0 : I.items) == null ? void 0 : F[0]) == null ? void 0 : $.data) == null ? void 0 : V.data
        });
        bt.functionName === "approve" && (E = bt.args[1].toString()), bt.functionName === "transfer" && (E = bt.args[1].toString());
      }
    } catch (bt) {
      console.error("[trails-sdk] Error decoding function data:", bt);
    }
  const A = (Ie = (ue = (ae = (Y = (Z = k == null ? void 0 : k.steps) == null ? void 0 : Z[((X = k == null ? void 0 : k.steps) == null ? void 0 : X.length) - 1]) == null ? void 0 : Y.items) == null ? void 0 : ae[((te = (oe = (Q = k == null ? void 0 : k.steps) == null ? void 0 : Q[((W = k == null ? void 0 : k.steps) == null ? void 0 : W.length) - 1]) == null ? void 0 : oe.items) == null ? void 0 : te.length) - 1]) == null ? void 0 : ue.data) == null ? void 0 : Ie.to;
  if ((Ze = (Le = k == null ? void 0 : k.details) == null ? void 0 : Le.currencyIn) != null && Ze.amountFormatted && ((yt = (vt = k == null ? void 0 : k.details) == null ? void 0 : vt.currencyIn) != null && yt.amountUsd)) {
    const bt = Number(k.details.currencyIn.amountUsd) / Number(k.details.currencyIn.amountFormatted);
    bt && (f = bt);
  }
  if ((Yt = (Ke = k == null ? void 0 : k.details) == null ? void 0 : Ke.currencyOut) != null && Yt.amountFormatted && ((ea = (Ys = k == null ? void 0 : k.details) == null ? void 0 : Ys.currencyOut) != null && ea.amountUsd)) {
    const bt = Number(k.details.currencyOut.amountUsd) / Number(k.details.currencyOut.amountFormatted);
    bt && (b = bt);
  }
  return {
    quote: await Bh({
      originAddress: A,
      destinationAddress: s,
      destinationCalldata: r,
      originAmount: E,
      destinationAmount: T,
      originTokenAddress: t,
      destinationTokenAddress: n,
      originTokenPriceUsd: (f == null ? void 0 : f.toString()) || null,
      destinationTokenPriceUsd: (b == null ? void 0 : b.toString()) || null,
      fees: dne(k),
      slippageTolerance: fne(k),
      priceImpact: pne(k),
      priceImpactUsd: hne(k),
      transactionStates: p,
      originChainId: a,
      destinationChainId: a,
      originNativeTokenPriceUsd: y,
      quoteProvider: "relay"
    }),
    send: async (bt) => {
      const { hasEnoughBalance: wf, balanceError: ta } = await SE({
        account: c,
        tokenAddress: t,
        depositAmount: E,
        publicClient: o
      });
      if (!wf)
        throw ta;
      await Rr({
        walletClient: i,
        desiredChainId: a
      });
      const _n = await EK(k, i);
      console.log("[trails-sdk] relaysdk result", _n);
      const Ye = xK(_n);
      bt && bt();
      const Dt = await o.waitForTransactionReceipt({
        hash: Ye
      });
      return p[0] = _r(
        Dt,
        a,
        "Swap"
      ), d(p), Dt && Dt.status === "success" ? Uw({
        userAddress: c.address,
        originTxHash: Dt.transactionHash,
        originChainId: a,
        destinationChainId: a
        // Same chain
      }) : Dt && vd({
        error: "Relay transaction failed",
        userAddress: c.address
      }), {
        originUserTxReceipt: Dt,
        originMetaTxnReceipt: null,
        destinationMetaTxnReceipt: null,
        totalCompletionSeconds: 0
      };
    }
  };
}
async function sne({
  paymasterUrl: t,
  depositTokenAddress: e,
  depositTokenAmount: n,
  depositRecipient: r,
  onOriginSend: s,
  walletClient: a,
  chain: i,
  account: o,
  originRelayer: c
}) {
  let u = null;
  const l = i.id;
  console.log("[trails-sdk] originChainId", l);
  const d = hn({
    chain: i,
    transport: Ge()
  }), p = m4[i.id];
  console.log("[trails-sdk] intentEntrypoint", p);
  let f = [];
  if (t) {
    console.log("[trails-sdk] doing gasless with paymaster");
    const b = await EZ({
      publicClient: d
    });
    p ? f = await mA({
      publicClient: d,
      walletClient: a,
      account: o,
      intentEntrypoint: p,
      depositTokenAddress: e,
      depositTokenAmount: BigInt(n),
      depositRecipient: r,
      chain: i
    }) : f = await xZ({
      walletClient: a,
      chain: i,
      tokenAddress: e,
      amount: BigInt(n),
      recipient: r,
      delegatorSmartAccount: b
    }), console.log("[trails-sdk] calls", f);
    const y = await AZ({
      walletClient: a,
      publicClient: d,
      chain: i,
      paymasterUrl: t,
      delegatorSmartAccount: b,
      calls: f
    });
    s && s();
    const g = await d.waitForTransactionReceipt({
      hash: y
    });
    console.log("[trails-sdk] receipt", g), u = g;
  } else {
    console.log("[trails-sdk] doing gasless with sequence wallet");
    const b = Fw(), y = Cd(b), g = Kd({
      account: y,
      chain: i,
      transport: Ge()
    });
    console.log("[trails-sdk] attempting to switch chain"), await Rr({
      walletClient: a,
      desiredChainId: l
    }), console.log("[trails-sdk] creating sequence wallet");
    const w = await IS(
      y
    );
    if (console.log("[trails-sdk] sequenceWalletAddress", w), p)
      f = await mA({
        publicClient: d,
        walletClient: a,
        account: o,
        intentEntrypoint: p,
        depositTokenAddress: e,
        depositTokenAmount: BigInt(n),
        depositRecipient: r,
        chain: i
      });
    else {
      const { signature: A, deadline: N } = await $w({
        publicClient: d,
        walletClient: a,
        signer: o.address,
        spender: w,
        tokenAddress: e,
        amount: BigInt(n),
        chain: i
      });
      f = $J(
        o.address,
        w,
        BigInt(n),
        N,
        A,
        r,
        e
      );
    }
    console.log("[trails-sdk] calls", f);
    const k = await fte(
      c,
      w,
      l,
      f.map((A) => ({
        to: A.to,
        value: BigInt(A.value),
        data: A.data,
        gasLimit: BigInt(0),
        delegateCall: !1,
        onlyFallback: !1,
        behaviorOnError: "revert"
      }))
    );
    console.log("[trails-sdk] feeOptions", k);
    const E = await BS(
      w,
      g,
      d,
      f,
      i
    );
    console.log("[trails-sdk] sequenceTxHash", E), s && s();
    const T = await d.waitForTransactionReceipt({
      hash: E
    });
    console.log("[trails-sdk] receipt", T), u = T;
  }
  return u;
}
async function ane({
  originTokenAddress: t,
  firstPreconditionMin: e,
  onOriginSend: n,
  publicClient: r,
  walletClient: s,
  originChainId: a,
  chain: i,
  account: o,
  fee: c,
  dryMode: u,
  sourceTokenPriceUsd: l,
  destinationTokenPriceUsd: d,
  swapAmount: p,
  destinationTokenDecimals: f,
  sourceTokenDecimals: b,
  intentAddress: y,
  onTransactionStateChange: g,
  transactionStates: w
}) {
  let k = null, E = !1;
  ay("0.00005", 18).toString(), a === 137 && ay("1.5", 18).toString(), console.log("[trails-sdk] needsNativeFee", E);
  const T = {
    to: t === Ne ? y : t,
    data: t === Ne ? "0x" : UT({
      recipient: y,
      amount: BigInt(e) + BigInt(c)
    }),
    value: t === Ne ? BigInt(e) + BigInt(c) : "0",
    chainId: a,
    chain: i
  };
  if (await Rr({
    walletClient: s,
    desiredChainId: a
  }), u && console.log("[trails-sdk] dry mode, skipping send calls"), console.log("[trails-sdk] using sendTransaction"), !u) {
    const A = await sT(
      o,
      s,
      T
    );
    console.log("[trails-sdk] origin tx", A), n && n(), w[0] && (w[0].state = "pending", g(w));
    const N = await r.waitForTransactionReceipt({
      hash: A
    });
    rT({
      transactionHash: A,
      chainId: a,
      userAddress: o.address,
      blockNumber: Number(N.blockNumber),
      intentAddress: y
    }), console.log("[trails-sdk] receipt", N), k = N;
  }
  return k;
}
async function ine({
  originTokenAddress: t,
  gasless: e,
  paymasterUrl: n,
  chain: r,
  account: s,
  originRelayer: a,
  firstPreconditionMin: i,
  intentAddress: o,
  onOriginSend: c,
  publicClient: u,
  walletClient: l,
  destinationTokenDecimals: d,
  sourceTokenDecimals: p,
  fee: f,
  dryMode: b,
  sourceTokenPriceUsd: y,
  destinationTokenPriceUsd: g,
  swapAmount: w,
  onTransactionStateChange: k,
  transactionStates: E,
  fundMethod: T
}) {
  let A = null;
  const N = r.id;
  if (T === "qr-code" || T === "exchange")
    return console.log("[trails-sdk] Skipping wallet deposit for QR code mode"), null;
  const D = one(t, e, n);
  if (console.log("[trails-sdk] doGasless", D, n), D)
    try {
      A = await sne({
        paymasterUrl: n,
        depositTokenAddress: t,
        depositTokenAmount: i,
        depositRecipient: o,
        onOriginSend: c,
        walletClient: l,
        chain: r,
        account: s,
        originRelayer: a
      });
    } catch (P) {
      console.log("[trails-sdk] gassless attempt failed", P);
    }
  return A || (A = await ane({
    originTokenAddress: t,
    firstPreconditionMin: i,
    intentAddress: o,
    onOriginSend: c,
    publicClient: u,
    walletClient: l,
    originChainId: N,
    chain: r,
    account: s,
    fee: f,
    dryMode: b,
    sourceTokenPriceUsd: y,
    destinationTokenPriceUsd: g,
    swapAmount: w,
    destinationTokenDecimals: d,
    sourceTokenDecimals: p,
    onTransactionStateChange: k,
    transactionStates: E
  })), A;
}
function one(t, e, n) {
  return !!(t !== Ne && (e || n));
}
function _r(t, e, n = "Transaction") {
  let r = "", s = "pending", a = 0;
  return "transactionHash" in t ? (r = t.transactionHash, s = t.status === "success" ? "confirmed" : "failed", a = Number(t.blockNumber)) : "txnHash" in t && (r = t.txnHash, s = t.status === "SUCCEEDED" ? "confirmed" : "failed", a = Number(t.blockNumber)), {
    transactionHash: r,
    explorerUrl: Ig({ txHash: r, chainId: e }),
    chainId: e,
    blockNumber: a,
    state: s,
    label: n
  };
}
async function zA({
  metaTx: t,
  relayer: e,
  precondition: n
}) {
  var r;
  try {
    let s = null;
    console.log("[trails-sdk] metaTx", t), hQ({
      walletAddress: t.walletAddress,
      contractAddress: t.contract,
      chainId: Number(t.chainId)
    });
    const a = await KJ(e, t, [n]);
    for (console.log("[trails-sdk] opHash", a), mQ({
      walletAddress: t.walletAddress,
      contractAddress: t.contract,
      chainId: Number(t.chainId)
    }); ; ) {
      console.log(
        "[trails-sdk] polling status",
        t.id,
        BigInt(t.chainId)
      );
      const i = await qJ(
        e,
        t.id,
        Number(t.chainId)
      );
      if (console.log("[trails-sdk] status", i), i != null && i.transactionHash) {
        s = (r = i.data) == null ? void 0 : r.receipt;
        break;
      }
      await new Promise((o) => setTimeout(o, 1e3));
    }
    return s;
  } catch (s) {
    throw yQ({
      walletAddress: t.walletAddress,
      contractAddress: t.contract,
      chainId: Number(t.chainId),
      error: s instanceof Error ? s.message : "Unknown error"
    }), s;
  }
}
async function SE({
  account: t,
  tokenAddress: e,
  depositAmount: n,
  publicClient: r
}) {
  try {
    let s;
    e === Ne ? s = await r.getBalance({ address: t.address }) : s = await r.readContract({
      address: e,
      abi: vl,
      functionName: "balanceOf",
      args: [t.address]
    });
    const a = BigInt(n);
    console.log("[trails-sdk] balance", s), console.log("[trails-sdk] requiredAmount", a);
    const i = s >= a;
    console.log("[trails-sdk] hasEnoughBalance", i);
    let o = "", c = "";
    if (e === Ne)
      o = sc(s, 18), c = sc(a, 18);
    else {
      const l = await r.readContract({
        address: e,
        abi: vl,
        functionName: "decimals"
      });
      o = sc(s, l), c = sc(a, l);
    }
    let u = null;
    return i || (u = new Mte(
      `Insufficient balance: Need ${Ni(c)} but only have ${Ni(o)}`
    )), {
      hasEnoughBalance: i,
      balance: s,
      balanceFormatted: o,
      requiredAmount: a,
      requiredAmountFormatted: c,
      balanceError: u
    };
  } catch (s) {
    return console.error("[trails-sdk] Error checking account balance:", s), {
      hasEnoughBalance: !1,
      balance: BigInt(0),
      balanceFormatted: "0",
      requiredAmount: BigInt(0),
      requiredAmountFormatted: "0",
      balanceError: s instanceof Error ? s : null
    };
  }
}
function sse({
  walletClient: t,
  fromTokenAddress: e,
  fromChainId: n,
  toTokenAddress: r,
  toChainId: s,
  swapAmount: a,
  tradeType: i,
  toRecipient: o,
  slippageTolerance: c,
  onStatusUpdate: u
} = {}) {
  var T;
  const l = ef(), { getRelayer: d } = jZ({
    env: Kl(),
    useV3Relayers: ql()
  }), p = df(), { supportedTokens: f } = HS(), { tokenBalance: b } = gte({
    account: (T = t == null ? void 0 : t.account) == null ? void 0 : T.address,
    token: e,
    chainId: n,
    indexerGatewayClient: p,
    apiClient: l
  }), y = r && s ? {
    tokenId: r,
    chainId: s,
    contractAddress: r
  } : null, { tokenPrice: g } = SZ(
    y,
    l
  ), { data: w, isLoading: k, error: E } = ar({
    queryKey: [
      "quote",
      e,
      n,
      r,
      s,
      a == null ? void 0 : a.toString(),
      o,
      i,
      c
    ],
    queryFn: async () => {
      var Z, Y;
      if (!t || !l || !e || !r || !a || !o || !n || !s || !(b != null && b.balance))
        return null;
      const A = (b == null ? void 0 : b.balance) ?? "0", N = d(s), D = d(n), P = ((Z = b == null ? void 0 : b.price) == null ? void 0 : Z.value) ?? 0, C = ((Y = g == null ? void 0 : g.price) == null ? void 0 : Y.value) ?? 0;
      if (A === "0")
        return null;
      const S = f == null ? void 0 : f.find(
        (W) => W.contractAddress === e && W.chainId === n
      ), R = f == null ? void 0 : f.find(
        (W) => W.contractAddress === r && W.chainId === s
      ), M = (S == null ? void 0 : S.decimals) ?? 18, _ = (R == null ? void 0 : R.decimals) ?? 18, j = (R == null ? void 0 : R.symbol) ?? "", I = {
        account: t.account,
        originTokenAddress: e,
        originChainId: n,
        originTokenBalance: A,
        destinationChainId: s,
        recipient: o,
        destinationTokenAddress: r,
        swapAmount: a.toString(),
        tradeType: i ?? "EXACT_OUTPUT",
        destinationTokenSymbol: j,
        client: t,
        apiClient: l,
        originRelayer: D,
        destinationRelayer: N,
        sourceTokenPriceUsd: P,
        destinationTokenPriceUsd: C,
        sourceTokenDecimals: M,
        destinationTokenDecimals: _,
        fee: "0",
        dryMode: !1,
        onTransactionStateChange: u ?? (() => {
        }),
        slippageTolerance: c == null ? void 0 : c.toString()
      };
      console.log("[trails-sdk] options", I);
      const { quote: F, send: $ } = await ene(I);
      return {
        quote: {
          fromAmount: F.originAmount,
          toAmount: F.destinationAmount,
          fromAmountMin: F.originAmountMin,
          toAmountMin: F.destinationAmountMin,
          originToken: F.originToken,
          destinationToken: F.destinationToken,
          originChain: F.originChain,
          destinationChain: F.destinationChain,
          fees: F.fees,
          priceImpact: F.priceImpact,
          completionEstimateSeconds: F.completionEstimateSeconds,
          slippageTolerance: F.slippageTolerance,
          transactionStates: F.transactionStates,
          originTokenRate: F.originTokenRate,
          destinationTokenRate: F.destinationTokenRate,
          quoteProvider: F.quoteProvider
        },
        swap: async () => {
          const {
            originUserTxReceipt: W,
            destinationMetaTxnReceipt: Q,
            totalCompletionSeconds: oe
          } = await $();
          return {
            originTransaction: {
              transactionHash: W == null ? void 0 : W.transactionHash,
              explorerUrl: Ig({
                txHash: W == null ? void 0 : W.transactionHash,
                chainId: n
              }),
              receipt: W
            },
            destinationTransaction: {
              transactionHash: Q == null ? void 0 : Q.txnHash,
              explorerUrl: Ig({
                txHash: Q == null ? void 0 : Q.txnHash,
                chainId: s
              }),
              receipt: Q
            },
            totalCompletionSeconds: oe
          };
        }
      };
    },
    // Prevent unnecessary refetching
    enabled: !!(t && l && e && r && a && o && n && s && (b != null && b.balance)),
    staleTime: 30 * 1e3,
    // Consider data fresh for 30 seconds
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnMount: !1,
    // Don't refetch on component remount if data exists
    refetchInterval: !1,
    // Disable automatic polling
    retry: 2,
    // Limit retry attempts
    refetchOnReconnect: !0
    // Refetch when network reconnects
  });
  return {
    quote: (w == null ? void 0 : w.quote) || null,
    swap: (w == null ? void 0 : w.swap) || null,
    isLoadingQuote: k,
    quoteError: E
  };
}
function cne(t, {
  tradeType: e,
  fromAmountUsd: n,
  toAmountUsd: r
}) {
  var i, o, c;
  const s = ((i = t == null ? void 0 : t.quote) == null ? void 0 : i.quoteProviderFeeUsd) ?? 0, a = vr(s);
  return console.log("[trails-sdk] getFeesFromIntent", {
    tradeType: e,
    fromAmountUsd: n,
    toAmountUsd: r,
    totalFeeAmountUsd: s,
    totalFeeAmountUsdDisplay: a
  }), {
    feeTokenAddress: ((o = t.trailsFee) == null ? void 0 : o.feeToken) ?? Ne,
    totalFeeAmount: ((c = t.trailsFee) == null ? void 0 : c.totalFeeAmount) ?? "0",
    totalFeeAmountUsd: s.toString(),
    totalFeeAmountUsdDisplay: a
  };
}
function lne(t) {
  var e, n;
  return ((n = (e = t == null ? void 0 : t.quote) == null ? void 0 : e.priceImpact) == null ? void 0 : n.toString()) ?? "0";
}
function une(t) {
  var e, n;
  return ((n = (e = t == null ? void 0 : t.quote) == null ? void 0 : e.priceImpactUsd) == null ? void 0 : n.toString()) ?? "0";
}
function dne(t) {
  var r, s, a, i, o, c, u;
  const e = ((s = (r = t == null ? void 0 : t.fees) == null ? void 0 : r.relayer) == null ? void 0 : s.amount) ?? 0, n = vr(e);
  return {
    feeTokenAddress: ((o = (i = (a = t == null ? void 0 : t.fees) == null ? void 0 : a.relayer) == null ? void 0 : i.currency) == null ? void 0 : o.address) ?? Ne,
    totalFeeAmount: ((u = (c = t == null ? void 0 : t.fees) == null ? void 0 : c.relayer) == null ? void 0 : u.amount) ?? "0",
    totalFeeAmountUsd: e.toString(),
    totalFeeAmountUsdDisplay: n
  };
}
function fne(t) {
  var e, n, r;
  return (Number(((r = (n = (e = t == null ? void 0 : t.details) == null ? void 0 : e.slippageTolerance) == null ? void 0 : n.origin) == null ? void 0 : r.percent) ?? "0") / 100).toString();
}
function pne(t) {
  var e, n;
  return (((n = (e = t == null ? void 0 : t.details) == null ? void 0 : e.swapImpact) == null ? void 0 : n.percent) ?? 0).toString();
}
function hne(t) {
  var e, n;
  return (((n = (e = t == null ? void 0 : t.details) == null ? void 0 : e.swapImpact) == null ? void 0 : n.usd) ?? 0).toString();
}
function mne() {
  return {
    feeTokenAddress: Ne,
    totalFeeAmount: "0",
    totalFeeAmountUsd: "0",
    totalFeeAmountUsdDisplay: vr(0)
  };
}
function yne({
  originChainId: t,
  destinationChainId: e
}) {
  return t === $e.id && e === $e.id ? 60 : t === $e.id || e === $e.id ? 45 : 15;
}
function au(t) {
  return t !== void 0 && t !== "" && t !== "0x";
}
async function Bh({
  originAddress: t,
  destinationAddress: e,
  destinationCalldata: n,
  originChainId: r,
  destinationChainId: s,
  originAmount: a,
  originAmountMin: i,
  destinationAmount: o,
  destinationAmountMin: c,
  originTokenAddress: u,
  destinationTokenAddress: l,
  originTokenPriceUsd: d,
  destinationTokenPriceUsd: p,
  transactionStates: f,
  fees: b,
  slippageTolerance: y,
  priceImpact: g,
  priceImpactUsd: w,
  originNativeTokenPriceUsd: k,
  quoteProvider: E
}) {
  if (!s)
    throw new Error("Destination chain id is required");
  if (!l && r === s && (l = u), !l && r === s && (l = u), !l)
    throw new Error("Destination token address is required");
  const T = await GA(r, u), A = await GA(
    s,
    l
  ), N = pe(r), D = pe(s);
  if (!T || !A || !N || !D)
    throw console.error("[trails-sdk] Token or chain not found", {
      originToken: T,
      destinationToken: A,
      originChain: N,
      destinationChain: D
    }), new Error("Token or chain not found");
  const P = Ui(
    i || "0",
    T.decimals
  ), C = Ni(
    lc({
      amount: P,
      usdPrice: d
    })
  ), S = vr(
    C
  ), R = Ui(
    c || "0",
    A.decimals
  ), M = Ni(
    lc({
      amount: R,
      usdPrice: p
    })
  ), _ = vr(
    M
  ), j = Ui(
    a,
    T.decimals
  ), I = Ni(
    lc({
      amount: j,
      usdPrice: d
    })
  ), F = vr(
    I
  ), $ = Ui(
    o,
    A.decimals
  ), V = Ni(
    lc({
      amount: $,
      usdPrice: p
    })
  ), X = vr(
    V
  ), Z = au(n), Y = hn({
    chain: N,
    transport: Ge()
  });
  let W = 0, Q = "0";
  try {
    k && (W = await Hte(
      Y,
      k,
      200000n
    ), Q = vr(W));
  } catch (yt) {
    console.error("[trails-sdk] Error estimating gas cost", yt);
  }
  const oe = d ? Number(d) : 0, te = p ? Number(p) : 0, ae = bne(
    oe,
    te,
    T.symbol,
    A.symbol
  );
  let ue = "";
  E === "cctp" ? ue = "https://www.circle.com/" : E === "relay" ? ue = "https://relay.link/" : E === "lifi" && (ue = "https://li.fi/");
  const Le = {
    cctp: "Circle CCTP",
    relay: "Relay",
    lifi: "LiFi"
  }[E] || E || "", Ze = {
    id: E || "",
    name: Le || "",
    url: ue || ""
  }, vt = vr(w);
  return {
    originAddress: t || "",
    destinationAddress: e || "",
    destinationCalldata: Z && n || "",
    originAmount: a || "0",
    originAmountMin: i || a || "0",
    originAmountMinUsdFormatted: C || "0",
    originAmountMinUsdDisplay: S || "0",
    destinationAmount: o || "0",
    destinationAmountMin: c || o || "0",
    destinationAmountMinUsdFormatted: M || "0",
    destinationAmountMinUsdDisplay: _ || "0",
    originAmountFormatted: j,
    originAmountUsdFormatted: I,
    originAmountUsdDisplay: F,
    destinationAmountFormatted: $,
    destinationAmountUsdFormatted: V,
    destinationAmountUsdDisplay: X,
    originToken: T,
    destinationToken: A,
    fees: b || mne(),
    slippageTolerance: y || "0",
    priceImpact: g || "0",
    priceImpactUsdDisplay: vt || "0",
    originChain: N,
    destinationChain: D,
    completionEstimateSeconds: yne({
      originChainId: r,
      destinationChainId: s
    }),
    transactionStates: f || [],
    gasCostUsd: W,
    gasCostUsdDisplay: Q,
    originTokenRate: ae.originTokenRate,
    destinationTokenRate: ae.destinationTokenRate,
    originAmountDisplay: fc(j),
    destinationAmountDisplay: fc($),
    originAmountMinDisplay: fc(P),
    destinationAmountMinDisplay: fc(
      R
    ),
    quoteProvider: Ze
  };
}
function bne(t, e, n, r) {
  if (t === 0 || e === 0)
    return {
      originTokenRate: "0",
      destinationTokenRate: "0"
    };
  const s = t / e, a = e / t, i = fc(s, {
    maxFractionDigits: r === "USDC" ? 2 : 7
  }), o = fc(a, {
    maxFractionDigits: n === "USDC" ? 2 : 7
  });
  return {
    originTokenRate: `1 ${n} = ${i} ${r}`,
    destinationTokenRate: `1 ${r} = ${o} ${n}`
  };
}
export {
  v3 as $,
  Ire as A,
  DK as B,
  df as C,
  wQ as D,
  ene as E,
  sse as F,
  Qte as G,
  NS as H,
  wte as I,
  Ete as J,
  Qre as K,
  Kre as L,
  Wre as M,
  qre as N,
  TE as O,
  HS as P,
  Zre as Q,
  Rte as R,
  zl as S,
  d4 as T,
  m1 as U,
  gd as V,
  dw as W,
  Ll as X,
  ire as Y,
  E3 as Z,
  H as _,
  on as a,
  TZ as a$,
  Zl as a0,
  mw as a1,
  are as a2,
  sre as a3,
  Wa as a4,
  cr as a5,
  rh as a6,
  HL as a7,
  jL as a8,
  Gre as a9,
  zre as aA,
  EX as aB,
  xX as aC,
  GT as aD,
  WP as aE,
  U as aF,
  je as aG,
  ew as aH,
  Br as aI,
  Dl as aJ,
  Y1 as aK,
  Ci as aL,
  bd as aM,
  nU as aN,
  lU as aO,
  RC as aP,
  Fre as aQ,
  Ue as aR,
  rre as aS,
  ze as aT,
  Mre as aU,
  Dne as aV,
  Pte as aW,
  _re as aX,
  $e as aY,
  Yre as aZ,
  Xre as a_,
  PL as aa,
  x3 as ab,
  yX as ac,
  $T as ad,
  Tn as ae,
  lre as af,
  Wl as ag,
  BW as ah,
  Dre as ai,
  Dv as aj,
  Yne as ak,
  Zne as al,
  xA as am,
  J as an,
  ni as ao,
  L4 as ap,
  Fe as aq,
  Gs as ar,
  qU as as,
  cX as at,
  $X as au,
  GX as av,
  vA as aw,
  nw as ax,
  AX as ay,
  jre as az,
  u7 as b,
  Ni as b0,
  Ui as b1,
  vr as b2,
  zZ as b3,
  CZ as b4,
  fc as b5,
  IA as b6,
  tse as b7,
  Ore as b8,
  Vre as b9,
  jne as bA,
  ese as bB,
  Bh as bC,
  $S as bD,
  nse as bE,
  rse as bF,
  Jre as ba,
  Ine as bb,
  SZ as bc,
  rs as bd,
  z as be,
  kn as bf,
  Gne as bg,
  E1 as bh,
  Lre as bi,
  Hre as bj,
  a6 as bk,
  Fne as bl,
  Mne as bm,
  Lne as bn,
  Hne as bo,
  _ne as bp,
  zne as bq,
  Vne as br,
  $ne as bs,
  Kne as bt,
  cm as bu,
  Sne as bv,
  Tne as bw,
  uv as bx,
  C4 as by,
  qne as bz,
  ql as c,
  ef as d,
  jZ as e,
  ar as f,
  E7 as g,
  sd as h,
  _l as i,
  UT as j,
  $re as k,
  pe as l,
  gQ as m,
  lt as n,
  aA as o,
  Rr as p,
  Wte as q,
  GZ as r,
  cy as s,
  PW as t,
  y6 as u,
  u4 as v,
  l4 as w,
  bQ as x,
  S4 as y,
  pC as z
};
