var L5 = Object.defineProperty;
var ww = (t) => {
  throw TypeError(t);
};
var H5 = (t, e, n) => e in t ? L5(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var R = (t, e, n) => H5(t, typeof e != "symbol" ? e + "" : e, n), Kh = (t, e, n) => e.has(t) || ww("Cannot " + n);
var p = (t, e, n) => (Kh(t, e, "read from private field"), n ? n.call(t) : e.get(t)), T = (t, e, n) => e.has(t) ? ww("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), E = (t, e, n, r) => (Kh(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n), _ = (t, e, n) => (Kh(t, e, "access private method"), n);
var Ss = (t, e, n, r) => ({
  set _(s) {
    E(t, e, s, n);
  },
  get _() {
    return p(t, e, r);
  }
});
import * as ht from "react";
import { createContext as $5, useState as D2, useContext as _5, useMemo as Wu, useEffect as G5 } from "react";
import { jsx as M2 } from "react/jsx-runtime";
import { encodeFunctionData as mn, custom as Ol, hexToBigInt as Os, createPublicClient as wa, fallback as Ew, http as ct, createWalletClient as Qu, zeroAddress as Me, isAddressEqual as z5, getAddress as vi, erc20Abi as Ju, maxUint256 as L2, parseAbi as H2, keccak256 as cl, encodeAbiParameters as xw, concat as Zu, pad as Ni, toHex as Ea, encodeDeployData as V5, decodeAbiParameters as j5, decodeFunctionData as Gm, parseGwei as q5, hexToBytes as ag, bytesToHex as K5, formatUnits as zm, parseUnits as Vm } from "viem";
import { SequenceAPIClient as W5 } from "@0xsequence/trails-api";
import { Config as Q5, Payload as J5 } from "@0xsequence/wallet-primitives";
import { Relayer as jm } from "@0xsequence/wallet-core";
import { useReadContracts as Z5 } from "wagmi";
const X5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get claimAppFees() {
    return LV;
  },
  get execute() {
    return UV;
  },
  get getAppFees() {
    return MV;
  },
  get getPrice() {
    return FV;
  },
  get getQuote() {
    return RV;
  },
  get getSolverCapacity() {
    return DV;
  }
}, Symbol.toStringTag, { value: "Module" })), Y5 = {
  indexerGatewayUrl: "https://indexer.sequence.app",
  metadataUrl: "https://metadata.sequence.app",
  apiUrl: "https://api.sequence.app",
  indexerUrl: "https://indexer.sequence.app",
  imageProxyUrl: "https://imgproxy.sequence.xyz/"
}, $2 = $5(null), DX = (t) => {
  const [e, n] = D2(t.config.jwt), r = {
    ...t.config,
    env: {
      ...Y5,
      ...t.config.env
    },
    jwt: e,
    setJWT: n
  };
  return M2($2.Provider, { value: r, children: t.children });
}, _2 = () => {
  const t = _5($2);
  if (!t)
    throw new Error("useConfig must be used within a SequenceHooksProvider");
  return t;
};
var Kc = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Ri = typeof window > "u" || "Deno" in globalThis;
function $t() {
}
function eT(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function qm(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function G2(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function fa(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Fn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Aw(t, e) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: s,
    predicate: a,
    queryKey: i,
    stale: o
  } = t;
  if (i) {
    if (r) {
      if (e.queryHash !== ig(i, e.options))
        return !1;
    } else if (!ru(e.queryKey, i))
      return !1;
  }
  if (n !== "all") {
    const c = e.isActive();
    if (n === "active" && !c || n === "inactive" && c)
      return !1;
  }
  return !(typeof o == "boolean" && e.isStale() !== o || s && s !== e.state.fetchStatus || a && !a(e));
}
function kw(t, e) {
  const { exact: n, status: r, predicate: s, mutationKey: a } = t;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (n) {
      if (nu(e.options.mutationKey) !== nu(a))
        return !1;
    } else if (!ru(e.options.mutationKey, a))
      return !1;
  }
  return !(r && e.state.status !== r || s && !s(e));
}
function ig(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || nu)(t);
}
function nu(t) {
  return JSON.stringify(
    t,
    (e, n) => Wm(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n
  );
}
function ru(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((n) => ru(t[n], e[n])) : !1;
}
function Uf(t, e) {
  if (t === e)
    return t;
  const n = vw(t) && vw(e);
  if (n || Wm(t) && Wm(e)) {
    const r = n ? t : Object.keys(t), s = r.length, a = n ? e : Object.keys(e), i = a.length, o = n ? [] : {}, c = new Set(r);
    let u = 0;
    for (let l = 0; l < i; l++) {
      const d = n ? l : a[l];
      (!n && c.has(d) || n) && t[d] === void 0 && e[d] === void 0 ? (o[d] = void 0, u++) : (o[d] = Uf(t[d], e[d]), o[d] === t[d] && t[d] !== void 0 && u++);
    }
    return s === i && u === s ? t : o;
  }
  return e;
}
function Km(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const n in t)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function vw(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Wm(t) {
  if (!Cw(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const n = e.prototype;
  return !(!Cw(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Cw(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function tT(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function Qm(t, e, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(t, e);
  if (n.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Uf(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${n.queryHash}]: ${r}`
        ), r;
      }
    return Uf(t, e);
  }
  return e;
}
function nT(t, e, n = 0) {
  const r = [...t, e];
  return n && r.length > n ? r.slice(1) : r;
}
function rT(t, e, n = 0) {
  const r = [e, ...t];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var Nf = Symbol();
function z2(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === Nf && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === Nf ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function sT(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var Wa, Ls, Po, v2, aT = (v2 = class extends Kc {
  constructor() {
    super();
    T(this, Wa);
    T(this, Ls);
    T(this, Po);
    E(this, Po, (e) => {
      if (!Ri && window.addEventListener) {
        const n = () => e();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    p(this, Ls) || this.setEventListener(p(this, Po));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = p(this, Ls)) == null || e.call(this), E(this, Ls, void 0));
  }
  setEventListener(e) {
    var n;
    E(this, Po, e), (n = p(this, Ls)) == null || n.call(this), E(this, Ls, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    p(this, Wa) !== e && (E(this, Wa, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((n) => {
      n(e);
    });
  }
  isFocused() {
    var e;
    return typeof p(this, Wa) == "boolean" ? p(this, Wa) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, Wa = new WeakMap(), Ls = new WeakMap(), Po = new WeakMap(), v2), og = new aT(), Uo, Hs, No, C2, iT = (C2 = class extends Kc {
  constructor() {
    super();
    T(this, Uo, !0);
    T(this, Hs);
    T(this, No);
    E(this, No, (e) => {
      if (!Ri && window.addEventListener) {
        const n = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    p(this, Hs) || this.setEventListener(p(this, No));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = p(this, Hs)) == null || e.call(this), E(this, Hs, void 0));
  }
  setEventListener(e) {
    var n;
    E(this, No, e), (n = p(this, Hs)) == null || n.call(this), E(this, Hs, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    p(this, Uo) !== e && (E(this, Uo, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return p(this, Uo);
  }
}, Uo = new WeakMap(), Hs = new WeakMap(), No = new WeakMap(), C2), Rf = new iT();
function Jm() {
  let t, e;
  const n = new Promise((s, a) => {
    t = s, e = a;
  });
  n.status = "pending", n.catch(() => {
  });
  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject;
  }
  return n.resolve = (s) => {
    r({
      status: "fulfilled",
      value: s
    }), t(s);
  }, n.reject = (s) => {
    r({
      status: "rejected",
      reason: s
    }), e(s);
  }, n;
}
function oT(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function V2(t) {
  return (t ?? "online") === "online" ? Rf.isOnline() : !0;
}
var j2 = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function Wh(t) {
  return t instanceof j2;
}
function q2(t) {
  let e = !1, n = 0, r = !1, s;
  const a = Jm(), i = (y) => {
    var g;
    r || (m(new j2(y)), (g = t.abort) == null || g.call(t));
  }, o = () => {
    e = !0;
  }, c = () => {
    e = !1;
  }, u = () => og.isFocused() && (t.networkMode === "always" || Rf.isOnline()) && t.canRun(), l = () => V2(t.networkMode) && t.canRun(), d = (y) => {
    var g;
    r || (r = !0, (g = t.onSuccess) == null || g.call(t, y), s == null || s(), a.resolve(y));
  }, m = (y) => {
    var g;
    r || (r = !0, (g = t.onError) == null || g.call(t, y), s == null || s(), a.reject(y));
  }, h = () => new Promise((y) => {
    var g;
    s = (w) => {
      (r || u()) && y(w);
    }, (g = t.onPause) == null || g.call(t);
  }).then(() => {
    var y;
    s = void 0, r || (y = t.onContinue) == null || y.call(t);
  }), b = () => {
    if (r)
      return;
    let y;
    const g = n === 0 ? t.initialPromise : void 0;
    try {
      y = g ?? t.fn();
    } catch (w) {
      y = Promise.reject(w);
    }
    Promise.resolve(y).then(d).catch((w) => {
      var N;
      if (r)
        return;
      const v = t.retry ?? (Ri ? 0 : 3), A = t.retryDelay ?? oT, B = typeof A == "function" ? A(n, w) : A, x = v === !0 || typeof v == "number" && n < v || typeof v == "function" && v(n, w);
      if (e || !x) {
        m(w);
        return;
      }
      n++, (N = t.onFail) == null || N.call(t, n, w), tT(B).then(() => u() ? void 0 : h()).then(() => {
        e ? m(w) : b();
      });
    });
  };
  return {
    promise: a,
    cancel: i,
    continue: () => (s == null || s(), a),
    cancelRetry: o,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? b() : h().then(b), a)
  };
}
var cT = (t) => setTimeout(t, 0);
function lT() {
  let t = [], e = 0, n = (o) => {
    o();
  }, r = (o) => {
    o();
  }, s = cT;
  const a = (o) => {
    e ? t.push(o) : s(() => {
      n(o);
    });
  }, i = () => {
    const o = t;
    t = [], o.length && s(() => {
      r(() => {
        o.forEach((c) => {
          n(c);
        });
      });
    });
  };
  return {
    batch: (o) => {
      let c;
      e++;
      try {
        c = o();
      } finally {
        e--, e || i();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (o) => (...c) => {
      a(() => {
        o(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (o) => {
      n = o;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (o) => {
      r = o;
    },
    setScheduler: (o) => {
      s = o;
    }
  };
}
var nt = lT(), Qa, T2, K2 = (T2 = class {
  constructor() {
    T(this, Qa);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), qm(this.gcTime) && E(this, Qa, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (Ri ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    p(this, Qa) && (clearTimeout(p(this, Qa)), E(this, Qa, void 0));
  }
}, Qa = new WeakMap(), T2), Ro, Ja, Sn, Za, Et, Bu, Xa, Kn, qr, S2, uT = (S2 = class extends K2 {
  constructor(e) {
    super();
    T(this, Kn);
    T(this, Ro);
    T(this, Ja);
    T(this, Sn);
    T(this, Za);
    T(this, Et);
    T(this, Bu);
    T(this, Xa);
    E(this, Xa, !1), E(this, Bu, e.defaultOptions), this.setOptions(e.options), this.observers = [], E(this, Za, e.client), E(this, Sn, p(this, Za).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, E(this, Ro, dT(this.options)), this.state = e.state ?? p(this, Ro), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = p(this, Et)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...p(this, Bu), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && p(this, Sn).remove(this);
  }
  setData(e, n) {
    const r = Qm(this.state.data, e, this.options);
    return _(this, Kn, qr).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(e, n) {
    _(this, Kn, qr).call(this, { type: "setState", state: e, setStateOptions: n });
  }
  cancel(e) {
    var r, s;
    const n = (r = p(this, Et)) == null ? void 0 : r.promise;
    return (s = p(this, Et)) == null || s.cancel(e), n ? n.then($t).catch($t) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(p(this, Ro));
  }
  isActive() {
    return this.observers.some(
      (e) => Fn(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Nf || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => fa(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !G2(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = p(this, Et)) == null || n.continue();
  }
  onOnline() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = p(this, Et)) == null || n.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), p(this, Sn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((n) => n !== e), this.observers.length || (p(this, Et) && (p(this, Xa) ? p(this, Et).cancel({ revert: !0 }) : p(this, Et).cancelRetry()), this.scheduleGc()), p(this, Sn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || _(this, Kn, qr).call(this, { type: "invalidate" });
  }
  fetch(e, n) {
    var u, l, d;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (p(this, Et))
        return p(this, Et).continueRetry(), p(this, Et).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const m = this.observers.find((h) => h.options.queryFn);
      m && this.setOptions(m.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), s = (m) => {
      Object.defineProperty(m, "signal", {
        enumerable: !0,
        get: () => (E(this, Xa, !0), r.signal)
      });
    }, a = () => {
      const m = z2(this.options, n), b = (() => {
        const y = {
          client: p(this, Za),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(y), y;
      })();
      return E(this, Xa, !1), this.options.persister ? this.options.persister(
        m,
        b,
        this
      ) : m(b);
    }, o = (() => {
      const m = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        client: p(this, Za),
        state: this.state,
        fetchFn: a
      };
      return s(m), m;
    })();
    (u = this.options.behavior) == null || u.onFetch(o, this), E(this, Ja, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((l = o.fetchOptions) == null ? void 0 : l.meta)) && _(this, Kn, qr).call(this, { type: "fetch", meta: (d = o.fetchOptions) == null ? void 0 : d.meta });
    const c = (m) => {
      var h, b, y, g;
      Wh(m) && m.silent || _(this, Kn, qr).call(this, {
        type: "error",
        error: m
      }), Wh(m) || ((b = (h = p(this, Sn).config).onError) == null || b.call(
        h,
        m,
        this
      ), (g = (y = p(this, Sn).config).onSettled) == null || g.call(
        y,
        this.state.data,
        m,
        this
      )), this.scheduleGc();
    };
    return E(this, Et, q2({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: o.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (m) => {
        var h, b, y, g;
        if (m === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(m);
        } catch (w) {
          c(w);
          return;
        }
        (b = (h = p(this, Sn).config).onSuccess) == null || b.call(h, m, this), (g = (y = p(this, Sn).config).onSettled) == null || g.call(
          y,
          m,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: c,
      onFail: (m, h) => {
        _(this, Kn, qr).call(this, { type: "failed", failureCount: m, error: h });
      },
      onPause: () => {
        _(this, Kn, qr).call(this, { type: "pause" });
      },
      onContinue: () => {
        _(this, Kn, qr).call(this, { type: "continue" });
      },
      retry: o.options.retry,
      retryDelay: o.options.retryDelay,
      networkMode: o.options.networkMode,
      canRun: () => !0
    })), p(this, Et).start();
  }
}, Ro = new WeakMap(), Ja = new WeakMap(), Sn = new WeakMap(), Za = new WeakMap(), Et = new WeakMap(), Bu = new WeakMap(), Xa = new WeakMap(), Kn = new WeakSet(), qr = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...W2(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return E(this, Ja, void 0), {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const s = e.error;
        return Wh(s) && s.revert && p(this, Ja) ? { ...p(this, Ja), fetchStatus: "idle" } : {
          ...r,
          error: s,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = n(this.state), nt.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), p(this, Sn).notify({ query: this, type: "updated", action: e });
  });
}, S2);
function W2(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: V2(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function dT(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Er, O2, fT = (O2 = class extends Kc {
  constructor(e = {}) {
    super();
    T(this, Er);
    this.config = e, E(this, Er, /* @__PURE__ */ new Map());
  }
  build(e, n, r) {
    const s = n.queryKey, a = n.queryHash ?? ig(s, n);
    let i = this.get(a);
    return i || (i = new uT({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(n),
      state: r,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(i)), i;
  }
  add(e) {
    p(this, Er).has(e.queryHash) || (p(this, Er).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const n = p(this, Er).get(e.queryHash);
    n && (e.destroy(), n === e && p(this, Er).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    nt.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return p(this, Er).get(e);
  }
  getAll() {
    return [...p(this, Er).values()];
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => Aw(n, r)
    );
  }
  findAll(e = {}) {
    const n = this.getAll();
    return Object.keys(e).length > 0 ? n.filter((r) => Aw(e, r)) : n;
  }
  notify(e) {
    nt.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  onFocus() {
    nt.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    nt.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, Er = new WeakMap(), O2), xr, Dt, Ya, Ar, Fs, B2, pT = (B2 = class extends K2 {
  constructor(e) {
    super();
    T(this, Ar);
    T(this, xr);
    T(this, Dt);
    T(this, Ya);
    this.mutationId = e.mutationId, E(this, Dt, e.mutationCache), E(this, xr, []), this.state = e.state || hT(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    p(this, xr).includes(e) || (p(this, xr).push(e), this.clearGcTimeout(), p(this, Dt).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    E(this, xr, p(this, xr).filter((n) => n !== e)), this.scheduleGc(), p(this, Dt).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    p(this, xr).length || (this.state.status === "pending" ? this.scheduleGc() : p(this, Dt).remove(this));
  }
  continue() {
    var e;
    return ((e = p(this, Ya)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var a, i, o, c, u, l, d, m, h, b, y, g, w, v, A, B, x, N, I, O;
    const n = () => {
      _(this, Ar, Fs).call(this, { type: "continue" });
    };
    E(this, Ya, q2({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (C, U) => {
        _(this, Ar, Fs).call(this, { type: "failed", failureCount: C, error: U });
      },
      onPause: () => {
        _(this, Ar, Fs).call(this, { type: "pause" });
      },
      onContinue: n,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => p(this, Dt).canRun(this)
    }));
    const r = this.state.status === "pending", s = !p(this, Ya).canStart();
    try {
      if (r)
        n();
      else {
        _(this, Ar, Fs).call(this, { type: "pending", variables: e, isPaused: s }), await ((i = (a = p(this, Dt).config).onMutate) == null ? void 0 : i.call(
          a,
          e,
          this
        ));
        const U = await ((c = (o = this.options).onMutate) == null ? void 0 : c.call(o, e));
        U !== this.state.context && _(this, Ar, Fs).call(this, {
          type: "pending",
          context: U,
          variables: e,
          isPaused: s
        });
      }
      const C = await p(this, Ya).start();
      return await ((l = (u = p(this, Dt).config).onSuccess) == null ? void 0 : l.call(
        u,
        C,
        e,
        this.state.context,
        this
      )), await ((m = (d = this.options).onSuccess) == null ? void 0 : m.call(d, C, e, this.state.context)), await ((b = (h = p(this, Dt).config).onSettled) == null ? void 0 : b.call(
        h,
        C,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((g = (y = this.options).onSettled) == null ? void 0 : g.call(y, C, null, e, this.state.context)), _(this, Ar, Fs).call(this, { type: "success", data: C }), C;
    } catch (C) {
      try {
        throw await ((v = (w = p(this, Dt).config).onError) == null ? void 0 : v.call(
          w,
          C,
          e,
          this.state.context,
          this
        )), await ((B = (A = this.options).onError) == null ? void 0 : B.call(
          A,
          C,
          e,
          this.state.context
        )), await ((N = (x = p(this, Dt).config).onSettled) == null ? void 0 : N.call(
          x,
          void 0,
          C,
          this.state.variables,
          this.state.context,
          this
        )), await ((O = (I = this.options).onSettled) == null ? void 0 : O.call(
          I,
          void 0,
          C,
          e,
          this.state.context
        )), C;
      } finally {
        _(this, Ar, Fs).call(this, { type: "error", error: C });
      }
    } finally {
      p(this, Dt).runNext(this);
    }
  }
}, xr = new WeakMap(), Dt = new WeakMap(), Ya = new WeakMap(), Ar = new WeakSet(), Fs = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: e.error,
          failureCount: r.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), nt.batch(() => {
    p(this, xr).forEach((r) => {
      r.onMutationUpdate(e);
    }), p(this, Dt).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, B2);
function hT() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Yr, Wn, Iu, I2, mT = (I2 = class extends Kc {
  constructor(e = {}) {
    super();
    T(this, Yr);
    T(this, Wn);
    T(this, Iu);
    this.config = e, E(this, Yr, /* @__PURE__ */ new Set()), E(this, Wn, /* @__PURE__ */ new Map()), E(this, Iu, 0);
  }
  build(e, n, r) {
    const s = new pT({
      mutationCache: this,
      mutationId: ++Ss(this, Iu)._,
      options: e.defaultMutationOptions(n),
      state: r
    });
    return this.add(s), s;
  }
  add(e) {
    p(this, Yr).add(e);
    const n = Ed(e);
    if (typeof n == "string") {
      const r = p(this, Wn).get(n);
      r ? r.push(e) : p(this, Wn).set(n, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (p(this, Yr).delete(e)) {
      const n = Ed(e);
      if (typeof n == "string") {
        const r = p(this, Wn).get(n);
        if (r)
          if (r.length > 1) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          } else r[0] === e && p(this, Wn).delete(n);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const n = Ed(e);
    if (typeof n == "string") {
      const r = p(this, Wn).get(n), s = r == null ? void 0 : r.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var r;
    const n = Ed(e);
    if (typeof n == "string") {
      const s = (r = p(this, Wn).get(n)) == null ? void 0 : r.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    nt.batch(() => {
      p(this, Yr).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), p(this, Yr).clear(), p(this, Wn).clear();
    });
  }
  getAll() {
    return Array.from(p(this, Yr));
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => kw(n, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((n) => kw(e, n));
  }
  notify(e) {
    nt.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((n) => n.state.isPaused);
    return nt.batch(
      () => Promise.all(
        e.map((n) => n.continue().catch($t))
      )
    );
  }
}, Yr = new WeakMap(), Wn = new WeakMap(), Iu = new WeakMap(), I2);
function Ed(t) {
  var e;
  return (e = t.options.scope) == null ? void 0 : e.id;
}
function Tw(t) {
  return {
    onFetch: (e, n) => {
      var l, d, m, h, b;
      const r = e.options, s = (m = (d = (l = e.fetchOptions) == null ? void 0 : l.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : m.direction, a = ((h = e.state.data) == null ? void 0 : h.pages) || [], i = ((b = e.state.data) == null ? void 0 : b.pageParams) || [];
      let o = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let y = !1;
        const g = (A) => {
          Object.defineProperty(A, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? y = !0 : e.signal.addEventListener("abort", () => {
              y = !0;
            }), e.signal)
          });
        }, w = z2(e.options, e.fetchOptions), v = async (A, B, x) => {
          if (y)
            return Promise.reject();
          if (B == null && A.pages.length)
            return Promise.resolve(A);
          const I = (() => {
            const P = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: B,
              direction: x ? "backward" : "forward",
              meta: e.options.meta
            };
            return g(P), P;
          })(), O = await w(I), { maxPages: C } = e.options, U = x ? rT : nT;
          return {
            pages: U(A.pages, O, C),
            pageParams: U(A.pageParams, B, C)
          };
        };
        if (s && a.length) {
          const A = s === "backward", B = A ? yT : Sw, x = {
            pages: a,
            pageParams: i
          }, N = B(r, x);
          o = await v(x, N, A);
        } else {
          const A = t ?? a.length;
          do {
            const B = c === 0 ? i[0] ?? r.initialPageParam : Sw(r, o);
            if (c > 0 && B == null)
              break;
            o = await v(o, B), c++;
          } while (c < A);
        }
        return o;
      };
      e.options.persister ? e.fetchFn = () => {
        var y, g;
        return (g = (y = e.options).persister) == null ? void 0 : g.call(
          y,
          u,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          n
        );
      } : e.fetchFn = u;
    }
  };
}
function Sw(t, { pages: e, pageParams: n }) {
  const r = e.length - 1;
  return e.length > 0 ? t.getNextPageParam(
    e[r],
    e,
    n[r],
    n
  ) : void 0;
}
function yT(t, { pages: e, pageParams: n }) {
  var r;
  return e.length > 0 ? (r = t.getPreviousPageParam) == null ? void 0 : r.call(t, e[0], e, n[0], n) : void 0;
}
var je, $s, _s, Fo, Do, Gs, Mo, Lo, P2, cg = (P2 = class {
  constructor(t = {}) {
    T(this, je);
    T(this, $s);
    T(this, _s);
    T(this, Fo);
    T(this, Do);
    T(this, Gs);
    T(this, Mo);
    T(this, Lo);
    E(this, je, t.queryCache || new fT()), E(this, $s, t.mutationCache || new mT()), E(this, _s, t.defaultOptions || {}), E(this, Fo, /* @__PURE__ */ new Map()), E(this, Do, /* @__PURE__ */ new Map()), E(this, Gs, 0);
  }
  mount() {
    Ss(this, Gs)._++, p(this, Gs) === 1 && (E(this, Mo, og.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), p(this, je).onFocus());
    })), E(this, Lo, Rf.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), p(this, je).onOnline());
    })));
  }
  unmount() {
    var t, e;
    Ss(this, Gs)._--, p(this, Gs) === 0 && ((t = p(this, Mo)) == null || t.call(this), E(this, Mo, void 0), (e = p(this, Lo)) == null || e.call(this), E(this, Lo, void 0));
  }
  isFetching(t) {
    return p(this, je).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return p(this, $s).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = p(this, je).get(e.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), n = p(this, je).build(this, e), r = n.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && n.isStaleByTime(fa(e.staleTime, n)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return p(this, je).findAll(t).map(({ queryKey: e, state: n }) => {
      const r = n.data;
      return [e, r];
    });
  }
  setQueryData(t, e, n) {
    const r = this.defaultQueryOptions({ queryKey: t }), s = p(this, je).get(
      r.queryHash
    ), a = s == null ? void 0 : s.state.data, i = eT(e, a);
    if (i !== void 0)
      return p(this, je).build(this, r).setData(i, { ...n, manual: !0 });
  }
  setQueriesData(t, e, n) {
    return nt.batch(
      () => p(this, je).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, n)
      ])
    );
  }
  getQueryState(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = p(this, je).get(
      e.queryHash
    )) == null ? void 0 : n.state;
  }
  removeQueries(t) {
    const e = p(this, je);
    nt.batch(() => {
      e.findAll(t).forEach((n) => {
        e.remove(n);
      });
    });
  }
  resetQueries(t, e) {
    const n = p(this, je);
    return nt.batch(() => (n.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const n = { revert: !0, ...e }, r = nt.batch(
      () => p(this, je).findAll(t).map((s) => s.cancel(n))
    );
    return Promise.all(r).then($t).catch($t);
  }
  invalidateQueries(t, e = {}) {
    return nt.batch(() => (p(this, je).findAll(t).forEach((n) => {
      n.invalidate();
    }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const n = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = nt.batch(
      () => p(this, je).findAll(t).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, n);
        return n.throwOnError || (a = a.catch($t)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(r).then($t);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const n = p(this, je).build(this, e);
    return n.isStaleByTime(
      fa(e.staleTime, n)
    ) ? n.fetch(e) : Promise.resolve(n.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then($t).catch($t);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Tw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then($t).catch($t);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Tw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Rf.isOnline() ? p(this, $s).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return p(this, je);
  }
  getMutationCache() {
    return p(this, $s);
  }
  getDefaultOptions() {
    return p(this, _s);
  }
  setDefaultOptions(t) {
    E(this, _s, t);
  }
  setQueryDefaults(t, e) {
    p(this, Fo).set(nu(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...p(this, Fo).values()], n = {};
    return e.forEach((r) => {
      ru(t, r.queryKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  setMutationDefaults(t, e) {
    p(this, Do).set(nu(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...p(this, Do).values()], n = {};
    return e.forEach((r) => {
      ru(t, r.mutationKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...p(this, _s).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = ig(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === Nf && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...p(this, _s).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    p(this, je).clear(), p(this, $s).clear();
  }
}, je = new WeakMap(), $s = new WeakMap(), _s = new WeakMap(), Fo = new WeakMap(), Do = new WeakMap(), Gs = new WeakMap(), Mo = new WeakMap(), Lo = new WeakMap(), P2), Wt, ve, Pu, Mt, ei, Ho, zs, Vs, Uu, $o, _o, ti, ni, js, Go, Ne, Bl, Zm, Xm, Ym, e0, t0, n0, r0, Q2, U2, lg = (U2 = class extends Kc {
  constructor(e, n) {
    super();
    T(this, Ne);
    T(this, Wt);
    T(this, ve);
    T(this, Pu);
    T(this, Mt);
    T(this, ei);
    T(this, Ho);
    T(this, zs);
    T(this, Vs);
    T(this, Uu);
    T(this, $o);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    T(this, _o);
    T(this, ti);
    T(this, ni);
    T(this, js);
    T(this, Go, /* @__PURE__ */ new Set());
    this.options = n, E(this, Wt, e), E(this, Vs, null), E(this, zs, Jm()), this.options.experimental_prefetchInRender || p(this, zs).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (p(this, ve).addObserver(this), Ow(p(this, ve), this.options) ? _(this, Ne, Bl).call(this) : this.updateResult(), _(this, Ne, e0).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return s0(
      p(this, ve),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return s0(
      p(this, ve),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), _(this, Ne, t0).call(this), _(this, Ne, n0).call(this), p(this, ve).removeObserver(this);
  }
  setOptions(e) {
    const n = this.options, r = p(this, ve);
    if (this.options = p(this, Wt).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Fn(this.options.enabled, p(this, ve)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    _(this, Ne, r0).call(this), p(this, ve).setOptions(this.options), n._defaulted && !Km(this.options, n) && p(this, Wt).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: p(this, ve),
      observer: this
    });
    const s = this.hasListeners();
    s && Bw(
      p(this, ve),
      r,
      this.options,
      n
    ) && _(this, Ne, Bl).call(this), this.updateResult(), s && (p(this, ve) !== r || Fn(this.options.enabled, p(this, ve)) !== Fn(n.enabled, p(this, ve)) || fa(this.options.staleTime, p(this, ve)) !== fa(n.staleTime, p(this, ve))) && _(this, Ne, Zm).call(this);
    const a = _(this, Ne, Xm).call(this);
    s && (p(this, ve) !== r || Fn(this.options.enabled, p(this, ve)) !== Fn(n.enabled, p(this, ve)) || a !== p(this, js)) && _(this, Ne, Ym).call(this, a);
  }
  getOptimisticResult(e) {
    const n = p(this, Wt).getQueryCache().build(p(this, Wt), e), r = this.createResult(n, e);
    return gT(this, r) && (E(this, Mt, r), E(this, Ho, this.options), E(this, ei, p(this, ve).state)), r;
  }
  getCurrentResult() {
    return p(this, Mt);
  }
  trackResult(e, n) {
    return new Proxy(e, {
      get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
    });
  }
  trackProp(e) {
    p(this, Go).add(e);
  }
  getCurrentQuery() {
    return p(this, ve);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const n = p(this, Wt).defaultQueryOptions(e), r = p(this, Wt).getQueryCache().build(p(this, Wt), n);
    return r.fetch().then(() => this.createResult(r, n));
  }
  fetch(e) {
    return _(this, Ne, Bl).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), p(this, Mt)));
  }
  createResult(e, n) {
    var C;
    const r = p(this, ve), s = this.options, a = p(this, Mt), i = p(this, ei), o = p(this, Ho), u = e !== r ? e.state : p(this, Pu), { state: l } = e;
    let d = { ...l }, m = !1, h;
    if (n._optimisticResults) {
      const U = this.hasListeners(), P = !U && Ow(e, n), D = U && Bw(e, r, n, s);
      (P || D) && (d = {
        ...d,
        ...W2(l.data, e.options)
      }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle");
    }
    let { error: b, errorUpdatedAt: y, status: g } = d;
    h = d.data;
    let w = !1;
    if (n.placeholderData !== void 0 && h === void 0 && g === "pending") {
      let U;
      a != null && a.isPlaceholderData && n.placeholderData === (o == null ? void 0 : o.placeholderData) ? (U = a.data, w = !0) : U = typeof n.placeholderData == "function" ? n.placeholderData(
        (C = p(this, _o)) == null ? void 0 : C.state.data,
        p(this, _o)
      ) : n.placeholderData, U !== void 0 && (g = "success", h = Qm(
        a == null ? void 0 : a.data,
        U,
        n
      ), m = !0);
    }
    if (n.select && h !== void 0 && !w)
      if (a && h === (i == null ? void 0 : i.data) && n.select === p(this, Uu))
        h = p(this, $o);
      else
        try {
          E(this, Uu, n.select), h = n.select(h), h = Qm(a == null ? void 0 : a.data, h, n), E(this, $o, h), E(this, Vs, null);
        } catch (U) {
          E(this, Vs, U);
        }
    p(this, Vs) && (b = p(this, Vs), h = p(this, $o), y = Date.now(), g = "error");
    const v = d.fetchStatus === "fetching", A = g === "pending", B = g === "error", x = A && v, N = h !== void 0, O = {
      status: g,
      fetchStatus: d.fetchStatus,
      isPending: A,
      isSuccess: g === "success",
      isError: B,
      isInitialLoading: x,
      isLoading: x,
      data: h,
      dataUpdatedAt: d.dataUpdatedAt,
      error: b,
      errorUpdatedAt: y,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount,
      isFetching: v,
      isRefetching: v && !A,
      isLoadingError: B && !N,
      isPaused: d.fetchStatus === "paused",
      isPlaceholderData: m,
      isRefetchError: B && N,
      isStale: ug(e, n),
      refetch: this.refetch,
      promise: p(this, zs),
      isEnabled: Fn(n.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const U = ($) => {
        O.status === "error" ? $.reject(O.error) : O.data !== void 0 && $.resolve(O.data);
      }, P = () => {
        const $ = E(this, zs, O.promise = Jm());
        U($);
      }, D = p(this, zs);
      switch (D.status) {
        case "pending":
          e.queryHash === r.queryHash && U(D);
          break;
        case "fulfilled":
          (O.status === "error" || O.data !== D.value) && P();
          break;
        case "rejected":
          (O.status !== "error" || O.error !== D.reason) && P();
          break;
      }
    }
    return O;
  }
  updateResult() {
    const e = p(this, Mt), n = this.createResult(p(this, ve), this.options);
    if (E(this, ei, p(this, ve).state), E(this, Ho, this.options), p(this, ei).data !== void 0 && E(this, _o, p(this, ve)), Km(n, e))
      return;
    E(this, Mt, n);
    const r = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: s } = this.options, a = typeof s == "function" ? s() : s;
      if (a === "all" || !a && !p(this, Go).size)
        return !0;
      const i = new Set(
        a ?? p(this, Go)
      );
      return this.options.throwOnError && i.add("error"), Object.keys(p(this, Mt)).some((o) => {
        const c = o;
        return p(this, Mt)[c] !== e[c] && i.has(c);
      });
    };
    _(this, Ne, Q2).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && _(this, Ne, e0).call(this);
  }
}, Wt = new WeakMap(), ve = new WeakMap(), Pu = new WeakMap(), Mt = new WeakMap(), ei = new WeakMap(), Ho = new WeakMap(), zs = new WeakMap(), Vs = new WeakMap(), Uu = new WeakMap(), $o = new WeakMap(), _o = new WeakMap(), ti = new WeakMap(), ni = new WeakMap(), js = new WeakMap(), Go = new WeakMap(), Ne = new WeakSet(), Bl = function(e) {
  _(this, Ne, r0).call(this);
  let n = p(this, ve).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (n = n.catch($t)), n;
}, Zm = function() {
  _(this, Ne, t0).call(this);
  const e = fa(
    this.options.staleTime,
    p(this, ve)
  );
  if (Ri || p(this, Mt).isStale || !qm(e))
    return;
  const r = G2(p(this, Mt).dataUpdatedAt, e) + 1;
  E(this, ti, setTimeout(() => {
    p(this, Mt).isStale || this.updateResult();
  }, r));
}, Xm = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(p(this, ve)) : this.options.refetchInterval) ?? !1;
}, Ym = function(e) {
  _(this, Ne, n0).call(this), E(this, js, e), !(Ri || Fn(this.options.enabled, p(this, ve)) === !1 || !qm(p(this, js)) || p(this, js) === 0) && E(this, ni, setInterval(() => {
    (this.options.refetchIntervalInBackground || og.isFocused()) && _(this, Ne, Bl).call(this);
  }, p(this, js)));
}, e0 = function() {
  _(this, Ne, Zm).call(this), _(this, Ne, Ym).call(this, _(this, Ne, Xm).call(this));
}, t0 = function() {
  p(this, ti) && (clearTimeout(p(this, ti)), E(this, ti, void 0));
}, n0 = function() {
  p(this, ni) && (clearInterval(p(this, ni)), E(this, ni, void 0));
}, r0 = function() {
  const e = p(this, Wt).getQueryCache().build(p(this, Wt), this.options);
  if (e === p(this, ve))
    return;
  const n = p(this, ve);
  E(this, ve, e), E(this, Pu, e.state), this.hasListeners() && (n == null || n.removeObserver(this), e.addObserver(this));
}, Q2 = function(e) {
  nt.batch(() => {
    e.listeners && this.listeners.forEach((n) => {
      n(p(this, Mt));
    }), p(this, Wt).getQueryCache().notify({
      query: p(this, ve),
      type: "observerResultsUpdated"
    });
  });
}, U2);
function bT(t, e) {
  return Fn(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function Ow(t, e) {
  return bT(t, e) || t.state.data !== void 0 && s0(t, e, e.refetchOnMount);
}
function s0(t, e, n) {
  if (Fn(e.enabled, t) !== !1 && fa(e.staleTime, t) !== "static") {
    const r = typeof n == "function" ? n(t) : n;
    return r === "always" || r !== !1 && ug(t, e);
  }
  return !1;
}
function Bw(t, e, n, r) {
  return (t !== e || Fn(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && ug(t, n);
}
function ug(t, e) {
  return Fn(e.enabled, t) !== !1 && t.isStaleByTime(fa(e.staleTime, t));
}
function gT(t, e) {
  return !Km(t.getCurrentResult(), e);
}
function Iw(t, e) {
  const n = new Set(e);
  return t.filter((r) => !n.has(r));
}
function wT(t, e, n) {
  const r = t.slice(0);
  return r[e] = n, r;
}
var ri, On, zo, Vo, Bn, qs, Nu, Ru, Fu, gt, a0, i0, o0, c0, l0, N2, ET = (N2 = class extends Kc {
  constructor(e, n, r) {
    super();
    T(this, gt);
    T(this, ri);
    T(this, On);
    T(this, zo);
    T(this, Vo);
    T(this, Bn);
    T(this, qs);
    T(this, Nu);
    T(this, Ru);
    T(this, Fu, []);
    E(this, ri, e), E(this, Vo, r), E(this, zo, []), E(this, Bn, []), E(this, On, []), this.setQueries(n);
  }
  onSubscribe() {
    this.listeners.size === 1 && p(this, Bn).forEach((e) => {
      e.subscribe((n) => {
        _(this, gt, c0).call(this, e, n);
      });
    });
  }
  onUnsubscribe() {
    this.listeners.size || this.destroy();
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), p(this, Bn).forEach((e) => {
      e.destroy();
    });
  }
  setQueries(e, n) {
    if (E(this, zo, e), E(this, Vo, n), process.env.NODE_ENV !== "production") {
      const r = e.map(
        (s) => p(this, ri).defaultQueryOptions(s).queryHash
      );
      new Set(r).size !== r.length && console.warn(
        "[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior."
      );
    }
    nt.batch(() => {
      const r = p(this, Bn), s = _(this, gt, o0).call(this, p(this, zo));
      E(this, Fu, s), s.forEach(
        (c) => c.observer.setOptions(c.defaultedQueryOptions)
      );
      const a = s.map((c) => c.observer), i = a.map(
        (c) => c.getCurrentResult()
      ), o = a.some(
        (c, u) => c !== r[u]
      );
      r.length === a.length && !o || (E(this, Bn, a), E(this, On, i), this.hasListeners() && (Iw(r, a).forEach((c) => {
        c.destroy();
      }), Iw(a, r).forEach((c) => {
        c.subscribe((u) => {
          _(this, gt, c0).call(this, c, u);
        });
      }), _(this, gt, l0).call(this)));
    });
  }
  getCurrentResult() {
    return p(this, On);
  }
  getQueries() {
    return p(this, Bn).map((e) => e.getCurrentQuery());
  }
  getObservers() {
    return p(this, Bn);
  }
  getOptimisticResult(e, n) {
    const r = _(this, gt, o0).call(this, e), s = r.map(
      (a) => a.observer.getOptimisticResult(a.defaultedQueryOptions)
    );
    return [
      s,
      (a) => _(this, gt, i0).call(this, a ?? s, n),
      () => _(this, gt, a0).call(this, s, r)
    ];
  }
}, ri = new WeakMap(), On = new WeakMap(), zo = new WeakMap(), Vo = new WeakMap(), Bn = new WeakMap(), qs = new WeakMap(), Nu = new WeakMap(), Ru = new WeakMap(), Fu = new WeakMap(), gt = new WeakSet(), a0 = function(e, n) {
  return n.map((r, s) => {
    const a = e[s];
    return r.defaultedQueryOptions.notifyOnChangeProps ? a : r.observer.trackResult(a, (i) => {
      n.forEach((o) => {
        o.observer.trackProp(i);
      });
    });
  });
}, i0 = function(e, n) {
  return n ? ((!p(this, qs) || p(this, On) !== p(this, Ru) || n !== p(this, Nu)) && (E(this, Nu, n), E(this, Ru, p(this, On)), E(this, qs, Uf(
    p(this, qs),
    n(e)
  ))), p(this, qs)) : e;
}, o0 = function(e) {
  const n = new Map(
    p(this, Bn).map((s) => [s.options.queryHash, s])
  ), r = [];
  return e.forEach((s) => {
    const a = p(this, ri).defaultQueryOptions(s), i = n.get(a.queryHash);
    i ? r.push({
      defaultedQueryOptions: a,
      observer: i
    }) : r.push({
      defaultedQueryOptions: a,
      observer: new lg(p(this, ri), a)
    });
  }), r;
}, c0 = function(e, n) {
  const r = p(this, Bn).indexOf(e);
  r !== -1 && (E(this, On, wT(p(this, On), r, n)), _(this, gt, l0).call(this));
}, l0 = function() {
  var e;
  if (this.hasListeners()) {
    const n = p(this, qs), r = _(this, gt, a0).call(this, p(this, On), p(this, Fu)), s = _(this, gt, i0).call(this, r, (e = p(this, Vo)) == null ? void 0 : e.combine);
    n !== s && nt.batch(() => {
      this.listeners.forEach((a) => {
        a(p(this, On));
      });
    });
  }
}, N2), J2 = ht.createContext(
  void 0
), Z2 = (t) => {
  const e = ht.useContext(J2);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, MX = ({
  client: t,
  children: e
}) => (ht.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ M2(J2.Provider, { value: t, children: e })), X2 = ht.createContext(!1), Y2 = () => ht.useContext(X2);
X2.Provider;
function xT() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var AT = ht.createContext(xT()), e6 = () => ht.useContext(AT), t6 = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, n6 = (t) => {
  ht.useEffect(() => {
    t.clearReset();
  }, [t]);
}, r6 = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: n,
  query: r,
  suspense: s
}) => t.isError && !e.isReset() && !t.isFetching && r && (s && t.data === void 0 || sT(n, [t.error, r])), s6 = (t) => {
  if (t.suspense) {
    const e = (r) => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime;
    t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3));
  }
}, a6 = (t, e) => t.isLoading && t.isFetching && !e, u0 = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, Ff = (t, e, n) => e.fetchOptimistic(t).catch(() => {
  n.clearReset();
});
function kT({
  queries: t,
  ...e
}, n) {
  const r = Z2(), s = Y2(), a = e6(), i = ht.useMemo(
    () => t.map((y) => {
      const g = r.defaultQueryOptions(
        y
      );
      return g._optimisticResults = s ? "isRestoring" : "optimistic", g;
    }),
    [t, r, s]
  );
  i.forEach((y) => {
    s6(y), t6(y, a);
  }), n6(a);
  const [o] = ht.useState(
    () => new ET(
      r,
      i,
      e
    )
  ), [c, u, l] = o.getOptimisticResult(
    i,
    e.combine
  ), d = !s && e.subscribed !== !1;
  ht.useSyncExternalStore(
    ht.useCallback(
      (y) => d ? o.subscribe(nt.batchCalls(y)) : $t,
      [o, d]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), ht.useEffect(() => {
    o.setQueries(
      i,
      e
    );
  }, [i, e, o]);
  const h = c.some(
    (y, g) => u0(i[g], y)
  ) ? c.flatMap((y, g) => {
    const w = i[g];
    if (w) {
      const v = new lg(r, w);
      if (u0(w, y))
        return Ff(w, v, a);
      a6(y, s) && Ff(w, v, a);
    }
    return [];
  }) : [];
  if (h.length > 0)
    throw Promise.all(h);
  const b = c.find(
    (y, g) => {
      const w = i[g];
      return w && r6({
        result: y,
        errorResetBoundary: a,
        throwOnError: w.throwOnError,
        query: r.getQueryCache().get(w.queryHash),
        suspense: w.suspense
      });
    }
  );
  if (b != null && b.error)
    throw b.error;
  return u(l());
}
function vT(t, e, n) {
  var d, m, h, b, y;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = Y2(), s = e6(), a = Z2(), i = a.defaultQueryOptions(t);
  (m = (d = a.getDefaultOptions().queries) == null ? void 0 : d._experimental_beforeQuery) == null || m.call(
    d,
    i
  ), process.env.NODE_ENV !== "production" && (i.queryFn || console.error(
    `[${i.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), i._optimisticResults = r ? "isRestoring" : "optimistic", s6(i), t6(i, s), n6(s);
  const o = !a.getQueryCache().get(i.queryHash), [c] = ht.useState(
    () => new e(
      a,
      i
    )
  ), u = c.getOptimisticResult(i), l = !r && t.subscribed !== !1;
  if (ht.useSyncExternalStore(
    ht.useCallback(
      (g) => {
        const w = l ? c.subscribe(nt.batchCalls(g)) : $t;
        return c.updateResult(), w;
      },
      [c, l]
    ),
    () => c.getCurrentResult(),
    () => c.getCurrentResult()
  ), ht.useEffect(() => {
    c.setOptions(i);
  }, [i, c]), u0(i, u))
    throw Ff(i, c, s);
  if (r6({
    result: u,
    errorResetBoundary: s,
    throwOnError: i.throwOnError,
    query: a.getQueryCache().get(i.queryHash),
    suspense: i.suspense
  }))
    throw u.error;
  if ((b = (h = a.getDefaultOptions().queries) == null ? void 0 : h._experimental_afterQuery) == null || b.call(
    h,
    i,
    u
  ), i.experimental_prefetchInRender && !Ri && a6(u, r)) {
    const g = o ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Ff(i, c, s)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (y = a.getQueryCache().get(i.queryHash)) == null ? void 0 : y.promise
    );
    g == null || g.catch($t).finally(() => {
      c.updateResult();
    });
  }
  return i.notifyOnChangeProps ? u : c.trackResult(u);
}
function yn(t, e) {
  return vT(t, lg);
}
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Df.apply(null, arguments);
}
let LX = /* @__PURE__ */ function(t) {
  return t.NOT_AVAILABLE = "NOT_AVAILABLE", t.REFRESHING = "REFRESHING", t.AVAILABLE = "AVAILABLE", t;
}({}), CT = /* @__PURE__ */ function(t) {
  return t.VERIFIED = "VERIFIED", t.UNVERIFIED = "UNVERIFIED", t.ALL = "ALL", t;
}({});
const TT = "Webrpc", ST = "webrpc@v0.21.1;gen-typescript@v0.15.1;sequence-indexer@v0.4.0";
class OT {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/IndexerGateway/", this.getNativeTokenBalance = (r, s, a) => this.fetch(this.url("GetNativeTokenBalance"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalances = (r, s, a) => this.fetch(this.url("GetTokenBalances"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesSummary = (r, s, a) => this.fetch(this.url("GetTokenBalancesSummary"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesDetails = (r, s, a) => this.fetch(this.url("GetTokenBalancesDetails"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesByContract = (r, s, a) => this.fetch(this.url("GetTokenBalancesByContract"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getBalanceUpdates = (r, s, a) => this.fetch(this.url("GetBalanceUpdates"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getChains = (r, s, a) => this.fetch(this.url("GetChains"), pr(r, s, a)).then((i) => hr(i).then((o) => ({
      chains: o.chains
    })), (i) => {
      throw zn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.ping = (r, s) => this.fetch(this.url("Ping"), pr({}, r, s)).then((a) => hr(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw zn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), pr({}, r, s)).then((a) => hr(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw zn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), pr({}, r, s)).then((a) => hr(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw zn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const pr = (t = {}, e = {}, n = null) => {
  const r = Df({}, e, {
    "Content-Type": "application/json"
  });
  return r[TT] = ST, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, hr = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), f6.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (oS[r] || Ee).new(n);
  }
  return n;
});
let Ee = class i6 extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, i6.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, BT = class o6 extends Ee {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, o6.prototype);
  }
}, zn = class c6 extends Ee {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, c6.prototype);
  }
}, IT = class l6 extends Ee {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, l6.prototype);
  }
}, PT = class u6 extends Ee {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, u6.prototype);
  }
}, UT = class d6 extends Ee {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, d6.prototype);
  }
}, f6 = class p6 extends Ee {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, p6.prototype);
  }
}, NT = class h6 extends Ee {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, h6.prototype);
  }
}, RT = class m6 extends Ee {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, m6.prototype);
  }
}, FT = class y6 extends Ee {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, y6.prototype);
  }
}, DT = class b6 extends Ee {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, b6.prototype);
  }
}, MT = class g6 extends Ee {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, g6.prototype);
  }
}, LT = class w6 extends Ee {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, w6.prototype);
  }
}, HT = class E6 extends Ee {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, E6.prototype);
  }
}, $T = class x6 extends Ee {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, x6.prototype);
  }
}, _T = class A6 extends Ee {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, A6.prototype);
  }
}, GT = class k6 extends Ee {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, k6.prototype);
  }
}, zT = class v6 extends Ee {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, v6.prototype);
  }
}, VT = class C6 extends Ee {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, C6.prototype);
  }
}, jT = class T6 extends Ee {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, T6.prototype);
  }
}, qT = class S6 extends Ee {
  constructor(e = "ProjectNotFound", n = 1100, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, S6.prototype);
  }
}, KT = class O6 extends Ee {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, O6.prototype);
  }
}, WT = class B6 extends Ee {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, B6.prototype);
  }
}, QT = class I6 extends Ee {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, I6.prototype);
  }
}, JT = class P6 extends Ee {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, P6.prototype);
  }
}, ZT = class U6 extends Ee {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, U6.prototype);
  }
}, XT = class N6 extends Ee {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, N6.prototype);
  }
};
class dg extends Ee {
  constructor(e = "RateLimit", n = 1201, r = "Rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, dg.prototype);
  }
}
let YT = class R6 extends Ee {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, R6.prototype);
  }
}, eS = class F6 extends Ee {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, F6.prototype);
  }
}, tS = class D6 extends Ee {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, D6.prototype);
  }
}, nS = class M6 extends Ee {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, M6.prototype);
  }
}, rS = class L6 extends Ee {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, L6.prototype);
  }
}, sS = class H6 extends Ee {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, H6.prototype);
  }
}, aS = class $6 extends Ee {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $6.prototype);
  }
};
class fg extends Ee {
  constructor(e = "ResourceExhausted", n = 2004, r = "Resource exhausted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, fg.prototype);
  }
}
let iS = class _6 extends Ee {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _6.prototype);
  }
};
class pg extends Ee {
  constructor(e = "MetadataCallFailed", n = 3003, r = "Metadata service call failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, pg.prototype);
  }
}
const oS = {
  0: BT,
  [-1]: zn,
  [-2]: IT,
  [-3]: PT,
  [-4]: UT,
  [-5]: f6,
  [-6]: NT,
  [-7]: RT,
  [-8]: FT,
  [-9]: DT,
  [-10]: MT,
  1e3: LT,
  1001: HT,
  1002: $T,
  1003: _T,
  1004: GT,
  1005: zT,
  1006: VT,
  1007: jT,
  1100: qT,
  1101: KT,
  1102: WT,
  1103: QT,
  1104: JT,
  1105: ZT,
  1200: XT,
  1201: dg,
  1300: YT,
  1301: eS,
  1302: tS,
  1900: nS,
  2001: rS,
  2002: sS,
  2003: aS,
  2004: fg,
  3e3: iS,
  3003: pg
};
class cS extends OT {
  constructor(e, n, r) {
    super(e.endsWith("/") ? e.slice(0, -1) : e, fetch), this.projectAccessKey = n, this.jwtAuth = r, this._fetch = (s, a) => {
      const i = {}, o = this.jwtAuth, c = this.projectAccessKey;
      return o && o.length > 0 && (i.Authorization = `BEARER ${o}`), c && c.length > 0 && (i["X-Access-Key"] = c), a.headers = Df({}, a.headers, i), fetch(s, a);
    }, this.fetch = this._fetch;
  }
}
let se = /* @__PURE__ */ function(t) {
  return t.MAINNET = "mainnet", t.TESTNET = "testnet", t;
}({}), k = /* @__PURE__ */ function(t) {
  return t[t.MAINNET = 1] = "MAINNET", t[t.ROPSTEN = 3] = "ROPSTEN", t[t.RINKEBY = 4] = "RINKEBY", t[t.GOERLI = 5] = "GOERLI", t[t.KOVAN = 42] = "KOVAN", t[t.SEPOLIA = 11155111] = "SEPOLIA", t[t.POLYGON = 137] = "POLYGON", t[t.POLYGON_MUMBAI = 80001] = "POLYGON_MUMBAI", t[t.POLYGON_ZKEVM = 1101] = "POLYGON_ZKEVM", t[t.POLYGON_AMOY = 80002] = "POLYGON_AMOY", t[t.BSC = 56] = "BSC", t[t.BSC_TESTNET = 97] = "BSC_TESTNET", t[t.OPTIMISM = 10] = "OPTIMISM", t[t.OPTIMISM_KOVAN = 69] = "OPTIMISM_KOVAN", t[t.OPTIMISM_GOERLI = 420] = "OPTIMISM_GOERLI", t[t.OPTIMISM_SEPOLIA = 11155420] = "OPTIMISM_SEPOLIA", t[t.ARBITRUM = 42161] = "ARBITRUM", t[t.ARBITRUM_GOERLI = 421613] = "ARBITRUM_GOERLI", t[t.ARBITRUM_SEPOLIA = 421614] = "ARBITRUM_SEPOLIA", t[t.ARBITRUM_NOVA = 42170] = "ARBITRUM_NOVA", t[t.AVALANCHE = 43114] = "AVALANCHE", t[t.AVALANCHE_TESTNET = 43113] = "AVALANCHE_TESTNET", t[t.GNOSIS = 100] = "GNOSIS", t[t.BASE = 8453] = "BASE", t[t.BASE_GOERLI = 84531] = "BASE_GOERLI", t[t.BASE_SEPOLIA = 84532] = "BASE_SEPOLIA", t[t.HOMEVERSE_TESTNET = 40875] = "HOMEVERSE_TESTNET", t[t.HOMEVERSE = 19011] = "HOMEVERSE", t[t.XAI = 660279] = "XAI", t[t.XAI_SEPOLIA = 37714555429] = "XAI_SEPOLIA", t[t.TELOS = 40] = "TELOS", t[t.TELOS_TESTNET = 41] = "TELOS_TESTNET", t[t.B3 = 8333] = "B3", t[t.B3_SEPOLIA = 1993] = "B3_SEPOLIA", t[t.APECHAIN = 33139] = "APECHAIN", t[t.APECHAIN_TESTNET = 33111] = "APECHAIN_TESTNET", t[t.BLAST = 81457] = "BLAST", t[t.BLAST_SEPOLIA = 168587773] = "BLAST_SEPOLIA", t[t.BORNE_TESTNET = 94984] = "BORNE_TESTNET", t[t.SKALE_NEBULA = 1482601649] = "SKALE_NEBULA", t[t.SKALE_NEBULA_TESTNET = 37084624] = "SKALE_NEBULA_TESTNET", t[t.SONEIUM_MINATO = 1946] = "SONEIUM_MINATO", t[t.SONEIUM = 1868] = "SONEIUM", t[t.TOY_TESTNET = 21e6] = "TOY_TESTNET", t[t.IMMUTABLE_ZKEVM = 13371] = "IMMUTABLE_ZKEVM", t[t.IMMUTABLE_ZKEVM_TESTNET = 13473] = "IMMUTABLE_ZKEVM_TESTNET", t[t.ROOT_NETWORK = 7668] = "ROOT_NETWORK", t[t.ROOT_NETWORK_PORCINI = 7672] = "ROOT_NETWORK_PORCINI", t[t.HARDHAT = 31337] = "HARDHAT", t[t.HARDHAT_2 = 31338] = "HARDHAT_2", t[t.LAOS = 6283] = "LAOS", t[t.LAOS_SIGMA_TESTNET = 62850] = "LAOS_SIGMA_TESTNET", t[t.ETHERLINK = 42793] = "ETHERLINK", t[t.ETHERLINK_TESTNET = 128123] = "ETHERLINK_TESTNET", t[t.MOONBEAM = 1284] = "MOONBEAM", t[t.MOONBASE_ALPHA = 1287] = "MOONBASE_ALPHA", t[t.MONAD_TESTNET = 10143] = "MONAD_TESTNET", t[t.SOMNIA_TESTNET = 50312] = "SOMNIA_TESTNET", t[t.SOMNIA = 5031] = "SOMNIA", t[t.INCENTIV_TESTNET = 11690] = "INCENTIV_TESTNET", t[t.SEI = 1329] = "SEI", t[t.SEI_TESTNET = 1328] = "SEI_TESTNET", t;
}({});
const d0 = {
  [k.MAINNET]: {
    chainId: k.MAINNET,
    type: se.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [k.ROPSTEN]: {
    chainId: k.ROPSTEN,
    type: se.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROPSTEN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.RINKEBY]: {
    chainId: k.RINKEBY,
    type: se.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.RINKEBY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.GOERLI]: {
    chainId: k.GOERLI,
    type: se.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.KOVAN]: {
    chainId: k.KOVAN,
    type: se.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.SEPOLIA]: {
    chainId: k.SEPOLIA,
    type: se.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.POLYGON]: {
    chainId: k.POLYGON,
    type: se.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "POL",
      name: "POL",
      decimals: 18
    }
  },
  [k.POLYGON_MUMBAI]: {
    chainId: k.POLYGON_MUMBAI,
    type: se.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_MUMBAI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: !0
  },
  [k.POLYGON_AMOY]: {
    chainId: k.POLYGON_AMOY,
    type: se.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_AMOY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aPOL",
      name: "Amoy POL",
      decimals: 18
    }
  },
  [k.POLYGON_ZKEVM]: {
    chainId: k.POLYGON_ZKEVM,
    type: se.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BSC]: {
    chainId: k.BSC,
    type: se.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [k.BSC_TESTNET]: {
    chainId: k.BSC_TESTNET,
    type: se.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BSC_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [k.OPTIMISM]: {
    chainId: k.OPTIMISM,
    type: se.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.OPTIMISM_KOVAN]: {
    chainId: k.OPTIMISM_KOVAN,
    type: se.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.OPTIMISM_GOERLI]: {
    chainId: k.OPTIMISM_GOERLI,
    type: se.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.OPTIMISM_SEPOLIA]: {
    chainId: k.OPTIMISM_SEPOLIA,
    type: se.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM]: {
    chainId: k.ARBITRUM,
    type: se.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM_GOERLI]: {
    chainId: k.ARBITRUM_GOERLI,
    type: se.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.ARBITRUM_SEPOLIA]: {
    chainId: k.ARBITRUM_SEPOLIA,
    type: se.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM_NOVA]: {
    chainId: k.ARBITRUM_NOVA,
    type: se.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.AVALANCHE]: {
    chainId: k.AVALANCHE,
    type: se.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [k.AVALANCHE_TESTNET]: {
    chainId: k.AVALANCHE_TESTNET,
    type: se.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.AVALANCHE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [k.GNOSIS]: {
    chainId: k.GNOSIS,
    type: se.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [k.BASE]: {
    chainId: k.BASE,
    type: se.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BASE_GOERLI]: {
    chainId: k.BASE_GOERLI,
    type: se.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.BASE_SEPOLIA]: {
    chainId: k.BASE_SEPOLIA,
    type: se.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.HOMEVERSE]: {
    chainId: k.HOMEVERSE,
    type: se.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [k.HOMEVERSE_TESTNET]: {
    chainId: k.HOMEVERSE_TESTNET,
    type: se.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.HOMEVERSE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [k.XAI]: {
    chainId: k.XAI,
    type: se.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [k.XAI_SEPOLIA]: {
    chainId: k.XAI_SEPOLIA,
    type: se.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.XAI_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [k.B3]: {
    chainId: k.B3,
    type: se.MAINNET,
    name: "b3",
    title: "B3",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.B3}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "B3 Explorer",
      rootUrl: "https://explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.B3_SEPOLIA]: {
    chainId: k.B3_SEPOLIA,
    type: se.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.B3_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.APECHAIN]: {
    chainId: k.APECHAIN,
    type: se.MAINNET,
    name: "apechain",
    title: "APE Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.APECHAIN}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://apechain.calderaexplorer.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [k.APECHAIN_TESTNET]: {
    chainId: k.APECHAIN_TESTNET,
    type: se.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.APECHAIN_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [k.BLAST]: {
    chainId: k.BLAST,
    type: se.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BLAST_SEPOLIA]: {
    chainId: k.BLAST_SEPOLIA,
    type: se.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BLAST_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.TELOS]: {
    chainId: k.TELOS,
    type: se.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [k.TELOS_TESTNET]: {
    chainId: k.TELOS_TESTNET,
    type: se.TESTNET,
    name: "telos-testnet",
    title: "Telos Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TELOS_TESTNET}.webp`,
    blockExplorer: {
      name: "Telos Testnet Explorer",
      rootUrl: "https://explorer-test.telos.net/network"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [k.BORNE_TESTNET]: {
    chainId: k.BORNE_TESTNET,
    type: se.TESTNET,
    name: "borne-testnet",
    title: "Borne Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BORNE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Borne Testnet Explorer",
      rootUrl: "https://subnets-test.avax.network/bornegfdn"
    },
    nativeToken: {
      symbol: "BORNE",
      name: "BORNE",
      decimals: 18
    }
  },
  [k.SKALE_NEBULA]: {
    chainId: k.SKALE_NEBULA,
    type: se.MAINNET,
    name: "skale-nebula",
    title: "SKALE Nebula Gaming Hub",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SKALE_NEBULA}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Explorer",
      rootUrl: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [k.SKALE_NEBULA_TESTNET]: {
    chainId: k.SKALE_NEBULA_TESTNET,
    type: se.TESTNET,
    name: "skale-nebula-testnet",
    title: "SKALE Nebula Gaming Hub Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SKALE_NEBULA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Testnet Explorer",
      rootUrl: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [k.SONEIUM]: {
    chainId: k.SONEIUM,
    type: se.MAINNET,
    name: "soneium",
    title: "Soneium",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SONEIUM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Soneium Explorer",
      rootUrl: "https://soneium.blockscout.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.SONEIUM_MINATO]: {
    chainId: k.SONEIUM_MINATO,
    type: se.TESTNET,
    name: "soneium-minato",
    title: "Soneium Minato (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SONEIUM_MINATO}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Soneium Minato Explorer",
      rootUrl: "https://explorer-testnet.soneium.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.TOY_TESTNET]: {
    chainId: k.TOY_TESTNET,
    type: se.TESTNET,
    name: "toy-testnet",
    title: "TOY (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TOY_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "TOY Testnet Explorer",
      rootUrl: "https://toy-chain-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "TOY",
      name: "TOY",
      decimals: 18
    }
  },
  [k.IMMUTABLE_ZKEVM]: {
    chainId: k.IMMUTABLE_ZKEVM,
    type: se.MAINNET,
    name: "immutable-zkevm",
    title: "Immutable zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.IMMUTABLE_ZKEVM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Immutable zkEVM Explorer",
      rootUrl: "https://explorer.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [k.IMMUTABLE_ZKEVM_TESTNET]: {
    chainId: k.IMMUTABLE_ZKEVM_TESTNET,
    type: se.TESTNET,
    name: "immutable-zkevm-testnet",
    title: "Immutable zkEVM Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.IMMUTABLE_ZKEVM_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Immutable zkEVM Testnet Explorer",
      rootUrl: "https://explorer.testnet.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [k.ROOT_NETWORK]: {
    chainId: k.ROOT_NETWORK,
    type: se.MAINNET,
    name: "rootnet",
    title: "The Root Network",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROOT_NETWORK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "The Root Network Explorer",
      rootUrl: "https://rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [k.ROOT_NETWORK_PORCINI]: {
    chainId: k.ROOT_NETWORK_PORCINI,
    type: se.TESTNET,
    name: "rootnet-porcini",
    title: "The Root Network Porcini Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROOT_NETWORK_PORCINI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "The Root Network Porcini Testnet Explorer",
      rootUrl: "https://porcini.rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [k.HARDHAT]: {
    chainId: k.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.HARDHAT_2]: {
    chainId: k.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.LAOS]: {
    chainId: k.LAOS,
    type: se.MAINNET,
    name: "laos",
    title: "LAOS",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.LAOS}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "LAOS Explorer",
      rootUrl: "https://blockscout.laos.laosfoundation.io/"
    },
    nativeToken: {
      symbol: "LAOS",
      name: "LAOS",
      decimals: 18
    }
  },
  [k.LAOS_SIGMA_TESTNET]: {
    chainId: k.LAOS_SIGMA_TESTNET,
    type: se.TESTNET,
    name: "laos-sigma-testnet",
    title: "LAOS Sigma Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.LAOS_SIGMA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "LAOS Sigma Testnet Explorer",
      rootUrl: "https://sigma.explorer.laosnetwork.io/"
    },
    nativeToken: {
      symbol: "SIGMA",
      name: "SIGMA",
      decimals: 18
    }
  },
  [k.MOONBEAM]: {
    chainId: k.MOONBEAM,
    type: se.MAINNET,
    name: "moonbeam",
    title: "Moonbeam",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MOONBEAM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Moonscan",
      rootUrl: "https://moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [k.MOONBASE_ALPHA]: {
    chainId: k.MOONBASE_ALPHA,
    type: se.TESTNET,
    name: "moonbase-alpha",
    title: "Moonbase Alpha",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MOONBASE_ALPHA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Moonscan (Moonbase Alpha)",
      rootUrl: "https://moonbase.moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [k.ETHERLINK]: {
    chainId: k.ETHERLINK,
    type: se.MAINNET,
    name: "etherlink",
    title: "Etherlink",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ETHERLINK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Etherlink Explorer",
      rootUrl: "https://explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [k.ETHERLINK_TESTNET]: {
    chainId: k.ETHERLINK_TESTNET,
    type: se.TESTNET,
    name: "etherlink-testnet",
    title: "Etherlink Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ETHERLINK_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherlink Testnet Explorer",
      rootUrl: "https://testnet.explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [k.MONAD_TESTNET]: {
    chainId: k.MONAD_TESTNET,
    type: se.TESTNET,
    name: "monad-testnet",
    title: "Monad Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MONAD_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Monad Testnet Explorer",
      rootUrl: "https://testnet.monadexplorer.com/"
    },
    nativeToken: {
      symbol: "MON",
      name: "MON",
      decimals: 18
    }
  },
  [k.SOMNIA_TESTNET]: {
    chainId: k.SOMNIA_TESTNET,
    type: se.TESTNET,
    name: "somnia-testnet",
    title: "Somnia Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SOMNIA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Somnia Testnet Explorer",
      rootUrl: "https://somnia-testnet.socialscan.io/"
    },
    nativeToken: {
      symbol: "STT",
      name: "STT",
      decimals: 18
    }
  },
  [k.INCENTIV_TESTNET]: {
    chainId: k.INCENTIV_TESTNET,
    type: se.TESTNET,
    name: "incentiv-testnet",
    title: "Incentiv Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.INCENTIV_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Incentiv Testnet Explorer",
      rootUrl: "https://explorer.testnet.incentiv.net/"
    },
    nativeToken: {
      symbol: "CENT",
      name: "CENT",
      decimals: 18
    }
  },
  [k.SEI]: {
    chainId: k.SEI,
    type: se.MAINNET,
    name: "sei",
    title: "Sei",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SEI}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "SEI Explorer",
      rootUrl: "https://seitrace.com/?chain=pacific-1"
    },
    nativeToken: {
      symbol: "SEI",
      name: "SEI",
      decimals: 18
    }
  },
  [k.SEI_TESTNET]: {
    chainId: k.SEI_TESTNET,
    type: se.TESTNET,
    name: "sei-testnet",
    title: "Sei Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SEI_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Sei Testnet Explorer",
      rootUrl: "https://seitrace.com/?chain=atlantic-2"
    },
    nativeToken: {
      symbol: "SEI",
      name: "SEI",
      decimals: 18
    }
  },
  [k.SOMNIA]: {
    chainId: k.SOMNIA,
    type: se.MAINNET,
    name: "somnia",
    title: "Somnia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SOMNIA}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Somnia Explorer",
      rootUrl: "https://mainnet.somnia.w3us.site/"
    },
    nativeToken: {
      symbol: "SOMI",
      name: "SOMI",
      decimals: 18
    }
  }
}, lS = "6.15.0";
function uS(t, e, n) {
  const r = e.split("|").map((a) => a.trim());
  for (let a = 0; a < r.length; a++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof t === e)
          return;
    }
  const s = new Error(`invalid value for type ${e}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${n}`, s.value = t, s;
}
async function dt(t) {
  const e = Object.keys(t);
  return (await Promise.all(e.map((r) => Promise.resolve(t[r])))).reduce((r, s, a) => (r[e[a]] = s, r), {});
}
function oe(t, e, n) {
  for (let r in e) {
    let s = e[r];
    const a = n ? n[r] : null;
    a && uS(s, a, r), Object.defineProperty(t, r, { enumerable: !0, value: s, writable: !1 });
  }
}
function po(t, e) {
  if (t == null)
    return "null";
  if (e == null && (e = /* @__PURE__ */ new Set()), typeof t == "object") {
    if (e.has(t))
      return "[Circular]";
    e.add(t);
  }
  if (Array.isArray(t))
    return "[ " + t.map((n) => po(n, e)).join(", ") + " ]";
  if (t instanceof Uint8Array) {
    const n = "0123456789abcdef";
    let r = "0x";
    for (let s = 0; s < t.length; s++)
      r += n[t[s] >> 4], r += n[t[s] & 15];
    return r;
  }
  if (typeof t == "object" && typeof t.toJSON == "function")
    return po(t.toJSON(), e);
  switch (typeof t) {
    case "boolean":
    case "number":
    case "symbol":
      return t.toString();
    case "bigint":
      return BigInt(t).toString();
    case "string":
      return JSON.stringify(t);
    case "object": {
      const n = Object.keys(t);
      return n.sort(), "{ " + n.map((r) => `${po(r, e)}: ${po(t[r], e)}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function mt(t, e) {
  return t && t.code === e;
}
function hg(t) {
  return mt(t, "CALL_EXCEPTION");
}
function Ge(t, e, n) {
  let r = t;
  {
    const a = [];
    if (n) {
      if ("message" in n || "code" in n || "name" in n)
        throw new Error(`value will overwrite populated values: ${po(n)}`);
      for (const i in n) {
        if (i === "shortMessage")
          continue;
        const o = n[i];
        a.push(i + "=" + po(o));
      }
    }
    a.push(`code=${e}`), a.push(`version=${lS}`), a.length && (t += " (" + a.join(", ") + ")");
  }
  let s;
  switch (e) {
    case "INVALID_ARGUMENT":
      s = new TypeError(t);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(t);
      break;
    default:
      s = new Error(t);
  }
  return oe(s, { code: e }), n && Object.assign(s, n), s.shortMessage == null && oe(s, { shortMessage: r }), s;
}
function j(t, e, n, r) {
  if (!t)
    throw Ge(e, n, r);
}
function S(t, e, n, r) {
  j(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
}
function G6(t, e, n) {
  n == null && (n = ""), n && (n = ": " + n), j(t >= e, "missing argument" + n, "MISSING_ARGUMENT", {
    count: t,
    expectedCount: e
  }), j(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
    count: t,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    t.push(e);
  } catch {
  }
  return t;
}, []);
function Op(t, e, n) {
  if (n == null && (n = ""), t !== e) {
    let r = n, s = "new";
    n && (r += ".", s += " " + n), j(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function z6(t, e, n) {
  if (t instanceof Uint8Array)
    return n ? new Uint8Array(t) : t;
  if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((t.length - 2) / 2);
    let s = 2;
    for (let a = 0; a < r.length; a++)
      r[a] = parseInt(t.substring(s, s + 2), 16), s += 2;
    return r;
  }
  S(!1, "invalid BytesLike value", e || "value", t);
}
function J(t, e) {
  return z6(t, e, !1);
}
function Gt(t, e) {
  return z6(t, e, !0);
}
function Ue(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === !0 && t.length % 2 !== 0);
}
function Fi(t) {
  return Ue(t, !0) || t instanceof Uint8Array;
}
const Pw = "0123456789abcdef";
function G(t) {
  const e = J(t);
  let n = "0x";
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    n += Pw[(s & 240) >> 4] + Pw[s & 15];
  }
  return n;
}
function Le(t) {
  return "0x" + t.map((e) => G(e).substring(2)).join("");
}
function Ci(t) {
  return Ue(t, !0) ? (t.length - 2) / 2 : J(t).length;
}
function ze(t, e, n) {
  const r = J(t);
  return n != null && n > r.length && j(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: r,
    length: r.length,
    offset: n
  }), G(r.slice(e ?? 0, n ?? r.length));
}
function V6(t, e, n) {
  const r = J(t);
  j(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: e,
    offset: e + 1
  });
  const s = new Uint8Array(e);
  return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), G(s);
}
function hn(t, e) {
  return V6(t, e, !0);
}
function j6(t, e) {
  return V6(t, e, !1);
}
const Bp = BigInt(0), tr = BigInt(1), ho = 9007199254740991;
function dS(t, e) {
  const n = Ip(t, "value"), r = BigInt(we(e, "width"));
  if (j(n >> r === Bp, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: t
  }), n >> r - tr) {
    const s = (tr << r) - tr;
    return -((~n & s) + tr);
  }
  return n;
}
function mg(t, e) {
  let n = ne(t, "value");
  const r = BigInt(we(e, "width")), s = tr << r - tr;
  if (n < Bp) {
    n = -n, j(n <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
    const a = (tr << r) - tr;
    return (~n & a) + tr;
  } else
    j(n < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
  return n;
}
function Il(t, e) {
  const n = Ip(t, "value"), r = BigInt(we(e, "bits"));
  return n & (tr << r) - tr;
}
function ne(t, e) {
  switch (typeof t) {
    case "bigint":
      return t;
    case "number":
      return S(Number.isInteger(t), "underflow", e || "value", t), S(t >= -ho && t <= ho, "overflow", e || "value", t), BigInt(t);
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t);
      } catch (n) {
        S(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t);
      }
  }
  S(!1, "invalid BigNumberish value", e || "value", t);
}
function Ip(t, e) {
  const n = ne(t, e);
  return j(n >= Bp, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: t
  }), n;
}
const Uw = "0123456789abcdef";
function yg(t) {
  if (t instanceof Uint8Array) {
    let e = "0x0";
    for (const n of t)
      e += Uw[n >> 4], e += Uw[n & 15];
    return BigInt(e);
  }
  return ne(t);
}
function we(t, e) {
  switch (typeof t) {
    case "bigint":
      return S(t >= -ho && t <= ho, "overflow", e || "value", t), Number(t);
    case "number":
      return S(Number.isInteger(t), "underflow", e || "value", t), S(t >= -ho && t <= ho, "overflow", e || "value", t), t;
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return we(BigInt(t), e);
      } catch (n) {
        S(!1, `invalid numeric string: ${n.message}`, e || "value", t);
      }
  }
  S(!1, "invalid numeric value", e || "value", t);
}
function fS(t) {
  return we(yg(t));
}
function sr(t, e) {
  let r = Ip(t, "value").toString(16);
  if (e == null)
    r.length % 2 && (r = "0" + r);
  else {
    const s = we(e, "width");
    for (j(s * 2 >= r.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: t
    }); r.length < s * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function rt(t) {
  const e = Ip(t, "value");
  if (e === Bp)
    return new Uint8Array([]);
  let n = e.toString(16);
  n.length % 2 && (n = "0" + n);
  const r = new Uint8Array(n.length / 2);
  for (let s = 0; s < r.length; s++) {
    const a = s * 2;
    r[s] = parseInt(n.substring(a, a + 2), 16);
  }
  return r;
}
function er(t) {
  let e = G(Fi(t) ? t : rt(t)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const Nw = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const Rw = BigInt(58);
function pS(t) {
  const e = J(t);
  let n = yg(e), r = "";
  for (; n; )
    r = Nw[Number(n % Rw)] + r, n /= Rw;
  for (let s = 0; s < e.length && !e[s]; s++)
    r = Nw[0] + r;
  return r;
}
function hS(t) {
  t = atob(t);
  const e = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    e[n] = t.charCodeAt(n);
  return J(e);
}
function mS(t) {
  const e = J(t);
  let n = "";
  for (let r = 0; r < e.length; r++)
    n += String.fromCharCode(e[r]);
  return btoa(n);
}
var jo;
class q6 {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, n, r) {
    /**
     *  The event filter.
     */
    R(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    R(this, "emitter");
    T(this, jo);
    E(this, jo, n), oe(this, { emitter: e, filter: r });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    p(this, jo) != null && await this.emitter.off(this.filter, p(this, jo));
  }
}
jo = new WeakMap();
function yS(t, e, n, r, s) {
  S(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
}
function K6(t, e, n, r, s) {
  if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
    let a = 0;
    for (let i = e + 1; i < n.length && n[i] >> 6 === 2; i++)
      a++;
    return a;
  }
  return t === "OVERRUN" ? n.length - e - 1 : 0;
}
function bS(t, e, n, r, s) {
  return t === "OVERLONG" ? (S(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), r.push(s), 0) : (r.push(65533), K6(t, e, n));
}
const gS = Object.freeze({
  error: yS,
  ignore: K6,
  replace: bS
});
function wS(t, e) {
  e == null && (e = gS.error);
  const n = J(t, "bytes"), r = [];
  let s = 0;
  for (; s < n.length; ) {
    const a = n[s++];
    if (!(a >> 7)) {
      r.push(a);
      continue;
    }
    let i = null, o = null;
    if ((a & 224) === 192)
      i = 1, o = 127;
    else if ((a & 240) === 224)
      i = 2, o = 2047;
    else if ((a & 248) === 240)
      i = 3, o = 65535;
    else {
      (a & 192) === 128 ? s += e("UNEXPECTED_CONTINUE", s - 1, n, r) : s += e("BAD_PREFIX", s - 1, n, r);
      continue;
    }
    if (s - 1 + i >= n.length) {
      s += e("OVERRUN", s - 1, n, r);
      continue;
    }
    let c = a & (1 << 8 - i - 1) - 1;
    for (let u = 0; u < i; u++) {
      let l = n[s];
      if ((l & 192) != 128) {
        s += e("MISSING_CONTINUE", s, n, r), c = null;
        break;
      }
      c = c << 6 | l & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += e("OUT_OF_RANGE", s - 1 - i, n, r, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += e("UTF16_SURROGATE", s - 1 - i, n, r, c);
        continue;
      }
      if (c <= o) {
        s += e("OVERLONG", s - 1 - i, n, r, c);
        continue;
      }
      r.push(c);
    }
  }
  return r;
}
function en(t, e) {
  S(typeof t == "string", "invalid string value", "str", t);
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t.charCodeAt(r);
    if (s < 128)
      n.push(s);
    else if (s < 2048)
      n.push(s >> 6 | 192), n.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      r++;
      const a = t.charCodeAt(r);
      S(r < t.length && (a & 64512) === 56320, "invalid surrogate pair", "str", t);
      const i = 65536 + ((s & 1023) << 10) + (a & 1023);
      n.push(i >> 18 | 240), n.push(i >> 12 & 63 | 128), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
    } else
      n.push(s >> 12 | 224), n.push(s >> 6 & 63 | 128), n.push(s & 63 | 128);
  }
  return new Uint8Array(n);
}
function ES(t) {
  return t.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function Mf(t, e) {
  return ES(wS(t, e));
}
function W6(t) {
  async function e(n, r) {
    j(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
    const s = n.url.split(":")[0].toLowerCase();
    j(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), j(s === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let a = null;
    const i = new AbortController(), o = setTimeout(() => {
      a = Ge("request timeout", "TIMEOUT"), i.abort();
    }, n.timeout);
    r && r.addListener(() => {
      a = Ge("request cancelled", "CANCELLED"), i.abort();
    });
    const c = Object.assign({}, t, {
      method: n.method,
      headers: new Headers(Array.from(n)),
      body: n.body || void 0,
      signal: i.signal
    });
    let u;
    try {
      u = await fetch(n.url, c);
    } catch (h) {
      throw clearTimeout(o), a || h;
    }
    clearTimeout(o);
    const l = {};
    u.headers.forEach((h, b) => {
      l[b.toLowerCase()] = h;
    });
    const d = await u.arrayBuffer(), m = d == null ? null : new Uint8Array(d);
    return {
      statusCode: u.status,
      statusMessage: u.statusText,
      headers: l,
      body: m
    };
  }
  return e;
}
const xS = 12, AS = 250;
let Fw = W6();
const kS = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), vS = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let Qh = !1;
async function Q6(t, e) {
  try {
    const n = t.match(kS);
    if (!n)
      throw new Error("invalid data");
    return new pa(200, "OK", {
      "content-type": n[1] || "text/plain"
    }, n[2] ? hS(n[3]) : TS(n[3]));
  } catch {
    return new pa(599, "BAD REQUEST (invalid data: URI)", {}, null, new Dr(t));
  }
}
function J6(t) {
  async function e(n, r) {
    try {
      const s = n.match(vS);
      if (!s)
        throw new Error("invalid link");
      return new Dr(`${t}${s[2]}`);
    } catch {
      return new pa(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Dr(n));
    }
  }
  return e;
}
const xd = {
  data: Q6,
  ipfs: J6("https://gateway.ipfs.io/ipfs/")
}, Z6 = /* @__PURE__ */ new WeakMap();
var si, Ks;
class CS {
  constructor(e) {
    T(this, si);
    T(this, Ks);
    E(this, si, []), E(this, Ks, !1), Z6.set(e, () => {
      if (!p(this, Ks)) {
        E(this, Ks, !0);
        for (const n of p(this, si))
          setTimeout(() => {
            n();
          }, 0);
        E(this, si, []);
      }
    });
  }
  addListener(e) {
    j(!p(this, Ks), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), p(this, si).push(e);
  }
  get cancelled() {
    return p(this, Ks);
  }
  checkSignal() {
    j(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
si = new WeakMap(), Ks = new WeakMap();
function Ad(t) {
  if (t == null)
    throw new Error("missing signal; should not happen");
  return t.checkSignal(), t;
}
var qo, Ko, Qn, es, Wo, Qo, at, un, ts, ai, ii, oi, kr, Jn, Ws, ci, Pl;
const xp = class xp {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    T(this, ci);
    T(this, qo);
    T(this, Ko);
    T(this, Qn);
    T(this, es);
    T(this, Wo);
    T(this, Qo);
    T(this, at);
    T(this, un);
    T(this, ts);
    // Hooks
    T(this, ai);
    T(this, ii);
    T(this, oi);
    T(this, kr);
    T(this, Jn);
    T(this, Ws);
    E(this, Qo, String(e)), E(this, qo, !1), E(this, Ko, !0), E(this, Qn, {}), E(this, es, ""), E(this, Wo, 3e5), E(this, Jn, {
      slotInterval: AS,
      maxAttempts: xS
    }), E(this, Ws, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return p(this, Qo);
  }
  set url(e) {
    E(this, Qo, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return p(this, at) == null ? null : new Uint8Array(p(this, at));
  }
  set body(e) {
    if (e == null)
      E(this, at, void 0), E(this, un, void 0);
    else if (typeof e == "string")
      E(this, at, en(e)), E(this, un, "text/plain");
    else if (e instanceof Uint8Array)
      E(this, at, e), E(this, un, "application/octet-stream");
    else if (typeof e == "object")
      E(this, at, en(JSON.stringify(e))), E(this, un, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return p(this, at) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return p(this, es) ? p(this, es) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), E(this, es, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, p(this, Qn));
    return p(this, ts) && (e.authorization = `Basic ${mS(en(p(this, ts)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && p(this, un) && (e["content-type"] = p(this, un)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, n) {
    p(this, Qn)[String(e).toLowerCase()] = String(n);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    E(this, Qn, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return p(this, ts) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, n) {
    S(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), E(this, ts, `${e}:${n}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return p(this, Ko);
  }
  set allowGzip(e) {
    E(this, Ko, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!p(this, qo);
  }
  set allowInsecureAuthentication(e) {
    E(this, qo, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return p(this, Wo);
  }
  set timeout(e) {
    S(e >= 0, "timeout must be non-zero", "timeout", e), E(this, Wo, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return p(this, ai) || null;
  }
  set preflightFunc(e) {
    E(this, ai, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return p(this, ii) || null;
  }
  set processFunc(e) {
    E(this, ii, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return p(this, oi) || null;
  }
  set retryFunc(e) {
    E(this, oi, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return p(this, Ws) || Fw;
  }
  set getUrlFunc(e) {
    E(this, Ws, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${p(this, at) ? G(p(this, at)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (p(this, Jn).slotInterval = e.slotInterval), e.maxAttempts != null && (p(this, Jn).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return j(p(this, kr) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), E(this, kr, new CS(this)), _(this, ci, Pl).call(this, 0, Dw() + this.timeout, 0, this, new pa(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    j(p(this, kr) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = Z6.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const n = this.url.split(":")[0].toLowerCase(), r = e.split(":")[0].toLowerCase();
    j(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const s = new xp(e);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, E(s, Qn, Object.assign({}, p(this, Qn))), p(this, at) && E(s, at, new Uint8Array(p(this, at))), E(s, un, p(this, un)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new xp(this.url);
    return E(e, es, p(this, es)), p(this, at) && E(e, at, p(this, at)), E(e, un, p(this, un)), E(e, Qn, Object.assign({}, p(this, Qn))), E(e, ts, p(this, ts)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), E(e, ai, p(this, ai)), E(e, ii, p(this, ii)), E(e, oi, p(this, oi)), E(e, Jn, Object.assign({}, p(this, Jn))), E(e, Ws, p(this, Ws)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    Qh = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return xd[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, n) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (Qh)
      throw new Error("gateways locked");
    xd[e] = n;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (Qh)
      throw new Error("gateways locked");
    Fw = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return W6(e);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return Q6;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return J6(e);
  }
};
qo = new WeakMap(), Ko = new WeakMap(), Qn = new WeakMap(), es = new WeakMap(), Wo = new WeakMap(), Qo = new WeakMap(), at = new WeakMap(), un = new WeakMap(), ts = new WeakMap(), ai = new WeakMap(), ii = new WeakMap(), oi = new WeakMap(), kr = new WeakMap(), Jn = new WeakMap(), Ws = new WeakMap(), ci = new WeakSet(), Pl = async function(e, n, r, s, a) {
  var l, d, m;
  if (e >= p(this, Jn).maxAttempts)
    return a.makeServerError("exceeded maximum retry limit");
  j(Dw() <= n, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), r > 0 && await SS(r);
  let i = this.clone();
  const o = (i.url.split(":")[0] || "").toLowerCase();
  if (o in xd) {
    const h = await xd[o](i.url, Ad(p(s, kr)));
    if (h instanceof pa) {
      let b = h;
      if (this.processFunc) {
        Ad(p(s, kr));
        try {
          b = await this.processFunc(i, b);
        } catch (y) {
          (y.throttle == null || typeof y.stall != "number") && b.makeServerError("error in post-processing function", y).assertOk();
        }
      }
      return b;
    }
    i = h;
  }
  this.preflightFunc && (i = await this.preflightFunc(i));
  const c = await this.getUrlFunc(i, Ad(p(s, kr)));
  let u = new pa(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const h = u.headers.location || "";
      return _(l = i.redirect(h), ci, Pl).call(l, e + 1, n, 0, s, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(i, u, e))) {
    const h = u.headers["retry-after"];
    let b = p(this, Jn).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
    return typeof h == "string" && h.match(/^[1-9][0-9]*$/) && (b = parseInt(h)), _(d = i.clone(), ci, Pl).call(d, e + 1, n, b, s, u);
  }
  if (this.processFunc) {
    Ad(p(s, kr));
    try {
      u = await this.processFunc(i, u);
    } catch (h) {
      (h.throttle == null || typeof h.stall != "number") && u.makeServerError("error in post-processing function", h).assertOk();
      let b = p(this, Jn).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return h.stall >= 0 && (b = h.stall), _(m = i.clone(), ci, Pl).call(m, e + 1, n, b, s, u);
    }
  }
  return u;
};
let Dr = xp;
var Du, Mu, Lu, dn, Jo, li;
const dw = class dw {
  constructor(e, n, r, s, a) {
    T(this, Du);
    T(this, Mu);
    T(this, Lu);
    T(this, dn);
    T(this, Jo);
    T(this, li);
    E(this, Du, e), E(this, Mu, n), E(this, Lu, Object.keys(r).reduce((i, o) => (i[o.toLowerCase()] = String(r[o]), i), {})), E(this, dn, s == null ? null : new Uint8Array(s)), E(this, Jo, a || null), E(this, li, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${p(this, dn) ? G(p(this, dn)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return p(this, Du);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return p(this, Mu);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, p(this, Lu));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return p(this, dn) == null ? null : new Uint8Array(p(this, dn));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return p(this, dn) == null ? "" : Mf(p(this, dn));
    } catch {
      j(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      j(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, n) {
    let r;
    e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const s = new dw(599, r, this.headers, this.body, p(this, Jo) || void 0);
    return E(s, li, { message: e, error: n }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, n) {
    n == null ? n = -1 : S(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
    const r = new Error(e || "throttling requests");
    throw oe(r, { stall: n, throttle: !0 }), r;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return p(this, dn) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return p(this, Jo);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return p(this, li).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: n } = p(this, li);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let s = null;
    try {
      p(this, dn) && (s = Mf(p(this, dn)));
    } catch {
    }
    j(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: n,
      info: {
        requestUrl: r,
        responseBody: s,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
Du = new WeakMap(), Mu = new WeakMap(), Lu = new WeakMap(), dn = new WeakMap(), Jo = new WeakMap(), li = new WeakMap();
let pa = dw;
function Dw() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function TS(t) {
  return en(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))));
}
function SS(t) {
  return new Promise((e) => setTimeout(e, t));
}
function OS(t) {
  let e = t.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function Mw(t, e, n) {
  let r = 0;
  for (let s = 0; s < n; s++)
    r = r * 256 + t[e + s];
  return r;
}
function Lw(t, e, n, r) {
  const s = [];
  for (; n < e + 1 + r; ) {
    const a = X6(t, n);
    s.push(a.result), n += a.consumed, j(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: r,
      offset: e
    });
  }
  return { consumed: 1 + r, result: s };
}
function X6(t, e) {
  j(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: t,
    length: 0,
    offset: 1
  });
  const n = (r) => {
    j(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: t.length,
      offset: r
    });
  };
  if (t[e] >= 248) {
    const r = t[e] - 247;
    n(e + 1 + r);
    const s = Mw(t, e + 1, r);
    return n(e + 1 + r + s), Lw(t, e, e + 1 + r, r + s);
  } else if (t[e] >= 192) {
    const r = t[e] - 192;
    return n(e + 1 + r), Lw(t, e, e + 1, r);
  } else if (t[e] >= 184) {
    const r = t[e] - 183;
    n(e + 1 + r);
    const s = Mw(t, e + 1, r);
    n(e + 1 + r + s);
    const a = G(t.slice(e + 1 + r, e + 1 + r + s));
    return { consumed: 1 + r + s, result: a };
  } else if (t[e] >= 128) {
    const r = t[e] - 128;
    n(e + 1 + r);
    const s = G(t.slice(e + 1, e + 1 + r));
    return { consumed: 1 + r, result: s };
  }
  return { consumed: 1, result: OS(t[e]) };
}
function Xu(t) {
  const e = J(t, "data"), n = X6(e, 0);
  return S(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result;
}
function Hw(t) {
  const e = [];
  for (; t; )
    e.unshift(t & 255), t >>= 8;
  return e;
}
function Y6(t) {
  if (Array.isArray(t)) {
    let r = [];
    if (t.forEach(function(a) {
      r = r.concat(Y6(a));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const s = Hw(r.length);
    return s.unshift(247 + s.length), s.concat(r);
  }
  const e = Array.prototype.slice.call(J(t, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const n = Hw(e.length);
  return n.unshift(183 + n.length), n.concat(e);
}
const $w = "0123456789abcdef";
function xa(t) {
  let e = "0x";
  for (const n of Y6(t))
    e += $w[n >> 4], e += $w[n & 15];
  return e;
}
const zt = 32, f0 = new Uint8Array(zt), BS = ["then"], kd = {}, eA = /* @__PURE__ */ new WeakMap();
function Ua(t) {
  return eA.get(t);
}
function _w(t, e) {
  eA.set(t, e);
}
function ll(t, e) {
  const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
  throw n.error = e, n;
}
function p0(t, e, n) {
  return t.indexOf(null) >= 0 ? e.map((r, s) => r instanceof Ic ? p0(Ua(r), r, n) : r) : t.reduce((r, s, a) => {
    let i = e.getValue(s);
    return s in r || (n && i instanceof Ic && (i = p0(Ua(i), i, n)), r[s] = i), r;
  }, {});
}
var Zo;
const wo = class wo extends Array {
  /**
   *  @private
   */
  constructor(...n) {
    const r = n[0];
    let s = n[1], a = (n[2] || []).slice(), i = !0;
    r !== kd && (s = n, a = [], i = !1);
    super(s.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    T(this, Zo);
    s.forEach((u, l) => {
      this[l] = u;
    });
    const o = a.reduce((u, l) => (typeof l == "string" && u.set(l, (u.get(l) || 0) + 1), u), /* @__PURE__ */ new Map());
    if (_w(this, Object.freeze(s.map((u, l) => {
      const d = a[l];
      return d != null && o.get(d) === 1 ? d : null;
    }))), E(this, Zo, []), p(this, Zo) == null && p(this, Zo), !i)
      return;
    Object.freeze(this);
    const c = new Proxy(this, {
      get: (u, l, d) => {
        if (typeof l == "string") {
          if (l.match(/^[0-9]+$/)) {
            const h = we(l, "%index");
            if (h < 0 || h >= this.length)
              throw new RangeError("out of result range");
            const b = u[h];
            return b instanceof Error && ll(`index ${h}`, b), b;
          }
          if (BS.indexOf(l) >= 0)
            return Reflect.get(u, l, d);
          const m = u[l];
          if (m instanceof Function)
            return function(...h) {
              return m.apply(this === d ? u : this, h);
            };
          if (!(l in u))
            return u.getValue.apply(this === d ? u : this, [l]);
        }
        return Reflect.get(u, l, d);
      }
    });
    return _w(c, Ua(this)), c;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(n) {
    const r = [];
    return this.forEach((s, a) => {
      s instanceof Error && ll(`index ${a}`, s), n && s instanceof wo && (s = s.toArray(n)), r.push(s);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(n) {
    const r = Ua(this);
    return r.reduce((s, a, i) => (j(a != null, `value at index ${i} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), p0(r, this, n)), {});
  }
  /**
   *  @_ignore
   */
  slice(n, r) {
    n == null && (n = 0), n < 0 && (n += this.length, n < 0 && (n = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const s = Ua(this), a = [], i = [];
    for (let o = n; o < r; o++)
      a.push(this[o]), i.push(s[o]);
    return new wo(kd, a, i);
  }
  /**
   *  @_ignore
   */
  filter(n, r) {
    const s = Ua(this), a = [], i = [];
    for (let o = 0; o < this.length; o++) {
      const c = this[o];
      c instanceof Error && ll(`index ${o}`, c), n.call(r, c, o, this) && (a.push(c), i.push(s[o]));
    }
    return new wo(kd, a, i);
  }
  /**
   *  @_ignore
   */
  map(n, r) {
    const s = [];
    for (let a = 0; a < this.length; a++) {
      const i = this[a];
      i instanceof Error && ll(`index ${a}`, i), s.push(n.call(r, i, a, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(n) {
    const r = Ua(this).indexOf(n);
    if (r === -1)
      return;
    const s = this[r];
    return s instanceof Error && ll(`property ${JSON.stringify(n)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(n, r) {
    return new wo(kd, n, r);
  }
};
Zo = new WeakMap();
let Ic = wo;
function Gw(t) {
  let e = rt(t);
  return j(e.length <= zt, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: zt, offset: e.length }), e.length !== zt && (e = Gt(Le([f0.slice(e.length % zt), e]))), e;
}
class xs {
  constructor(e, n, r, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    R(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    R(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    R(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    R(this, "dynamic");
    oe(this, { name: e, type: n, localName: r, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, n) {
    S(!1, e, this.localName, n);
  }
}
var ns, ui, Xo, pf;
class h0 {
  constructor() {
    T(this, Xo);
    // An array of WordSize lengthed objects to concatenation
    T(this, ns);
    T(this, ui);
    E(this, ns, []), E(this, ui, 0);
  }
  get data() {
    return Le(p(this, ns));
  }
  get length() {
    return p(this, ui);
  }
  appendWriter(e) {
    return _(this, Xo, pf).call(this, Gt(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let n = Gt(e);
    const r = n.length % zt;
    return r && (n = Gt(Le([n, f0.slice(r)]))), _(this, Xo, pf).call(this, n);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return _(this, Xo, pf).call(this, Gw(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = p(this, ns).length;
    return p(this, ns).push(f0), E(this, ui, p(this, ui) + zt), (n) => {
      p(this, ns)[e] = Gw(n);
    };
  }
}
ns = new WeakMap(), ui = new WeakMap(), Xo = new WeakSet(), pf = function(e) {
  return p(this, ns).push(e), E(this, ui, p(this, ui) + e.length), e.length;
};
var Qt, fn, di, fi, Qs, Yi, y0, tA;
const fw = class fw {
  constructor(e, n, r) {
    T(this, Yi);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    R(this, "allowLoose");
    T(this, Qt);
    T(this, fn);
    T(this, di);
    T(this, fi);
    T(this, Qs);
    oe(this, { allowLoose: !!n }), E(this, Qt, Gt(e)), E(this, di, 0), E(this, fi, null), E(this, Qs, r ?? 1024), E(this, fn, 0);
  }
  get data() {
    return G(p(this, Qt));
  }
  get dataLength() {
    return p(this, Qt).length;
  }
  get consumed() {
    return p(this, fn);
  }
  get bytes() {
    return new Uint8Array(p(this, Qt));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const n = new fw(p(this, Qt).slice(p(this, fn) + e), this.allowLoose, p(this, Qs));
    return E(n, fi, this), n;
  }
  // Read bytes
  readBytes(e, n) {
    let r = _(this, Yi, tA).call(this, 0, e, !!n);
    return _(this, Yi, y0).call(this, e), E(this, fn, p(this, fn) + r.length), r.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return yg(this.readBytes(zt));
  }
  readIndex() {
    return fS(this.readBytes(zt));
  }
};
Qt = new WeakMap(), fn = new WeakMap(), di = new WeakMap(), fi = new WeakMap(), Qs = new WeakMap(), Yi = new WeakSet(), y0 = function(e) {
  var n;
  if (p(this, fi))
    return _(n = p(this, fi), Yi, y0).call(n, e);
  E(this, di, p(this, di) + e), j(p(this, Qs) < 1 || p(this, di) <= p(this, Qs) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${p(this, Qs)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: Gt(p(this, Qt)),
    offset: p(this, fn),
    length: e,
    info: {
      bytesRead: p(this, di),
      dataLength: this.dataLength
    }
  });
}, tA = function(e, n, r) {
  let s = Math.ceil(n / zt) * zt;
  return p(this, fn) + s > p(this, Qt).length && (this.allowLoose && r && p(this, fn) + n <= p(this, Qt).length ? s = n : j(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Gt(p(this, Qt)),
    length: p(this, Qt).length,
    offset: p(this, fn) + s
  })), p(this, Qt).slice(p(this, fn), p(this, fn) + s);
};
let m0 = fw;
function Lf(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function bg(t, ...e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function IS(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Lf(t.outputLen), Lf(t.blockLen);
}
function Pc(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function nA(t, e) {
  bg(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const Jh = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const rA = (t) => t instanceof Uint8Array, PS = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), Zh = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), mr = (t, e) => t << 32 - e | t >>> e, US = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!US)
  throw new Error("Non little-endian hardware is not supported");
function NS(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Pp(t) {
  if (typeof t == "string" && (t = NS(t)), !rA(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
function RS(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!rA(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
let gg = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wg(t) {
  const e = (r) => t().update(Pp(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function FS(t = 32) {
  if (Jh && typeof Jh.getRandomValues == "function")
    return Jh.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
let sA = class extends gg {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, IS(e);
    const r = Pp(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(e) {
    return Pc(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Pc(this), bg(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const aA = (t, e, n) => new sA(t, e).update(n).digest();
aA.create = (t, e) => new sA(t, e);
function DS(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
class iA extends gg {
  constructor(e, n, r, s) {
    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Zh(this.buffer);
  }
  update(e) {
    Pc(this);
    const { view: n, buffer: r, blockLen: s } = this;
    e = Pp(e);
    const a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = Zh(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Pc(this), nA(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    DS(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = Zh(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.length = s, e.pos = o, e.finished = a, e.destroyed = i, s % n && e.buffer.set(r), e;
  }
}
const MS = (t, e, n) => t & e ^ ~t & n, LS = (t, e, n) => t & e ^ t & n ^ e & n, HS = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Bs = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Is = /* @__PURE__ */ new Uint32Array(64);
let $S = class extends iA {
  constructor() {
    super(64, 32, 8, !1), this.A = Bs[0] | 0, this.B = Bs[1] | 0, this.C = Bs[2] | 0, this.D = Bs[3] | 0, this.E = Bs[4] | 0, this.F = Bs[5] | 0, this.G = Bs[6] | 0, this.H = Bs[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      Is[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const m = Is[d - 15], h = Is[d - 2], b = mr(m, 7) ^ mr(m, 18) ^ m >>> 3, y = mr(h, 17) ^ mr(h, 19) ^ h >>> 10;
      Is[d] = y + Is[d - 7] + b + Is[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const m = mr(o, 6) ^ mr(o, 11) ^ mr(o, 25), h = l + m + MS(o, c, u) + HS[d] + Is[d] | 0, y = (mr(r, 2) ^ mr(r, 13) ^ mr(r, 22)) + LS(r, s, a) | 0;
      l = u, u = c, c = o, o = i + h | 0, i = a, a = s, s = r, r = h + y | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    Is.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const oA = /* @__PURE__ */ wg(() => new $S()), vd = /* @__PURE__ */ BigInt(2 ** 32 - 1), b0 = /* @__PURE__ */ BigInt(32);
function cA(t, e = !1) {
  return e ? { h: Number(t & vd), l: Number(t >> b0 & vd) } : { h: Number(t >> b0 & vd) | 0, l: Number(t & vd) | 0 };
}
function lA(t, e = !1) {
  let n = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: a, l: i } = cA(t[s], e);
    [n[s], r[s]] = [a, i];
  }
  return [n, r];
}
const _S = (t, e) => BigInt(t >>> 0) << b0 | BigInt(e >>> 0), GS = (t, e, n) => t >>> n, zS = (t, e, n) => t << 32 - n | e >>> n, VS = (t, e, n) => t >>> n | e << 32 - n, jS = (t, e, n) => t << 32 - n | e >>> n, qS = (t, e, n) => t << 64 - n | e >>> n - 32, KS = (t, e, n) => t >>> n - 32 | e << 64 - n, WS = (t, e) => e, QS = (t, e) => t, uA = (t, e, n) => t << n | e >>> 32 - n, dA = (t, e, n) => e << n | t >>> 32 - n, fA = (t, e, n) => e << n - 32 | t >>> 64 - n, pA = (t, e, n) => t << n - 32 | e >>> 64 - n;
function JS(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const ZS = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), XS = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, YS = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), e7 = (t, e, n, r, s) => e + n + r + s + (t / 2 ** 32 | 0) | 0, t7 = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), n7 = (t, e, n, r, s, a) => e + n + r + s + a + (t / 2 ** 32 | 0) | 0, me = {
  fromBig: cA,
  split: lA,
  toBig: _S,
  shrSH: GS,
  shrSL: zS,
  rotrSH: VS,
  rotrSL: jS,
  rotrBH: qS,
  rotrBL: KS,
  rotr32H: WS,
  rotr32L: QS,
  rotlSH: uA,
  rotlSL: dA,
  rotlBH: fA,
  rotlBL: pA,
  add: JS,
  add3L: ZS,
  add3H: XS,
  add4L: YS,
  add4H: e7,
  add5H: n7,
  add5L: t7
}, [r7, s7] = me.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), Ps = /* @__PURE__ */ new Uint32Array(80), Us = /* @__PURE__ */ new Uint32Array(80);
class a7 extends iA {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: a, Cl: i, Dh: o, Dl: c, Eh: u, El: l, Fh: d, Fl: m, Gh: h, Gl: b, Hh: y, Hl: g } = this;
    return [e, n, r, s, a, i, o, c, u, l, d, m, h, b, y, g];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c, u, l, d, m, h, b, y, g) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = m | 0, this.Gh = h | 0, this.Gl = b | 0, this.Hh = y | 0, this.Hl = g | 0;
  }
  process(e, n) {
    for (let A = 0; A < 16; A++, n += 4)
      Ps[A] = e.getUint32(n), Us[A] = e.getUint32(n += 4);
    for (let A = 16; A < 80; A++) {
      const B = Ps[A - 15] | 0, x = Us[A - 15] | 0, N = me.rotrSH(B, x, 1) ^ me.rotrSH(B, x, 8) ^ me.shrSH(B, x, 7), I = me.rotrSL(B, x, 1) ^ me.rotrSL(B, x, 8) ^ me.shrSL(B, x, 7), O = Ps[A - 2] | 0, C = Us[A - 2] | 0, U = me.rotrSH(O, C, 19) ^ me.rotrBH(O, C, 61) ^ me.shrSH(O, C, 6), P = me.rotrSL(O, C, 19) ^ me.rotrBL(O, C, 61) ^ me.shrSL(O, C, 6), D = me.add4L(I, P, Us[A - 7], Us[A - 16]), $ = me.add4H(D, N, U, Ps[A - 7], Ps[A - 16]);
      Ps[A] = $ | 0, Us[A] = D | 0;
    }
    let { Ah: r, Al: s, Bh: a, Bl: i, Ch: o, Cl: c, Dh: u, Dl: l, Eh: d, El: m, Fh: h, Fl: b, Gh: y, Gl: g, Hh: w, Hl: v } = this;
    for (let A = 0; A < 80; A++) {
      const B = me.rotrSH(d, m, 14) ^ me.rotrSH(d, m, 18) ^ me.rotrBH(d, m, 41), x = me.rotrSL(d, m, 14) ^ me.rotrSL(d, m, 18) ^ me.rotrBL(d, m, 41), N = d & h ^ ~d & y, I = m & b ^ ~m & g, O = me.add5L(v, x, I, s7[A], Us[A]), C = me.add5H(O, w, B, N, r7[A], Ps[A]), U = O | 0, P = me.rotrSH(r, s, 28) ^ me.rotrBH(r, s, 34) ^ me.rotrBH(r, s, 39), D = me.rotrSL(r, s, 28) ^ me.rotrBL(r, s, 34) ^ me.rotrBL(r, s, 39), $ = r & a ^ r & o ^ a & o, K = s & i ^ s & c ^ i & c;
      w = y | 0, v = g | 0, y = h | 0, g = b | 0, h = d | 0, b = m | 0, { h: d, l: m } = me.add(u | 0, l | 0, C | 0, U | 0), u = o | 0, l = c | 0, o = a | 0, c = i | 0, a = r | 0, i = s | 0;
      const F = me.add3L(U, D, K);
      r = me.add3H(F, C, P, $), s = F | 0;
    }
    ({ h: r, l: s } = me.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: a, l: i } = me.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: o, l: c } = me.add(this.Ch | 0, this.Cl | 0, o | 0, c | 0), { h: u, l } = me.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: m } = me.add(this.Eh | 0, this.El | 0, d | 0, m | 0), { h, l: b } = me.add(this.Fh | 0, this.Fl | 0, h | 0, b | 0), { h: y, l: g } = me.add(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: w, l: v } = me.add(this.Hh | 0, this.Hl | 0, w | 0, v | 0), this.set(r, s, a, i, o, c, u, l, d, m, h, b, y, g, w, v);
  }
  roundClean() {
    Ps.fill(0), Us.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const i7 = /* @__PURE__ */ wg(() => new a7());
function o7() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const zw = o7(), Vw = zw.crypto || zw.msCrypto;
function c7(t) {
  switch (t) {
    case "sha256":
      return oA.create();
    case "sha512":
      return i7.create();
  }
  S(!1, "invalid hashing algorithm name", "algorithm", t);
}
function l7(t) {
  j(Vw != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  }), S(Number.isInteger(t) && t > 0 && t <= 1024, "invalid length", "length", t);
  const e = new Uint8Array(t);
  return Vw.getRandomValues(e), e;
}
const [hA, mA, yA] = [[], [], []], u7 = /* @__PURE__ */ BigInt(0), ul = /* @__PURE__ */ BigInt(1), d7 = /* @__PURE__ */ BigInt(2), f7 = /* @__PURE__ */ BigInt(7), p7 = /* @__PURE__ */ BigInt(256), h7 = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = ul, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], hA.push(2 * (5 * r + n)), mA.push((t + 1) * (t + 2) / 2 % 64);
  let s = u7;
  for (let a = 0; a < 7; a++)
    e = (e << ul ^ (e >> f7) * h7) % p7, e & d7 && (s ^= ul << (ul << /* @__PURE__ */ BigInt(a)) - ul);
  yA.push(s);
}
const [m7, y7] = /* @__PURE__ */ lA(yA, !0), jw = (t, e, n) => n > 32 ? fA(t, e, n) : uA(t, e, n), qw = (t, e, n) => n > 32 ? pA(t, e, n) : dA(t, e, n);
function b7(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = jw(u, l, 1) ^ n[o], m = qw(u, l, 1) ^ n[o + 1];
      for (let h = 0; h < 50; h += 10)
        t[i + h] ^= d, t[i + h + 1] ^= m;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = mA[i], c = jw(s, a, o), u = qw(s, a, o), l = hA[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= m7[r], t[1] ^= y7[r];
  }
  n.fill(0);
}
let g7 = class bA extends gg {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Lf(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = PS(this.state);
  }
  keccak() {
    b7(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Pc(this);
    const { blockLen: n, state: r } = this;
    e = Pp(e);
    const s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Pc(this, !1), bg(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Lf(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (nA(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new bA(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
};
const w7 = (t, e, n) => wg(() => new g7(e, t, n)), E7 = /* @__PURE__ */ w7(1, 136, 256 / 8);
let gA = !1;
const wA = function(t) {
  return E7(t);
};
let EA = wA;
function ke(t) {
  const e = J(t, "data");
  return G(EA(e));
}
ke._ = wA;
ke.lock = function() {
  gA = !0;
};
ke.register = function(t) {
  if (gA)
    throw new TypeError("keccak256 is locked");
  EA = t;
};
Object.freeze(ke);
let xA = !1;
const AA = function(t) {
  return new Uint8Array(l7(t));
};
let kA = AA;
function Aa(t) {
  return kA(t);
}
Aa._ = AA;
Aa.lock = function() {
  xA = !0;
};
Aa.register = function(t) {
  if (xA)
    throw new Error("randomBytes is locked");
  kA = t;
};
Object.freeze(Aa);
const vA = function(t) {
  return c7("sha256").update(t).digest();
};
let CA = vA, TA = !1;
function Wc(t) {
  const e = J(t, "data");
  return G(CA(e));
}
Wc._ = vA;
Wc.lock = function() {
  TA = !0;
};
Wc.register = function(t) {
  if (TA)
    throw new Error("sha256 is locked");
  CA = t;
};
Object.freeze(Wc);
Object.freeze(Wc);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const SA = BigInt(0), Up = BigInt(1), x7 = BigInt(2), Np = (t) => t instanceof Uint8Array, A7 = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Uc(t) {
  if (!Np(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += A7[t[n]];
  return e;
}
function OA(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function Eg(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function Nc(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(e / 2);
  for (let r = 0; r < n.length; r++) {
    const s = r * 2, a = t.slice(s, s + 2), i = Number.parseInt(a, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    n[r] = i;
  }
  return n;
}
function Ti(t) {
  return Eg(Uc(t));
}
function xg(t) {
  if (!Np(t))
    throw new Error("Uint8Array expected");
  return Eg(Uc(Uint8Array.from(t).reverse()));
}
function Rc(t, e) {
  return Nc(t.toString(16).padStart(e * 2, "0"));
}
function Ag(t, e) {
  return Rc(t, e).reverse();
}
function k7(t) {
  return Nc(OA(t));
}
function qn(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = Nc(e);
    } catch (a) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${a}`);
    }
  else if (Np(e))
    r = Uint8Array.from(e);
  else
    throw new Error(`${t} must be hex string or Uint8Array`);
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(`${t} expected ${n} bytes, got ${s}`);
  return r;
}
function su(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!Np(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
function v7(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function C7(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function T7(t) {
  let e;
  for (e = 0; t > SA; t >>= Up, e += 1)
    ;
  return e;
}
function S7(t, e) {
  return t >> BigInt(e) & Up;
}
const O7 = (t, e, n) => t | (n ? Up : SA) << BigInt(e), kg = (t) => (x7 << BigInt(t - 1)) - Up, Xh = (t) => new Uint8Array(t), Kw = (t) => Uint8Array.from(t);
function BA(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = Xh(t), s = Xh(t), a = 0;
  const i = () => {
    r.fill(1), s.fill(0), a = 0;
  }, o = (...d) => n(s, r, ...d), c = (d = Xh()) => {
    s = o(Kw([0]), d), r = o(), d.length !== 0 && (s = o(Kw([1]), d), r = o());
  }, u = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const m = [];
    for (; d < e; ) {
      r = o();
      const h = r.slice();
      m.push(h), d += r.length;
    }
    return su(...m);
  };
  return (d, m) => {
    i(), c(d);
    let h;
    for (; !(h = m(u())); )
      c();
    return i(), h;
  };
}
const B7 = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  stringOrUint8Array: (t) => typeof t == "string" || t instanceof Uint8Array,
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function Yu(t, e, n = {}) {
  const r = (s, a, i) => {
    const o = B7[a];
    if (typeof o != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const c = t[s];
    if (!(i && c === void 0) && !o(c, t))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${a}`);
  };
  for (const [s, a] of Object.entries(e))
    r(s, a, !1);
  for (const [s, a] of Object.entries(n))
    r(s, a, !0);
  return t;
}
const I7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: S7,
  bitLen: T7,
  bitMask: kg,
  bitSet: O7,
  bytesToHex: Uc,
  bytesToNumberBE: Ti,
  bytesToNumberLE: xg,
  concatBytes: su,
  createHmacDrbg: BA,
  ensureBytes: qn,
  equalBytes: v7,
  hexToBytes: Nc,
  hexToNumber: Eg,
  numberToBytesBE: Rc,
  numberToBytesLE: Ag,
  numberToHexUnpadded: OA,
  numberToVarBytesBE: k7,
  utf8ToBytes: C7,
  validateObject: Yu
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lt = BigInt(0), Je = BigInt(1), Na = BigInt(2), P7 = BigInt(3), g0 = BigInt(4), Ww = BigInt(5), Qw = BigInt(8);
BigInt(9);
BigInt(16);
function Zt(t, e) {
  const n = t % e;
  return n >= lt ? n : e + n;
}
function U7(t, e, n) {
  if (n <= lt || e < lt)
    throw new Error("Expected power/modulo > 0");
  if (n === Je)
    return lt;
  let r = Je;
  for (; e > lt; )
    e & Je && (r = r * t % n), t = t * t % n, e >>= Je;
  return r;
}
function En(t, e, n) {
  let r = t;
  for (; e-- > lt; )
    r *= r, r %= n;
  return r;
}
function w0(t, e) {
  if (t === lt || e <= lt)
    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
  let n = Zt(t, e), r = e, s = lt, a = Je;
  for (; n !== lt; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== Je)
    throw new Error("invert: does not exist");
  return Zt(s, e);
}
function N7(t) {
  const e = (t - Je) / Na;
  let n, r, s;
  for (n = t - Je, r = 0; n % Na === lt; n /= Na, r++)
    ;
  for (s = Na; s < t && U7(s, e, t) !== t - Je; s++)
    ;
  if (r === 1) {
    const i = (t + Je) / g0;
    return function(c, u) {
      const l = c.pow(u, i);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (n + Je) / Na;
  return function(o, c) {
    if (o.pow(c, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let u = r, l = o.pow(o.mul(o.ONE, s), n), d = o.pow(c, a), m = o.pow(c, n);
    for (; !o.eql(m, o.ONE); ) {
      if (o.eql(m, o.ZERO))
        return o.ZERO;
      let h = 1;
      for (let y = o.sqr(m); h < u && !o.eql(y, o.ONE); h++)
        y = o.sqr(y);
      const b = o.pow(l, Je << BigInt(u - h - 1));
      l = o.sqr(b), d = o.mul(d, b), m = o.mul(m, l), u = h;
    }
    return d;
  };
}
function R7(t) {
  if (t % g0 === P7) {
    const e = (t + Je) / g0;
    return function(r, s) {
      const a = r.pow(s, e);
      if (!r.eql(r.sqr(a), s))
        throw new Error("Cannot find square root");
      return a;
    };
  }
  if (t % Qw === Ww) {
    const e = (t - Ww) / Qw;
    return function(r, s) {
      const a = r.mul(s, Na), i = r.pow(a, e), o = r.mul(s, i), c = r.mul(r.mul(o, Na), i), u = r.mul(o, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return N7(t);
}
const F7 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function D7(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = F7.reduce((r, s) => (r[s] = "function", r), e);
  return Yu(t, n);
}
function M7(t, e, n) {
  if (n < lt)
    throw new Error("Expected power > 0");
  if (n === lt)
    return t.ONE;
  if (n === Je)
    return e;
  let r = t.ONE, s = e;
  for (; n > lt; )
    n & Je && (r = t.mul(r, s)), s = t.sqr(s), n >>= Je;
  return r;
}
function L7(t, e) {
  const n = new Array(e.length), r = e.reduce((a, i, o) => t.is0(i) ? a : (n[o] = a, t.mul(a, i)), t.ONE), s = t.inv(r);
  return e.reduceRight((a, i, o) => t.is0(i) ? a : (n[o] = t.mul(a, n[o]), t.mul(a, i)), s), n;
}
function IA(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function H7(t, e, n = !1, r = {}) {
  if (t <= lt)
    throw new Error(`Expected Field ORDER > 0, got ${t}`);
  const { nBitLength: s, nByteLength: a } = IA(t, e);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = R7(t), o = Object.freeze({
    ORDER: t,
    BITS: s,
    BYTES: a,
    MASK: kg(s),
    ZERO: lt,
    ONE: Je,
    create: (c) => Zt(c, t),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return lt <= c && c < t;
    },
    is0: (c) => c === lt,
    isOdd: (c) => (c & Je) === Je,
    neg: (c) => Zt(-c, t),
    eql: (c, u) => c === u,
    sqr: (c) => Zt(c * c, t),
    add: (c, u) => Zt(c + u, t),
    sub: (c, u) => Zt(c - u, t),
    mul: (c, u) => Zt(c * u, t),
    pow: (c, u) => M7(o, c, u),
    div: (c, u) => Zt(c * w0(u, t), t),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => w0(c, t),
    sqrt: r.sqrt || ((c) => i(o, c)),
    invertBatch: (c) => L7(o, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => n ? Ag(c, a) : Rc(c, a),
    fromBytes: (c) => {
      if (c.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${c.length}`);
      return n ? xg(c) : Ti(c);
    }
  });
  return Object.freeze(o);
}
function PA(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function UA(t) {
  const e = PA(t);
  return e + Math.ceil(e / 2);
}
function $7(t, e, n = !1) {
  const r = t.length, s = PA(e), a = UA(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error(`expected ${a}-1024 bytes of input, got ${r}`);
  const i = n ? Ti(t) : xg(t), o = Zt(i, e - Je) + Je;
  return n ? Ag(o, s) : Rc(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _7 = BigInt(0), Yh = BigInt(1);
function G7(t, e) {
  const n = (s, a) => {
    const i = a.negate();
    return s ? i : a;
  }, r = (s) => {
    const a = Math.ceil(e / s) + 1, i = 2 ** (s - 1);
    return { windows: a, windowSize: i };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(s, a) {
      let i = t.ZERO, o = s;
      for (; a > _7; )
        a & Yh && (i = i.add(o)), o = o.double(), a >>= Yh;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, a) {
      const { windows: i, windowSize: o } = r(a), c = [];
      let u = s, l = u;
      for (let d = 0; d < i; d++) {
        l = u, c.push(l);
        for (let m = 1; m < o; m++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, a, i) {
      const { windows: o, windowSize: c } = r(s);
      let u = t.ZERO, l = t.BASE;
      const d = BigInt(2 ** s - 1), m = 2 ** s, h = BigInt(s);
      for (let b = 0; b < o; b++) {
        const y = b * c;
        let g = Number(i & d);
        i >>= h, g > c && (g -= m, i += Yh);
        const w = y, v = y + Math.abs(g) - 1, A = b % 2 !== 0, B = g < 0;
        g === 0 ? l = l.add(n(A, a[w])) : u = u.add(n(B, a[v]));
      }
      return { p: u, f: l };
    },
    wNAFCached(s, a, i, o) {
      const c = s._WINDOW_SIZE || 1;
      let u = a.get(s);
      return u || (u = this.precomputeWindow(s, c), c !== 1 && a.set(s, o(u))), this.wNAF(c, u, i);
    }
  };
}
function NA(t) {
  return D7(t.Fp), Yu(t, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...IA(t.n, t.nBitLength),
    ...t,
    p: t.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function z7(t) {
  const e = NA(t);
  Yu(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: s } = e;
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: V7, hexToBytes: j7 } = I7, La = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(t) {
    const { Err: e } = La;
    if (t.length < 2 || t[0] !== 2)
      throw new e("Invalid signature integer tag");
    const n = t[1], r = t.subarray(2, n + 2);
    if (!n || r.length !== n)
      throw new e("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: V7(r), l: t.subarray(n + 2) };
  },
  toSig(t) {
    const { Err: e } = La, n = typeof t == "string" ? j7(t) : t;
    if (!(n instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = n.length;
    if (r < 2 || n[0] != 48)
      throw new e("Invalid signature tag");
    if (n[1] !== r - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: s, l: a } = La._parseInt(n.subarray(2)), { d: i, l: o } = La._parseInt(a);
    if (o.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: s, s: i };
  },
  hexFromSig(t) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, n = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, r = e(n(t.s)), s = e(n(t.r)), a = r.length / 2, i = s.length / 2, o = n(a), c = n(i);
    return `30${n(i + a + 4)}02${c}${s}02${o}${r}`;
  }
}, ds = BigInt(0), Rn = BigInt(1);
BigInt(2);
const Jw = BigInt(3);
BigInt(4);
function q7(t) {
  const e = z7(t), { Fp: n } = e, r = e.toBytes || ((b, y, g) => {
    const w = y.toAffine();
    return su(Uint8Array.from([4]), n.toBytes(w.x), n.toBytes(w.y));
  }), s = e.fromBytes || ((b) => {
    const y = b.subarray(1), g = n.fromBytes(y.subarray(0, n.BYTES)), w = n.fromBytes(y.subarray(n.BYTES, 2 * n.BYTES));
    return { x: g, y: w };
  });
  function a(b) {
    const { a: y, b: g } = e, w = n.sqr(b), v = n.mul(w, b);
    return n.add(n.add(v, n.mul(b, y)), g);
  }
  if (!n.eql(n.sqr(e.Gy), a(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function i(b) {
    return typeof b == "bigint" && ds < b && b < e.n;
  }
  function o(b) {
    if (!i(b))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(b) {
    const { allowedPrivateKeyLengths: y, nByteLength: g, wrapPrivateKey: w, n: v } = e;
    if (y && typeof b != "bigint") {
      if (b instanceof Uint8Array && (b = Uc(b)), typeof b != "string" || !y.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(g * 2, "0");
    }
    let A;
    try {
      A = typeof b == "bigint" ? b : Ti(qn("private key", b, g));
    } catch {
      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof b}`);
    }
    return w && (A = Zt(A, v)), o(A), A;
  }
  const u = /* @__PURE__ */ new Map();
  function l(b) {
    if (!(b instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(y, g, w) {
      if (this.px = y, this.py = g, this.pz = w, y == null || !n.isValid(y))
        throw new Error("x required");
      if (g == null || !n.isValid(g))
        throw new Error("y required");
      if (w == null || !n.isValid(w))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(y) {
      const { x: g, y: w } = y || {};
      if (!y || !n.isValid(g) || !n.isValid(w))
        throw new Error("invalid affine point");
      if (y instanceof d)
        throw new Error("projective point not allowed");
      const v = (A) => n.eql(A, n.ZERO);
      return v(g) && v(w) ? d.ZERO : new d(g, w, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(y) {
      const g = n.invertBatch(y.map((w) => w.pz));
      return y.map((w, v) => w.toAffine(g[v])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(y) {
      const g = d.fromAffine(s(qn("pointHex", y)));
      return g.assertValidity(), g;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(y) {
      return d.BASE.multiply(c(y));
    }
    // "Private method", don't use it directly
    _setWindowSize(y) {
      this._WINDOW_SIZE = y, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !n.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: y, y: g } = this.toAffine();
      if (!n.isValid(y) || !n.isValid(g))
        throw new Error("bad point: x or y not FE");
      const w = n.sqr(g), v = a(y);
      if (!n.eql(w, v))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(y) {
      l(y);
      const { px: g, py: w, pz: v } = this, { px: A, py: B, pz: x } = y, N = n.eql(n.mul(g, x), n.mul(A, v)), I = n.eql(n.mul(w, x), n.mul(B, v));
      return N && I;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: y, b: g } = e, w = n.mul(g, Jw), { px: v, py: A, pz: B } = this;
      let x = n.ZERO, N = n.ZERO, I = n.ZERO, O = n.mul(v, v), C = n.mul(A, A), U = n.mul(B, B), P = n.mul(v, A);
      return P = n.add(P, P), I = n.mul(v, B), I = n.add(I, I), x = n.mul(y, I), N = n.mul(w, U), N = n.add(x, N), x = n.sub(C, N), N = n.add(C, N), N = n.mul(x, N), x = n.mul(P, x), I = n.mul(w, I), U = n.mul(y, U), P = n.sub(O, U), P = n.mul(y, P), P = n.add(P, I), I = n.add(O, O), O = n.add(I, O), O = n.add(O, U), O = n.mul(O, P), N = n.add(N, O), U = n.mul(A, B), U = n.add(U, U), O = n.mul(U, P), x = n.sub(x, O), I = n.mul(U, C), I = n.add(I, I), I = n.add(I, I), new d(x, N, I);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(y) {
      l(y);
      const { px: g, py: w, pz: v } = this, { px: A, py: B, pz: x } = y;
      let N = n.ZERO, I = n.ZERO, O = n.ZERO;
      const C = e.a, U = n.mul(e.b, Jw);
      let P = n.mul(g, A), D = n.mul(w, B), $ = n.mul(v, x), K = n.add(g, w), F = n.add(A, B);
      K = n.mul(K, F), F = n.add(P, D), K = n.sub(K, F), F = n.add(g, v);
      let M = n.add(A, x);
      return F = n.mul(F, M), M = n.add(P, $), F = n.sub(F, M), M = n.add(w, v), N = n.add(B, x), M = n.mul(M, N), N = n.add(D, $), M = n.sub(M, N), O = n.mul(C, F), N = n.mul(U, $), O = n.add(N, O), N = n.sub(D, O), O = n.add(D, O), I = n.mul(N, O), D = n.add(P, P), D = n.add(D, P), $ = n.mul(C, $), F = n.mul(U, F), D = n.add(D, $), $ = n.sub(P, $), $ = n.mul(C, $), F = n.add(F, $), P = n.mul(D, F), I = n.add(I, P), P = n.mul(M, F), N = n.mul(K, N), N = n.sub(N, P), P = n.mul(K, D), O = n.mul(M, O), O = n.add(O, P), new d(N, I, O);
    }
    subtract(y) {
      return this.add(y.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(y) {
      return h.wNAFCached(this, u, y, (g) => {
        const w = n.invertBatch(g.map((v) => v.pz));
        return g.map((v, A) => v.toAffine(w[A])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(y) {
      const g = d.ZERO;
      if (y === ds)
        return g;
      if (o(y), y === Rn)
        return this;
      const { endo: w } = e;
      if (!w)
        return h.unsafeLadder(this, y);
      let { k1neg: v, k1: A, k2neg: B, k2: x } = w.splitScalar(y), N = g, I = g, O = this;
      for (; A > ds || x > ds; )
        A & Rn && (N = N.add(O)), x & Rn && (I = I.add(O)), O = O.double(), A >>= Rn, x >>= Rn;
      return v && (N = N.negate()), B && (I = I.negate()), I = new d(n.mul(I.px, w.beta), I.py, I.pz), N.add(I);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(y) {
      o(y);
      let g = y, w, v;
      const { endo: A } = e;
      if (A) {
        const { k1neg: B, k1: x, k2neg: N, k2: I } = A.splitScalar(g);
        let { p: O, f: C } = this.wNAF(x), { p: U, f: P } = this.wNAF(I);
        O = h.constTimeNegate(B, O), U = h.constTimeNegate(N, U), U = new d(n.mul(U.px, A.beta), U.py, U.pz), w = O.add(U), v = C.add(P);
      } else {
        const { p: B, f: x } = this.wNAF(g);
        w = B, v = x;
      }
      return d.normalizeZ([w, v])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(y, g, w) {
      const v = d.BASE, A = (x, N) => N === ds || N === Rn || !x.equals(v) ? x.multiplyUnsafe(N) : x.multiply(N), B = A(this, g).add(A(y, w));
      return B.is0() ? void 0 : B;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(y) {
      const { px: g, py: w, pz: v } = this, A = this.is0();
      y == null && (y = A ? n.ONE : n.inv(v));
      const B = n.mul(g, y), x = n.mul(w, y), N = n.mul(v, y);
      if (A)
        return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(N, n.ONE))
        throw new Error("invZ was invalid");
      return { x: B, y: x };
    }
    isTorsionFree() {
      const { h: y, isTorsionFree: g } = e;
      if (y === Rn)
        return !0;
      if (g)
        return g(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: y, clearCofactor: g } = e;
      return y === Rn ? this : g ? g(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(y = !0) {
      return this.assertValidity(), r(d, this, y);
    }
    toHex(y = !0) {
      return Uc(this.toRawBytes(y));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
  const m = e.nBitLength, h = G7(d, e.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: a,
    isWithinCurveOrder: i
  };
}
function K7(t) {
  const e = NA(t);
  return Yu(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function W7(t) {
  const e = K7(t), { Fp: n, n: r } = e, s = n.BYTES + 1, a = 2 * n.BYTES + 1;
  function i(F) {
    return ds < F && F < n.ORDER;
  }
  function o(F) {
    return Zt(F, r);
  }
  function c(F) {
    return w0(F, r);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: d, isWithinCurveOrder: m } = q7({
    ...e,
    toBytes(F, M, V) {
      const z = M.toAffine(), X = n.toBytes(z.x), Y = su;
      return V ? Y(Uint8Array.from([M.hasEvenY() ? 2 : 3]), X) : Y(Uint8Array.from([4]), X, n.toBytes(z.y));
    },
    fromBytes(F) {
      const M = F.length, V = F[0], z = F.subarray(1);
      if (M === s && (V === 2 || V === 3)) {
        const X = Ti(z);
        if (!i(X))
          throw new Error("Point is not on curve");
        const Y = d(X);
        let Q = n.sqrt(Y);
        const le = (Q & Rn) === Rn;
        return (V & 1) === 1 !== le && (Q = n.neg(Q)), { x: X, y: Q };
      } else if (M === a && V === 4) {
        const X = n.fromBytes(z.subarray(0, n.BYTES)), Y = n.fromBytes(z.subarray(n.BYTES, 2 * n.BYTES));
        return { x: X, y: Y };
      } else
        throw new Error(`Point of length ${M} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`);
    }
  }), h = (F) => Uc(Rc(F, e.nByteLength));
  function b(F) {
    const M = r >> Rn;
    return F > M;
  }
  function y(F) {
    return b(F) ? o(-F) : F;
  }
  const g = (F, M, V) => Ti(F.slice(M, V));
  class w {
    constructor(M, V, z) {
      this.r = M, this.s = V, this.recovery = z, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(M) {
      const V = e.nByteLength;
      return M = qn("compactSignature", M, V * 2), new w(g(M, 0, V), g(M, V, 2 * V));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(M) {
      const { r: V, s: z } = La.toSig(qn("DER", M));
      return new w(V, z);
    }
    assertValidity() {
      if (!m(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!m(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(M) {
      return new w(this.r, this.s, M);
    }
    recoverPublicKey(M) {
      const { r: V, s: z, recovery: X } = this, Y = I(qn("msgHash", M));
      if (X == null || ![0, 1, 2, 3].includes(X))
        throw new Error("recovery id invalid");
      const Q = X === 2 || X === 3 ? V + e.n : V;
      if (Q >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const le = X & 1 ? "03" : "02", Z = u.fromHex(le + h(Q)), ce = c(Q), te = o(-Y * ce), ie = o(z * ce), fe = u.BASE.multiplyAndAddUnsafe(Z, te, ie);
      if (!fe)
        throw new Error("point at infinify");
      return fe.assertValidity(), fe;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return b(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new w(this.r, o(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Nc(this.toDERHex());
    }
    toDERHex() {
      return La.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Nc(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const v = {
    isValidPrivateKey(F) {
      try {
        return l(F), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const F = UA(e.n);
      return $7(e.randomBytes(F), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(F = 8, M = u.BASE) {
      return M._setWindowSize(F), M.multiply(BigInt(3)), M;
    }
  };
  function A(F, M = !0) {
    return u.fromPrivateKey(F).toRawBytes(M);
  }
  function B(F) {
    const M = F instanceof Uint8Array, V = typeof F == "string", z = (M || V) && F.length;
    return M ? z === s || z === a : V ? z === 2 * s || z === 2 * a : F instanceof u;
  }
  function x(F, M, V = !0) {
    if (B(F))
      throw new Error("first arg must be private key");
    if (!B(M))
      throw new Error("second arg must be public key");
    return u.fromHex(M).multiply(l(F)).toRawBytes(V);
  }
  const N = e.bits2int || function(F) {
    const M = Ti(F), V = F.length * 8 - e.nBitLength;
    return V > 0 ? M >> BigInt(V) : M;
  }, I = e.bits2int_modN || function(F) {
    return o(N(F));
  }, O = kg(e.nBitLength);
  function C(F) {
    if (typeof F != "bigint")
      throw new Error("bigint expected");
    if (!(ds <= F && F < O))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return Rc(F, e.nByteLength);
  }
  function U(F, M, V = P) {
    if (["recovered", "canonical"].some((Ae) => Ae in V))
      throw new Error("sign() legacy options not supported");
    const { hash: z, randomBytes: X } = e;
    let { lowS: Y, prehash: Q, extraEntropy: le } = V;
    Y == null && (Y = !0), F = qn("msgHash", F), Q && (F = qn("prehashed msgHash", z(F)));
    const Z = I(F), ce = l(M), te = [C(ce), C(Z)];
    if (le != null) {
      const Ae = le === !0 ? X(n.BYTES) : le;
      te.push(qn("extraEntropy", Ae));
    }
    const ie = su(...te), fe = Z;
    function he(Ae) {
      const $e = N(Ae);
      if (!m($e))
        return;
      const tt = c($e), Nt = u.BASE.multiply($e).toAffine(), _e = o(Nt.x);
      if (_e === ds)
        return;
      const wn = o(tt * o(fe + _e * ce));
      if (wn === ds)
        return;
      let ol = (Nt.x === _e ? 0 : 2) | Number(Nt.y & Rn), wd = wn;
      return Y && b(wn) && (wd = y(wn), ol ^= 1), new w(_e, wd, ol);
    }
    return { seed: ie, k2sig: he };
  }
  const P = { lowS: e.lowS, prehash: !1 }, D = { lowS: e.lowS, prehash: !1 };
  function $(F, M, V = P) {
    const { seed: z, k2sig: X } = U(F, M, V), Y = e;
    return BA(Y.hash.outputLen, Y.nByteLength, Y.hmac)(z, X);
  }
  u.BASE._setWindowSize(8);
  function K(F, M, V, z = D) {
    var Nt;
    const X = F;
    if (M = qn("msgHash", M), V = qn("publicKey", V), "strict" in z)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Y, prehash: Q } = z;
    let le, Z;
    try {
      if (typeof X == "string" || X instanceof Uint8Array)
        try {
          le = w.fromDER(X);
        } catch (_e) {
          if (!(_e instanceof La.Err))
            throw _e;
          le = w.fromCompact(X);
        }
      else if (typeof X == "object" && typeof X.r == "bigint" && typeof X.s == "bigint") {
        const { r: _e, s: wn } = X;
        le = new w(_e, wn);
      } else
        throw new Error("PARSE");
      Z = u.fromHex(V);
    } catch (_e) {
      if (_e.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Y && le.hasHighS())
      return !1;
    Q && (M = e.hash(M));
    const { r: ce, s: te } = le, ie = I(M), fe = c(te), he = o(ie * fe), Ae = o(ce * fe), $e = (Nt = u.BASE.multiplyAndAddUnsafe(Z, he, Ae)) == null ? void 0 : Nt.toAffine();
    return $e ? o($e.x) === ce : !1;
  }
  return {
    CURVE: e,
    getPublicKey: A,
    getSharedSecret: x,
    sign: $,
    verify: K,
    ProjectivePoint: u,
    Signature: w,
    utils: v
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Q7(t) {
  return {
    hash: t,
    hmac: (e, ...n) => aA(t, e, RS(...n)),
    randomBytes: FS
  };
}
function J7(t, e) {
  const n = (r) => W7({ ...t, ...Q7(r) });
  return Object.freeze({ ...n(e), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const RA = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Zw = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Z7 = BigInt(1), E0 = BigInt(2), Xw = (t, e) => (t + e / E0) / e;
function X7(t) {
  const e = RA, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = En(l, n, e) * l % e, m = En(d, n, e) * l % e, h = En(m, E0, e) * u % e, b = En(h, s, e) * h % e, y = En(b, a, e) * b % e, g = En(y, o, e) * y % e, w = En(g, c, e) * g % e, v = En(w, o, e) * y % e, A = En(v, n, e) * l % e, B = En(A, i, e) * b % e, x = En(B, r, e) * u % e, N = En(x, E0, e);
  if (!x0.eql(x0.sqr(N), t))
    throw new Error("Cannot find square root");
  return N;
}
const x0 = H7(RA, void 0, void 0, { sqrt: X7 }), Ds = J7({
  a: BigInt(0),
  b: BigInt(7),
  Fp: x0,
  n: Zw,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = Zw, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -Z7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = Xw(a * t, e), c = Xw(-r * t, e);
      let u = Zt(t - o * n - c * s, e), l = Zt(-o * r - c * a, e);
      const d = u > i, m = l > i;
      if (d && (u = e - u), m && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: m, k2: l };
    }
  }
}, oA);
BigInt(0);
Ds.ProjectivePoint;
const ka = "0x0000000000000000000000000000000000000000", Hf = "0x0000000000000000000000000000000000000000000000000000000000000000", FA = `Ethereum Signed Message:
`, Yw = BigInt(0), eE = BigInt(1), tE = BigInt(2), nE = BigInt(27), rE = BigInt(28), Cd = BigInt(35), ro = {};
function sE(t) {
  return hn(rt(t), 32);
}
var Yo, vr, ec, pi;
const jn = class jn {
  /**
   *  @private
   */
  constructor(e, n, r, s) {
    T(this, Yo);
    T(this, vr);
    T(this, ec);
    T(this, pi);
    Op(e, ro, "Signature"), E(this, Yo, n), E(this, vr, r), E(this, ec, s), E(this, pi, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return p(this, Yo);
  }
  set r(e) {
    S(Ci(e) === 32, "invalid r", "value", e), E(this, Yo, G(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return S(parseInt(p(this, vr).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", p(this, vr)), p(this, vr);
  }
  set s(e) {
    S(Ci(e) === 32, "invalid s", "value", e), E(this, vr, G(e));
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return p(this, vr);
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return parseInt(p(this, vr).substring(0, 3)) < 8;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return p(this, ec);
  }
  set v(e) {
    const n = we(e, "value");
    S(n === 27 || n === 28, "invalid v", "v", e), E(this, ec, n);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return p(this, pi);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : jn.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = J(this.s);
    return this.yParity && (e[0] |= 128), G(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return Le([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return Le([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new jn(ro, this.r, this._s, this.v);
    return this.networkV && E(e, pi, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const n = ne(e, "v");
    return n == nE || n == rE ? Yw : (S(n >= Cd, "invalid EIP-155 v", "v", e), (n - Cd) / tE);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, n) {
    return ne(e) * tE + BigInt(35 + n - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const n = ne(e);
    return n === Yw || n === nE ? 27 : n === eE || n === rE ? 28 : (S(n >= Cd, "invalid v", "v", e), n & eE ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function n(u, l) {
      S(u, l, "signature", e);
    }
    if (e == null)
      return new jn(ro, Hf, Hf, 27);
    if (typeof e == "string") {
      const u = J(e, "signature");
      if (u.length === 64) {
        const l = G(u.slice(0, 32)), d = u.slice(32, 64), m = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new jn(ro, l, G(d), m);
      }
      if (u.length === 65) {
        const l = G(u.slice(0, 32)), d = G(u.slice(32, 64)), m = jn.getNormalizedV(u[64]);
        return new jn(ro, l, d, m);
      }
      n(!1, "invalid raw signature length");
    }
    if (e instanceof jn)
      return e.clone();
    const r = e.r;
    n(r != null, "missing r");
    const s = sE(r), a = function(u, l) {
      if (u != null)
        return sE(u);
      if (l != null) {
        n(Ue(l, 32), "invalid yParityAndS");
        const d = J(l);
        return d[0] &= 127, G(d);
      }
      n(!1, "missing s");
    }(e.s, e.yParityAndS), { networkV: i, v: o } = function(u, l, d) {
      if (u != null) {
        const m = ne(u);
        return {
          networkV: m >= Cd ? m : void 0,
          v: jn.getNormalizedV(m)
        };
      }
      if (l != null)
        return n(Ue(l, 32), "invalid yParityAndS"), { v: J(l)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (we(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        n(!1, "invalid yParity");
      }
      n(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), c = new jn(ro, s, a, o);
    return i && E(c, pi, i), n(e.yParity == null || we(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
Yo = new WeakMap(), vr = new WeakMap(), ec = new WeakMap(), pi = new WeakMap();
let tn = jn;
var rs;
const Da = class Da {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    T(this, rs);
    S(Ci(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), E(this, rs, G(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return p(this, rs);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Da.computePublicKey(p(this, rs));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Da.computePublicKey(p(this, rs), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    S(Ci(e) === 32, "invalid digest length", "digest", e);
    const n = Ds.sign(Gt(e), Gt(p(this, rs)), {
      lowS: !0
    });
    return tn.from({
      r: sr(n.r, 32),
      s: sr(n.s, 32),
      v: n.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const n = Da.computePublicKey(e);
    return G(Ds.getSharedSecret(Gt(p(this, rs)), J(n), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, n) {
    let r = J(e, "key");
    if (r.length === 32) {
      const a = Ds.getPublicKey(r, !!n);
      return G(a);
    }
    if (r.length === 64) {
      const a = new Uint8Array(65);
      a[0] = 4, a.set(r, 1), r = a;
    }
    const s = Ds.ProjectivePoint.fromHex(r);
    return G(s.toRawBytes(n));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, n) {
    S(Ci(e) === 32, "invalid digest length", "digest", e);
    const r = tn.from(n);
    let s = Ds.Signature.fromCompact(Gt(Le([r.r, r.s])));
    s = s.addRecoveryBit(r.yParity);
    const a = s.recoverPublicKey(Gt(e));
    return S(a != null, "invalid signature for digest", "signature", n), "0x" + a.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, n, r) {
    const s = Ds.ProjectivePoint.fromHex(Da.computePublicKey(e).substring(2)), a = Ds.ProjectivePoint.fromHex(Da.computePublicKey(n).substring(2));
    return "0x" + s.add(a).toHex(!!r);
  }
};
rs = new WeakMap();
let au = Da;
const Y7 = BigInt(0), eO = BigInt(36);
function aE(t) {
  t = t.toLowerCase();
  const e = t.substring(2).split(""), n = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    n[s] = e[s].charCodeAt(0);
  const r = J(ke(n));
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
  return "0x" + e.join("");
}
const vg = {};
for (let t = 0; t < 10; t++)
  vg[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  vg[String.fromCharCode(65 + t)] = String(10 + t);
const iE = 15;
function tO(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((r) => vg[r]).join("");
  for (; e.length >= iE; ) {
    let r = e.substring(0, iE);
    e = parseInt(r, 10) % 97 + e.substring(r.length);
  }
  let n = String(98 - parseInt(e, 10) % 97);
  for (; n.length < 2; )
    n = "0" + n;
  return n;
}
const nO = function() {
  const t = {};
  for (let e = 0; e < 36; e++) {
    const n = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    t[n] = BigInt(e);
  }
  return t;
}();
function rO(t) {
  t = t.toLowerCase();
  let e = Y7;
  for (let n = 0; n < t.length; n++)
    e = e * eO + nO[t[n]];
  return e;
}
function ue(t) {
  if (S(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    t.startsWith("0x") || (t = "0x" + t);
    const e = aE(t);
    return S(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e;
  }
  if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    S(t.substring(2, 4) === tO(t), "bad icap checksum", "address", t);
    let e = rO(t.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return aE("0x" + e);
  }
  S(!1, "invalid address", "address", t);
}
function sO(t) {
  const e = ue(t.from);
  let r = ne(t.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, ue(ze(ke(xa([e, r])), 12));
}
function DA(t) {
  return t && typeof t.getAddress == "function";
}
function oE(t) {
  try {
    return ue(t), !0;
  } catch {
  }
  return !1;
}
async function em(t, e) {
  const n = await e;
  return (n == null || n === "0x0000000000000000000000000000000000000000") && (j(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: t }), S(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), ue(n);
}
function Vt(t, e) {
  if (typeof t == "string")
    return t.match(/^0x[0-9a-f]{40}$/i) ? ue(t) : (j(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), em(t, e.resolveName(t)));
  if (DA(t))
    return em(t, t.getAddress());
  if (t && typeof t.then == "function")
    return em(t, t);
  S(!1, "unsupported addressable value", "target", t);
}
const Wr = {};
function ee(t, e) {
  let n = !1;
  return e < 0 && (n = !0, e *= -1), new Tt(Wr, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e });
}
function Oe(t, e) {
  return new Tt(Wr, `bytes${e || ""}`, t, { size: e });
}
const cE = Symbol.for("_ethers_typed");
var hi;
const Qr = class Qr {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    R(this, "type");
    /**
     *  The actual value.
     */
    R(this, "value");
    T(this, hi);
    /**
     *  @_ignore:
     */
    R(this, "_typedSymbol");
    s == null && (s = null), Op(Wr, e, "Typed"), oe(this, { _typedSymbol: cE, type: n, value: r }), E(this, hi, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return p(this, hi);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return p(this, hi) === !0 ? -1 : p(this, hi) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, n) {
    return new Qr(Wr, e, n);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return ee(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return ee(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return ee(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return ee(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return ee(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return ee(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return ee(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return ee(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return ee(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return ee(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return ee(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return ee(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return ee(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return ee(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return ee(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return ee(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return ee(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return ee(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return ee(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return ee(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return ee(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return ee(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return ee(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return ee(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return ee(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return ee(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return ee(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return ee(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return ee(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return ee(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return ee(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return ee(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return ee(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return ee(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return ee(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return ee(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return ee(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return ee(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return ee(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return ee(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return ee(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return ee(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return ee(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return ee(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return ee(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return ee(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return ee(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return ee(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return ee(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return ee(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return ee(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return ee(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return ee(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return ee(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return ee(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return ee(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return ee(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return ee(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return ee(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return ee(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return ee(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return ee(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return ee(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return ee(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return ee(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return ee(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Oe(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Oe(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Oe(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Oe(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Oe(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Oe(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Oe(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Oe(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Oe(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Oe(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Oe(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Oe(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Oe(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Oe(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Oe(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Oe(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Oe(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Oe(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Oe(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Oe(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Oe(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Oe(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Oe(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Oe(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Oe(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Oe(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Oe(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Oe(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Oe(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Oe(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Oe(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Oe(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new Qr(Wr, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new Qr(Wr, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new Qr(Wr, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new Qr(Wr, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new Qr(Wr, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === cE;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, n) {
    if (Qr.isTyped(e)) {
      if (e.type !== n)
        throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
hi = new WeakMap();
let Tt = Qr;
class aO extends xs {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, n) {
    let r = Tt.dereference(n, "string");
    try {
      r = ue(r);
    } catch (s) {
      return this._throwError(s.message, n);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return ue(sr(e.readValue(), 20));
  }
}
class iO extends xs {
  constructor(n) {
    super(n.name, n.type, "_", n.dynamic);
    R(this, "coder");
    this.coder = n;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(n, r) {
    return this.coder.encode(n, r);
  }
  decode(n) {
    return this.coder.decode(n);
  }
}
function MA(t, e, n) {
  let r = [];
  if (Array.isArray(n))
    r = n;
  else if (n && typeof n == "object") {
    let c = {};
    r = e.map((u) => {
      const l = u.localName;
      return j(l, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), j(!c[l], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), c[l] = !0, n[l];
    });
  } else
    S(!1, "invalid tuple value", "tuple", n);
  S(e.length === r.length, "types/value length mismatch", "tuple", n);
  let s = new h0(), a = new h0(), i = [];
  e.forEach((c, u) => {
    let l = r[u];
    if (c.dynamic) {
      let d = a.length;
      c.encode(a, l);
      let m = s.writeUpdatableValue();
      i.push((h) => {
        m(h + d);
      });
    } else
      c.encode(s, l);
  }), i.forEach((c) => {
    c(s.length);
  });
  let o = t.appendWriter(s);
  return o += t.appendWriter(a), o;
}
function LA(t, e) {
  let n = [], r = [], s = t.subReader(0);
  return e.forEach((a) => {
    let i = null;
    if (a.dynamic) {
      let o = t.readIndex(), c = s.subReader(o);
      try {
        i = a.decode(c);
      } catch (u) {
        if (mt(u, "BUFFER_OVERRUN"))
          throw u;
        i = u, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    } else
      try {
        i = a.decode(t);
      } catch (o) {
        if (mt(o, "BUFFER_OVERRUN"))
          throw o;
        i = o, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    if (i == null)
      throw new Error("investigate");
    n.push(i), r.push(a.localName || null);
  }), Ic.fromItems(n, r);
}
class oO extends xs {
  constructor(n, r, s) {
    const a = n.type + "[" + (r >= 0 ? r : "") + "]", i = r === -1 || n.dynamic;
    super("array", a, s, i);
    R(this, "coder");
    R(this, "length");
    oe(this, { coder: n, length: r });
  }
  defaultValue() {
    const n = this.coder.defaultValue(), r = [];
    for (let s = 0; s < this.length; s++)
      r.push(n);
    return r;
  }
  encode(n, r) {
    const s = Tt.dereference(r, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let a = this.length;
    a === -1 && (a = s.length, n.writeValue(s.length)), G6(s.length, a, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let o = 0; o < s.length; o++)
      i.push(this.coder);
    return MA(n, i, s);
  }
  decode(n) {
    let r = this.length;
    r === -1 && (r = n.readIndex(), j(r * zt <= n.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: n.bytes, offset: r * zt, length: n.dataLength }));
    let s = [];
    for (let a = 0; a < r; a++)
      s.push(new iO(this.coder));
    return LA(n, s);
  }
}
class cO extends xs {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, n) {
    const r = Tt.dereference(n, "bool");
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class HA extends xs {
  constructor(e, n) {
    super(e, e, n, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, n) {
    n = Gt(n);
    let r = e.writeValue(n.length);
    return r += e.writeBytes(n), r;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class lO extends HA {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return G(super.decode(e));
  }
}
class uO extends xs {
  constructor(n, r) {
    let s = "bytes" + String(n);
    super(s, s, r, !1);
    R(this, "size");
    oe(this, { size: n }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(n, r) {
    let s = Gt(Tt.dereference(r, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", r), n.writeBytes(s);
  }
  decode(n) {
    return G(n.readBytes(this.size));
  }
}
const dO = new Uint8Array([]);
class fO extends xs {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, n) {
    return n != null && this._throwError("not null", n), e.writeBytes(dO);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const pO = BigInt(0), hO = BigInt(1), mO = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class yO extends xs {
  constructor(n, r, s) {
    const a = (r ? "int" : "uint") + n * 8;
    super(a, a, s, !1);
    R(this, "size");
    R(this, "signed");
    oe(this, { size: n, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(n, r) {
    let s = ne(Tt.dereference(r, this.type)), a = Il(mO, zt * 8);
    if (this.signed) {
      let i = Il(a, this.size * 8 - 1);
      (s > i || s < -(i + hO)) && this._throwError("value out-of-bounds", r), s = mg(s, 8 * zt);
    } else (s < pO || s > Il(a, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return n.writeValue(s);
  }
  decode(n) {
    let r = Il(n.readValue(), this.size * 8);
    return this.signed && (r = dS(r, this.size * 8)), r;
  }
}
class bO extends HA {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, n) {
    return super.encode(e, en(Tt.dereference(n, "string")));
  }
  decode(e) {
    return Mf(super.decode(e));
  }
}
class Td extends xs {
  constructor(n, r) {
    let s = !1;
    const a = [];
    n.forEach((o) => {
      o.dynamic && (s = !0), a.push(o.type);
    });
    const i = "tuple(" + a.join(",") + ")";
    super("tuple", i, r, s);
    R(this, "coders");
    oe(this, { coders: Object.freeze(n.slice()) });
  }
  defaultValue() {
    const n = [];
    this.coders.forEach((s) => {
      n.push(s.defaultValue());
    });
    const r = this.coders.reduce((s, a) => {
      const i = a.localName;
      return i && (s[i] || (s[i] = 0), s[i]++), s;
    }, {});
    return this.coders.forEach((s, a) => {
      let i = s.localName;
      !i || r[i] !== 1 || (i === "length" && (i = "_length"), n[i] == null && (n[i] = n[a]));
    }), Object.freeze(n);
  }
  encode(n, r) {
    const s = Tt.dereference(r, "tuple");
    return MA(n, this.coders, s);
  }
  decode(n) {
    return LA(n, this.coders);
  }
}
function tm(t, e) {
  return {
    address: ue(t),
    storageKeys: e.map((n, r) => (S(Ue(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
  };
}
function eo(t) {
  if (Array.isArray(t))
    return t.map((n, r) => Array.isArray(n) ? (S(n.length === 2, "invalid slot set", `value[${r}]`, n), tm(n[0], n[1])) : (S(n != null && typeof n == "object", "invalid address-slot set", "value", t), tm(n.address, n.storageKeys)));
  S(t != null && typeof t == "object", "invalid access list", "value", t);
  const e = Object.keys(t).map((n) => {
    const r = t[n].reduce((s, a) => (s[a] = !0, s), {});
    return tm(n, Object.keys(r).sort());
  });
  return e.sort((n, r) => n.address.localeCompare(r.address)), e;
}
function $A(t) {
  return {
    address: ue(t.address),
    nonce: ne(t.nonce != null ? t.nonce : 0),
    chainId: ne(t.chainId != null ? t.chainId : 0),
    signature: tn.from(t.signature)
  };
}
function gO(t) {
  let e;
  return typeof t == "string" ? e = au.computePublicKey(t, !1) : e = t.publicKey, ue(ke("0x" + e.substring(4)).substring(26));
}
function A0(t, e) {
  return gO(au.recoverPublicKey(t, e));
}
const it = BigInt(0), wO = BigInt(2), EO = BigInt(27), xO = BigInt(28), AO = BigInt(35), kO = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), nm = 4096 * 32;
function vO(t) {
  return { blobToKzgCommitment: (r) => {
    if ("computeBlobProof" in t) {
      if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
        return J(t.blobToKzgCommitment(G(r)));
    } else if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
      return J(t.blobToKzgCommitment(r));
    if ("blobToKZGCommitment" in t && typeof t.blobToKZGCommitment == "function")
      return J(t.blobToKZGCommitment(G(r)));
    S(!1, "unsupported KZG library", "kzg", t);
  }, computeBlobKzgProof: (r, s) => {
    if ("computeBlobProof" in t && typeof t.computeBlobProof == "function")
      return J(t.computeBlobProof(G(r), G(s)));
    if ("computeBlobKzgProof" in t && typeof t.computeBlobKzgProof == "function")
      return t.computeBlobKzgProof(r, s);
    if ("computeBlobKZGProof" in t && typeof t.computeBlobKZGProof == "function")
      return J(t.computeBlobKZGProof(G(r), G(s)));
    S(!1, "unsupported KZG library", "kzg", t);
  } };
}
function lE(t, e) {
  let n = t.toString(16);
  for (; n.length < 2; )
    n = "0" + n;
  return n += Wc(e).substring(4), "0x" + n;
}
function Qc(t) {
  return t === "0x" ? null : ue(t);
}
function Rp(t, e) {
  try {
    return eo(t);
  } catch (n) {
    S(!1, n.message, e, t);
  }
}
function CO(t, e) {
  try {
    if (!Array.isArray(t))
      throw new Error("authorizationList: invalid array");
    const n = [];
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (!Array.isArray(s))
        throw new Error(`authorization[${r}]: invalid array`);
      if (s.length !== 6)
        throw new Error(`authorization[${r}]: wrong length`);
      if (!s[1])
        throw new Error(`authorization[${r}]: null address`);
      n.push({
        address: Qc(s[1]),
        nonce: De(s[2], "nonce"),
        chainId: De(s[0], "chainId"),
        signature: tn.from({
          yParity: to(s[3], "yParity"),
          r: hn(s[4], 32),
          s: hn(s[5], 32)
        })
      });
    }
    return n;
  } catch (n) {
    S(!1, n.message, e, t);
  }
}
function to(t, e) {
  return t === "0x" ? 0 : we(t, e);
}
function De(t, e) {
  if (t === "0x")
    return it;
  const n = ne(t, e);
  return S(n <= kO, "value exceeds uint size", e, n), n;
}
function Te(t, e) {
  const n = ne(t, "value"), r = rt(n);
  return S(r.length <= 32, "value too large", `tx.${e}`, n), r;
}
function Fp(t) {
  return eo(t).map((e) => [e.address, e.storageKeys]);
}
function TO(t) {
  return t.map((e) => [
    Te(e.chainId, "chainId"),
    e.address,
    Te(e.nonce, "nonce"),
    Te(e.signature.yParity, "yParity"),
    rt(e.signature.r),
    rt(e.signature.s)
  ]);
}
function SO(t, e) {
  S(Array.isArray(t), `invalid ${e}`, "value", t);
  for (let n = 0; n < t.length; n++)
    S(Ue(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
  return t;
}
function OO(t) {
  const e = Xu(t);
  S(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
  const n = {
    type: 0,
    nonce: to(e[0], "nonce"),
    gasPrice: De(e[1], "gasPrice"),
    gasLimit: De(e[2], "gasLimit"),
    to: Qc(e[3]),
    value: De(e[4], "value"),
    data: G(e[5]),
    chainId: it
  };
  if (e.length === 6)
    return n;
  const r = De(e[6], "v"), s = De(e[7], "r"), a = De(e[8], "s");
  if (s === it && a === it)
    n.chainId = r;
  else {
    let i = (r - AO) / wO;
    i < it && (i = it), n.chainId = i, S(i !== it || r === EO || r === xO, "non-canonical legacy v", "v", e[6]), n.signature = tn.from({
      r: hn(e[7], 32),
      s: hn(e[8], 32),
      v: r
    });
  }
  return n;
}
function BO(t, e) {
  const n = [
    Te(t.nonce, "nonce"),
    Te(t.gasPrice || 0, "gasPrice"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data
  ];
  let r = it;
  if (t.chainId != it)
    r = ne(t.chainId, "tx.chainId"), S(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
  else if (t.signature) {
    const a = t.signature.legacyChainId;
    a != null && (r = a);
  }
  if (!e)
    return r !== it && (n.push(rt(r)), n.push("0x"), n.push("0x")), xa(n);
  let s = BigInt(27 + e.yParity);
  return r !== it ? s = tn.getChainIdV(r, e.v) : BigInt(e.v) !== s && S(!1, "tx.chainId/sig.v mismatch", "sig", e), n.push(rt(s)), n.push(rt(e.r)), n.push(rt(e.s)), xa(n);
}
function Dp(t, e) {
  let n;
  try {
    if (n = to(e[0], "yParity"), n !== 0 && n !== 1)
      throw new Error("bad yParity");
  } catch {
    S(!1, "invalid yParity", "yParity", e[0]);
  }
  const r = hn(e[1], 32), s = hn(e[2], 32), a = tn.from({ r, s, yParity: n });
  t.signature = a;
}
function IO(t) {
  const e = Xu(J(t).slice(1));
  S(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", G(t));
  const n = {
    type: 2,
    chainId: De(e[0], "chainId"),
    nonce: to(e[1], "nonce"),
    maxPriorityFeePerGas: De(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: De(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: De(e[4], "gasLimit"),
    to: Qc(e[5]),
    value: De(e[6], "value"),
    data: G(e[7]),
    accessList: Rp(e[8], "accessList")
  };
  return e.length === 9 || Dp(n, e.slice(9)), n;
}
function PO(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    Fp(t.accessList || [])
  ];
  return e && (n.push(Te(e.yParity, "yParity")), n.push(rt(e.r)), n.push(rt(e.s))), Le(["0x02", xa(n)]);
}
function UO(t) {
  const e = Xu(J(t).slice(1));
  S(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", G(t));
  const n = {
    type: 1,
    chainId: De(e[0], "chainId"),
    nonce: to(e[1], "nonce"),
    gasPrice: De(e[2], "gasPrice"),
    gasLimit: De(e[3], "gasLimit"),
    to: Qc(e[4]),
    value: De(e[5], "value"),
    data: G(e[6]),
    accessList: Rp(e[7], "accessList")
  };
  return e.length === 8 || Dp(n, e.slice(8)), n;
}
function NO(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.gasPrice || 0, "gasPrice"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    Fp(t.accessList || [])
  ];
  return e && (n.push(Te(e.yParity, "recoveryParam")), n.push(rt(e.r)), n.push(rt(e.s))), Le(["0x01", xa(n)]);
}
function RO(t) {
  let e = Xu(J(t).slice(1)), n = "3", r = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    n = "3 (network format)";
    const a = e[1], i = e[2], o = e[3];
    S(Array.isArray(a), "invalid network format: blobs not an array", "fields[1]", a), S(Array.isArray(i), "invalid network format: commitments not an array", "fields[2]", i), S(Array.isArray(o), "invalid network format: proofs not an array", "fields[3]", o), S(a.length === i.length, "invalid network format: blobs/commitments length mismatch", "fields", e), S(a.length === o.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
    for (let c = 0; c < e[1].length; c++)
      r.push({
        data: a[c],
        commitment: i[c],
        proof: o[c]
      });
    e = e[0];
  }
  S(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${n}`, "data", G(t));
  const s = {
    type: 3,
    chainId: De(e[0], "chainId"),
    nonce: to(e[1], "nonce"),
    maxPriorityFeePerGas: De(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: De(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: De(e[4], "gasLimit"),
    to: Qc(e[5]),
    value: De(e[6], "value"),
    data: G(e[7]),
    accessList: Rp(e[8], "accessList"),
    maxFeePerBlobGas: De(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  r && (s.blobs = r), S(s.to != null, `invalid address for transaction type: ${n}`, "data", t), S(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
  for (let a = 0; a < s.blobVersionedHashes.length; a++)
    S(Ue(s.blobVersionedHashes[a], 32), `invalid blobVersionedHash at index ${a}: must be length 32`, "data", t);
  return e.length === 11 || Dp(s, e.slice(11)), s;
}
function FO(t, e, n) {
  const r = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || ka,
    Te(t.value, "value"),
    t.data,
    Fp(t.accessList || []),
    Te(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    SO(t.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (r.push(Te(e.yParity, "yParity")), r.push(rt(e.r)), r.push(rt(e.s)), n) ? Le([
    "0x03",
    xa([
      r,
      n.map((s) => s.data),
      n.map((s) => s.commitment),
      n.map((s) => s.proof)
    ])
  ]) : Le(["0x03", xa(r)]);
}
function DO(t) {
  const e = Xu(J(t).slice(1));
  S(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", G(t));
  const n = {
    type: 4,
    chainId: De(e[0], "chainId"),
    nonce: to(e[1], "nonce"),
    maxPriorityFeePerGas: De(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: De(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: De(e[4], "gasLimit"),
    to: Qc(e[5]),
    value: De(e[6], "value"),
    data: G(e[7]),
    accessList: Rp(e[8], "accessList"),
    authorizationList: CO(e[9], "authorizationList")
  };
  return e.length === 10 || Dp(n, e.slice(10)), n;
}
function MO(t, e) {
  const n = [
    Te(t.chainId, "chainId"),
    Te(t.nonce, "nonce"),
    Te(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Te(t.maxFeePerGas || 0, "maxFeePerGas"),
    Te(t.gasLimit, "gasLimit"),
    t.to || "0x",
    Te(t.value, "value"),
    t.data,
    Fp(t.accessList || []),
    TO(t.authorizationList || [])
  ];
  return e && (n.push(Te(e.yParity, "yParity")), n.push(rt(e.r)), n.push(rt(e.s))), Le(["0x04", xa(n)]);
}
var Zn, tc, nc, rc, sc, ac, ic, oc, cc, lc, uc, dc, mi, Js, Cr, Zs, fc, pc, hf;
const gr = class gr {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    T(this, pc);
    T(this, Zn);
    T(this, tc);
    T(this, nc);
    T(this, rc);
    T(this, sc);
    T(this, ac);
    T(this, ic);
    T(this, oc);
    T(this, cc);
    T(this, lc);
    T(this, uc);
    T(this, dc);
    T(this, mi);
    T(this, Js);
    T(this, Cr);
    T(this, Zs);
    T(this, fc);
    E(this, Zn, null), E(this, tc, null), E(this, rc, 0), E(this, sc, it), E(this, ac, null), E(this, ic, null), E(this, oc, null), E(this, nc, "0x"), E(this, cc, it), E(this, lc, it), E(this, uc, null), E(this, dc, null), E(this, mi, null), E(this, Js, null), E(this, Cr, null), E(this, Zs, null), E(this, fc, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return p(this, Zn);
  }
  set type(e) {
    switch (e) {
      case null:
        E(this, Zn, null);
        break;
      case 0:
      case "legacy":
        E(this, Zn, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        E(this, Zn, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        E(this, Zn, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        E(this, Zn, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        E(this, Zn, 4);
        break;
      default:
        S(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = p(this, tc);
    return e == null && this.type === 3 ? ka : e;
  }
  set to(e) {
    E(this, tc, e == null ? null : ue(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return p(this, rc);
  }
  set nonce(e) {
    E(this, rc, we(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return p(this, sc);
  }
  set gasLimit(e) {
    E(this, sc, ne(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = p(this, ac);
    return e == null && (this.type === 0 || this.type === 1) ? it : e;
  }
  set gasPrice(e) {
    E(this, ac, e == null ? null : ne(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = p(this, ic);
    return e ?? (this.type === 2 || this.type === 3 ? it : null);
  }
  set maxPriorityFeePerGas(e) {
    E(this, ic, e == null ? null : ne(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = p(this, oc);
    return e ?? (this.type === 2 || this.type === 3 ? it : null);
  }
  set maxFeePerGas(e) {
    E(this, oc, e == null ? null : ne(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return p(this, nc);
  }
  set data(e) {
    E(this, nc, G(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return p(this, cc);
  }
  set value(e) {
    E(this, cc, ne(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return p(this, lc);
  }
  set chainId(e) {
    E(this, lc, ne(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return p(this, uc) || null;
  }
  set signature(e) {
    E(this, uc, e == null ? null : tn.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = p(this, dc) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    E(this, dc, e == null ? null : eo(e));
  }
  get authorizationList() {
    const e = p(this, fc) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    E(this, fc, e == null ? null : e.map((n) => $A(n)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = p(this, mi);
    return e == null && this.type === 3 ? it : e;
  }
  set maxFeePerBlobGas(e) {
    E(this, mi, e == null ? null : ne(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = p(this, Js);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      S(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let n = 0; n < e.length; n++)
        S(Ue(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n]);
    }
    E(this, Js, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return p(this, Zs) == null ? null : p(this, Zs).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      E(this, Zs, null);
      return;
    }
    const n = [], r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (Fi(a)) {
        j(p(this, Cr), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let i = J(a);
        if (S(i.length <= nm, "blob is too large", `blobs[${s}]`, a), i.length !== nm) {
          const u = new Uint8Array(nm);
          u.set(i), i = u;
        }
        const o = p(this, Cr).blobToKzgCommitment(i), c = G(p(this, Cr).computeBlobKzgProof(i, o));
        n.push({
          data: G(i),
          commitment: G(o),
          proof: c
        }), r.push(lE(1, o));
      } else {
        const i = G(a.commitment);
        n.push({
          data: G(a.data),
          commitment: i,
          proof: G(a.proof)
        }), r.push(lE(1, i));
      }
    }
    E(this, Zs, n), E(this, Js, r);
  }
  get kzg() {
    return p(this, Cr);
  }
  set kzg(e) {
    e == null ? E(this, Cr, null) : E(this, Cr, vO(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : ke(_(this, pc, hf).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return ke(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : A0(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : au.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return _(this, pc, hf).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return _(this, pc, hf).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, s = p(this, mi) != null || p(this, Js);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && j(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), j(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), j(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const a = [];
    return this.type != null ? a.push(this.type) : this.authorizationList && this.authorizationList.length ? a.push(4) : n ? a.push(2) : e ? (a.push(1), r || a.push(0)) : r ? (a.push(1), a.push(2)) : (s && this.to || (a.push(0), a.push(1), a.push(2)), a.push(3)), a.sort(), a;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return gr.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (n) => n == null ? null : n.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new gr();
    if (typeof e == "string") {
      const r = J(e);
      if (r[0] >= 127)
        return gr.from(OO(r));
      switch (r[0]) {
        case 1:
          return gr.from(UO(r));
        case 2:
          return gr.from(IO(r));
        case 3:
          return gr.from(RO(r));
        case 4:
          return gr.from(DO(r));
      }
      j(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const n = new gr();
    return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = tn.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.authorizationList != null && (n.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (n.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (n.kzg = e.kzg), e.blobs != null && (n.blobs = e.blobs), e.hash != null && (S(n.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), S(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (S(n.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), S(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n;
  }
};
Zn = new WeakMap(), tc = new WeakMap(), nc = new WeakMap(), rc = new WeakMap(), sc = new WeakMap(), ac = new WeakMap(), ic = new WeakMap(), oc = new WeakMap(), cc = new WeakMap(), lc = new WeakMap(), uc = new WeakMap(), dc = new WeakMap(), mi = new WeakMap(), Js = new WeakMap(), Cr = new WeakMap(), Zs = new WeakMap(), fc = new WeakMap(), pc = new WeakSet(), hf = function(e, n) {
  j(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return BO(this, r);
    case 1:
      return NO(this, r);
    case 2:
      return PO(this, r);
    case 3:
      return FO(this, r, n ? this.blobs : null);
    case 4:
      return MO(this, r);
  }
  j(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let $f = gr;
function Mr(t) {
  return ke(en(t));
}
var LO = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const uE = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), dE = 4;
function HO(t) {
  let e = 0;
  function n() {
    return t[e++] << 8 | t[e++];
  }
  let r = n(), s = 1, a = [0, 1];
  for (let x = 1; x < r; x++)
    a.push(s += n());
  let i = n(), o = e;
  e += i;
  let c = 0, u = 0;
  function l() {
    return c == 0 && (u = u << 8 | t[e++], c = 8), u >> --c & 1;
  }
  const d = 31, m = 2 ** d, h = m >>> 1, b = h >> 1, y = m - 1;
  let g = 0;
  for (let x = 0; x < d; x++) g = g << 1 | l();
  let w = [], v = 0, A = m;
  for (; ; ) {
    let x = Math.floor(((g - v + 1) * s - 1) / A), N = 0, I = r;
    for (; I - N > 1; ) {
      let U = N + I >>> 1;
      x < a[U] ? I = U : N = U;
    }
    if (N == 0) break;
    w.push(N);
    let O = v + Math.floor(A * a[N] / s), C = v + Math.floor(A * a[N + 1] / s) - 1;
    for (; !((O ^ C) & h); )
      g = g << 1 & y | l(), O = O << 1 & y, C = C << 1 & y | 1;
    for (; O & ~C & b; )
      g = g & h | g << 1 & y >>> 1 | l(), O = O << 1 ^ h, C = (C ^ h) << 1 | h | 1;
    v = O, A = 1 + C - O;
  }
  let B = r - 4;
  return w.map((x) => {
    switch (x - B) {
      case 3:
        return B + 65792 + (t[o++] << 16 | t[o++] << 8 | t[o++]);
      case 2:
        return B + 256 + (t[o++] << 8 | t[o++]);
      case 1:
        return B + t[o++];
      default:
        return x - 1;
    }
  });
}
function $O(t) {
  let e = 0;
  return () => t[e++];
}
function _A(t) {
  return $O(HO(_O(t)));
}
function _O(t) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, a) => e[s.charCodeAt(0)] = a);
  let n = t.length, r = new Uint8Array(6 * n >> 3);
  for (let s = 0, a = 0, i = 0, o = 0; s < n; s++)
    o = o << 6 | e[t.charCodeAt(s)], i += 6, i >= 8 && (r[a++] = o >> (i -= 8));
  return r;
}
function GO(t) {
  return t & 1 ? ~t >> 1 : t >> 1;
}
function zO(t, e) {
  let n = Array(t);
  for (let r = 0, s = 0; r < t; r++) n[r] = s += GO(e());
  return n;
}
function iu(t, e = 0) {
  let n = [];
  for (; ; ) {
    let r = t(), s = t();
    if (!s) break;
    e += r;
    for (let a = 0; a < s; a++)
      n.push(e + a);
    e += s + 1;
  }
  return n;
}
function GA(t) {
  return ou(() => {
    let e = iu(t);
    if (e.length) return e;
  });
}
function zA(t) {
  let e = [];
  for (; ; ) {
    let n = t();
    if (n == 0) break;
    e.push(VO(n, t));
  }
  for (; ; ) {
    let n = t() - 1;
    if (n < 0) break;
    e.push(jO(n, t));
  }
  return e.flat();
}
function ou(t) {
  let e = [];
  for (; ; ) {
    let n = t(e.length);
    if (!n) break;
    e.push(n);
  }
  return e;
}
function VA(t, e, n) {
  let r = Array(t).fill().map(() => []);
  for (let s = 0; s < e; s++)
    zO(t, n).forEach((a, i) => r[i].push(a));
  return r;
}
function VO(t, e) {
  let n = 1 + e(), r = e(), s = ou(e);
  return VA(s.length, 1 + t, e).flatMap((i, o) => {
    let [c, ...u] = i;
    return Array(s[o]).fill().map((l, d) => {
      let m = d * r;
      return [c + d * n, u.map((h) => h + m)];
    });
  });
}
function jO(t, e) {
  let n = 1 + e();
  return VA(n, 1 + t, e).map((s) => [s[0], s.slice(1)]);
}
function qO(t) {
  let e = [], n = iu(t);
  return s(r([]), []), e;
  function r(a) {
    let i = t(), o = ou(() => {
      let c = iu(t).map((u) => n[u]);
      if (c.length) return r(c);
    });
    return { S: i, B: o, Q: a };
  }
  function s({ S: a, B: i }, o, c) {
    if (!(a & 4 && c === o[o.length - 1])) {
      a & 2 && (c = o[o.length - 1]), a & 1 && e.push(o);
      for (let u of i)
        for (let l of u.Q)
          s(u, [...o, l], c);
    }
  }
}
function KO(t) {
  return t.toString(16).toUpperCase().padStart(2, "0");
}
function jA(t) {
  return `{${KO(t)}}`;
}
function WO(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; ) {
    let s = t.codePointAt(n);
    n += s < 65536 ? 1 : 2, e.push(s);
  }
  return e;
}
function Fc(t) {
  let n = t.length;
  if (n < 4096) return String.fromCodePoint(...t);
  let r = [];
  for (let s = 0; s < n; )
    r.push(String.fromCodePoint(...t.slice(s, s += 4096)));
  return r.join("");
}
function QO(t, e) {
  let n = t.length, r = n - e.length;
  for (let s = 0; r == 0 && s < n; s++) r = t[s] - e[s];
  return r;
}
var JO = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const cu = 44032, _f = 4352, Gf = 4449, zf = 4519, qA = 19, KA = 21, Dc = 28, Vf = KA * Dc, ZO = qA * Vf, XO = cu + ZO, YO = _f + qA, eB = Gf + KA, tB = zf + Dc;
function Ul(t) {
  return t >> 24 & 255;
}
function WA(t) {
  return t & 16777215;
}
let k0, fE, v0, mf;
function nB() {
  let t = _A(JO);
  k0 = new Map(GA(t).flatMap((e, n) => e.map((r) => [r, n + 1 << 24]))), fE = new Set(iu(t)), v0 = /* @__PURE__ */ new Map(), mf = /* @__PURE__ */ new Map();
  for (let [e, n] of zA(t)) {
    if (!fE.has(e) && n.length == 2) {
      let [r, s] = n, a = mf.get(r);
      a || (a = /* @__PURE__ */ new Map(), mf.set(r, a)), a.set(s, e);
    }
    v0.set(e, n.reverse());
  }
}
function QA(t) {
  return t >= cu && t < XO;
}
function rB(t, e) {
  if (t >= _f && t < YO && e >= Gf && e < eB)
    return cu + (t - _f) * Vf + (e - Gf) * Dc;
  if (QA(t) && e > zf && e < tB && (t - cu) % Dc == 0)
    return t + (e - zf);
  {
    let n = mf.get(t);
    return n && (n = n.get(e), n) ? n : -1;
  }
}
function JA(t) {
  k0 || nB();
  let e = [], n = [], r = !1;
  function s(a) {
    let i = k0.get(a);
    i && (r = !0, a |= i), e.push(a);
  }
  for (let a of t)
    for (; ; ) {
      if (a < 128)
        e.push(a);
      else if (QA(a)) {
        let i = a - cu, o = i / Vf | 0, c = i % Vf / Dc | 0, u = i % Dc;
        s(_f + o), s(Gf + c), u > 0 && s(zf + u);
      } else {
        let i = v0.get(a);
        i ? n.push(...i) : s(a);
      }
      if (!n.length) break;
      a = n.pop();
    }
  if (r && e.length > 1) {
    let a = Ul(e[0]);
    for (let i = 1; i < e.length; i++) {
      let o = Ul(e[i]);
      if (o == 0 || a <= o) {
        a = o;
        continue;
      }
      let c = i - 1;
      for (; ; ) {
        let u = e[c + 1];
        if (e[c + 1] = e[c], e[c] = u, !c || (a = Ul(e[--c]), a <= o)) break;
      }
      a = Ul(e[i]);
    }
  }
  return e;
}
function sB(t) {
  let e = [], n = [], r = -1, s = 0;
  for (let a of t) {
    let i = Ul(a), o = WA(a);
    if (r == -1)
      i == 0 ? r = o : e.push(o);
    else if (s > 0 && s >= i)
      i == 0 ? (e.push(r, ...n), n.length = 0, r = o) : n.push(o), s = i;
    else {
      let c = rB(r, o);
      c >= 0 ? r = c : s == 0 && i == 0 ? (e.push(r), r = o) : (n.push(o), s = i);
    }
  }
  return r >= 0 && e.push(r, ...n), e;
}
function ZA(t) {
  return JA(t).map(WA);
}
function aB(t) {
  return sB(JA(t));
}
const pE = 45, XA = ".", YA = 65039, ek = 1, jf = (t) => Array.from(t);
function lu(t, e) {
  return t.P.has(e) || t.Q.has(e);
}
class iB extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let C0, tk, Ha, T0, nk, Ao, rm, co, Ia, hE, S0;
function Cg() {
  if (C0) return;
  let t = _A(LO);
  const e = () => iu(t), n = () => new Set(e()), r = (l, d) => d.forEach((m) => l.add(m));
  C0 = new Map(zA(t)), tk = n(), Ha = e(), T0 = new Set(e().map((l) => Ha[l])), Ha = new Set(Ha), nk = n(), n();
  let s = GA(t), a = t();
  const i = () => {
    let l = /* @__PURE__ */ new Set();
    return e().forEach((d) => r(l, s[d])), r(l, e()), l;
  };
  Ao = ou((l) => {
    let d = ou(t).map((m) => m + 96);
    if (d.length) {
      let m = l >= a;
      d[0] -= 32, d = Fc(d), m && (d = `Restricted[${d}]`);
      let h = i(), b = i(), y = !t();
      return { N: d, P: h, Q: b, M: y, R: m };
    }
  }), rm = n(), co = /* @__PURE__ */ new Map();
  let o = e().concat(jf(rm)).sort((l, d) => l - d);
  o.forEach((l, d) => {
    let m = t(), h = o[d] = m ? o[d - m] : { V: [], M: /* @__PURE__ */ new Map() };
    h.V.push(l), rm.has(l) || co.set(l, h);
  });
  for (let { V: l, M: d } of new Set(co.values())) {
    let m = [];
    for (let b of l) {
      let y = Ao.filter((w) => lu(w, b)), g = m.find(({ G: w }) => y.some((v) => w.has(v)));
      g || (g = { G: /* @__PURE__ */ new Set(), V: [] }, m.push(g)), g.V.push(b), r(g.G, y);
    }
    let h = m.flatMap((b) => jf(b.G));
    for (let { G: b, V: y } of m) {
      let g = new Set(h.filter((w) => !b.has(w)));
      for (let w of y)
        d.set(w, g);
    }
  }
  Ia = /* @__PURE__ */ new Set();
  let c = /* @__PURE__ */ new Set();
  const u = (l) => Ia.has(l) ? c.add(l) : Ia.add(l);
  for (let l of Ao) {
    for (let d of l.P) u(d);
    for (let d of l.Q) u(d);
  }
  for (let l of Ia)
    !co.has(l) && !c.has(l) && co.set(l, ek);
  r(Ia, ZA(Ia)), hE = qO(t).map((l) => iB.from(l)).sort(QO), S0 = /* @__PURE__ */ new Map();
  for (let l of hE) {
    let d = [S0];
    for (let m of l) {
      let h = d.map((b) => {
        let y = b.get(m);
        return y || (y = /* @__PURE__ */ new Map(), b.set(m, y)), y;
      });
      m === YA ? d.push(...h) : d = h;
    }
    for (let m of d)
      m.V = l;
  }
}
function Tg(t) {
  return (rk(t) ? "" : `${Sg(Mp([t]))} `) + jA(t);
}
function Sg(t) {
  return `"${t}"`;
}
function oB(t) {
  if (t.length >= 4 && t[2] == pE && t[3] == pE)
    throw new Error(`invalid label extension: "${Fc(t.slice(0, 4))}"`);
}
function cB(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function lB(t) {
  let e = t[0], n = uE.get(e);
  if (n) throw _l(`leading ${n}`);
  let r = t.length, s = -1;
  for (let a = 1; a < r; a++) {
    e = t[a];
    let i = uE.get(e);
    if (i) {
      if (s == a) throw _l(`${n} + ${i}`);
      s = a + 1, n = i;
    }
  }
  if (s == r) throw _l(`trailing ${n}`);
}
function Mp(t, e = 1 / 0, n = jA) {
  let r = [];
  uB(t[0]) && r.push(""), t.length > e && (e >>= 1, t = [...t.slice(0, e), 8230, ...t.slice(-e)]);
  let s = 0, a = t.length;
  for (let i = 0; i < a; i++) {
    let o = t[i];
    rk(o) && (r.push(Fc(t.slice(s, i))), r.push(n(o)), s = i + 1);
  }
  return r.push(Fc(t.slice(s, a))), r.join("");
}
function uB(t) {
  return Cg(), Ha.has(t);
}
function rk(t) {
  return Cg(), nk.has(t);
}
function dB(t) {
  return mB(fB(t, aB, gB));
}
function fB(t, e, n) {
  if (!t) return [];
  Cg();
  let r = 0;
  return t.split(XA).map((s) => {
    let a = WO(s), i = {
      input: a,
      offset: r
      // codepoint, not substring!
    };
    r += a.length + 1;
    try {
      let o = i.tokens = bB(a, e, n), c = o.length, u;
      if (!c)
        throw new Error("empty label");
      let l = i.output = o.flat();
      if (cB(l), !(i.emoji = c > 1 || o[0].is_emoji) && l.every((m) => m < 128))
        oB(l), u = "ASCII";
      else {
        let m = o.flatMap((h) => h.is_emoji ? [] : h);
        if (!m.length)
          u = "Emoji";
        else {
          if (Ha.has(l[0])) throw _l("leading combining mark");
          for (let y = 1; y < c; y++) {
            let g = o[y];
            if (!g.is_emoji && Ha.has(g[0]))
              throw _l(`emoji + combining mark: "${Fc(o[y - 1])} + ${Mp([g[0]])}"`);
          }
          lB(l);
          let h = jf(new Set(m)), [b] = hB(h);
          yB(b, m), pB(b, h), u = b.N;
        }
      }
      i.type = u;
    } catch (o) {
      i.error = o;
    }
    return i;
  });
}
function pB(t, e) {
  let n, r = [];
  for (let s of e) {
    let a = co.get(s);
    if (a === ek) return;
    if (a) {
      let i = a.M.get(s);
      if (n = n ? n.filter((o) => i.has(o)) : jf(i), !n.length) return;
    } else
      r.push(s);
  }
  if (n) {
    for (let s of n)
      if (r.every((a) => lu(s, a)))
        throw new Error(`whole-script confusable: ${t.N}/${s.N}`);
  }
}
function hB(t) {
  let e = Ao;
  for (let n of t) {
    let r = e.filter((s) => lu(s, n));
    if (!r.length)
      throw Ao.some((s) => lu(s, n)) ? ak(e[0], n) : sk(n);
    if (e = r, r.length == 1) break;
  }
  return e;
}
function mB(t) {
  return t.map(({ input: e, error: n, output: r }) => {
    if (n) {
      let s = n.message;
      throw new Error(t.length == 1 ? s : `Invalid label ${Sg(Mp(e, 63))}: ${s}`);
    }
    return Fc(r);
  }).join(XA);
}
function sk(t) {
  return new Error(`disallowed character: ${Tg(t)}`);
}
function ak(t, e) {
  let n = Tg(e), r = Ao.find((s) => s.P.has(e));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`);
}
function _l(t) {
  return new Error(`illegal placement: ${t}`);
}
function yB(t, e) {
  for (let n of e)
    if (!lu(t, n))
      throw ak(t, n);
  if (t.M) {
    let n = ZA(e);
    for (let r = 1, s = n.length; r < s; r++)
      if (T0.has(n[r])) {
        let a = r + 1;
        for (let i; a < s && T0.has(i = n[a]); a++)
          for (let o = r; o < a; o++)
            if (n[o] == i)
              throw new Error(`duplicate non-spacing marks: ${Tg(i)}`);
        if (a - r > dE)
          throw new Error(`excessive non-spacing marks: ${Sg(Mp(n.slice(r - 1, a)))} (${a - r}/${dE})`);
        r = a;
      }
  }
}
function bB(t, e, n) {
  let r = [], s = [];
  for (t = t.slice().reverse(); t.length; ) {
    let a = wB(t);
    if (a)
      s.length && (r.push(e(s)), s = []), r.push(n(a));
    else {
      let i = t.pop();
      if (Ia.has(i))
        s.push(i);
      else {
        let o = C0.get(i);
        if (o)
          s.push(...o);
        else if (!tk.has(i))
          throw sk(i);
      }
    }
  }
  return s.length && r.push(e(s)), r;
}
function gB(t) {
  return t.filter((e) => e != YA);
}
function wB(t, e) {
  let n = S0, r, s = t.length;
  for (; s && (n = n.get(t[--s]), !!n); ) {
    let { V: a } = n;
    a && (r = a, t.length = s);
  }
  return r;
}
const ik = new Uint8Array(32);
ik.fill(0);
function mE(t) {
  return S(t.length !== 0, "invalid ENS name; empty component", "comp", t), t;
}
function ok(t) {
  const e = en(EB(t)), n = [];
  if (t.length === 0)
    return n;
  let r = 0;
  for (let s = 0; s < e.length; s++)
    e[s] === 46 && (n.push(mE(e.slice(r, s))), r = s + 1);
  return S(r < e.length, "invalid ENS name; empty component", "name", t), n.push(mE(e.slice(r))), n;
}
function EB(t) {
  try {
    if (t.length === 0)
      throw new Error("empty label");
    return dB(t);
  } catch (e) {
    S(!1, `invalid ENS name (${e.message})`, "name", t);
  }
}
function O0(t) {
  S(typeof t == "string", "invalid ENS name; not a string", "name", t), S(t.length, "invalid ENS name (empty label)", "name", t);
  let e = ik;
  const n = ok(t);
  for (; n.length; )
    e = ke(Le([e, ke(n.pop())]));
  return G(e);
}
function xB(t, e) {
  const n = e;
  return S(n <= 255, "DNS encoded label cannot exceed 255", "length", n), G(Le(ok(t).map((r) => {
    S(r.length <= n, `label ${JSON.stringify(t)} exceeds ${n} bytes`, "name", t);
    const s = new Uint8Array(r.length + 1);
    return s.set(r, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
function ck(t) {
  return typeof t == "string" && (t = en(t)), ke(Le([
    en(FA),
    en(String(t.length)),
    t
  ]));
}
const AB = new RegExp("^bytes([0-9]+)$"), kB = new RegExp("^(u?int)([0-9]*)$"), vB = new RegExp("^(.*)\\[([0-9]*)\\]$");
function lk(t, e, n) {
  switch (t) {
    case "address":
      return J(n ? hn(e, 32) : ue(e));
    case "string":
      return en(e);
    case "bytes":
      return J(e);
    case "bool":
      return e = e ? "0x01" : "0x00", J(n ? hn(e, 32) : e);
  }
  let r = t.match(kB);
  if (r) {
    let s = r[1] === "int", a = parseInt(r[2] || "256");
    return S((!r[2] || r[2] === String(a)) && a % 8 === 0 && a !== 0 && a <= 256, "invalid number type", "type", t), n && (a = 256), s && (e = mg(e, a)), J(hn(rt(e), a / 8));
  }
  if (r = t.match(AB), r) {
    const s = parseInt(r[1]);
    return S(String(s) === r[1] && s !== 0 && s <= 32, "invalid bytes type", "type", t), S(Ci(e) === s, `invalid value for ${t}`, "value", e), n ? J(j6(e, 32)) : e;
  }
  if (r = t.match(vB), r && Array.isArray(e)) {
    const s = r[1], a = parseInt(r[2] || String(e.length));
    S(a === e.length, `invalid array length for ${t}`, "value", e);
    const i = [];
    return e.forEach(function(o) {
      i.push(lk(s, o, !0));
    }), J(Le(i));
  }
  S(!1, "invalid type", "type", t);
}
function xe(t, e) {
  S(t.length === e.length, "wrong number of values; expected ${ types.length }", "values", e);
  const n = [];
  return t.forEach(function(r, s) {
    n.push(lk(r, e[s]));
  }), G(Le(n));
}
function Si(t, e) {
  return ke(xe(t, e));
}
const uk = new Uint8Array(32);
uk.fill(0);
const CB = BigInt(-1), dk = BigInt(0), fk = BigInt(1), TB = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function SB(t) {
  const e = J(t), n = e.length % 32;
  return n ? Le([e, uk.slice(n)]) : G(e);
}
const OB = sr(fk, 32), BB = sr(dk, 32), yE = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, sm = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function bE(t) {
  return function(e) {
    return S(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e;
  };
}
const IB = {
  name: bE("name"),
  version: bE("version"),
  chainId: function(t) {
    const e = ne(t, "domain.chainId");
    return S(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : er(e);
  },
  verifyingContract: function(t) {
    try {
      return ue(t).toLowerCase();
    } catch {
    }
    S(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t);
  },
  salt: function(t) {
    const e = J(t, "domain.salt");
    return S(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), G(e);
  }
};
function am(t) {
  {
    const e = t.match(/^(u?)int(\d+)$/);
    if (e) {
      const n = e[1] === "", r = parseInt(e[2]);
      S(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", t);
      const s = Il(TB, n ? r - 1 : r), a = n ? (s + fk) * CB : dk;
      return function(i) {
        const o = ne(i, "value");
        return S(o >= a && o <= s, `value out-of-bounds for ${t}`, "value", o), sr(n ? mg(o, 256) : o, 32);
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const n = parseInt(e[1]);
      return S(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t), function(r) {
        const s = J(r);
        return S(s.length === n, `invalid length for ${t}`, "value", r), SB(r);
      };
    }
  }
  switch (t) {
    case "address":
      return function(e) {
        return hn(ue(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? OB : BB;
      };
    case "bytes":
      return function(e) {
        return ke(e);
      };
    case "string":
      return function(e) {
        return Mr(e);
      };
  }
  return null;
}
function gE(t, e) {
  return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
function Sd(t) {
  const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: t };
}
var Hu, ss, hc, Ap, pk;
const vn = class vn {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    T(this, Ap);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    R(this, "primaryType");
    T(this, Hu);
    T(this, ss);
    T(this, hc);
    E(this, ss, /* @__PURE__ */ new Map()), E(this, hc, /* @__PURE__ */ new Map());
    const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = {};
    Object.keys(e).forEach((c) => {
      a[c] = e[c].map(({ name: u, type: l }) => {
        let { base: d, index: m } = Sd(l);
        return d === "int" && !e.int && (d = "int256"), d === "uint" && !e.uint && (d = "uint256"), { name: u, type: d + (m || "") };
      }), n.set(c, /* @__PURE__ */ new Set()), r.set(c, []), s.set(c, /* @__PURE__ */ new Set());
    }), E(this, Hu, JSON.stringify(a));
    for (const c in a) {
      const u = /* @__PURE__ */ new Set();
      for (const l of a[c]) {
        S(!u.has(l.name), `duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(c)}`, "types", e), u.add(l.name);
        const d = Sd(l.type).base;
        S(d !== c, `circular type reference to ${JSON.stringify(d)}`, "types", e), !am(d) && (S(r.has(d), `unknown type ${JSON.stringify(d)}`, "types", e), r.get(d).push(c), n.get(c).add(d));
      }
    }
    const i = Array.from(r.keys()).filter((c) => r.get(c).length === 0);
    S(i.length !== 0, "missing primary type", "types", e), S(i.length === 1, `ambiguous primary types or unused types: ${i.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), oe(this, { primaryType: i[0] });
    function o(c, u) {
      S(!u.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), u.add(c);
      for (const l of n.get(c))
        if (r.has(l)) {
          o(l, u);
          for (const d of u)
            s.get(d).add(l);
        }
      u.delete(c);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [c, u] of s) {
      const l = Array.from(u);
      l.sort(), p(this, ss).set(c, gE(c, a[c]) + l.map((d) => gE(d, a[d])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(p(this, Hu));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let n = p(this, hc).get(e);
    return n || (n = _(this, Ap, pk).call(this, e), p(this, hc).set(e, n)), n;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const n = p(this, ss).get(e);
    return S(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, n) {
    return this.getEncoder(e)(n);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, n) {
    return ke(this.encodeData(e, n));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, n, r) {
    if (am(e))
      return r(e, n);
    const s = Sd(e).array;
    if (s)
      return S(s.count === -1 || s.count === n.length, `array length mismatch; expected length ${s.count}`, "value", n), n.map((i) => this._visit(s.prefix, i, r));
    const a = this.types[e];
    if (a)
      return a.reduce((i, { name: o, type: c }) => (i[o] = this._visit(c, n[o], r), i), {});
    S(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, n) {
    return this._visit(this.primaryType, e, n);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new vn(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return vn.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, n, r) {
    return vn.from(n).hashStruct(e, r);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const n = [];
    for (const r in e) {
      if (e[r] == null)
        continue;
      const s = yE[r];
      S(s, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({ name: r, type: s });
    }
    return n.sort((r, s) => sm.indexOf(r.name) - sm.indexOf(s.name)), vn.hashStruct("EIP712Domain", { EIP712Domain: n }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, n, r) {
    return Le([
      "0x1901",
      vn.hashDomain(e),
      vn.from(n).hash(r)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, n, r) {
    return ke(vn.encode(e, n, r));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, n, r, s) {
    e = Object.assign({}, e);
    for (const o in e)
      e[o] == null && delete e[o];
    const a = {};
    e.verifyingContract && !Ue(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x");
    const i = vn.from(n);
    i.visit(r, (o, c) => (o === "address" && !Ue(c, 20) && (a[c] = "0x"), c));
    for (const o in a)
      a[o] = await s(o);
    return e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]), r = i.visit(r, (o, c) => o === "address" && a[c] ? a[c] : c), { domain: e, value: r };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, n, r) {
    vn.hashDomain(e);
    const s = {}, a = [];
    sm.forEach((c) => {
      const u = e[c];
      u != null && (s[c] = IB[c](u), a.push({ name: c, type: yE[c] }));
    });
    const i = vn.from(n);
    n = i.types;
    const o = Object.assign({}, n);
    return S(o.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), o.EIP712Domain = a, i.encode(r), {
      types: o,
      domain: s,
      primaryType: i.primaryType,
      message: i.visit(r, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return G(J(u));
        if (c.match(/^u?int/))
          return ne(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return S(typeof u == "string", "invalid string", "value", u), u;
        }
        S(!1, "unsupported type", "type", c);
      })
    };
  }
};
Hu = new WeakMap(), ss = new WeakMap(), hc = new WeakMap(), Ap = new WeakSet(), pk = function(e) {
  {
    const s = am(e);
    if (s)
      return s;
  }
  const n = Sd(e).array;
  if (n) {
    const s = n.prefix, a = this.getEncoder(s);
    return (i) => {
      S(n.count === -1 || n.count === i.length, `array length mismatch; expected length ${n.count}`, "value", i);
      let o = i.map(a);
      return p(this, ss).has(s) && (o = o.map(ke)), ke(Le(o));
    };
  }
  const r = this.types[e];
  if (r) {
    const s = Mr(p(this, ss).get(e));
    return (a) => {
      const i = r.map(({ name: o, type: c }) => {
        const u = this.getEncoder(c)(a[o]);
        return p(this, ss).has(c) ? ke(u) : u;
      });
      return i.unshift(s), Le(i);
    };
  }
  S(!1, `unknown type: ${e}`, "type", e);
};
let uu = vn;
function jt(t) {
  const e = /* @__PURE__ */ new Set();
  return t.forEach((n) => e.add(n)), Object.freeze(e);
}
const PB = "external public payable override", UB = jt(PB.split(" ")), hk = "constant external internal payable private public pure view override", NB = jt(hk.split(" ")), mk = "constructor error event fallback function receive struct", yk = jt(mk.split(" ")), bk = "calldata memory storage payable indexed", RB = jt(bk.split(" ")), FB = "tuple returns", DB = [mk, bk, FB, hk].join(" "), MB = jt(DB.split(" ")), LB = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, HB = new RegExp("^(\\s*)"), $B = new RegExp("^([0-9]+)"), _B = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), gk = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), wk = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var ut, Xn, $u, B0;
const kp = class kp {
  constructor(e) {
    T(this, $u);
    T(this, ut);
    T(this, Xn);
    E(this, ut, 0), E(this, Xn, e.slice());
  }
  get offset() {
    return p(this, ut);
  }
  get length() {
    return p(this, Xn).length - p(this, ut);
  }
  clone() {
    return new kp(p(this, Xn));
  }
  reset() {
    E(this, ut, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const n = this.peek();
    if (n.type !== "KEYWORD" || !e.has(n.text))
      throw new Error(`expected keyword ${n.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const n = this.peek();
      throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = _(this, $u, B0).call(this, p(this, ut) + 1, e.match + 1);
    return E(this, ut, e.match + 1), n;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = [];
    for (; p(this, ut) < e.match - 1; ) {
      const r = this.peek().linkNext;
      n.push(_(this, $u, B0).call(this, p(this, ut) + 1, r)), E(this, ut, r);
    }
    return E(this, ut, e.match + 1), n;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (p(this, ut) >= p(this, Xn).length)
      throw new Error("out-of-bounds");
    return p(this, Xn)[p(this, ut)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const n = this.peekType("KEYWORD");
    return n != null && e.has(n) ? n : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const n = this.peek();
    return n.type === e ? n.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return Ss(this, ut)._++, e;
  }
  toString() {
    const e = [];
    for (let n = p(this, ut); n < p(this, Xn).length; n++) {
      const r = p(this, Xn)[n];
      e.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
ut = new WeakMap(), Xn = new WeakMap(), $u = new WeakSet(), B0 = function(e = 0, n = 0) {
  return new kp(p(this, Xn).slice(e, n).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - e,
    linkBack: r.linkBack - e,
    linkNext: r.linkNext - e
  }))));
};
let ir = kp;
function Oa(t) {
  const e = [], n = (i) => {
    const o = a < t.length ? JSON.stringify(t[a]) : "$EOI";
    throw new Error(`invalid token ${o} at ${a}: ${i}`);
  };
  let r = [], s = [], a = 0;
  for (; a < t.length; ) {
    let i = t.substring(a), o = i.match(HB);
    o && (a += o[1].length, i = t.substring(a));
    const c = { depth: r.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: a, value: -1 };
    e.push(c);
    let u = LB[i[0]] || "";
    if (u) {
      if (c.type = u, c.text = i[0], a++, u === "OPEN_PAREN")
        r.push(e.length - 1), s.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        r.length === 0 && n("no matching open bracket"), c.match = r.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (u === "COMMA")
        c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1, s.push(e.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let l = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const d = e.pop().text;
          l = d + l, e[e.length - 1].value = we(d);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += l;
      }
      continue;
    }
    if (o = i.match(_B), o) {
      if (c.text = o[1], a += c.text.length, MB.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(wk)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (o = i.match($B), o) {
      c.text = o[1], c.type = "NUMBER", a += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(i[0])} at position ${a}`);
  }
  return new ir(e.map((i) => Object.freeze(i)));
}
function wE(t, e) {
  let n = [];
  for (const r in e.keys())
    t.has(r) && n.push(r);
  if (n.length > 1)
    throw new Error(`conflicting types: ${n.join(", ")}`);
}
function Lp(t, e) {
  if (e.peekKeyword(yk)) {
    const n = e.pop().text;
    if (n !== t)
      throw new Error(`expected ${t}, got ${n}`);
  }
  return e.popType("ID");
}
function ys(t, e) {
  const n = /* @__PURE__ */ new Set();
  for (; ; ) {
    const r = t.peekType("KEYWORD");
    if (r == null || e && !e.has(r))
      break;
    if (t.pop(), n.has(r))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    n.add(r);
  }
  return Object.freeze(n);
}
function Ek(t) {
  let e = ys(t, NB);
  return wE(e, jt("constant payable nonpayable".split(" "))), wE(e, jt("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function ps(t, e) {
  return t.popParams().map((n) => bt.from(n, e));
}
function xk(t) {
  if (t.peekType("AT")) {
    if (t.pop(), t.peekType("NUMBER"))
      return ne(t.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function Di(t) {
  if (t.length)
    throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`);
}
const GB = new RegExp(/^(.*)\[([0-9]*)\]$/);
function EE(t) {
  const e = t.match(wk);
  if (S(e, "invalid type", "type", t), t === "uint")
    return "uint256";
  if (t === "int")
    return "int256";
  if (e[2]) {
    const n = parseInt(e[2]);
    S(n !== 0 && n <= 32, "invalid bytes length", "type", t);
  } else if (e[3]) {
    const n = parseInt(e[3]);
    S(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t);
  }
  return t;
}
const Ve = {}, on = Symbol.for("_ethers_internal"), xE = "_ParamTypeInternal", AE = "_ErrorInternal", kE = "_EventInternal", vE = "_ConstructorInternal", CE = "_FallbackInternal", TE = "_FunctionInternal", SE = "_StructInternal";
var mc, yf;
const Cn = class Cn {
  /**
   *  @private
   */
  constructor(e, n, r, s, a, i, o, c) {
    T(this, mc);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    R(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    R(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    R(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    R(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    R(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    R(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    R(this, "arrayChildren");
    if (Op(e, Ve, "ParamType"), Object.defineProperty(this, on, { value: xE }), i && (i = Object.freeze(i.slice())), s === "array") {
      if (o == null || c == null)
        throw new Error("");
    } else if (o != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (i == null)
        throw new Error("");
    } else if (i != null)
      throw new Error("");
    oe(this, {
      name: n,
      type: r,
      baseType: s,
      indexed: a,
      components: i,
      arrayLength: o,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const r = this.name || "";
      if (this.isArray()) {
        const a = JSON.parse(this.arrayChildren.format("json"));
        return a.name = r, a.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(a);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((a) => JSON.parse(a.format(e)))), JSON.stringify(s);
    }
    let n = "";
    return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? n += "(" + this.components.map((r) => r.format(e)).join(e === "full" ? ", " : ",") + ")" : n += this.type, e !== "sighash" && (this.indexed === !0 && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, n) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s) => r.arrayChildren.walk(s, n));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s, a) => r.components[a].walk(s, n));
    }
    return n(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, n) {
    const r = [], s = [e];
    return _(this, mc, yf).call(this, r, e, n, (a) => {
      s[0] = a;
    }), r.length && await Promise.all(r), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, n) {
    if (Cn.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return Cn.from(Oa(e), n);
      } catch {
        S(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof ir) {
      let o = "", c = "", u = null;
      ys(e, jt(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", u = e.popParams().map((y) => Cn.from(y)), o = `tuple(${u.map((y) => y.format()).join(",")})`) : (o = EE(e.popType("TYPE")), c = o);
      let l = null, d = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const y = e.pop();
        l = new Cn(Ve, "", o, c, null, u, d, l), d = y.value, o += y.text, c = "array", u = null;
      }
      let m = null;
      if (ys(e, RB).has("indexed")) {
        if (!n)
          throw new Error("");
        m = !0;
      }
      const b = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new Cn(Ve, b, o, c, m, u, d, l);
    }
    const r = e.name;
    S(!r || typeof r == "string" && r.match(gk), "invalid name", "obj.name", r);
    let s = e.indexed;
    s != null && (S(n, "parameter cannot be indexed", "obj.indexed", e.indexed), s = !!s);
    let a = e.type, i = a.match(GB);
    if (i) {
      const o = parseInt(i[2] || "-1"), c = Cn.from({
        type: i[1],
        components: e.components
      });
      return new Cn(Ve, r || "", a, "array", s, null, o, c);
    }
    if (a === "tuple" || a.startsWith(
      "tuple("
      /* fix: ) */
    ) || a.startsWith(
      "("
      /* fix: ) */
    )) {
      const o = e.components != null ? e.components.map((u) => Cn.from(u)) : null;
      return new Cn(Ve, r || "", a, "tuple", s, o, null, null);
    }
    return a = EE(e.type), new Cn(Ve, r || "", a, a, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[on] === xE;
  }
};
mc = new WeakSet(), yf = function(e, n, r, s) {
  if (this.isArray()) {
    if (!Array.isArray(n))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && n.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const i = this.arrayChildren, o = n.slice();
    o.forEach((c, u) => {
      var l;
      _(l = i, mc, yf).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  if (this.isTuple()) {
    const i = this.components;
    let o;
    if (Array.isArray(n))
      o = n.slice();
    else {
      if (n == null || typeof n != "object")
        throw new Error("invalid tuple value");
      o = i.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in n))
          throw new Error(`missing value for component ${c.name}`);
        return n[c.name];
      });
    }
    if (o.length !== this.components.length)
      throw new Error("array is wrong length");
    o.forEach((c, u) => {
      var l;
      _(l = i[u], mc, yf).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  const a = r(this.type, n);
  a.then ? e.push(async function() {
    s(await a);
  }()) : s(a);
};
let bt = Cn;
class Mi {
  /**
   *  @private
   */
  constructor(e, n, r) {
    /**
     *  The type of the fragment.
     */
    R(this, "type");
    /**
     *  The inputs for the fragment.
     */
    R(this, "inputs");
    Op(e, Ve, "Fragment"), r = Object.freeze(r.slice()), oe(this, { type: n, inputs: r });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        Mi.from(JSON.parse(e));
      } catch {
      }
      return Mi.from(Oa(e));
    }
    if (e instanceof ir)
      switch (e.peekKeyword(yk)) {
        case "constructor":
          return fs.from(e);
        case "error":
          return Xt.from(e);
        case "event":
          return Ur.from(e);
        case "fallback":
        case "receive":
          return Jr.from(e);
        case "function":
          return Nr.from(e);
        case "struct":
          return Oi.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return fs.from(e);
        case "error":
          return Xt.from(e);
        case "event":
          return Ur.from(e);
        case "fallback":
        case "receive":
          return Jr.from(e);
        case "function":
          return Nr.from(e);
        case "struct":
          return Oi.from(e);
      }
      j(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    S(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return fs.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return Xt.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return Ur.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return Nr.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return Oi.isFragment(e);
  }
}
class Hp extends Mi {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, r, a);
    /**
     *  The name of the fragment.
     */
    R(this, "name");
    S(typeof s == "string" && s.match(gk), "invalid identifier", "name", s), a = Object.freeze(a.slice()), oe(this, { name: s });
  }
}
function du(t, e) {
  return "(" + e.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")";
}
class Xt extends Hp {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "error", n, r), Object.defineProperty(this, on, { value: AE });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return Mr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("error"), n.push(this.name + du(e, this.inputs)), n.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (Xt.isFragment(e))
      return e;
    if (typeof e == "string")
      return Xt.from(Oa(e));
    if (e instanceof ir) {
      const n = Lp("error", e), r = ps(e);
      return Di(e), new Xt(Ve, n, r);
    }
    return new Xt(Ve, e.name, e.inputs ? e.inputs.map(bt.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[on] === AE;
  }
}
class Ur extends Hp {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, "event", r, s);
    /**
     *  Whether this event is anonymous.
     */
    R(this, "anonymous");
    Object.defineProperty(this, on, { value: kE }), oe(this, { anonymous: a });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return Mr(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("event"), r.push(this.name + du(n, this.inputs)), n !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(n, r) {
    return r = (r || []).map((a) => bt.from(a)), new Ur(Ve, n, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(n) {
    if (Ur.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return Ur.from(Oa(n));
      } catch {
        S(!1, "invalid event fragment", "obj", n);
      }
    else if (n instanceof ir) {
      const r = Lp("event", n), s = ps(n, !0), a = !!ys(n, jt(["anonymous"])).has("anonymous");
      return Di(n), new Ur(Ve, r, s, a);
    }
    return new Ur(Ve, n.name, n.inputs ? n.inputs.map((r) => bt.from(r, !0)) : [], !!n.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(n) {
    return n && n[on] === kE;
  }
}
class fs extends Mi {
  /**
   *  @private
   */
  constructor(n, r, s, a, i) {
    super(n, r, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    R(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    R(this, "gas");
    Object.defineProperty(this, on, { value: vE }), oe(this, { payable: a, gas: i });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(n) {
    if (j(n != null && n !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), n === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [`constructor${du(n, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(n) {
    if (fs.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return fs.from(Oa(n));
      } catch {
        S(!1, "invalid constuctor fragment", "obj", n);
      }
    else if (n instanceof ir) {
      ys(n, jt(["constructor"]));
      const r = ps(n), s = !!ys(n, UB).has("payable"), a = xk(n);
      return Di(n), new fs(Ve, "constructor", r, s, a);
    }
    return new fs(Ve, "constructor", n.inputs ? n.inputs.map(bt.from) : [], !!n.payable, n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(n) {
    return n && n[on] === vE;
  }
}
class Jr extends Mi {
  constructor(n, r, s) {
    super(n, "fallback", r);
    /**
     *  If the function can be sent value during invocation.
     */
    R(this, "payable");
    Object.defineProperty(this, on, { value: CE }), oe(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(n) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (n === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: s });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(n) {
    if (Jr.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return Jr.from(Oa(n));
      } catch {
        S(!1, "invalid fallback fragment", "obj", n);
      }
    else if (n instanceof ir) {
      const r = n.toString(), s = n.peekKeyword(jt(["fallback", "receive"]));
      if (S(s, "type must be fallback or receive", "obj", r), n.popKeyword(jt(["fallback", "receive"])) === "receive") {
        const c = ps(n);
        return S(c.length === 0, "receive cannot have arguments", "obj.inputs", c), ys(n, jt(["payable"])), Di(n), new Jr(Ve, [], !0);
      }
      let i = ps(n);
      i.length ? S(i.length === 1 && i[0].type === "bytes", "invalid fallback inputs", "obj.inputs", i.map((c) => c.format("minimal")).join(", ")) : i = [bt.from("bytes")];
      const o = Ek(n);
      if (S(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o), ys(n, jt(["returns"])).has("returns")) {
        const c = ps(n);
        S(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return Di(n), new Jr(Ve, i, o === "payable");
    }
    if (n.type === "receive")
      return new Jr(Ve, [], !0);
    if (n.type === "fallback") {
      const r = [bt.from("bytes")], s = n.stateMutability === "payable";
      return new Jr(Ve, r, s);
    }
    S(!1, "invalid fallback description", "obj", n);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(n) {
    return n && n[on] === CE;
  }
}
class Nr extends Hp {
  /**
   *  @private
   */
  constructor(n, r, s, a, i, o) {
    super(n, "function", r, a);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    R(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    R(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    R(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    R(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    R(this, "gas");
    Object.defineProperty(this, on, { value: TE }), i = Object.freeze(i.slice()), oe(this, { constant: s === "view" || s === "pure", gas: o, outputs: i, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return Mr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("function"), r.push(this.name + du(n, this.inputs)), n !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(du(n, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(n, r) {
    return r = (r || []).map((a) => bt.from(a)), new Nr(Ve, n, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(n) {
    if (Nr.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return Nr.from(Oa(n));
      } catch {
        S(!1, "invalid function fragment", "obj", n);
      }
    else if (n instanceof ir) {
      const s = Lp("function", n), a = ps(n), i = Ek(n);
      let o = [];
      ys(n, jt(["returns"])).has("returns") && (o = ps(n));
      const c = xk(n);
      return Di(n), new Nr(Ve, s, i, a, o, c);
    }
    let r = n.stateMutability;
    return r == null && (r = "payable", typeof n.constant == "boolean" ? (r = "view", n.constant || (r = "payable", typeof n.payable == "boolean" && !n.payable && (r = "nonpayable"))) : typeof n.payable == "boolean" && !n.payable && (r = "nonpayable")), new Nr(Ve, n.name, r, n.inputs ? n.inputs.map(bt.from) : [], n.outputs ? n.outputs.map(bt.from) : [], n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(n) {
    return n && n[on] === TE;
  }
}
class Oi extends Hp {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "struct", n, r), Object.defineProperty(this, on, { value: SE });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return Oi.from(Oa(e));
      } catch {
        S(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof ir) {
      const n = Lp("struct", e), r = ps(e);
      return Di(e), new Oi(Ve, n, r);
    }
    return new Oi(Ve, e.name, e.inputs ? e.inputs.map(bt.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[on] === SE;
  }
}
const dr = /* @__PURE__ */ new Map();
dr.set(0, "GENERIC_PANIC");
dr.set(1, "ASSERT_FALSE");
dr.set(17, "OVERFLOW");
dr.set(18, "DIVIDE_BY_ZERO");
dr.set(33, "ENUM_RANGE_ERROR");
dr.set(34, "BAD_STORAGE_DATA");
dr.set(49, "STACK_UNDERFLOW");
dr.set(50, "ARRAY_RANGE_ERROR");
dr.set(65, "OUT_OF_MEMORY");
dr.set(81, "UNINITIALIZED_FUNCTION_CALL");
const zB = new RegExp(/^bytes([0-9]*)$/), VB = new RegExp(/^(u?int)([0-9]*)$/);
let im = null, OE = 1024;
function jB(t, e, n, r) {
  let s = "missing revert data", a = null;
  const i = null;
  let o = null;
  if (n) {
    s = "execution reverted";
    const u = J(n);
    if (n = G(n), u.length === 0)
      s += " (no data present; likely require(false) occurred", a = "require(false)";
    else if (u.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (G(u.slice(0, 4)) === "0x08c379a0")
      try {
        a = r.decode(["string"], u.slice(4))[0], o = {
          signature: "Error(string)",
          name: "Error",
          args: [a]
        }, s += `: ${JSON.stringify(a)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (G(u.slice(0, 4)) === "0x4e487b71")
      try {
        const l = Number(r.decode(["uint256"], u.slice(4))[0]);
        o = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [l]
        }, a = `Panic due to ${dr.get(l) || "UNKNOWN"}(${l})`, s += `: ${a}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: e.to ? ue(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = ue(e.from)), Ge(s, "CALL_EXCEPTION", {
    action: t,
    data: n,
    reason: a,
    transaction: c,
    invocation: i,
    revert: o
  });
}
var Xs, lo;
const vp = class vp {
  constructor() {
    T(this, Xs);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const n = e.map((s) => _(this, Xs, lo).call(this, bt.from(s)));
    return new Td(n, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, n) {
    G6(n.length, e.length, "types/values length mismatch");
    const r = e.map((i) => _(this, Xs, lo).call(this, bt.from(i))), s = new Td(r, "_"), a = new h0();
    return s.encode(a, n), a.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, n, r) {
    const s = e.map((i) => _(this, Xs, lo).call(this, bt.from(i)));
    return new Td(s, "_").decode(new m0(n, r, OE));
  }
  static _setDefaultMaxInflation(e) {
    S(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), OE = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return im == null && (im = new vp()), im;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, n, r) {
    return jB(e, n, r, vp.defaultAbiCoder());
  }
};
Xs = new WeakSet(), lo = function(e) {
  if (e.isArray())
    return new oO(_(this, Xs, lo).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new Td(e.components.map((r) => _(this, Xs, lo).call(this, r)), e.name);
  switch (e.baseType) {
    case "address":
      return new aO(e.name);
    case "bool":
      return new cO(e.name);
    case "string":
      return new bO(e.name);
    case "bytes":
      return new lO(e.name);
    case "":
      return new fO(e.name);
  }
  let n = e.type.match(VB);
  if (n) {
    let r = parseInt(n[2] || "256");
    return S(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new yO(r / 8, n[1] === "int", e.name);
  }
  if (n = e.type.match(zB), n) {
    let r = parseInt(n[1]);
    return S(r !== 0 && r <= 32, "invalid bytes length", "param", e), new uO(r, e.name);
  }
  S(!1, "invalid type", "type", e.type);
};
let Ot = vp;
class qB {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    R(this, "fragment");
    /**
     *  The name of the Event.
     */
    R(this, "name");
    /**
     *  The full Event signature.
     */
    R(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    R(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    R(this, "args");
    const s = e.name, a = e.format();
    oe(this, {
      fragment: e,
      name: s,
      signature: a,
      topic: n,
      args: r
    });
  }
}
class KB {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    R(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    R(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    R(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    R(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    R(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    R(this, "value");
    const a = e.name, i = e.format();
    oe(this, {
      fragment: e,
      name: a,
      args: r,
      signature: i,
      selector: n,
      value: s
    });
  }
}
class WB {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment.
     */
    R(this, "fragment");
    /**
     *  The name of the Error.
     */
    R(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    R(this, "args");
    /**
     *  The full Error signature.
     */
    R(this, "signature");
    /**
     *  The selector for the Error.
     */
    R(this, "selector");
    const s = e.name, a = e.format();
    oe(this, {
      fragment: e,
      name: s,
      args: r,
      signature: a,
      selector: n
    });
  }
}
class BE {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    R(this, "hash");
    /**
     *  @_ignore:
     */
    R(this, "_isIndexed");
    oe(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const IE = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, PE = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (t) => `reverted with reason string ${JSON.stringify(t)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (t) => {
      let e = "unknown panic code";
      return t >= 0 && t <= 255 && IE[t.toString()] && (e = IE[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`;
    }
  }
};
var Tr, Sr, Or, xt, Fr, bf, gf;
const Ma = class Ma {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    T(this, Fr);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    R(this, "fragments");
    /**
     *  The Contract constructor.
     */
    R(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    R(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    R(this, "receive");
    T(this, Tr);
    T(this, Sr);
    T(this, Or);
    //    #structs: Map<string, StructFragment>;
    T(this, xt);
    let n = [];
    typeof e == "string" ? n = JSON.parse(e) : n = e, E(this, Or, /* @__PURE__ */ new Map()), E(this, Tr, /* @__PURE__ */ new Map()), E(this, Sr, /* @__PURE__ */ new Map());
    const r = [];
    for (const i of n)
      try {
        r.push(Mi.from(i));
      } catch (o) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(i)}:`, o.message);
      }
    oe(this, {
      fragments: Object.freeze(r)
    });
    let s = null, a = !1;
    E(this, xt, this.getAbiCoder()), this.fragments.forEach((i, o) => {
      let c;
      switch (i.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          oe(this, { deploy: i });
          return;
        case "fallback":
          i.inputs.length === 0 ? a = !0 : (S(!s || i.payable !== s.payable, "conflicting fallback fragments", `fragments[${o}]`, i), s = i, a = s.payable);
          return;
        case "function":
          c = p(this, Or);
          break;
        case "event":
          c = p(this, Sr);
          break;
        case "error":
          c = p(this, Tr);
          break;
        default:
          return;
      }
      const u = i.format();
      c.has(u) || c.set(u, i);
    }), this.deploy || oe(this, {
      deploy: fs.from("constructor()")
    }), oe(this, { fallback: s, receive: a });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const n = e ? "minimal" : "full";
    return this.fragments.map((s) => s.format(n));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((n) => n.format("json"));
    return JSON.stringify(e.map((n) => JSON.parse(n)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Ot.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const n = _(this, Fr, bf).call(this, e, null, !1);
    return S(n, "no matching function", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!_(this, Fr, bf).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, n) {
    return _(this, Fr, bf).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const n = Array.from(p(this, Or).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(p(this, Or).get(s), r);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const n = _(this, Fr, gf).call(this, e, null, !1);
    return S(n, "no matching event", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!_(this, Fr, gf).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, n) {
    return _(this, Fr, gf).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const n = Array.from(p(this, Sr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(p(this, Sr).get(s), r);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, n) {
    if (Ue(e)) {
      const s = e.toLowerCase();
      if (PE[s])
        return Xt.from(PE[s].signature);
      for (const a of p(this, Tr).values())
        if (s === a.selector)
          return a;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [a, i] of p(this, Tr))
        a.split(
          "("
          /* fix:) */
        )[0] === e && s.push(i);
      if (s.length === 0)
        return e === "Error" ? Xt.from("error Error(string)") : e === "Panic" ? Xt.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const a = s.map((i) => JSON.stringify(i.format())).join(", ");
        S(!1, `ambiguous error description (i.e. ${a})`, "name", e);
      }
      return s[0];
    }
    if (e = Xt.from(e).format(), e === "Error(string)")
      return Xt.from("error Error(string)");
    if (e === "Panic(uint256)")
      return Xt.from("error Panic(uint256)");
    const r = p(this, Tr).get(e);
    return r || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const n = Array.from(p(this, Tr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(p(this, Tr).get(s), r);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, n) {
    return p(this, xt).decode(e, n);
  }
  _encodeParams(e, n) {
    return p(this, xt).encode(e, n);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      S(r, "unknown error", "fragment", e), e = r;
    }
    return S(ze(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, ze(n, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      S(r, "unknown error", "fragment", e), e = r;
    }
    return Le([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return S(ze(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, ze(n, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return Le([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const a = this.getFunction(e);
      S(a, "unknown function", "fragment", e), e = a;
    }
    let r = "invalid length for result data";
    const s = Gt(n);
    if (s.length % 32 === 0)
      try {
        return p(this, xt).decode(e.outputs, s);
      } catch {
        r = "could not decode result data";
      }
    j(!1, r, "BAD_DATA", {
      value: G(s),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, n) {
    const r = J(e, "data"), s = Ot.getBuiltinCallException("call", n, r);
    if (s.message.startsWith("execution reverted (unknown custom error)")) {
      const o = G(r.slice(0, 4)), c = this.getError(o);
      if (c)
        try {
          const u = p(this, xt).decode(c.inputs, r.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const i = this.parseTransaction(n);
    return i && (s.invocation = {
      method: i.name,
      signature: i.signature,
      args: i.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return G(p(this, xt).encode(e.outputs, n || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, n) {
    if (typeof e == "string") {
      const a = this.getEvent(e);
      S(a, "unknown event", "eventFragment", e), e = a;
    }
    j(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: n.length, expectedCount: e.inputs.length });
    const r = [];
    e.anonymous || r.push(e.topicHash);
    const s = (a, i) => a.type === "string" ? Mr(i) : a.type === "bytes" ? ke(G(i)) : (a.type === "bool" && typeof i == "boolean" ? i = i ? "0x01" : "0x00" : a.type.match(/^u?int/) ? i = sr(i) : a.type.match(/^bytes/) ? i = j6(i, 32) : a.type === "address" && p(this, xt).encode(["address"], [i]), hn(G(i), 32));
    for (n.forEach((a, i) => {
      const o = e.inputs[i];
      if (!o.indexed) {
        S(a == null, "cannot filter non-indexed parameters; must be null", "contract." + o.name, a);
        return;
      }
      a == null ? r.push(null) : o.baseType === "array" || o.baseType === "tuple" ? S(!1, "filtering with tuples or arrays not supported", "contract." + o.name, a) : Array.isArray(a) ? r.push(a.map((c) => s(o, c))) : r.push(s(o, a));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(e, n) {
    if (typeof e == "string") {
      const i = this.getEvent(e);
      S(i, "unknown event", "eventFragment", e), e = i;
    }
    const r = [], s = [], a = [];
    return e.anonymous || r.push(e.topicHash), S(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((i, o) => {
      const c = n[o];
      if (i.indexed)
        if (i.type === "string")
          r.push(Mr(c));
        else if (i.type === "bytes")
          r.push(ke(c));
        else {
          if (i.baseType === "tuple" || i.baseType === "array")
            throw new Error("not implemented");
          r.push(p(this, xt).encode([i.type], [c]));
        }
      else
        s.push(i), a.push(c);
    }), {
      data: p(this, xt).encode(s, a),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, n, r) {
    if (typeof e == "string") {
      const h = this.getEvent(e);
      S(h, "unknown event", "eventFragment", e), e = h;
    }
    if (r != null && !e.anonymous) {
      const h = e.topicHash;
      S(Ue(r[0], 32) && r[0].toLowerCase() === h, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
    }
    const s = [], a = [], i = [];
    e.inputs.forEach((h, b) => {
      h.indexed ? h.type === "string" || h.type === "bytes" || h.baseType === "tuple" || h.baseType === "array" ? (s.push(bt.from({ type: "bytes32", name: h.name })), i.push(!0)) : (s.push(h), i.push(!1)) : (a.push(h), i.push(!1));
    });
    const o = r != null ? p(this, xt).decode(s, Le(r)) : null, c = p(this, xt).decode(a, n, !0), u = [], l = [];
    let d = 0, m = 0;
    return e.inputs.forEach((h, b) => {
      let y = null;
      if (h.indexed)
        if (o == null)
          y = new BE(null);
        else if (i[b])
          y = new BE(o[m++]);
        else
          try {
            y = o[m++];
          } catch (g) {
            y = g;
          }
      else
        try {
          y = c[d++];
        } catch (g) {
          y = g;
        }
      u.push(y), l.push(h.name || null);
    }), Ic.fromItems(u, l);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const n = J(e.data, "tx.data"), r = ne(e.value != null ? e.value : 0, "tx.value"), s = this.getFunction(G(n.slice(0, 4)));
    if (!s)
      return null;
    const a = p(this, xt).decode(s.inputs, n.slice(4));
    return new KB(s, s.selector, a, r);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const n = this.getEvent(e.topics[0]);
    return !n || n.anonymous ? null : new qB(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const n = G(e), r = this.getError(ze(n, 0, 4));
    if (!r)
      return null;
    const s = p(this, xt).decode(r.inputs, ze(n, 4));
    return new WB(r, r.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof Ma ? e : typeof e == "string" ? new Ma(JSON.parse(e)) : typeof e.formatJson == "function" ? new Ma(e.formatJson()) : typeof e.format == "function" ? new Ma(e.format("json")) : new Ma(e);
  }
};
Tr = new WeakMap(), Sr = new WeakMap(), Or = new WeakMap(), xt = new WeakMap(), Fr = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
bf = function(e, n, r) {
  if (Ue(e)) {
    const a = e.toLowerCase();
    for (const i of p(this, Or).values())
      if (a === i.selector)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of p(this, Or))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      const i = n.length > 0 ? n[n.length - 1] : null;
      let o = n.length, c = !0;
      Tt.isTyped(i) && i.type === "overrides" && (c = !1, o--);
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs.length;
        l !== o && (!c || l !== o - 1) && a.splice(u, 1);
      }
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs;
        for (let d = 0; d < n.length; d++)
          if (Tt.isTyped(n[d])) {
            if (d >= l.length) {
              if (n[d].type === "overrides")
                continue;
              a.splice(u, 1);
              break;
            }
            if (n[d].type !== l[d].baseType) {
              a.splice(u, 1);
              break;
            }
          }
      }
    }
    if (a.length === 1 && n && n.length !== a[0].inputs.length) {
      const i = n[n.length - 1];
      (i == null || Array.isArray(i) || typeof i != "object") && a.splice(0, 1);
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      S(!1, `ambiguous function description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = p(this, Or).get(Nr.from(e).format());
  return s || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
gf = function(e, n, r) {
  if (Ue(e)) {
    const a = e.toLowerCase();
    for (const i of p(this, Sr).values())
      if (a === i.topicHash)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of p(this, Sr))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      for (let i = a.length - 1; i >= 0; i--)
        a[i].inputs.length < n.length && a.splice(i, 1);
      for (let i = a.length - 1; i >= 0; i--) {
        const o = a[i].inputs;
        for (let c = 0; c < n.length; c++)
          if (Tt.isTyped(n[c]) && n[c].type !== o[c].baseType) {
            a.splice(i, 1);
            break;
          }
      }
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      S(!1, `ambiguous event description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = p(this, Sr).get(Ur.from(e).format());
  return s || null;
};
let Bt = Ma;
const Ak = BigInt(0);
function ko(t) {
  return t ?? null;
}
function Qe(t) {
  return t == null ? null : t.toString();
}
class UE {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, n, r) {
    /**
     *  The gas price for legacy networks.
     */
    R(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    R(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    R(this, "maxPriorityFeePerGas");
    oe(this, {
      gasPrice: ko(e),
      maxFeePerGas: ko(n),
      maxPriorityFeePerGas: ko(r)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: n, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: Qe(e),
      maxFeePerGas: Qe(n),
      maxPriorityFeePerGas: Qe(r)
    };
  }
}
function qf(t) {
  const e = {};
  t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = G(t.data));
  const n = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of n)
    !(s in t) || t[s] == null || (e[s] = ne(t[s], `request.${s}`));
  const r = "type,nonce".split(/,/);
  for (const s of r)
    !(s in t) || t[s] == null || (e[s] = we(t[s], `request.${s}`));
  return t.accessList && (e.accessList = eo(t.accessList)), t.authorizationList && (e.authorizationList = t.authorizationList.slice()), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map((s) => Fi(s) ? G(s) : Object.assign({}, s))), e;
}
var as;
class QB {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, n) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    R(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    R(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    R(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    R(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    R(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    R(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    R(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    R(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    R(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    R(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    R(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    R(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    R(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    R(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    R(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    R(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    R(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    R(this, "baseFeePerGas");
    T(this, as);
    E(this, as, e.transactions.map((r) => typeof r != "string" ? new fu(r, n) : r)), oe(this, {
      provider: n,
      hash: ko(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      parentBeaconBlockRoot: e.parentBeaconBlockRoot,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      blobGasUsed: e.blobGasUsed,
      excessBlobGas: e.excessBlobGas,
      miner: e.miner,
      prevRandao: ko(e.prevRandao),
      extraData: e.extraData,
      baseFeePerGas: ko(e.baseFeePerGas),
      stateRoot: e.stateRoot,
      receiptsRoot: e.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return p(this, as).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = p(this, as).slice();
    return e.length === 0 ? [] : (j(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: n, extraData: r, gasLimit: s, gasUsed: a, hash: i, miner: o, prevRandao: c, nonce: u, number: l, parentHash: d, parentBeaconBlockRoot: m, stateRoot: h, receiptsRoot: b, timestamp: y, transactions: g } = this;
    return {
      _type: "Block",
      baseFeePerGas: Qe(e),
      difficulty: Qe(n),
      extraData: r,
      gasLimit: Qe(s),
      gasUsed: Qe(a),
      blobGasUsed: Qe(this.blobGasUsed),
      excessBlobGas: Qe(this.excessBlobGas),
      hash: i,
      miner: o,
      prevRandao: c,
      nonce: u,
      number: l,
      parentHash: d,
      timestamp: y,
      parentBeaconBlockRoot: m,
      stateRoot: h,
      receiptsRoot: b,
      transactions: g
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const n = this.transactions;
    return {
      next: () => e < this.length ? {
        value: n[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return p(this, as).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let n;
    if (typeof e == "number")
      n = p(this, as)[e];
    else {
      const r = e.toLowerCase();
      for (const s of p(this, as))
        if (typeof s == "string") {
          if (s !== r)
            continue;
          n = s;
          break;
        } else {
          if (s.hash !== r)
            continue;
          n = s;
          break;
        }
    }
    if (n == null)
      throw new Error("no such tx");
    return typeof n == "string" ? await this.provider.getTransaction(n) : n;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const n = this.prefetchedTransactions;
    if (typeof e == "number")
      return n[e];
    e = e.toLowerCase();
    for (const r of n)
      if (r.hash === e)
        return r;
    S(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return JB(this);
  }
}
as = new WeakMap();
class ed {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    R(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    R(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    R(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    R(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    R(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    R(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    R(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    R(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    R(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    R(this, "transactionIndex");
    this.provider = n;
    const r = Object.freeze(e.topics.slice());
    oe(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: r,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: n, blockNumber: r, data: s, index: a, removed: i, topics: o, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: e,
      blockHash: n,
      blockNumber: r,
      data: s,
      index: a,
      removed: i,
      topics: o,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return j(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return j(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return j(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return ZB(this);
  }
}
var _u;
class kk {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    R(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    R(this, "to");
    /**
     *  The sender of the transaction.
     */
    R(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    R(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    R(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    R(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    R(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    R(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    R(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    R(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    R(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    R(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    R(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    R(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    R(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    R(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    R(this, "root");
    T(this, _u);
    E(this, _u, Object.freeze(e.logs.map((s) => new ed(s, n))));
    let r = Ak;
    e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), oe(this, {
      provider: n,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      blobGasUsed: e.blobGasUsed,
      gasPrice: r,
      blobGasPrice: e.blobGasPrice,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return p(this, _u);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: n,
      contractAddress: r,
      hash: s,
      index: a,
      blockHash: i,
      blockNumber: o,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: l,
      root: d
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: i,
      blockNumber: o,
      //byzantium, 
      contractAddress: r,
      cumulativeGasUsed: Qe(this.cumulativeGasUsed),
      from: n,
      gasPrice: Qe(this.gasPrice),
      blobGasUsed: Qe(this.blobGasUsed),
      blobGasPrice: Qe(this.blobGasPrice),
      gasUsed: Qe(this.gasUsed),
      hash: s,
      index: a,
      logs: u,
      logsBloom: c,
      root: d,
      status: l,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Ck(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return j(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), vk(this, e);
  }
}
_u = new WeakMap();
var Ys;
const pw = class pw {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    R(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    R(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    R(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    R(this, "index");
    /**
     *  The transaction hash.
     */
    R(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    R(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    R(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    R(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    R(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    R(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    R(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    R(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    R(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    R(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    R(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    R(this, "value");
    /**
     *  The chain ID.
     */
    R(this, "chainId");
    /**
     *  The signature.
     */
    R(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    R(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    R(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    R(this, "authorizationList");
    T(this, Ys);
    this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, E(this, Ys, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: n, index: r, hash: s, type: a, to: i, from: o, nonce: c, data: u, signature: l, accessList: d, blobVersionedHashes: m } = this;
    return {
      _type: "TransactionResponse",
      accessList: d,
      blockNumber: e,
      blockHash: n,
      blobVersionedHashes: m,
      chainId: Qe(this.chainId),
      data: u,
      from: o,
      gasLimit: Qe(this.gasLimit),
      gasPrice: Qe(this.gasPrice),
      hash: s,
      maxFeePerGas: Qe(this.maxFeePerGas),
      maxPriorityFeePerGas: Qe(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: Qe(this.maxFeePerBlobGas),
      nonce: c,
      signature: l,
      to: i,
      index: r,
      type: a,
      value: Qe(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const r = await this.getTransaction();
      r && (e = r.blockNumber);
    }
    if (e == null)
      return null;
    const n = this.provider.getBlock(e);
    if (n == null)
      throw new Error("TODO");
    return n;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: n, blockNumber: r } = await dt({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, n) {
    const r = e ?? 1, s = n ?? 0;
    let a = p(this, Ys), i = -1, o = a === -1;
    const c = async () => {
      if (o)
        return null;
      const { blockNumber: m, nonce: h } = await dt({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (h < this.nonce) {
        a = m;
        return;
      }
      if (o)
        return null;
      const b = await this.getTransaction();
      if (!(b && b.blockNumber != null))
        for (i === -1 && (i = a - 3, i < p(this, Ys) && (i = p(this, Ys))); i <= m; ) {
          if (o)
            return null;
          const y = await this.provider.getBlock(i, !0);
          if (y == null)
            return;
          for (const g of y)
            if (g === this.hash)
              return;
          for (let g = 0; g < y.length; g++) {
            const w = await y.getTransaction(g);
            if (w.from === this.from && w.nonce === this.nonce) {
              if (o)
                return null;
              const v = await this.provider.getTransactionReceipt(w.hash);
              if (v == null || m - v.blockNumber + 1 < r)
                return;
              let A = "replaced";
              w.data === this.data && w.to === this.to && w.value === this.value ? A = "repriced" : w.data === "0x" && w.from === w.to && w.value === Ak && (A = "cancelled"), j(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: A === "replaced" || A === "cancelled",
                reason: A,
                replacement: w.replaceableTransaction(a),
                hash: w.hash,
                receipt: v
              });
            }
          }
          i++;
        }
    }, u = (m) => {
      if (m == null || m.status !== 0)
        return m;
      j(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: m.to,
          from: m.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: m
      });
    }, l = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0)
      return u(l);
    if (l) {
      if (r === 1 || await l.confirmations() >= r)
        return u(l);
    } else if (await c(), r === 0)
      return null;
    return await new Promise((m, h) => {
      const b = [], y = () => {
        b.forEach((w) => w());
      };
      if (b.push(() => {
        o = !0;
      }), s > 0) {
        const w = setTimeout(() => {
          y(), h(Ge("wait for transaction timeout", "TIMEOUT"));
        }, s);
        b.push(() => {
          clearTimeout(w);
        });
      }
      const g = async (w) => {
        if (await w.confirmations() >= r) {
          y();
          try {
            m(u(w));
          } catch (v) {
            h(v);
          }
        }
      };
      if (b.push(() => {
        this.provider.off(this.hash, g);
      }), this.provider.on(this.hash, g), a >= 0) {
        const w = async () => {
          try {
            await c();
          } catch (v) {
            if (mt(v, "TRANSACTION_REPLACED")) {
              y(), h(v);
              return;
            }
          }
          o || this.provider.once("block", w);
        };
        b.push(() => {
          this.provider.off("block", w);
        }), this.provider.once("block", w);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return j(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Ck(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return j(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), j(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), vk(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    S(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const n = new pw(this, this.provider);
    return E(n, Ys, e), n;
  }
};
Ys = new WeakMap();
let fu = pw;
function JB(t) {
  return { orphan: "drop-block", hash: t.hash, number: t.number };
}
function vk(t, e) {
  return { orphan: "reorder-transaction", tx: t, other: e };
}
function Ck(t) {
  return { orphan: "drop-transaction", tx: t };
}
function ZB(t) {
  return { orphan: "drop-log", log: {
    transactionHash: t.transactionHash,
    blockHash: t.blockHash,
    blockNumber: t.blockNumber,
    address: t.address,
    data: t.data,
    topics: Object.freeze(t.topics.slice()),
    index: t.index
  } };
}
class Og extends ed {
  /**
   * @_ignore:
   */
  constructor(n, r, s) {
    super(n, n.provider);
    /**
     *  The Contract Interface.
     */
    R(this, "interface");
    /**
     *  The matching event.
     */
    R(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    R(this, "args");
    const a = r.decodeEventLog(s, n.data, n.topics);
    oe(this, { args: a, fragment: s, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class Tk extends ed {
  /**
   * @_ignore:
   */
  constructor(n, r) {
    super(n, n.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    R(this, "error");
    oe(this, { error: r });
  }
}
var yc;
class XB extends kk {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    T(this, yc);
    E(this, yc, n);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((n) => {
      const r = n.topics.length ? p(this, yc).getEvent(n.topics[0]) : null;
      if (r)
        try {
          return new Og(n, p(this, yc), r);
        } catch (s) {
          return new Tk(n, s);
        }
      return n;
    });
  }
}
yc = new WeakMap();
var Gu;
class Bg extends fu {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    T(this, Gu);
    E(this, Gu, n);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(n, r) {
    const s = await super.wait(n, r);
    return s == null ? null : new XB(p(this, Gu), this.provider, s);
  }
}
Gu = new WeakMap();
class Sk extends q6 {
  /**
   *  @_event:
   */
  constructor(n, r, s, a) {
    super(n, r, s);
    /**
     *  The log with no matching events.
     */
    R(this, "log");
    oe(this, { log: a });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class YB extends Sk {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s, a) {
    super(e, n, r, new Og(a, e.interface, s));
    const i = e.interface.decodeEventLog(s, this.log.data, this.log.topics);
    oe(this, { args: i, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const NE = BigInt(0);
function Ok(t) {
  return t && typeof t.call == "function";
}
function Bk(t) {
  return t && typeof t.estimateGas == "function";
}
function $p(t) {
  return t && typeof t.resolveName == "function";
}
function Ik(t) {
  return t && typeof t.sendTransaction == "function";
}
function Pk(t) {
  if (t != null) {
    if ($p(t))
      return t;
    if (t.provider)
      return t.provider;
  }
}
var zu;
class e9 {
  constructor(e, n, r) {
    T(this, zu);
    R(this, "fragment");
    if (oe(this, { fragment: n }), n.inputs.length < r.length)
      throw new Error("too many arguments");
    const s = Li(e.runner, "resolveName"), a = $p(s) ? s : null;
    E(this, zu, async function() {
      const i = await Promise.all(n.inputs.map((o, c) => r[c] == null ? null : o.walkAsync(r[c], (l, d) => l === "address" ? Array.isArray(d) ? Promise.all(d.map((m) => Vt(m, a))) : Vt(d, a) : d)));
      return e.interface.encodeFilterTopics(n, i);
    }());
  }
  getTopicFilter() {
    return p(this, zu);
  }
}
zu = new WeakMap();
function Li(t, e) {
  return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null;
}
function $a(t) {
  return t == null ? null : t.provider || null;
}
async function Uk(t, e) {
  const n = Tt.dereference(t, "overrides");
  S(typeof n == "object", "invalid overrides parameter", "overrides", t);
  const r = qf(n);
  return S(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), S(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
}
async function t9(t, e, n) {
  const r = Li(t, "resolveName"), s = $p(r) ? r : null;
  return await Promise.all(e.map((a, i) => a.walkAsync(n[i], (o, c) => (c = Tt.dereference(c, o), o === "address" ? Vt(c, s) : c))));
}
function n9(t) {
  const e = async function(i) {
    const o = await Uk(i, ["data"]);
    o.to = await t.getAddress(), o.from && (o.from = await Vt(o.from, Pk(t.runner)));
    const c = t.interface, u = ne(o.value || NE, "overrides.value") === NE, l = (o.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !l && !u && S(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", i), S(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data);
    const d = c.receive || c.fallback && c.fallback.payable;
    return S(d || u, "cannot send value to non-payable fallback", "overrides.value", o.value), S(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data), o;
  }, n = async function(i) {
    const o = Li(t.runner, "call");
    j(Ok(o), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await e(i);
    try {
      return await o.call(c);
    } catch (u) {
      throw hg(u) && u.data ? t.interface.makeError(u.data, c) : u;
    }
  }, r = async function(i) {
    const o = t.runner;
    j(Ik(o), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await o.sendTransaction(await e(i)), u = $a(t.runner);
    return new Bg(t.interface, u, c);
  }, s = async function(i) {
    const o = Li(t.runner, "estimateGas");
    return j(Bk(o), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await o.estimateGas(await e(i));
  }, a = async (i) => await r(i);
  return oe(a, {
    _contract: t,
    estimateGas: s,
    populateTransaction: e,
    send: r,
    staticCall: n
  }), a;
}
function r9(t, e) {
  const n = function(...u) {
    const l = t.interface.getFunction(e, u);
    return j(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: u }
    }), l;
  }, r = async function(...u) {
    const l = n(...u);
    let d = {};
    if (l.inputs.length + 1 === u.length && (d = await Uk(u.pop()), d.from && (d.from = await Vt(d.from, Pk(t.runner)))), l.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const m = await t9(t.runner, l.inputs, u);
    return Object.assign({}, d, await dt({
      to: t.getAddress(),
      data: t.interface.encodeFunctionData(l, m)
    }));
  }, s = async function(...u) {
    const l = await o(...u);
    return l.length === 1 ? l[0] : l;
  }, a = async function(...u) {
    const l = t.runner;
    j(Ik(l), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const d = await l.sendTransaction(await r(...u)), m = $a(t.runner);
    return new Bg(t.interface, m, d);
  }, i = async function(...u) {
    const l = Li(t.runner, "estimateGas");
    return j(Bk(l), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await l.estimateGas(await r(...u));
  }, o = async function(...u) {
    const l = Li(t.runner, "call");
    j(Ok(l), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const d = await r(...u);
    let m = "0x";
    try {
      m = await l.call(d);
    } catch (b) {
      throw hg(b) && b.data ? t.interface.makeError(b.data, d) : b;
    }
    const h = n(...u);
    return t.interface.decodeFunctionResult(h, m);
  }, c = async (...u) => n(...u).constant ? await s(...u) : await a(...u);
  return oe(c, {
    name: t.interface.getFunctionName(e),
    _contract: t,
    _key: e,
    getFragment: n,
    estimateGas: i,
    populateTransaction: r,
    send: a,
    staticCall: s,
    staticCallResult: o
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = t.interface.getFunction(e);
      return j(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), u;
    }
  }), c;
}
function s9(t, e) {
  const n = function(...s) {
    const a = t.interface.getEvent(e, s);
    return j(a, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: s }
    }), a;
  }, r = function(...s) {
    return new e9(t, n(...s), s);
  };
  return oe(r, {
    name: t.interface.getEventName(e),
    _contract: t,
    _key: e,
    getFragment: n
  }), Object.defineProperty(r, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = t.interface.getEvent(e);
      return j(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), s;
    }
  }), r;
}
const Kf = Symbol.for("_ethersInternal_contract"), Nk = /* @__PURE__ */ new WeakMap();
function a9(t, e) {
  Nk.set(t[Kf], e);
}
function ln(t) {
  return Nk.get(t[Kf]);
}
function i9(t) {
  return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment;
}
async function Ig(t, e) {
  let n, r = null;
  if (Array.isArray(e)) {
    const a = function(i) {
      if (Ue(i, 32))
        return i;
      const o = t.interface.getEvent(i);
      return S(o, "unknown fragment", "name", i), o.topicHash;
    };
    n = e.map((i) => i == null ? null : Array.isArray(i) ? i.map(a) : a(i));
  } else e === "*" ? n = [null] : typeof e == "string" ? Ue(e, 32) ? n = [e] : (r = t.interface.getEvent(e), S(r, "unknown fragment", "event", e), n = [r.topicHash]) : i9(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [r.topicHash]) : S(!1, "unknown event name", "event", e);
  n = n.map((a) => {
    if (a == null)
      return null;
    if (Array.isArray(a)) {
      const i = Array.from(new Set(a.map((o) => o.toLowerCase())).values());
      return i.length === 1 ? i[0] : (i.sort(), i);
    }
    return a.toLowerCase();
  });
  const s = n.map((a) => a == null ? "null" : Array.isArray(a) ? a.join("|") : a).join("&");
  return { fragment: r, tag: s, topics: n };
}
async function Nl(t, e) {
  const { subs: n } = ln(t);
  return n.get((await Ig(t, e)).tag) || null;
}
async function RE(t, e, n) {
  const r = $a(t.runner);
  j(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: s, tag: a, topics: i } = await Ig(t, n), { addr: o, subs: c } = ln(t);
  let u = c.get(a);
  if (!u) {
    const d = { address: o || t, topics: i }, m = (g) => {
      let w = s;
      if (w == null)
        try {
          w = t.interface.getEvent(g.topics[0]);
        } catch {
        }
      if (w) {
        const v = w, A = s ? t.interface.decodeEventLog(s, g.data, g.topics) : [];
        P0(t, n, A, (B) => new YB(t, B, n, v, g));
      } else
        P0(t, n, [], (v) => new Sk(t, v, n, g));
    };
    let h = [];
    u = { tag: a, listeners: [], start: () => {
      h.length || h.push(r.on(d, m));
    }, stop: async () => {
      if (h.length == 0)
        return;
      let g = h;
      h = [], await Promise.all(g), r.off(d, m);
    } }, c.set(a, u);
  }
  return u;
}
let I0 = Promise.resolve();
async function o9(t, e, n, r) {
  await I0;
  const s = await Nl(t, e);
  if (!s)
    return !1;
  const a = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: i, once: o }) => {
    const c = Array.from(n);
    r && c.push(r(o ? null : i));
    try {
      i.call(t, ...c);
    } catch {
    }
    return !o;
  }), s.listeners.length === 0 && (s.stop(), ln(t).subs.delete(s.tag)), a > 0;
}
async function P0(t, e, n, r) {
  try {
    await I0;
  } catch {
  }
  const s = o9(t, e, n, r);
  return I0 = s, await s;
}
const Od = ["then"];
var R2;
R2 = Kf;
const tu = class tu {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, n, r, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    R(this, "target");
    /**
     *  The contract Interface.
     */
    R(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    R(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    R(this, "filters");
    /**
     *  @_ignore:
     */
    R(this, R2);
    /**
     *  The fallback or receive function if any.
     */
    R(this, "fallback");
    S(typeof e == "string" || DA(e), "invalid value for Contract target", "target", e), r == null && (r = null);
    const a = Bt.from(n);
    oe(this, { target: e, runner: r, interface: a }), Object.defineProperty(this, Kf, { value: {} });
    let i, o = null, c = null;
    if (s) {
      const d = $a(r);
      c = new Bg(this.interface, d, s);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (Ue(e))
        o = e, i = Promise.resolve(e);
      else {
        const d = Li(r, "resolveName");
        if (!$p(d))
          throw Ge("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        i = d.resolveName(e).then((m) => {
          if (m == null)
            throw Ge("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return ln(this).addr = m, m;
        });
      }
    else
      i = e.getAddress().then((d) => {
        if (d == null)
          throw new Error("TODO");
        return ln(this).addr = d, d;
      });
    a9(this, { addrPromise: i, addr: o, deployTx: c, subs: u });
    const l = new Proxy({}, {
      get: (d, m, h) => {
        if (typeof m == "symbol" || Od.indexOf(m) >= 0)
          return Reflect.get(d, m, h);
        try {
          return this.getEvent(m);
        } catch (b) {
          if (!mt(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, m) => Od.indexOf(m) >= 0 ? Reflect.has(d, m) : Reflect.has(d, m) || this.interface.hasEvent(String(m))
    });
    return oe(this, { filters: l }), oe(this, {
      fallback: a.receive || a.fallback ? n9(this) : null
    }), new Proxy(this, {
      get: (d, m, h) => {
        if (typeof m == "symbol" || m in d || Od.indexOf(m) >= 0)
          return Reflect.get(d, m, h);
        try {
          return d.getFunction(m);
        } catch (b) {
          if (!mt(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, m) => typeof m == "symbol" || m in d || Od.indexOf(m) >= 0 ? Reflect.has(d, m) : d.interface.hasFunction(m)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new tu(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new tu(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await ln(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = $a(this.runner);
    j(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const n = await e.getCode(await this.getAddress());
    return n === "0x" ? null : n;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = $a(this.runner);
    return j(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, a) => {
      const i = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          r.once("block", i);
        } catch (o) {
          a(o);
        }
      };
      i();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return ln(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), r9(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), s9(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, n, r) {
    n == null && (n = 0), r == null && (r = "latest");
    const { addr: s, addrPromise: a } = ln(this), i = s || await a, { fragment: o, topics: c } = await Ig(this, e), u = { address: i, topics: c, fromBlock: n, toBlock: r }, l = $a(this.runner);
    return j(l, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await l.getLogs(u)).map((d) => {
      let m = o;
      if (m == null)
        try {
          m = this.interface.getEvent(d.topics[0]);
        } catch {
        }
      if (m)
        try {
          return new Og(d, this.interface, m);
        } catch (h) {
          return new Tk(d, h);
        }
      return new ed(d, l);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, n) {
    const r = await RE(this, "on", e);
    return r.listeners.push({ listener: n, once: !1 }), r.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, n) {
    const r = await RE(this, "once", e);
    return r.listeners.push({ listener: n, once: !0 }), r.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...n) {
    return await P0(this, e, n, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const s = await Nl(this, e);
      return s ? s.listeners.length : 0;
    }
    const { subs: n } = ln(this);
    let r = 0;
    for (const { listeners: s } of n.values())
      r += s.length;
    return r;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const s = await Nl(this, e);
      return s ? s.listeners.map(({ listener: a }) => a) : [];
    }
    const { subs: n } = ln(this);
    let r = [];
    for (const { listeners: s } of n.values())
      r = r.concat(s.map(({ listener: a }) => a));
    return r;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, n) {
    const r = await Nl(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (n == null || r.listeners.length === 0) && (r.stop(), ln(this).subs.delete(r.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const n = await Nl(this, e);
      if (!n)
        return this;
      n.stop(), ln(this).subs.delete(n.tag);
    } else {
      const { subs: n } = ln(this);
      for (const { tag: r, stop: s } of n.values())
        s(), n.delete(r);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, n) {
    return await this.on(e, n);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, n) {
    return await this.off(e, n);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class n extends tu {
      constructor(s, a = null) {
        super(s, e, a);
      }
    }
    return n;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, n, r) {
    return r == null && (r = null), new this(e, n, r);
  }
};
let U0 = tu;
function c9() {
  return U0;
}
class Rr extends c9() {
}
function om(t) {
  return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : S(!1, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`;
}
class l9 {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    /**
     *  The name.
     */
    R(this, "name");
    oe(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
}
const Rk = new RegExp("^(ipfs)://(.*)$", "i"), FE = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  Rk,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var ea, yi, ta, uo, Cp, Fk;
const Eo = class Eo {
  constructor(e, n, r) {
    T(this, ta);
    /**
     *  The connected provider.
     */
    R(this, "provider");
    /**
     *  The address of the resolver.
     */
    R(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    R(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    T(this, ea);
    T(this, yi);
    oe(this, { provider: e, address: n, name: r }), E(this, ea, null), E(this, yi, new Rr(n, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return p(this, ea) == null && E(this, ea, (async () => {
      try {
        return await p(this, yi).supportsInterface("0x9061b923");
      } catch (e) {
        if (mt(e, "CALL_EXCEPTION"))
          return !1;
        throw E(this, ea, null), e;
      }
    })()), await p(this, ea);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const a = await _(this, ta, uo).call(this, "addr(bytes32)");
        return a == null || a === ka ? null : a;
      } catch (a) {
        if (mt(a, "CALL_EXCEPTION"))
          return null;
        throw a;
      }
    if (e >= 0 && e < 2147483648) {
      let a = e + 2147483648;
      const i = await _(this, ta, uo).call(this, "addr(bytes32,uint)", [a]);
      if (Ue(i, 20))
        return ue(i);
    }
    let n = null;
    for (const a of this.provider.plugins)
      if (a instanceof l9 && a.supportsCoinType(e)) {
        n = a;
        break;
      }
    if (n == null)
      return null;
    const r = await _(this, ta, uo).call(this, "addr(bytes32,uint)", [e]);
    if (r == null || r === "0x")
      return null;
    const s = await n.decodeAddress(e, r);
    if (s != null)
      return s;
    j(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: r }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const n = await _(this, ta, uo).call(this, "text(bytes32,string)", [e]);
    return n == null || n === "0x" ? null : n;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await _(this, ta, uo).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (n) {
      const s = n[1] === "e3010170" ? "ipfs" : "ipns", a = parseInt(n[4], 16);
      if (n[5].length === a * 2)
        return `${s}://${pS("0x" + n[2])}`;
    }
    const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64)
      return `bzz://${r[1]}`;
    j(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const n = await this.getText("avatar");
      if (n == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: n });
      for (let r = 0; r < FE.length; r++) {
        const s = n.match(FE[r]);
        if (s == null)
          continue;
        const a = s[1].toLowerCase();
        switch (a) {
          case "https":
          case "data":
            return e.push({ type: "url", value: n }), { linkage: e, url: n };
          case "ipfs": {
            const i = om(n);
            return e.push({ type: "ipfs", value: n }), e.push({ type: "url", value: i }), { linkage: e, url: i };
          }
          case "erc721":
          case "erc1155": {
            const i = a === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: a, value: n });
            const o = await this.getAddress();
            if (o == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return e.push({ type: `!${a}caip`, value: s[2] || "" }), { url: null, linkage: e };
            const u = c[1], l = new Rr(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (a === "erc721") {
              const y = await l.ownerOf(u);
              if (o !== y)
                return e.push({ type: "!owner", value: y }), { url: null, linkage: e };
              e.push({ type: "owner", value: y });
            } else if (a === "erc1155") {
              const y = await l.balanceOf(o, u);
              if (!y)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: y.toString() });
            }
            let d = await l[i](u);
            if (d == null || d === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: d }), a === "erc1155" && (d = d.replace("{id}", sr(u, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: d })), d.match(/^ipfs:/i) && (d = om(d)), e.push({ type: "metadata-url", value: d });
            let m = {};
            const h = await new Dr(d).send();
            h.assertOk();
            try {
              m = h.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: h.bodyText });
              } catch {
                const w = h.body;
                return w && e.push({ type: "!metadata", value: G(w) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!m)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(m) });
            let b = m.image;
            if (typeof b != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!b.match(/^(https:\/\/|data:)/i)) {
              if (b.match(Rk) == null)
                return e.push({ type: "!imageUrl-ipfs", value: b }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: b }), b = om(b);
            }
            return e.push({ type: "url", value: b }), { linkage: e, url: b };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const n = await e.getNetwork(), r = n.getPlugin("org.ethers.plugins.network.Ens");
    return j(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: n }
    }), r.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, n) {
    var s;
    let r = n;
    for (; ; ) {
      if (r === "" || r === "." || n !== "eth" && r === "eth")
        return null;
      const a = await _(s = Eo, Cp, Fk).call(s, e, r);
      if (a != null) {
        const i = new Eo(e, a, n);
        return r !== n && !await i.supportsWildcard() ? null : i;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
};
ea = new WeakMap(), yi = new WeakMap(), ta = new WeakSet(), uo = async function(e, n) {
  n = (n || []).slice();
  const r = p(this, yi).interface;
  n.unshift(O0(this.name));
  let s = null;
  await this.supportsWildcard() && (s = r.getFunction(e), j(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: e }
  }), n = [
    xB(this.name, 255),
    r.encodeFunctionData(s, n)
  ], e = "resolve(bytes,bytes)"), n.push({
    enableCcipRead: !0
  });
  try {
    const a = await p(this, yi)[e](...n);
    return s ? r.decodeFunctionResult(s, a)[0] : a;
  } catch (a) {
    if (!mt(a, "CALL_EXCEPTION"))
      throw a;
  }
  return null;
}, Cp = new WeakSet(), Fk = async function(e, n) {
  const r = await Eo.getEnsAddress(e);
  try {
    const a = await new Rr(r, [
      "function resolver(bytes32) view returns (address)"
    ], e).resolver(O0(n), {
      enableCcipRead: !0
    });
    return a === ka ? null : a;
  } catch (s) {
    throw s;
  }
  return null;
}, T(Eo, Cp);
let Wf = Eo;
const DE = BigInt(0);
function Ce(t, e) {
  return function(n) {
    return n == null ? e : t(n);
  };
}
function pu(t, e) {
  return (n) => {
    if (e && n == null)
      return null;
    if (!Array.isArray(n))
      throw new Error("not an array");
    return n.map((r) => t(r));
  };
}
function td(t, e) {
  return (n) => {
    const r = {};
    for (const s in t) {
      let a = s;
      if (e && s in e && !(a in n)) {
        for (const i of e[s])
          if (i in n) {
            a = i;
            break;
          }
      }
      try {
        const i = t[s](n[a]);
        i !== void 0 && (r[s] = i);
      } catch (i) {
        const o = i instanceof Error ? i.message : "not-an-error";
        j(!1, `invalid value for value.${s} (${o})`, "BAD_DATA", { value: n });
      }
    }
    return r;
  };
}
function u9(t) {
  switch (t) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  S(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
}
function Mc(t) {
  return S(Ue(t, !0), "invalid data", "value", t), t;
}
function ft(t) {
  return S(Ue(t, 32), "invalid hash", "value", t), t;
}
const d9 = td({
  address: ue,
  blockHash: ft,
  blockNumber: we,
  data: Mc,
  index: we,
  removed: Ce(u9, !1),
  topics: pu(ft),
  transactionHash: ft,
  transactionIndex: we
}, {
  index: ["logIndex"]
});
function f9(t) {
  return d9(t);
}
const p9 = td({
  hash: Ce(ft),
  parentHash: ft,
  parentBeaconBlockRoot: Ce(ft, null),
  number: we,
  timestamp: we,
  nonce: Ce(Mc),
  difficulty: ne,
  gasLimit: ne,
  gasUsed: ne,
  stateRoot: Ce(ft, null),
  receiptsRoot: Ce(ft, null),
  blobGasUsed: Ce(ne, null),
  excessBlobGas: Ce(ne, null),
  miner: Ce(ue),
  prevRandao: Ce(ft, null),
  extraData: Mc,
  baseFeePerGas: Ce(ne)
}, {
  prevRandao: ["mixHash"]
});
function h9(t) {
  const e = p9(t);
  return e.transactions = t.transactions.map((n) => typeof n == "string" ? n : Dk(n)), e;
}
const m9 = td({
  transactionIndex: we,
  blockNumber: we,
  transactionHash: ft,
  address: ue,
  topics: pu(ft),
  data: Mc,
  index: we,
  blockHash: ft
}, {
  index: ["logIndex"]
});
function y9(t) {
  return m9(t);
}
const b9 = td({
  to: Ce(ue, null),
  from: Ce(ue, null),
  contractAddress: Ce(ue, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: we,
  root: Ce(G),
  gasUsed: ne,
  blobGasUsed: Ce(ne, null),
  logsBloom: Ce(Mc),
  blockHash: ft,
  hash: ft,
  logs: pu(y9),
  blockNumber: we,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: ne,
  effectiveGasPrice: Ce(ne),
  blobGasPrice: Ce(ne, null),
  status: Ce(we),
  type: Ce(we, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function g9(t) {
  return b9(t);
}
function Dk(t) {
  t.to && ne(t.to) === DE && (t.to = "0x0000000000000000000000000000000000000000");
  const e = td({
    hash: ft,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: Ce(we, void 0),
    type: (n) => n === "0x" || n == null ? 0 : we(n),
    accessList: Ce(eo, null),
    blobVersionedHashes: Ce(pu(ft, !0), null),
    authorizationList: Ce(pu((n) => {
      let r;
      if (n.signature)
        r = n.signature;
      else {
        let s = n.yParity;
        s === "0x1b" ? s = 0 : s === "0x1c" && (s = 1), r = Object.assign({}, n, { yParity: s });
      }
      return {
        address: ue(n.address),
        chainId: ne(n.chainId),
        nonce: ne(n.nonce),
        signature: tn.from(r)
      };
    }, !1), null),
    blockHash: Ce(ft, null),
    blockNumber: Ce(we, null),
    transactionIndex: Ce(we, null),
    from: ue,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: Ce(ne),
    maxPriorityFeePerGas: Ce(ne),
    maxFeePerGas: Ce(ne),
    maxFeePerBlobGas: Ce(ne, null),
    gasLimit: ne,
    to: Ce(ue, null),
    value: ne,
    nonce: we,
    data: Mc,
    creates: Ce(ue, null),
    chainId: Ce(ne, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(t);
  if (e.to == null && e.creates == null && (e.creates = sO(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = tn.from(t.signature) : e.signature = tn.from(t), e.chainId == null) {
    const n = e.signature.legacyChainId;
    n != null && (e.chainId = n);
  }
  return e.blockHash && ne(e.blockHash) === DE && (e.blockHash = null), e;
}
const w9 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class nd {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    R(this, "name");
    oe(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new nd(this.name);
  }
}
class _p extends nd {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(n, r) {
    n == null && (n = 0);
    super(`org.ethers.network.plugins.GasCost#${n || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    R(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    R(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    R(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    R(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    R(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    R(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    R(this, "txAccessListAddress");
    const s = { effectiveBlock: n };
    function a(i, o) {
      let c = (r || {})[i];
      c == null && (c = o), S(typeof c == "number", `invalud value for ${i}`, "costs", r), s[i] = c;
    }
    a("txBase", 21e3), a("txCreate", 32e3), a("txDataZero", 4), a("txDataNonzero", 16), a("txAccessListStorageKey", 1900), a("txAccessListAddress", 2400), oe(this, s);
  }
  clone() {
    return new _p(this.effectiveBlock, this);
  }
}
class Gp extends nd {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    R(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    R(this, "targetNetwork");
    oe(this, {
      address: n || w9,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new Gp(this.address, this.targetNetwork);
  }
}
var Vu, ju;
class E9 extends nd {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    T(this, Vu);
    T(this, ju);
    E(this, Vu, n), E(this, ju, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return p(this, Vu);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return p(this, ju);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
Vu = new WeakMap(), ju = new WeakMap();
const cm = /* @__PURE__ */ new Map();
var bc, gc, na;
const xo = class xo {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, n) {
    T(this, bc);
    T(this, gc);
    T(this, na);
    E(this, bc, e), E(this, gc, ne(n)), E(this, na, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return p(this, bc);
  }
  set name(e) {
    E(this, bc, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return p(this, gc);
  }
  set chainId(e) {
    E(this, gc, ne(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === ne(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === ne(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === ne(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(p(this, na).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (p(this, na).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return p(this, na).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return p(this, na).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((n) => n.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new xo(this.name, this.chainId);
    return this.plugins.forEach((n) => {
      e.attachPlugin(n.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new _p();
    let r = n.txBase;
    if (e.to == null && (r += n.txCreate), e.data)
      for (let s = 2; s < e.data.length; s += 2)
        e.data.substring(s, s + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
    if (e.accessList) {
      const s = eo(e.accessList);
      for (const a in s)
        r += n.txAccessListAddress + n.txAccessListStorageKey * s[a].storageKeys.length;
    }
    return r;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (x9(), e == null)
      return xo.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const n = cm.get(e);
      if (n)
        return n();
      if (typeof e == "bigint")
        return new xo("unknown", e);
      S(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      S(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const n = new xo(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new Gp(e.ensAddress, e.ensNetwork)), n;
    }
    S(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, n) {
    typeof e == "number" && (e = BigInt(e));
    const r = cm.get(e);
    r && S(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), cm.set(e, n);
  }
};
bc = new WeakMap(), gc = new WeakMap(), na = new WeakMap();
let rr = xo;
function ME(t, e) {
  const n = String(t);
  if (!n.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${t}`);
  const r = n.split(".");
  if (r.length === 1 && r.push(""), r.length !== 2)
    throw new Error(`invalid gwei value: ${t}`);
  for (; r[1].length < e; )
    r[1] += "0";
  if (r[1].length > 9) {
    let s = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || s++, r[1] = s.toString();
  }
  return BigInt(r[0] + r[1]);
}
function LE(t) {
  return new E9(t, async (e, n, r) => {
    r.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [a, i] = await Promise.all([
        r.send(),
        e()
      ]);
      s = a;
      const o = s.bodyJson.standard;
      return {
        gasPrice: i.gasPrice,
        maxFeePerGas: ME(o.maxFee, 9),
        maxPriorityFeePerGas: ME(o.maxPriorityFee, 9)
      };
    } catch (a) {
      j(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", { request: r, response: s, error: a });
    }
  });
}
let HE = !1;
function x9() {
  if (HE)
    return;
  HE = !0;
  function t(e, n, r) {
    const s = function() {
      const a = new rr(e, n);
      return r.ensNetwork != null && a.attachPlugin(new Gp(null, r.ensNetwork)), a.attachPlugin(new _p()), (r.plugins || []).forEach((i) => {
        a.attachPlugin(i);
      }), a;
    };
    rr.register(e, s), rr.register(n, s), r.altNames && r.altNames.forEach((a) => {
      rr.register(a, s);
    });
  }
  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), t("ropsten", 3, { ensNetwork: 3 }), t("rinkeby", 4, { ensNetwork: 4 }), t("goerli", 5, { ensNetwork: 5 }), t("kovan", 42, { ensNetwork: 42 }), t("sepolia", 11155111, { ensNetwork: 11155111 }), t("holesky", 17e3, { ensNetwork: 17e3 }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
    ensNetwork: 1
  }), t("arbitrum-goerli", 421613, {}), t("arbitrum-sepolia", 421614, {}), t("base", 8453, { ensNetwork: 1 }), t("base-goerli", 84531, {}), t("base-sepolia", 84532, {}), t("bnb", 56, { ensNetwork: 1 }), t("bnbt", 97, {}), t("linea", 59144, { ensNetwork: 1 }), t("linea-goerli", 59140, {}), t("linea-sepolia", 59141, {}), t("matic", 137, {
    ensNetwork: 1,
    plugins: [
      LE("https://gasstation.polygon.technology/v2")
    ]
  }), t("matic-amoy", 80002, {}), t("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      LE("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), t("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), t("optimism-goerli", 420, {}), t("optimism-sepolia", 11155420, {}), t("xdai", 100, { ensNetwork: 1 });
}
function N0(t) {
  return JSON.parse(JSON.stringify(t));
}
var is, In, ra, Br, wc, wf;
class A9 {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    T(this, wc);
    T(this, is);
    T(this, In);
    T(this, ra);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    T(this, Br);
    E(this, is, e), E(this, In, null), E(this, ra, 4e3), E(this, Br, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return p(this, ra);
  }
  set pollingInterval(e) {
    E(this, ra, e);
  }
  start() {
    p(this, In) || (E(this, In, p(this, is)._setTimeout(_(this, wc, wf).bind(this), p(this, ra))), _(this, wc, wf).call(this));
  }
  stop() {
    p(this, In) && (p(this, is)._clearTimeout(p(this, In)), E(this, In, null));
  }
  pause(e) {
    this.stop(), e && E(this, Br, -2);
  }
  resume() {
    this.start();
  }
}
is = new WeakMap(), In = new WeakMap(), ra = new WeakMap(), Br = new WeakMap(), wc = new WeakSet(), wf = async function() {
  try {
    const e = await p(this, is).getBlockNumber();
    if (p(this, Br) === -2) {
      E(this, Br, e);
      return;
    }
    if (e !== p(this, Br)) {
      for (let n = p(this, Br) + 1; n <= e; n++) {
        if (p(this, In) == null)
          return;
        await p(this, is).emit("block", n);
      }
      E(this, Br, e);
    }
  } catch {
  }
  p(this, In) != null && E(this, In, p(this, is)._setTimeout(_(this, wc, wf).bind(this), p(this, ra)));
};
var bi, gi, sa;
class Pg {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    T(this, bi);
    T(this, gi);
    T(this, sa);
    E(this, bi, e), E(this, sa, !1), E(this, gi, (n) => {
      this._poll(n, p(this, bi));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, n) {
    throw new Error("sub-classes must override this");
  }
  start() {
    p(this, sa) || (E(this, sa, !0), p(this, gi).call(this, -2), p(this, bi).on("block", p(this, gi)));
  }
  stop() {
    p(this, sa) && (E(this, sa, !1), p(this, bi).off("block", p(this, gi)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
bi = new WeakMap(), gi = new WeakMap(), sa = new WeakMap();
var Ec, os;
class k9 extends Pg {
  constructor(n, r) {
    super(n);
    T(this, Ec);
    T(this, os);
    E(this, Ec, r), E(this, os, -2);
  }
  pause(n) {
    n && E(this, os, -2), super.pause(n);
  }
  async _poll(n, r) {
    const s = await r.getBlock(p(this, Ec));
    s != null && (p(this, os) === -2 ? E(this, os, s.number) : s.number > p(this, os) && (r.emit(p(this, Ec), s.number), E(this, os, s.number)));
  }
}
Ec = new WeakMap(), os = new WeakMap();
var Tp;
class v9 extends Pg {
  constructor(n, r) {
    super(n);
    T(this, Tp);
    E(this, Tp, N0(r));
  }
  async _poll(n, r) {
    throw new Error("@TODO");
  }
}
Tp = new WeakMap();
var xc;
class C9 extends Pg {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(n, r) {
    super(n);
    T(this, xc);
    E(this, xc, r);
  }
  async _poll(n, r) {
    const s = await r.getTransactionReceipt(p(this, xc));
    s && r.emit(p(this, xc), s);
  }
}
xc = new WeakMap();
var cs, Ac, kc, aa, Pn, Sp, Mk;
class Ug {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, n) {
    T(this, Sp);
    T(this, cs);
    T(this, Ac);
    T(this, kc);
    T(this, aa);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    T(this, Pn);
    E(this, cs, e), E(this, Ac, N0(n)), E(this, kc, _(this, Sp, Mk).bind(this)), E(this, aa, !1), E(this, Pn, -2);
  }
  start() {
    p(this, aa) || (E(this, aa, !0), p(this, Pn) === -2 && p(this, cs).getBlockNumber().then((e) => {
      E(this, Pn, e);
    }), p(this, cs).on("block", p(this, kc)));
  }
  stop() {
    p(this, aa) && (E(this, aa, !1), p(this, cs).off("block", p(this, kc)));
  }
  pause(e) {
    this.stop(), e && E(this, Pn, -2);
  }
  resume() {
    this.start();
  }
}
cs = new WeakMap(), Ac = new WeakMap(), kc = new WeakMap(), aa = new WeakMap(), Pn = new WeakMap(), Sp = new WeakSet(), Mk = async function(e) {
  if (p(this, Pn) === -2)
    return;
  const n = N0(p(this, Ac));
  n.fromBlock = p(this, Pn) + 1, n.toBlock = e;
  const r = await p(this, cs).getLogs(n);
  if (r.length === 0) {
    p(this, Pn) < e - 60 && E(this, Pn, e - 60);
    return;
  }
  for (const s of r)
    p(this, cs).emit(p(this, Ac), s), E(this, Pn, s.blockNumber);
};
const T9 = BigInt(2), S9 = 10;
function Bd(t) {
  return t && typeof t.then == "function";
}
function Ef(t, e) {
  return t + ":" + JSON.stringify(e, (n, r) => {
    if (r == null)
      return "null";
    if (typeof r == "bigint")
      return `bigint:${r.toString()}`;
    if (typeof r == "string")
      return r.toLowerCase();
    if (typeof r == "object" && !Array.isArray(r)) {
      const s = Object.keys(r);
      return s.sort(), s.reduce((a, i) => (a[i] = r[i], a), {});
    }
    return r;
  });
}
class Lk {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    /**
     *  The name fof the event.
     */
    R(this, "name");
    oe(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function O9(t) {
  return JSON.parse(JSON.stringify(t));
}
function R0(t) {
  return t = Array.from(new Set(t).values()), t.sort(), t;
}
async function lm(t, e) {
  if (t == null)
    throw new Error("invalid event");
  if (Array.isArray(t) && (t = { topics: t }), typeof t == "string")
    switch (t) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: t, tag: t };
    }
  if (Ue(t, 32)) {
    const n = t.toLowerCase();
    return { type: "transaction", tag: Ef("tx", { hash: n }), hash: n };
  }
  if (t.orphan) {
    const n = t;
    return { type: "orphan", tag: Ef("orphan", n), filter: O9(n) };
  }
  if (t.address || t.topics) {
    const n = t, r = {
      topics: (n.topics || []).map((s) => s == null ? null : Array.isArray(s) ? R0(s.map((a) => a.toLowerCase())) : s.toLowerCase())
    };
    if (n.address) {
      const s = [], a = [], i = (o) => {
        Ue(o) ? s.push(o) : a.push((async () => {
          s.push(await Vt(o, e));
        })());
      };
      Array.isArray(n.address) ? n.address.forEach(i) : i(n.address), a.length && await Promise.all(a), r.address = R0(s.map((o) => o.toLowerCase()));
    }
    return { filter: r, tag: Ef("event", r), type: "event" };
  }
  S(!1, "unknown ProviderEvent", "event", t);
}
function um() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const B9 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var At, ia, kt, vc, pn, wi, oa, ls, qu, Un, Cc, Tc, ge, cn, F0, D0, Rl, M0, Fl, xf;
class I9 {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, n) {
    T(this, ge);
    T(this, At);
    T(this, ia);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    T(this, kt);
    T(this, vc);
    T(this, pn);
    T(this, wi);
    T(this, oa);
    // The most recent block number if running an event or -1 if no "block" event
    T(this, ls);
    T(this, qu);
    T(this, Un);
    T(this, Cc);
    T(this, Tc);
    if (E(this, Tc, Object.assign({}, B9, n || {})), e === "any")
      E(this, wi, !0), E(this, pn, null);
    else if (e) {
      const r = rr.from(e);
      E(this, wi, !1), E(this, pn, Promise.resolve(r)), setTimeout(() => {
        this.emit("network", r, null);
      }, 0);
    } else
      E(this, wi, !1), E(this, pn, null);
    E(this, ls, -1), E(this, oa, /* @__PURE__ */ new Map()), E(this, At, /* @__PURE__ */ new Map()), E(this, ia, /* @__PURE__ */ new Map()), E(this, kt, null), E(this, vc, !1), E(this, qu, 1), E(this, Un, /* @__PURE__ */ new Map()), E(this, Cc, !1);
  }
  get pollingInterval() {
    return p(this, Tc).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(p(this, ia).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (p(this, ia).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return p(this, ia).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return p(this, ia).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return p(this, Cc);
  }
  set disableCcipRead(e) {
    E(this, Cc, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, n, r) {
    if (this.disableCcipRead || r.length === 0 || e.to == null)
      return null;
    const s = e.to.toLowerCase(), a = n.toLowerCase(), i = [];
    for (let o = 0; o < r.length; o++) {
      const c = r[o], u = c.replace("{sender}", s).replace("{data}", a), l = new Dr(u);
      c.indexOf("{data}") === -1 && (l.body = { data: a, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: l, index: o, urls: r });
      let d = "unknown error", m;
      try {
        m = await l.send();
      } catch (h) {
        i.push(h.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: { error: h } });
        continue;
      }
      try {
        const h = m.bodyJson;
        if (h.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: l, result: h }), h.data;
        h.message && (d = h.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: h });
      } catch {
      }
      j(m.statusCode < 400 || m.statusCode >= 500, `response not found during CCIP fetch: ${d}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: c, errorMessage: d } }), i.push(d);
    }
    j(!1, `error encountered during CCIP fetch: ${i.map((o) => JSON.stringify(o)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: r, errorMessages: i }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, n) {
    return new QB(h9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, n) {
    return new ed(f9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, n) {
    return new kk(g9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, n) {
    return new fu(Dk(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    j(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    j(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = we(await _(this, ge, cn).call(this, { method: "getBlockNumber" }), "%response");
    return p(this, ls) >= 0 && E(this, ls, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return Vt(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (Ue(e))
      return Ue(e, 32) ? e : er(e);
    if (typeof e == "bigint" && (e = we(e, "blockTag")), typeof e == "number")
      return e >= 0 ? er(e) : p(this, ls) >= 0 ? er(p(this, ls) + e) : this.getBlockNumber().then((n) => er(n + e));
    S(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const n = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? R0(c.map((u) => u.toLowerCase())) : c.toLowerCase()), r = "blockHash" in e ? e.blockHash : void 0, s = (c, u, l) => {
      let d;
      switch (c.length) {
        case 0:
          break;
        case 1:
          d = c[0];
          break;
        default:
          c.sort(), d = c;
      }
      if (r && (u != null || l != null))
        throw new Error("invalid filter");
      const m = {};
      return d && (m.address = d), n.length && (m.topics = n), u && (m.fromBlock = u), l && (m.toBlock = l), r && (m.blockHash = r), m;
    };
    let a = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const c of e.address)
          a.push(this._getAddress(c));
      else
        a.push(this._getAddress(e.address));
    let i;
    "fromBlock" in e && (i = this._getBlockTag(e.fromBlock));
    let o;
    return "toBlock" in e && (o = this._getBlockTag(e.toBlock)), a.filter((c) => typeof c != "string").length || i != null && typeof i != "string" || o != null && typeof o != "string" ? Promise.all([Promise.all(a), i, o]).then((c) => s(c[0], c[1], c[2])) : s(a, i, o);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const n = qf(e), r = [];
    if (["to", "from"].forEach((s) => {
      if (n[s] == null)
        return;
      const a = Vt(n[s], this);
      Bd(a) ? r.push(async function() {
        n[s] = await a;
      }()) : n[s] = a;
    }), n.blockTag != null) {
      const s = this._getBlockTag(n.blockTag);
      Bd(s) ? r.push(async function() {
        n.blockTag = await s;
      }()) : n.blockTag = s;
    }
    return r.length ? async function() {
      return await Promise.all(r), n;
    }() : n;
  }
  async getNetwork() {
    if (p(this, pn) == null) {
      const s = (async () => {
        try {
          const a = await this._detectNetwork();
          return this.emit("network", a, null), a;
        } catch (a) {
          throw p(this, pn) === s && E(this, pn, null), a;
        }
      })();
      return E(this, pn, s), (await s).clone();
    }
    const e = p(this, pn), [n, r] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return n.chainId !== r.chainId && (p(this, wi) ? (this.emit("network", r, n), p(this, pn) === e && E(this, pn, Promise.resolve(r))) : j(!1, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), n.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), n = async () => {
      const { _block: s, gasPrice: a, priorityFee: i } = await dt({
        _block: _(this, ge, M0).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const l = await _(this, ge, cn).call(this, { method: "getGasPrice" });
            return ne(l, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const l = await _(this, ge, cn).call(this, { method: "getPriorityFee" });
            return ne(l, "%response");
          } catch {
          }
          return null;
        })()
      });
      let o = null, c = null;
      const u = this._wrapBlock(s, e);
      return u && u.baseFeePerGas && (c = i ?? BigInt("1000000000"), o = u.baseFeePerGas * T9 + c), new UE(a, o, c);
    }, r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const s = new Dr(r.url), a = await r.processFunc(n, this, s);
      return new UE(a.gasPrice, a.maxFeePerGas, a.maxPriorityFeePerGas);
    }
    return await n();
  }
  async estimateGas(e) {
    let n = this._getTransactionRequest(e);
    return Bd(n) && (n = await n), ne(await _(this, ge, cn).call(this, {
      method: "estimateGas",
      transaction: n
    }), "%response");
  }
  async call(e) {
    const { tx: n, blockTag: r } = await dt({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await _(this, ge, D0).call(this, _(this, ge, F0).call(this, n, r, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, n) {
    return ne(await _(this, ge, Rl).call(this, { method: "getBalance" }, e, n), "%response");
  }
  async getTransactionCount(e, n) {
    return we(await _(this, ge, Rl).call(this, { method: "getTransactionCount" }, e, n), "%response");
  }
  async getCode(e, n) {
    return G(await _(this, ge, Rl).call(this, { method: "getCode" }, e, n));
  }
  async getStorage(e, n, r) {
    const s = ne(n, "position");
    return G(await _(this, ge, Rl).call(this, { method: "getStorage", position: s }, e, r));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: n, hash: r, network: s } = await dt({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), a = $f.from(e);
    if (a.hash !== r)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(a, s).replaceableTransaction(n);
  }
  // Queries
  async getBlock(e, n) {
    const { network: r, params: s } = await dt({
      network: this.getNetwork(),
      params: _(this, ge, M0).call(this, e, !!n)
    });
    return s == null ? null : this._wrapBlock(s, r);
  }
  async getTransaction(e) {
    const { network: n, params: r } = await dt({
      network: this.getNetwork(),
      params: _(this, ge, cn).call(this, { method: "getTransaction", hash: e })
    });
    return r == null ? null : this._wrapTransactionResponse(r, n);
  }
  async getTransactionReceipt(e) {
    const { network: n, params: r } = await dt({
      network: this.getNetwork(),
      params: _(this, ge, cn).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (r == null)
      return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const s = await _(this, ge, cn).call(this, { method: "getTransaction", hash: e });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(r, n);
  }
  async getTransactionResult(e) {
    const { result: n } = await dt({
      network: this.getNetwork(),
      result: _(this, ge, cn).call(this, { method: "getTransactionResult", hash: e })
    });
    return n == null ? null : G(n);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let n = this._getFilter(e);
    Bd(n) && (n = await n);
    const { network: r, params: s } = await dt({
      network: this.getNetwork(),
      params: _(this, ge, cn).call(this, { method: "getLogs", filter: n })
    });
    return s.map((a) => this._wrapLog(a, r));
  }
  // ENS
  _getProvider(e) {
    j(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await Wf.fromName(this, e);
  }
  async getAvatar(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAvatar() : null;
  }
  async resolveName(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAddress() : null;
  }
  async lookupAddress(e) {
    e = ue(e);
    const n = O0(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await Wf.getEnsAddress(this), a = await new Rr(r, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(n);
      if (a == null || a === ka)
        return null;
      const o = await new Rr(a, [
        "function name(bytes32) view returns (string)"
      ], this).name(n);
      return await this.resolveName(o) !== e ? null : o;
    } catch (r) {
      if (mt(r, "BAD_DATA") && r.value === "0x" || mt(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(e, n, r) {
    const s = n ?? 1;
    return s === 0 ? this.getTransactionReceipt(e) : new Promise(async (a, i) => {
      let o = null;
      const c = async (u) => {
        try {
          const l = await this.getTransactionReceipt(e);
          if (l != null && u - l.blockNumber + 1 >= s) {
            a(l), o && (clearTimeout(o), o = null);
            return;
          }
        } catch (l) {
          console.log("EEE", l);
        }
        this.once("block", c);
      };
      r != null && (o = setTimeout(() => {
        o != null && (o = null, this.off("block", c), i(Ge("timeout", "TIMEOUT", { reason: "timeout" })));
      }, r)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    j(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const n = p(this, Un).get(e);
    n && (n.timer && clearTimeout(n.timer), p(this, Un).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, n) {
    n == null && (n = 0);
    const r = Ss(this, qu)._++, s = () => {
      p(this, Un).delete(r), e();
    };
    if (this.paused)
      p(this, Un).set(r, { timer: null, func: s, time: n });
    else {
      const a = setTimeout(s, n);
      p(this, Un).set(r, { timer: a, func: s, time: um() });
    }
    return r;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const n of p(this, At).values())
      e(n.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new Lk(e.type);
      case "block": {
        const n = new A9(this);
        return n.pollingInterval = this.pollingInterval, n;
      }
      case "safe":
      case "finalized":
        return new k9(this, e.type);
      case "event":
        return new Ug(this, e.filter);
      case "transaction":
        return new C9(this, e.hash);
      case "orphan":
        return new v9(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, n) {
    for (const r of p(this, At).values())
      if (r.subscriber === e) {
        r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), p(this, kt) != null && n.pause(p(this, kt));
        break;
      }
  }
  async on(e, n) {
    const r = await _(this, ge, xf).call(this, e);
    return r.listeners.push({ listener: n, once: !1 }), r.started || (r.subscriber.start(), r.started = !0, p(this, kt) != null && r.subscriber.pause(p(this, kt))), this;
  }
  async once(e, n) {
    const r = await _(this, ge, xf).call(this, e);
    return r.listeners.push({ listener: n, once: !0 }), r.started || (r.subscriber.start(), r.started = !0, p(this, kt) != null && r.subscriber.pause(p(this, kt))), this;
  }
  async emit(e, ...n) {
    const r = await _(this, ge, Fl).call(this, e, n);
    if (!r || r.listeners.length === 0)
      return !1;
    const s = r.listeners.length;
    return r.listeners = r.listeners.filter(({ listener: a, once: i }) => {
      const o = new q6(this, i ? null : a, e);
      try {
        a.call(this, ...n, o);
      } catch {
      }
      return !i;
    }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), p(this, At).delete(r.tag)), s > 0;
  }
  async listenerCount(e) {
    if (e) {
      const r = await _(this, ge, Fl).call(this, e);
      return r ? r.listeners.length : 0;
    }
    let n = 0;
    for (const { listeners: r } of p(this, At).values())
      n += r.length;
    return n;
  }
  async listeners(e) {
    if (e) {
      const r = await _(this, ge, Fl).call(this, e);
      return r ? r.listeners.map(({ listener: s }) => s) : [];
    }
    let n = [];
    for (const { listeners: r } of p(this, At).values())
      n = n.concat(r.map(({ listener: s }) => s));
    return n;
  }
  async off(e, n) {
    const r = await _(this, ge, Fl).call(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), p(this, At).delete(r.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: n, started: r, subscriber: s } = await _(this, ge, xf).call(this, e);
      r && s.stop(), p(this, At).delete(n);
    } else
      for (const [n, { started: r, subscriber: s }] of p(this, At))
        r && s.stop(), p(this, At).delete(n);
    return this;
  }
  // Alias for "on"
  async addListener(e, n) {
    return await this.on(e, n);
  }
  // Alias for "off"
  async removeListener(e, n) {
    return this.off(e, n);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return p(this, vc);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of p(this, Un).keys())
      this._clearTimeout(e);
    E(this, vc, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return p(this, kt) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (E(this, ls, -1), p(this, kt) != null) {
      if (p(this, kt) == !!e)
        return;
      j(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((n) => n.pause(e)), E(this, kt, !!e);
    for (const n of p(this, Un).values())
      n.timer && clearTimeout(n.timer), n.time = um() - n.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (p(this, kt) != null) {
      this._forEachSubscriber((e) => e.resume()), E(this, kt, null);
      for (const e of p(this, Un).values()) {
        let n = e.time;
        n < 0 && (n = 0), e.time = um(), setTimeout(e.func, n);
      }
    }
  }
}
At = new WeakMap(), ia = new WeakMap(), kt = new WeakMap(), vc = new WeakMap(), pn = new WeakMap(), wi = new WeakMap(), oa = new WeakMap(), ls = new WeakMap(), qu = new WeakMap(), Un = new WeakMap(), Cc = new WeakMap(), Tc = new WeakMap(), ge = new WeakSet(), cn = async function(e) {
  const n = p(this, Tc).cacheTimeout;
  if (n < 0)
    return await this._perform(e);
  const r = Ef(e.method, e);
  let s = p(this, oa).get(r);
  return s || (s = this._perform(e), p(this, oa).set(r, s), setTimeout(() => {
    p(this, oa).get(r) === s && p(this, oa).delete(r);
  }, n)), await s;
}, F0 = async function(e, n, r) {
  j(r < S9, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, e, { blockTag: n, enableCcipRead: !0 })
  });
  const s = qf(e);
  try {
    return G(await this._perform({ method: "call", transaction: s, blockTag: n }));
  } catch (a) {
    if (!this.disableCcipRead && hg(a) && a.data && r >= 0 && n === "latest" && s.to != null && ze(a.data, 0, 4) === "0x556f1830") {
      const i = a.data, o = await Vt(s.to, this);
      let c;
      try {
        c = F9(ze(a.data, 4));
      } catch (d) {
        j(!1, d.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: i }
        });
      }
      j(c.sender.toLowerCase() === o.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: i,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(s, c.calldata, c.urls);
      j(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: a.data, errorArgs: c.errorArgs }
      });
      const l = {
        to: o,
        data: Le([c.selector, R9([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: l });
      try {
        const d = await _(this, ge, F0).call(this, l, n, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, l), result: d }), d;
      } catch (d) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, l), error: d }), d;
      }
    }
    throw a;
  }
}, D0 = async function(e) {
  const { value: n } = await dt({
    network: this.getNetwork(),
    value: e
  });
  return n;
}, Rl = async function(e, n, r) {
  let s = this._getAddress(n), a = this._getBlockTag(r);
  return (typeof s != "string" || typeof a != "string") && ([s, a] = await Promise.all([s, a])), await _(this, ge, D0).call(this, _(this, ge, cn).call(this, Object.assign(e, { address: s, blockTag: a })));
}, M0 = async function(e, n) {
  if (Ue(e, 32))
    return await _(this, ge, cn).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: n
    });
  let r = this._getBlockTag(e);
  return typeof r != "string" && (r = await r), await _(this, ge, cn).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: n
  });
}, Fl = async function(e, n) {
  let r = await lm(e, this);
  return r.type === "event" && n && n.length > 0 && n[0].removed === !0 && (r = await lm({ orphan: "drop-log", log: n[0] }, this)), p(this, At).get(r.tag) || null;
}, xf = async function(e) {
  const n = await lm(e, this), r = n.tag;
  let s = p(this, At).get(r);
  return s || (s = { subscriber: this._getSubscriber(n), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, p(this, At).set(r, s)), s;
};
function P9(t, e) {
  try {
    const n = L0(t, e);
    if (n)
      return Mf(n);
  } catch {
  }
  return null;
}
function L0(t, e) {
  if (t === "0x")
    return null;
  try {
    const n = we(ze(t, e, e + 32)), r = we(ze(t, n, n + 32));
    return ze(t, n + 32, n + 32 + r);
  } catch {
  }
  return null;
}
function $E(t) {
  const e = rt(t);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const n = new Uint8Array(32);
  return n.set(e, 32 - e.length), n;
}
function U9(t) {
  if (t.length % 32 === 0)
    return t;
  const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
  return e.set(t), e;
}
const N9 = new Uint8Array([]);
function R9(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++)
    e.push(N9), n += 32;
  for (let r = 0; r < t.length; r++) {
    const s = J(t[r]);
    e[r] = $E(n), e.push($E(s.length)), e.push(U9(s)), n += 32 + Math.ceil(s.length / 32) * 32;
  }
  return Le(e);
}
const _E = "0x0000000000000000000000000000000000000000000000000000000000000000";
function F9(t) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  j(Ci(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const n = ze(t, 0, 32);
  j(ze(n, 0, 12) === ze(_E, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = ze(n, 12);
  try {
    const r = [], s = we(ze(t, 32, 64)), a = we(ze(t, s, s + 32)), i = ze(t, s + 32);
    for (let o = 0; o < a; o++) {
      const c = P9(i, o * 32);
      if (c == null)
        throw new Error("abort");
      r.push(c);
    }
    e.urls = r;
  } catch {
    j(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const r = L0(t, 64);
    if (r == null)
      throw new Error("abort");
    e.calldata = r;
  } catch {
    j(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  j(ze(t, 100, 128) === ze(_E, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = ze(t, 96, 100);
  try {
    const r = L0(t, 128);
    if (r == null)
      throw new Error("abort");
    e.extraData = r;
  } catch {
    j(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => e[r]), e;
}
function Ba(t, e) {
  if (t.provider)
    return t.provider;
  j(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function GE(t, e) {
  let n = qf(e);
  if (n.to != null && (n.to = Vt(n.to, t)), n.from != null) {
    const r = n.from;
    n.from = Promise.all([
      t.getAddress(),
      Vt(r, t)
    ]).then(([s, a]) => (S(s.toLowerCase() === a.toLowerCase(), "transaction from mismatch", "tx.from", a), s));
  } else
    n.from = t.getAddress();
  return await dt(n);
}
class Hk {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    /**
     *  The provider this signer is connected to.
     */
    R(this, "provider");
    oe(this, { provider: e || null });
  }
  async getNonce(e) {
    return Ba(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await GE(this, e);
  }
  async populateTransaction(e) {
    const n = Ba(this, "populateTransaction"), r = await GE(this, e);
    r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const s = await this.provider.getNetwork();
    if (r.chainId != null) {
      const i = ne(r.chainId);
      S(i === s.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      r.chainId = s.chainId;
    const a = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (r.gasPrice != null && (r.type === 2 || a) ? S(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && a && S(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const i = await n.getFeeData();
      j(i.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), r.gasPrice == null && (r.gasPrice = i.gasPrice);
    } else {
      const i = await n.getFeeData();
      if (r.type == null)
        if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
          if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, r.gasPrice != null) {
            const o = r.gasPrice;
            delete r.gasPrice, r.maxFeePerGas = o, r.maxPriorityFeePerGas = o;
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
        else i.gasPrice != null ? (j(!a, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : j(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
    }
    return await dt(r);
  }
  async populateAuthorization(e) {
    const n = Object.assign({}, e);
    return n.chainId == null && (n.chainId = (await Ba(this, "getNetwork").getNetwork()).chainId), n.nonce == null && (n.nonce = await this.getNonce()), n;
  }
  async estimateGas(e) {
    return Ba(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return Ba(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await Ba(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const n = Ba(this, "sendTransaction"), r = await this.populateTransaction(e);
    delete r.from;
    const s = $f.from(r);
    return await n.broadcastTransaction(await this.signTransaction(s));
  }
  // @TODO: in v7 move this to be abstract
  authorize(e) {
    j(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
function D9(t) {
  return JSON.parse(JSON.stringify(t));
}
var Lt, Ir, Ei, ca, xi, Sc, Sa, H0, $0;
class $k {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    T(this, Sa);
    T(this, Lt);
    T(this, Ir);
    T(this, Ei);
    T(this, ca);
    T(this, xi);
    T(this, Sc);
    E(this, Lt, e), E(this, Ir, null), E(this, Ei, _(this, Sa, H0).bind(this)), E(this, ca, !1), E(this, xi, null), E(this, Sc, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, n) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    p(this, ca) || (E(this, ca, !0), _(this, Sa, H0).call(this, -2));
  }
  stop() {
    p(this, ca) && (E(this, ca, !1), E(this, Sc, !0), _(this, Sa, $0).call(this), p(this, Lt).off("block", p(this, Ei)));
  }
  pause(e) {
    e && _(this, Sa, $0).call(this), p(this, Lt).off("block", p(this, Ei));
  }
  resume() {
    this.start();
  }
}
Lt = new WeakMap(), Ir = new WeakMap(), Ei = new WeakMap(), ca = new WeakMap(), xi = new WeakMap(), Sc = new WeakMap(), Sa = new WeakSet(), H0 = async function(e) {
  try {
    p(this, Ir) == null && E(this, Ir, this._subscribe(p(this, Lt)));
    let n = null;
    try {
      n = await p(this, Ir);
    } catch (a) {
      if (!mt(a, "UNSUPPORTED_OPERATION") || a.operation !== "eth_newFilter")
        throw a;
    }
    if (n == null) {
      E(this, Ir, null), p(this, Lt)._recoverSubscriber(this, this._recover(p(this, Lt)));
      return;
    }
    const r = await p(this, Lt).getNetwork();
    if (p(this, xi) || E(this, xi, r), p(this, xi).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (p(this, Sc))
      return;
    const s = await p(this, Lt).send("eth_getFilterChanges", [n]);
    await this._emitResults(p(this, Lt), s);
  } catch (n) {
    console.log("@TODO", n);
  }
  p(this, Lt).once("block", p(this, Ei));
}, $0 = function() {
  const e = p(this, Ir);
  e && (E(this, Ir, null), e.then((n) => {
    p(this, Lt).destroyed || p(this, Lt).send("eth_uninstallFilter", [n]);
  }));
};
var Ai;
class M9 extends $k {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(n, r) {
    super(n);
    T(this, Ai);
    E(this, Ai, D9(r));
  }
  _recover(n) {
    return new Ug(n, p(this, Ai));
  }
  async _subscribe(n) {
    return await n.send("eth_newFilter", [p(this, Ai)]);
  }
  async _emitResults(n, r) {
    for (const s of r)
      n.emit(p(this, Ai), n._wrapLog(s, n._network));
  }
}
Ai = new WeakMap();
class L9 extends $k {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, n) {
    for (const r of n)
      e.emit("pending", r);
  }
}
const H9 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Af(t) {
  if (t == null || H9.indexOf(typeof t) >= 0 || typeof t.getAddress == "function")
    return t;
  if (Array.isArray(t))
    return t.map(Af);
  if (typeof t == "object")
    return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
  throw new Error(`should not happen: ${t} (${typeof t})`);
}
function $9(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function so(t) {
  return t && t.toLowerCase();
}
function zE(t) {
  return t && typeof t.pollingInterval == "number";
}
const _k = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class dm extends Hk {
  constructor(n, r) {
    super(n);
    R(this, "address");
    r = ue(r), oe(this, { address: r });
  }
  connect(n) {
    j(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(n) {
    return await this.populateCall(n);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(n) {
    const r = Af(n), s = [];
    if (r.from) {
      const i = r.from;
      s.push((async () => {
        const o = await Vt(i, this.provider);
        S(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = o;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && s.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const i = r.to;
      s.push((async () => {
        r.to = await Vt(i, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const a = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [a]);
  }
  async sendTransaction(n) {
    const r = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(n);
    return await new Promise((a, i) => {
      const o = [1e3, 100];
      let c = 0;
      const u = async () => {
        try {
          const l = await this.provider.getTransaction(s);
          if (l != null) {
            a(l.replaceableTransaction(r));
            return;
          }
        } catch (l) {
          if (mt(l, "CANCELLED") || mt(l, "BAD_DATA") || mt(l, "NETWORK_ERROR") || mt(l, "UNSUPPORTED_OPERATION")) {
            l.info == null && (l.info = {}), l.info.sendTransactionHash = s, i(l);
            return;
          }
          if (mt(l, "INVALID_ARGUMENT") && (c++, l.info == null && (l.info = {}), l.info.sendTransactionHash = s, c > 10)) {
            i(l);
            return;
          }
          this.provider.emit("error", Ge("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: l }));
        }
        this.provider._setTimeout(() => {
          u();
        }, o.pop() || 4e3);
      };
      u();
    });
  }
  async signTransaction(n) {
    const r = Af(n);
    if (r.from) {
      const a = await Vt(r.from, this.provider);
      S(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = a;
    } else
      r.from = this.address;
    const s = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(n) {
    const r = typeof n == "string" ? en(n) : n;
    return await this.provider.send("personal_sign", [
      G(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(n, r, s) {
    const a = Af(s), i = await uu.resolveNames(n, r, a, async (o) => {
      const c = await Vt(o);
      return S(c != null, "TypedData does not support null address", "value", o), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(uu.getPayload(i.domain, r, i.value))
    ]);
  }
  async unlock(n) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      n,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(n) {
    const r = typeof n == "string" ? en(n) : n;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      G(r)
    ]);
  }
}
var ki, Oc, us, Pr, Yn, Nn, Jt, Ku, _0;
class _9 extends I9 {
  constructor(n, r) {
    super(n, r);
    T(this, Ku);
    T(this, ki);
    // The next ID to use for the JSON-RPC ID field
    T(this, Oc);
    // Payloads are queued and triggered in batches using the drainTimer
    T(this, us);
    T(this, Pr);
    T(this, Yn);
    T(this, Nn);
    T(this, Jt);
    E(this, Oc, 1), E(this, ki, Object.assign({}, _k, r || {})), E(this, us, []), E(this, Pr, null), E(this, Nn, null), E(this, Jt, null);
    {
      let a = null;
      const i = new Promise((o) => {
        a = o;
      });
      E(this, Yn, { promise: i, resolve: a });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (S(!s || n !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), s && n != null && E(this, Nn, rr.from(n))) : s && (S(n == null || s.matches(n), "staticNetwork MUST match network object", "options", r), E(this, Nn, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(n) {
    return p(this, ki)[n];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return j(p(this, Nn), "network is not available yet", "NETWORK_ERROR"), p(this, Nn);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(n) {
    if (n.method === "call" || n.method === "estimateGas") {
      let s = n.transaction;
      if (s && s.type != null && ne(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const a = await this.getFeeData();
        a.maxFeePerGas == null && a.maxPriorityFeePerGas == null && (n = Object.assign({}, n, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(n);
    return r != null ? await this.send(r.method, r.args) : super._perform(n);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const n = this._getOption("staticNetwork");
    if (n)
      if (n === !0) {
        if (p(this, Nn))
          return p(this, Nn);
      } else
        return n;
    return p(this, Jt) ? await p(this, Jt) : this.ready ? (E(this, Jt, (async () => {
      try {
        const r = rr.from(ne(await this.send("eth_chainId", [])));
        return E(this, Jt, null), r;
      } catch (r) {
        throw E(this, Jt, null), r;
      }
    })()), await p(this, Jt)) : (E(this, Jt, (async () => {
      const r = {
        id: Ss(this, Oc)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let s;
      try {
        s = (await this._send(r))[0], E(this, Jt, null);
      } catch (a) {
        throw E(this, Jt, null), this.emit("debug", { action: "receiveRpcError", error: a }), a;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return rr.from(ne(s.result));
      throw this.getRpcError(r, s);
    })()), await p(this, Jt));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    p(this, Yn) == null || p(this, Yn).resolve == null || (p(this, Yn).resolve(), E(this, Yn, null), (async () => {
      for (; p(this, Nn) == null && !this.destroyed; )
        try {
          E(this, Nn, await this._detectNetwork());
        } catch (n) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Ge("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: n } })), await $9(1e3);
        }
      _(this, Ku, _0).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (p(this, Yn) != null)
      return await p(this, Yn).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(n) {
    return n.type === "pending" ? new L9(this) : n.type === "event" ? this._getOption("polling") ? new Ug(this, n.filter) : new M9(this, n.filter) : n.type === "orphan" && n.filter.orphan === "drop-log" ? new Lk("orphan") : super._getSubscriber(n);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return p(this, Yn) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(n) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (n[s] == null)
        return;
      let a = s;
      s === "gasLimit" && (a = "gas"), r[a] = er(ne(n[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      n[s] != null && (r[s] = G(n[s]));
    }), n.accessList && (r.accessList = eo(n.accessList)), n.blobVersionedHashes && (r.blobVersionedHashes = n.blobVersionedHashes.map((s) => s.toLowerCase())), n.authorizationList && (r.authorizationList = n.authorizationList.map((s) => {
      const a = $A(s);
      return {
        address: a.address,
        nonce: er(a.nonce),
        chainId: er(a.chainId),
        yParity: er(a.signature.yParity),
        r: er(a.signature.r),
        s: er(a.signature.s)
      };
    })), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(n) {
    switch (n.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [so(n.address), n.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [so(n.address), n.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [so(n.address), n.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            so(n.address),
            "0x" + n.position.toString(16),
            n.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [n.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in n)
          return {
            method: "eth_getBlockByNumber",
            args: [n.blockTag, !!n.includeTransactions]
          };
        if ("blockHash" in n)
          return {
            method: "eth_getBlockByHash",
            args: [n.blockHash, !!n.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [n.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [n.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(n.transaction), n.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(n.transaction)]
        };
      case "getLogs":
        return n.filter && n.filter.address != null && (Array.isArray(n.filter.address) ? n.filter.address = n.filter.address.map(so) : n.filter.address = so(n.filter.address)), { method: "eth_getLogs", args: [n.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(n, r) {
    const { method: s } = n, { error: a } = r;
    if (s === "eth_estimateGas" && a.message) {
      const c = a.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return Ge("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
      if (c.match(/nonce/i) && c.match(/too low/i))
        return Ge("nonce has already been used", "NONCE_EXPIRED", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = G0(a), u = Ot.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", n.params[0], c ? c.data : null);
      return u.info = { error: a, payload: n }, u;
    }
    const i = JSON.stringify(z9(a));
    if (typeof a.message == "string" && a.message.match(/user denied|ethers-user-denied/i))
      return Ge("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: n, error: a }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = n.params[0];
      if (i.match(/insufficient funds|base fee exceeds gas limit/i))
        return Ge("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: a }
        });
      if (i.match(/nonce/i) && i.match(/too low/i))
        return Ge("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: a } });
      if (i.match(/replacement transaction/i) && i.match(/underpriced/i))
        return Ge("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: a } });
      if (i.match(/only replay-protected/i))
        return Ge("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: a } }
        });
    }
    let o = !!i.match(/the method .* does not exist/i);
    return o || a && a.details && a.details.startsWith("Unauthorized method:") && (o = !0), o ? Ge("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: n.method,
      info: { error: a, payload: n }
    }) : Ge("could not coalesce error", "UNKNOWN_ERROR", { error: a, payload: n });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(n, r) {
    if (this.destroyed)
      return Promise.reject(Ge("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n }));
    const s = Ss(this, Oc)._++, a = new Promise((i, o) => {
      p(this, us).push({
        resolve: i,
        reject: o,
        payload: { method: n, params: r, id: s, jsonrpc: "2.0" }
      });
    });
    return _(this, Ku, _0).call(this), a;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(n) {
    n == null && (n = 0);
    const r = this.send("eth_accounts", []);
    if (typeof n == "number") {
      const a = await r;
      if (n >= a.length)
        throw new Error("no such account");
      return new dm(this, a[n]);
    }
    const { accounts: s } = await dt({
      network: this.getNetwork(),
      accounts: r
    });
    n = ue(n);
    for (const a of s)
      if (ue(a) === n)
        return new dm(this, n);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((r) => new dm(this, r));
  }
  destroy() {
    p(this, Pr) && (clearTimeout(p(this, Pr)), E(this, Pr, null));
    for (const { payload: n, reject: r } of p(this, us))
      r(Ge("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n.method }));
    E(this, us, []), super.destroy();
  }
}
ki = new WeakMap(), Oc = new WeakMap(), us = new WeakMap(), Pr = new WeakMap(), Yn = new WeakMap(), Nn = new WeakMap(), Jt = new WeakMap(), Ku = new WeakSet(), _0 = function() {
  if (p(this, Pr))
    return;
  const n = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  E(this, Pr, setTimeout(() => {
    E(this, Pr, null);
    const r = p(this, us);
    for (E(this, us, []); r.length; ) {
      const s = [r.shift()];
      for (; r.length && s.length !== p(this, ki).batchMaxCount; )
        if (s.push(r.shift()), JSON.stringify(s.map((i) => i.payload)).length > p(this, ki).batchMaxSize) {
          r.unshift(s.pop());
          break;
        }
      (async () => {
        const a = s.length === 1 ? s[0].payload : s.map((i) => i.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: a });
        try {
          const i = await this._send(a);
          this.emit("debug", { action: "receiveRpcResult", result: i });
          for (const { resolve: o, reject: c, payload: u } of s) {
            if (this.destroyed) {
              c(Ge("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const l = i.filter((d) => d.id === u.id)[0];
            if (l == null) {
              const d = Ge("missing response for request", "BAD_DATA", {
                value: i,
                info: { payload: u }
              });
              this.emit("error", d), c(d);
              continue;
            }
            if ("error" in l) {
              c(this.getRpcError(u, l));
              continue;
            }
            o(l.result);
          }
        } catch (i) {
          this.emit("debug", { action: "receiveRpcError", error: i });
          for (const { reject: o } of s)
            o(i);
        }
      })();
    }
  }, n));
};
var la;
class G9 extends _9 {
  constructor(n, r) {
    super(n, r);
    T(this, la);
    let s = this._getOption("pollingInterval");
    s == null && (s = _k.pollingInterval), E(this, la, s);
  }
  _getSubscriber(n) {
    const r = super._getSubscriber(n);
    return zE(r) && (r.pollingInterval = p(this, la)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return p(this, la);
  }
  set pollingInterval(n) {
    if (!Number.isInteger(n) || n < 0)
      throw new Error("invalid interval");
    E(this, la, n), this._forEachSubscriber((r) => {
      zE(r) && (r.pollingInterval = p(this, la));
    });
  }
}
la = new WeakMap();
var Bc, F2;
let Ng = (F2 = class extends G9 {
  constructor(n, r, s) {
    n == null && (n = "http://localhost:8545");
    super(r, s);
    T(this, Bc);
    typeof n == "string" ? E(this, Bc, new Dr(n)) : E(this, Bc, n.clone());
  }
  _getConnection() {
    return p(this, Bc).clone();
  }
  async send(n, r) {
    return await this._start(), await super.send(n, r);
  }
  async _send(n) {
    const r = this._getConnection();
    r.body = JSON.stringify(n), r.setHeader("content-type", "application/json");
    const s = await r.send();
    s.assertOk();
    let a = s.bodyJson;
    return Array.isArray(a) || (a = [a]), a;
  }
}, Bc = new WeakMap(), F2);
function G0(t) {
  if (t == null)
    return null;
  if (typeof t.message == "string" && t.message.match(/revert/i) && Ue(t.data))
    return { message: t.message, data: t.data };
  if (typeof t == "object") {
    for (const e in t) {
      const n = G0(t[e]);
      if (n)
        return n;
    }
    return null;
  }
  if (typeof t == "string")
    try {
      return G0(JSON.parse(t));
    } catch {
    }
  return null;
}
function z0(t, e) {
  if (t != null) {
    if (typeof t.message == "string" && e.push(t.message), typeof t == "object")
      for (const n in t)
        z0(t[n], e);
    if (typeof t == "string")
      try {
        return z0(JSON.parse(t), e);
      } catch {
      }
  }
}
function z9(t) {
  const e = [];
  return z0(t, e), e;
}
const V9 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), V0 = (t) => {
  const e = t.toString(16);
  return `${e.length % 2 === 0 ? "0x" : "0x0"}${e}`;
}, Dl = (t, e) => typeof e == "bigint" ? {
  $bigint: e.toString()
} : e, j9 = (t, e, n) => xe(["string", "uint256", "address", "bytes32"], ["", e, t, n]), VE = (t, e, n) => ke(j9(t, e, n));
function Qf() {
  return Qf = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Qf.apply(null, arguments);
}
var Vn = /* @__PURE__ */ function(t) {
  return t[t.DEBUG = 1] = "DEBUG", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.DISABLED = 5] = "DISABLED", t;
}(Vn || {});
class q9 {
  constructor(e) {
    this.config = e, this.logLevel = void 0, this.configure(e);
  }
  configure(e) {
    switch (this.config = Qf({}, this.config, e), this.config.logLevel) {
      case "DEBUG":
        this.logLevel = Vn.DEBUG;
        break;
      case "INFO":
        this.logLevel = Vn.INFO;
        break;
      case "WARN":
        this.logLevel = Vn.WARN;
        break;
      case "ERROR":
        this.logLevel = Vn.ERROR;
        break;
      case "DISABLED":
        this.logLevel = Vn.DISABLED;
        break;
      default:
        this.logLevel = Vn.INFO;
        break;
    }
    this.config.silence === void 0 && (this.config.silence = !1);
  }
  debug(e, ...n) {
    this.config.silence !== !0 && this.logLevel === Vn.DEBUG && console.log(e, ...n);
  }
  info(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Vn.INFO && console.log(e, ...n);
  }
  warn(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Vn.WARN && (console.warn(e, ...n), this.config.onwarn && this.config.onwarn(e, n));
  }
  error(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Vn.ERROR && (console.error(e, ...n), this.config.onerror && this.config.onerror(e, n));
  }
}
const Gn = new q9({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: !0
}), Gk = (t, e, n) => {
  const r = new Dr(t);
  return n && r.setHeader("Authorization", `BEARER ${n}`), e && r.setHeader("X-Access-Key", e), r;
}, K9 = (t) => {
  const e = Qf({}, t.types);
  return delete e.EIP712Domain, uu.hash(t.domain, e, t.message);
}, zk = (t) => J(K9(t));
function Lc() {
  return Lc = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Lc.apply(null, arguments);
}
const W9 = (t, e = !1, n = !1) => {
  if (!t) throw new Error("invalid network config: empty config");
  const r = [];
  if (Array.isArray(t) ? r.push(...t) : r.push(t), r.length === 0) {
    if (e) throw new Error("invalid network config: empty config");
    return !1;
  }
  const s = r.map((u) => u.chainId).sort(), a = s.filter((u, l) => s.indexOf(u) !== l);
  if (a.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate chainIds ${a}`);
    return !1;
  }
  r.forEach((u) => u.name = u.name.toLowerCase());
  const i = r.map((u) => u.name).sort(), o = i.filter((u, l) => i.indexOf(u) !== l);
  if (o.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate network names ${o}`);
    return !1;
  }
  let c = !1;
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if ((!l.rpcUrl || l.rpcUrl === "") && !l.provider) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: rpcUrl or provider must be provided`);
      return !1;
    }
    if (!n && !l.relayer) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: relayer must be provided`);
      return !1;
    }
    if (l.isDefaultChain) {
      if (c) {
        if (e) throw new Error(`invalid network config for chainId ${l.chainId}: DefaultChain is already set by another config`);
        return !1;
      }
      c = !0;
    }
  }
  if (!c) {
    if (e) throw new Error("invalid network config: DefaultChain must be set");
    return !1;
  }
  return !0;
}, Q9 = (t, e = !1) => (W9(t, !0, e), t), J9 = (t) => Q9(Z9(t)), Z9 = (t) => {
  if (!t)
    return [];
  const e = t.sort((r, s) => r.chainId === s.chainId ? 0 : r.chainId < s.chainId ? -1 : 1), n = e.findIndex((r) => r.isDefaultChain);
  return n > 0 && e.splice(0, 0, e.splice(n, 1)[0]), e;
}, Rg = (t, e) => typeof t == "string" ? (e = e || {}, t.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(n, r) {
  let s = e[r];
  return typeof s == "function" ? s = s() : s == null ? s = "" : typeof s == "object" || typeof s == "symbol" ? s = s.toString() : s = s.valueOf(), s;
})) : "", X9 = (t) => Rg("https://${network}-indexer.sequence.app", {
  network: t
}), Y9 = (t) => Rg("https://${network}-relayer.sequence.app", {
  network: t
}), eI = (t) => Rg("https://nodes.sequence.app/${network}", {
  network: t
}), ae = (t, e) => {
  const n = d0[t];
  if (!n)
    throw new Error(`Network with chainId ${t} not found`);
  const r = eI(n.name);
  return Lc({}, n, {
    rpcUrl: r,
    indexerUrl: X9(n.name),
    relayer: {
      url: Y9(n.name),
      provider: {
        url: r
      }
    }
  }, e);
}, tI = [Lc({}, d0[k.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), Lc({}, d0[k.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})], nI = J9([Lc({}, ae(k.POLYGON), {
  isDefaultChain: !0,
  isAuthChain: !0
}), ae(k.MAINNET), ae(k.BSC), ae(k.AVALANCHE), ae(k.ARBITRUM), ae(k.ARBITRUM_NOVA), ae(k.OPTIMISM), ae(k.OPTIMISM_SEPOLIA), ae(k.POLYGON_ZKEVM), ae(k.GNOSIS), ae(k.RINKEBY, {
  disabled: !0
}), ae(k.GOERLI, {
  disabled: !0
}), ae(k.SEPOLIA), ae(k.POLYGON_MUMBAI, {
  disabled: !0
}), ae(k.POLYGON_AMOY), ae(k.BSC_TESTNET), ae(k.ARBITRUM_SEPOLIA), ae(k.BASE), ae(k.BASE_SEPOLIA), ae(k.HOMEVERSE), ae(k.HOMEVERSE_TESTNET), ae(k.XAI), ae(k.XAI_SEPOLIA), ae(k.AVALANCHE_TESTNET), ae(k.B3), ae(k.B3_SEPOLIA), ae(k.APECHAIN), ae(k.APECHAIN_TESTNET), ae(k.BLAST), ae(k.BLAST_SEPOLIA), ae(k.TELOS), ae(k.TELOS_TESTNET), ae(k.BORNE_TESTNET), ae(k.SKALE_NEBULA), ae(k.SKALE_NEBULA_TESTNET), ae(k.SONEIUM), ae(k.SONEIUM_MINATO), ae(k.TOY_TESTNET), ae(k.IMMUTABLE_ZKEVM), ae(k.IMMUTABLE_ZKEVM_TESTNET), ae(k.ROOT_NETWORK), ae(k.ROOT_NETWORK_PORCINI), ae(k.LAOS), ae(k.LAOS_SIGMA_TESTNET), ae(k.MOONBEAM), ae(k.MOONBASE_ALPHA), ae(k.ETHERLINK), ae(k.ETHERLINK_TESTNET), ae(k.SOMNIA), ae(k.SOMNIA_TESTNET), ae(k.MONAD_TESTNET), ae(k.INCENTIV_TESTNET), ae(k.SEI), ae(k.SEI_TESTNET), ...tI]), VX = "0xd7571bd1e3af468c3a49966c9a92a2e907cdfa52", jX = "0x9a013e7d186611af36a918ef23d81886e8c256f8", qX = "0xc1A9B197eBb31Fc2B613C59dAC3f3E5698A429D0", rI = "https://dev-indexer.sequence.app", sI = "https://v3-api.sequence.app", aI = {
  8453: "0x2bf4c63199eD7D8A737E8DB2cC19E0C0103F6bE3",
  84532: "0xdcd9160492C6D43ABbd28D4d06F68ad77f1A0F2b",
  421614: "0xf18A16E1C778baCA5d6f7F48cC4c9bb913e5e579",
  42161: "0x674827B6BE8780DBdb96DC02c735275e3a982c90",
  137: "0x4dBb20eA3A969F1A44d7653D4Dc8632B853E36DE"
}, iI = !0;
function oI({
  apiUrl: t = sI,
  projectAccessKey: e,
  jwt: n
}) {
  return new W5(t, e, n);
}
const rd = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = _2();
  return Wu(() => oI({
    apiUrl: (t == null ? void 0 : t.apiUrl) ?? r.apiUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.apiUrl, t]);
};
function f(t) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...t
  };
}
const cI = /* @__PURE__ */ f({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: !1
}), Vk = "2.32.0";
let dl = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) => e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
  version: `viem@${Vk}`
}, H = class j0 extends Error {
  constructor(e, n = {}) {
    var o;
    const r = (() => {
      var c;
      return n.cause instanceof j0 ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof j0 && n.cause.docsPath || n.docsPath, a = (o = dl.getDocsUrl) == null ? void 0 : o.call(dl, { ...n, docsPath: s }), i = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...r ? [`Details: ${r}`] : [],
      ...dl.version ? [`Version: ${dl.version}`] : []
    ].join(`
`);
    super(i, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = e, this.version = Vk;
  }
  walk(e) {
    return jk(this, e);
  }
};
function jk(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? jk(t.cause, e) : e ? null : t;
}
let qk = class extends H {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
};
class lI extends H {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
let uI = class extends H {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
};
function Jc(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function Xe(t) {
  return Jc(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
function bs(t, { dir: e = "left" } = {}) {
  let n = typeof t == "string" ? t.replace("0x", "") : t, r = 0;
  for (let s = 0; s < n.length - 1 && n[e === "left" ? s : n.length - s - 1].toString() === "0"; s++)
    r++;
  return n = e === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof t == "string" ? (n.length === 1 && e === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
let Kk = class extends H {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}, Wk = class extends H {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
class jE extends H {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function vt(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string" ? ha(t, { dir: e, size: n }) : dI(t, { dir: e, size: n });
}
function ha(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  const r = t.replace("0x", "");
  if (r.length > n * 2)
    throw new Wk({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function dI(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  if (t.length > n)
    throw new Wk({
      size: t.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let s = 0; s < n; s++) {
    const a = e === "right";
    r[a ? s : n - s - 1] = t[a ? s : t.length - s - 1];
  }
  return r;
}
const fI = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Pe(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? W(t, e) : typeof t == "string" ? hu(t, e) : typeof t == "boolean" ? Qk(t, e) : It(t, e);
}
function Qk(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Gr(n, { size: e.size }), vt(n, { size: e.size })) : n;
}
function It(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += fI[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (Gr(r, { size: e.size }), vt(r, { dir: "right", size: e.size })) : r;
}
function W(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const c = typeof t == "bigint" ? "n" : "";
    throw new qk({
      max: a ? `${a}${c}` : void 0,
      min: `${i}${c}`,
      signed: n,
      size: r,
      value: `${t}${c}`
    });
  }
  const o = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? vt(o, { size: r }) : o;
}
const pI = /* @__PURE__ */ new TextEncoder();
function hu(t, e = {}) {
  const n = pI.encode(t);
  return It(n, e);
}
const hI = /* @__PURE__ */ new TextEncoder();
function vo(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? yI(t, e) : typeof t == "boolean" ? mI(t, e) : Jc(t) ? nn(t, e) : Jk(t, e);
}
function mI(t, e = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(t), typeof e.size == "number" ? (Gr(n, { size: e.size }), vt(n, { size: e.size })) : n;
}
const zr = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function qE(t) {
  if (t >= zr.zero && t <= zr.nine)
    return t - zr.zero;
  if (t >= zr.A && t <= zr.F)
    return t - (zr.A - 10);
  if (t >= zr.a && t <= zr.f)
    return t - (zr.a - 10);
}
function nn(t, e = {}) {
  let n = t;
  e.size && (Gr(n, { size: e.size }), n = vt(n, { dir: "right", size: e.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const s = r.length / 2, a = new Uint8Array(s);
  for (let i = 0, o = 0; i < s; i++) {
    const c = qE(r.charCodeAt(o++)), u = qE(r.charCodeAt(o++));
    if (c === void 0 || u === void 0)
      throw new H(`Invalid byte sequence ("${r[o - 2]}${r[o - 1]}" in "${r}").`);
    a[i] = c * 16 + u;
  }
  return a;
}
function yI(t, e) {
  const n = W(t, e);
  return nn(n);
}
function Jk(t, e = {}) {
  const n = hI.encode(t);
  return typeof e.size == "number" ? (Gr(n, { size: e.size }), vt(n, { dir: "right", size: e.size })) : n;
}
function Gr(t, { size: e }) {
  if (Xe(t) > e)
    throw new uI({
      givenSize: Xe(t),
      maxSize: e
    });
}
function Re(t, e = {}) {
  const { signed: n } = e;
  e.size && Gr(t, { size: e.size });
  const r = BigInt(t);
  if (!n)
    return r;
  const s = (t.length - 2) / 2, a = (1n << BigInt(s) * 8n - 1n) - 1n;
  return r <= a ? r : r - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function va(t, e = {}) {
  return Number(Re(t, e));
}
function zp(t, e) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (s) => {
      const a = e(s);
      if (n)
        for (const i of n)
          delete a[i];
      return {
        ...a,
        ...r(s)
      };
    },
    type: t
  });
}
const Zk = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function Vp(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? va(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? va(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? Zk[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = bI(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
const Fg = /* @__PURE__ */ zp("transaction", Vp);
function bI(t) {
  return t.map((e) => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function Xk(t) {
  const e = (t.transactions ?? []).map((n) => typeof n == "string" ? n : Vp(n));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
const Dg = /* @__PURE__ */ zp("block", Xk);
function Mg(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...n ? { args: e, eventName: n } : {}
  };
}
const gI = {
  "0x0": "reverted",
  "0x1": "success"
};
function Yk(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map((n) => Mg(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? va(t.transactionIndex) : null,
    status: t.status ? gI[t.status] : null,
    type: t.type ? Zk[t.type] || t.type : null
  };
  return t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)), t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)), e;
}
const e8 = /* @__PURE__ */ zp("transactionReceipt", Yk), wI = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Lg(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = EI(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((n) => It(n)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = W(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = W(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = W(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = W(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = W(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = W(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = wI[t.type]), typeof t.value < "u" && (e.value = W(t.value)), e;
}
const t8 = /* @__PURE__ */ zp("transactionRequest", Lg);
function EI(t) {
  return t.map((e) => ({
    address: e.address,
    r: e.r ? W(BigInt(e.r)) : e.r,
    s: e.s ? W(BigInt(e.s)) : e.s,
    chainId: W(e.chainId),
    nonce: W(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: W(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: W(e.v) } : {}
  }));
}
const xI = 2n ** 16n - 1n, sd = 2n ** 256n - 1n, Hg = 50000n, KE = xI * 32n, n8 = {
  block: /* @__PURE__ */ Dg({
    format(t) {
      var n;
      const e = (n = t.transactions) == null ? void 0 : n.map((r) => {
        var a;
        if (typeof r == "string")
          return r;
        const s = (a = n8.transaction) == null ? void 0 : a.format(r);
        return s.typeHex === "0x71" ? s.type = "eip712" : s.typeHex === "0xff" && (s.type = "priority"), s;
      });
      return {
        l1BatchNumber: t.l1BatchNumber ? Re(t.l1BatchNumber) : null,
        l1BatchTimestamp: t.l1BatchTimestamp ? Re(t.l1BatchTimestamp) : null,
        transactions: e
      };
    }
  }),
  transaction: /* @__PURE__ */ Fg({
    format(t) {
      const e = {};
      return t.type === "0x71" ? e.type = "eip712" : t.type === "0xff" && (e.type = "priority"), {
        ...e,
        l1BatchNumber: t.l1BatchNumber ? Re(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Re(t.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: /* @__PURE__ */ e8({
    format(t) {
      return {
        l1BatchNumber: t.l1BatchNumber ? Re(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Re(t.l1BatchTxIndex) : null,
        logs: t.logs.map((e) => ({
          ...Mg(e),
          l1BatchNumber: e.l1BatchNumber ? Re(e.l1BatchNumber) : null,
          transactionLogIndex: va(e.transactionLogIndex),
          logType: e.logType
        })),
        l2ToL1Logs: t.l2ToL1Logs.map((e) => ({
          blockNumber: Re(e.blockHash),
          blockHash: e.blockHash,
          l1BatchNumber: e.l1BatchNumber ? Re(e.l1BatchNumber) : null,
          transactionIndex: Re(e.transactionIndex),
          shardId: Re(e.shardId),
          isService: e.isService,
          sender: e.sender,
          key: e.key,
          value: e.value,
          transactionHash: e.transactionHash,
          logIndex: Re(e.logIndex)
        }))
      };
    }
  }),
  transactionRequest: /* @__PURE__ */ t8({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(t) {
      return t.gasPerPubdata || t.paymaster && t.paymasterInput || t.factoryDeps || t.customSignature ? {
        eip712Meta: {
          ...t.gasPerPubdata ? { gasPerPubdata: Pe(t.gasPerPubdata) } : { gasPerPubdata: Pe(Hg) },
          ...t.paymaster && t.paymasterInput ? {
            paymasterParams: {
              paymaster: t.paymaster,
              paymasterInput: Array.from(nn(t.paymasterInput))
            }
          } : {},
          ...t.factoryDeps ? {
            factoryDeps: t.factoryDeps.map((e) => Array.from(nn(e)))
          } : {},
          ...t.customSignature ? {
            customSignature: Array.from(nn(t.customSignature))
          } : {}
        },
        type: "0x71"
      } : {};
    }
  })
};
function rn(t) {
  return typeof t[0] == "string" ? _n(t) : AI(t);
}
function AI(t) {
  let e = 0;
  for (const s of t)
    e += s.length;
  const n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function _n(t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
class WE extends H {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class kI extends H {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class vI extends H {
  constructor({ count: e, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const CI = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new vI({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new kI({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new WE({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new WE({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const n = e ?? this.position;
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(t);
    return this.position += e ?? t, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function $g(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(CI);
  return n.bytes = t, n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = e, n;
}
function Lr(t, e = "hex") {
  const n = r8(t), r = $g(new Uint8Array(n.length));
  return n.encode(r), e === "hex" ? It(r.bytes) : r.bytes;
}
function r8(t) {
  return Array.isArray(t) ? TI(t.map((e) => r8(e))) : SI(t);
}
function TI(t) {
  const e = t.reduce((s, a) => s + a.length, 0), n = s8(e);
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(s) {
      e <= 55 ? s.pushByte(192 + e) : (s.pushByte(247 + n), n === 1 ? s.pushUint8(e) : n === 2 ? s.pushUint16(e) : n === 3 ? s.pushUint24(e) : s.pushUint32(e));
      for (const { encode: a } of t)
        a(s);
    }
  };
}
function SI(t) {
  const e = typeof t == "string" ? nn(t) : t, n = s8(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + n + e.length,
    encode(s) {
      e.length === 1 && e[0] < 128 ? s.pushBytes(e) : e.length <= 55 ? (s.pushByte(128 + e.length), s.pushBytes(e)) : (s.pushByte(183 + n), n === 1 ? s.pushUint8(e.length) : n === 2 ? s.pushUint16(e.length) : n === 3 ? s.pushUint24(e.length) : s.pushUint32(e.length), s.pushBytes(e));
    }
  };
}
function s8(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new H("Length is too large.");
}
const OI = {
  gwei: 9,
  wei: 18
}, BI = {
  ether: -9,
  wei: 9
};
function a8(t, e) {
  let n = t.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(e, "0");
  let [s, a] = [
    n.slice(0, n.length - e),
    n.slice(n.length - e)
  ];
  return a = a.replace(/(0+)$/, ""), `${r ? "-" : ""}${s || "0"}${a ? `.${a}` : ""}`;
}
function II(t, e = "wei") {
  return a8(t, OI[e]);
}
function hs(t, e = "wei") {
  return a8(t, BI[e]);
}
function jp(t) {
  const e = Object.entries(t).map(([r, s]) => s === void 0 || s === !1 ? null : [r, s]).filter(Boolean), n = e.reduce((r, [s]) => Math.max(r, s.length), 0);
  return e.map(([r, s]) => `  ${`${r}:`.padEnd(n + 1)}  ${s}`).join(`
`);
}
class PI extends H {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class UI extends H {
  constructor({ v: e }) {
    super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class NI extends H {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        jp(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class RI extends H {
  constructor({ storageKey: e }) {
    super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
function FI(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (const n of t) {
    const { chainId: r, nonce: s, ...a } = n, i = n.address;
    e.push([
      r ? Pe(r) : "0x",
      i,
      s ? Pe(s) : "0x",
      ...Xc({}, a)
    ]);
  }
  return e;
}
function i8(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((a) => nn(a)) : t.blobs, s = [];
  for (const a of r)
    s.push(Uint8Array.from(e.blobToKzgCommitment(a)));
  return n === "bytes" ? s : s.map((a) => It(a));
}
function o8(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((i) => nn(i)) : t.blobs, s = typeof t.commitments[0] == "string" ? t.commitments.map((i) => nn(i)) : t.commitments, a = [];
  for (let i = 0; i < r.length; i++) {
    const o = r[i], c = s[i];
    a.push(Uint8Array.from(e.computeBlobKzgProof(o, c)));
  }
  return n === "bytes" ? a : a.map((i) => It(i));
}
const ao = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _g(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mu(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function or(t, ...e) {
  if (!_g(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function DI(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  mu(t.outputLen), mu(t.blockLen);
}
function Hc(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function c8(t, e) {
  or(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
function MI(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function $c(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function fm(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function yr(t, e) {
  return t << 32 - e | t >>> e;
}
const LI = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function HI(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function $I(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = HI(t[e]);
  return t;
}
const QE = LI ? (t) => t : $I, l8 = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", _I = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function yu(t) {
  if (or(t), l8)
    return t.toHex();
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += _I[t[n]];
  return e;
}
const Vr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function JE(t) {
  if (t >= Vr._0 && t <= Vr._9)
    return t - Vr._0;
  if (t >= Vr.A && t <= Vr.F)
    return t - (Vr.A - 10);
  if (t >= Vr.a && t <= Vr.f)
    return t - (Vr.a - 10);
}
function Gg(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (l8)
    return Uint8Array.fromHex(t);
  const e = t.length, n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, a = 0; s < n; s++, a += 2) {
    const i = JE(t.charCodeAt(a)), o = JE(t.charCodeAt(a + 1));
    if (i === void 0 || o === void 0) {
      const c = t[a] + t[a + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + a);
    }
    r[s] = i * 16 + o;
  }
  return r;
}
function GI(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function qp(t) {
  return typeof t == "string" && (t = GI(t)), or(t), t;
}
function _a(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    or(s), e += s.length;
  }
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
class zg {
}
function u8(t) {
  const e = (r) => t().update(qp(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function zI(t = 32) {
  if (ao && typeof ao.getRandomValues == "function")
    return ao.getRandomValues(new Uint8Array(t));
  if (ao && typeof ao.randomBytes == "function")
    return Uint8Array.from(ao.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
function VI(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
function jI(t, e, n) {
  return t & e ^ ~t & n;
}
function qI(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
class KI extends zg {
  constructor(e, n, r, s) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = fm(this.buffer);
  }
  update(e) {
    Hc(this), e = qp(e), or(e);
    const { view: n, buffer: r, blockLen: s } = this, a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = fm(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Hc(this), c8(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, $c(this.buffer.subarray(i)), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    VI(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = fm(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.destroyed = i, e.finished = a, e.length = s, e.pos = o, s % n && e.buffer.set(r), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const Ns = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Id = /* @__PURE__ */ BigInt(2 ** 32 - 1), ZE = /* @__PURE__ */ BigInt(32);
function WI(t, e = !1) {
  return e ? { h: Number(t & Id), l: Number(t >> ZE & Id) } : { h: Number(t >> ZE & Id) | 0, l: Number(t & Id) | 0 };
}
function QI(t, e = !1) {
  const n = t.length;
  let r = new Uint32Array(n), s = new Uint32Array(n);
  for (let a = 0; a < n; a++) {
    const { h: i, l: o } = WI(t[a], e);
    [r[a], s[a]] = [i, o];
  }
  return [r, s];
}
const JI = (t, e, n) => t << n | e >>> 32 - n, ZI = (t, e, n) => e << n | t >>> 32 - n, XI = (t, e, n) => e << n - 32 | t >>> 64 - n, YI = (t, e, n) => t << n - 32 | e >>> 64 - n, eP = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Rs = /* @__PURE__ */ new Uint32Array(64);
class tP extends KI {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = Ns[0] | 0, this.B = Ns[1] | 0, this.C = Ns[2] | 0, this.D = Ns[3] | 0, this.E = Ns[4] | 0, this.F = Ns[5] | 0, this.G = Ns[6] | 0, this.H = Ns[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      Rs[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const m = Rs[d - 15], h = Rs[d - 2], b = yr(m, 7) ^ yr(m, 18) ^ m >>> 3, y = yr(h, 17) ^ yr(h, 19) ^ h >>> 10;
      Rs[d] = y + Rs[d - 7] + b + Rs[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const m = yr(o, 6) ^ yr(o, 11) ^ yr(o, 25), h = l + m + jI(o, c, u) + eP[d] + Rs[d] | 0, y = (yr(r, 2) ^ yr(r, 13) ^ yr(r, 22)) + qI(r, s, a) | 0;
      l = u, u = c, c = o, o = i + h | 0, i = a, a = s, s = r, r = h + y | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    $c(Rs);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), $c(this.buffer);
  }
}
const d8 = /* @__PURE__ */ u8(() => new tP()), nP = d8;
function f8(t, e) {
  const n = e || "hex", r = nP(Jc(t, { strict: !1 }) ? vo(t) : t);
  return n === "bytes" ? r : Pe(r);
}
function rP(t) {
  const { commitment: e, version: n = 1 } = t, r = t.to ?? (typeof e == "string" ? "hex" : "bytes"), s = f8(e, "bytes");
  return s.set([n], 0), r === "bytes" ? s : It(s);
}
function sP(t) {
  const { commitments: e, version: n } = t, r = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), s = [];
  for (const a of e)
    s.push(rP({
      commitment: a,
      to: r,
      version: n
    }));
  return s;
}
const XE = 6, p8 = 32, Vg = 4096, h8 = p8 * Vg, YE = h8 * XE - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Vg * XE, m8 = 1;
class aP extends H {
  constructor({ maxSize: e, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class y8 extends H {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class iP extends H {
  constructor({ hash: e, size: n }) {
    super(`Versioned hash "${e}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class oP extends H {
  constructor({ hash: e, version: n }) {
    super(`Versioned hash "${e}" version is invalid.`, {
      metaMessages: [
        `Expected: ${m8}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function cP(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), n = typeof t.data == "string" ? nn(t.data) : t.data, r = Xe(n);
  if (!r)
    throw new y8();
  if (r > YE)
    throw new aP({
      maxSize: YE,
      size: r
    });
  const s = [];
  let a = !0, i = 0;
  for (; a; ) {
    const o = $g(new Uint8Array(h8));
    let c = 0;
    for (; c < Vg; ) {
      const u = n.slice(i, i + (p8 - 1));
      if (o.pushByte(0), o.pushBytes(u), u.length < 31) {
        o.pushByte(128), a = !1;
        break;
      }
      c++, i += 31;
    }
    s.push(o);
  }
  return e === "bytes" ? s.map((o) => o.bytes) : s.map((o) => It(o.bytes));
}
function lP(t) {
  const { data: e, kzg: n, to: r } = t, s = t.blobs ?? cP({ data: e, to: r }), a = t.commitments ?? i8({ blobs: s, kzg: n, to: r }), i = t.proofs ?? o8({ blobs: s, commitments: a, kzg: n, to: r }), o = [];
  for (let c = 0; c < s.length; c++)
    o.push({
      blob: s[c],
      commitment: a[c],
      proof: i[c]
    });
  return o;
}
let Ye = class extends H {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
};
class q0 extends H {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...e && r.blockCreated && r.blockCreated > e ? [
          `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`
        ] : [
          `- The chain does not have the contract "${r.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class b8 extends H {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class Zc extends H {
  constructor({ chainId: e }) {
    super(typeof e == "number" ? `Chain ID "${e}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
let mo = class extends H {
  constructor({ cause: e, message: n } = {}) {
    var s;
    const r = (s = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : s.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
};
Object.defineProperty(mo, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(mo, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Ca extends H {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${hs(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Ca, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class K0 extends H {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${hs(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(K0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class W0 extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(W0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class Q0 extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(Q0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class J0 extends H {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(J0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class Z0 extends H {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(Z0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class X0 extends H {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(X0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class Y0 extends H {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(Y0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class ey extends H {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(ey, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class _c extends H {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${hs(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${hs(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(_c, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class g8 extends H {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
let jg = class extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
};
const uP = BigInt(0), fl = BigInt(1), dP = BigInt(2), fP = BigInt(7), pP = BigInt(256), hP = BigInt(113), w8 = [], E8 = [], x8 = [];
for (let t = 0, e = fl, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], w8.push(2 * (5 * r + n)), E8.push((t + 1) * (t + 2) / 2 % 64);
  let s = uP;
  for (let a = 0; a < 7; a++)
    e = (e << fl ^ (e >> fP) * hP) % pP, e & dP && (s ^= fl << (fl << /* @__PURE__ */ BigInt(a)) - fl);
  x8.push(s);
}
const A8 = QI(x8, !0), mP = A8[0], yP = A8[1], ex = (t, e, n) => n > 32 ? XI(t, e, n) : JI(t, e, n), tx = (t, e, n) => n > 32 ? YI(t, e, n) : ZI(t, e, n);
function bP(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = ex(u, l, 1) ^ n[o], m = tx(u, l, 1) ^ n[o + 1];
      for (let h = 0; h < 50; h += 10)
        t[i + h] ^= d, t[i + h + 1] ^= m;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = E8[i], c = ex(s, a, o), u = tx(s, a, o), l = w8[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= mP[r], t[1] ^= yP[r];
  }
  $c(n);
}
class qg extends zg {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, mu(r), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = MI(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    QE(this.state32), bP(this.state32, this.rounds), QE(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Hc(this), e = qp(e), or(e);
    const { blockLen: n, state: r } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Hc(this, !1), or(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mu(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (c8(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, $c(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new qg(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
}
const gP = (t, e, n) => u8(() => new qg(e, t, n)), k8 = gP(1, 136, 256 / 8);
function We(t, e) {
  const n = e || "hex", r = k8(Jc(t, { strict: !1 }) ? vo(t) : t);
  return n === "bytes" ? r : Pe(r);
}
const pm = /* @__PURE__ */ new jg(8192);
function Kp(t, e) {
  if (pm.has(`${t}.${e}`))
    return pm.get(`${t}.${e}`);
  const n = t.substring(2).toLowerCase(), r = We(Jk(n), "bytes"), s = n.split("");
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && s[i] && (s[i] = s[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && s[i + 1] && (s[i + 1] = s[i + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return pm.set(`${t}.${e}`, a), a;
}
function eY(t, e) {
  if (!He(t, { strict: !1 }))
    throw new Ye({ address: t });
  return Kp(t, e);
}
const wP = /^0x[a-fA-F0-9]{40}$/, hm = /* @__PURE__ */ new jg(8192);
function He(t, e) {
  const { strict: n = !0 } = e ?? {}, r = `${t}.${n}`;
  if (hm.has(r))
    return hm.get(r);
  const s = wP.test(t) ? t.toLowerCase() === t ? !0 : n ? Kp(t) === t : !0 : !1;
  return hm.set(r, s), s;
}
function bu(t, e, n, { strict: r } = {}) {
  return Jc(t, { strict: !1 }) ? EP(t, e, n, {
    strict: r
  }) : T8(t, e, n, {
    strict: r
  });
}
function v8(t, e) {
  if (typeof e == "number" && e > 0 && e > Xe(t) - 1)
    throw new Kk({
      offset: e,
      position: "start",
      size: Xe(t)
    });
}
function C8(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && Xe(t) !== n - e)
    throw new Kk({
      offset: n,
      position: "end",
      size: Xe(t)
    });
}
function T8(t, e, n, { strict: r } = {}) {
  v8(t, e);
  const s = t.slice(e, n);
  return r && C8(s, e, n), s;
}
function EP(t, e, n, { strict: r } = {}) {
  v8(t, e);
  const s = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return r && C8(s, e, n), s;
}
function xP(t) {
  const { authorizationList: e } = t;
  if (e)
    for (const n of e) {
      const { chainId: r } = n, s = n.address;
      if (!He(s))
        throw new Ye({ address: s });
      if (r < 0)
        throw new Zc({ chainId: r });
    }
  Kg(t);
}
function AP(t) {
  const { blobVersionedHashes: e } = t;
  if (e) {
    if (e.length === 0)
      throw new y8();
    for (const n of e) {
      const r = Xe(n), s = va(bu(n, 0, 1));
      if (r !== 32)
        throw new iP({ hash: n, size: r });
      if (s !== m8)
        throw new oP({
          hash: n,
          version: s
        });
    }
  }
  Kg(t);
}
function Kg(t) {
  const { chainId: e, maxPriorityFeePerGas: n, maxFeePerGas: r, to: s } = t;
  if (e <= 0)
    throw new Zc({ chainId: e });
  if (s && !He(s))
    throw new Ye({ address: s });
  if (r && r > sd)
    throw new Ca({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new _c({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function kP(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (e <= 0)
    throw new Zc({ chainId: e });
  if (a && !He(a))
    throw new Ye({ address: a });
  if (n || s)
    throw new H("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > sd)
    throw new Ca({ maxFeePerGas: r });
}
function vP(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (a && !He(a))
    throw new Ye({ address: a });
  if (typeof e < "u" && e <= 0)
    throw new Zc({ chainId: e });
  if (n || s)
    throw new H("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > sd)
    throw new Ca({ maxFeePerGas: r });
}
function CP(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new NI({ transaction: t });
}
function ad(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const { address: r, storageKeys: s } = t[n];
    for (let a = 0; a < s.length; a++)
      if (s[a].length - 2 !== 64)
        throw new RI({ storageKey: s[a] });
    if (!He(r, { strict: !1 }))
      throw new Ye({ address: r });
    e.push([r, s]);
  }
  return e;
}
function Wg(t, e) {
  const n = CP(t);
  return n === "eip1559" ? OP(t, e) : n === "eip2930" ? BP(t, e) : n === "eip4844" ? SP(t, e) : n === "eip7702" ? TP(t, e) : IP(t, e);
}
function TP(t, e) {
  const { authorizationList: n, chainId: r, gas: s, nonce: a, to: i, value: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  xP(t);
  const m = ad(l), h = FI(n);
  return _n([
    "0x04",
    Lr([
      W(r),
      a ? W(a) : "0x",
      u ? W(u) : "0x",
      c ? W(c) : "0x",
      s ? W(s) : "0x",
      i ?? "0x",
      o ? W(o) : "0x",
      d ?? "0x",
      m,
      h,
      ...Xc(t, e)
    ])
  ]);
}
function SP(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerBlobGas: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  AP(t);
  let m = t.blobVersionedHashes, h = t.sidecars;
  if (t.blobs && (typeof m > "u" || typeof h > "u")) {
    const A = typeof t.blobs[0] == "string" ? t.blobs : t.blobs.map((N) => It(N)), B = t.kzg, x = i8({
      blobs: A,
      kzg: B
    });
    if (typeof m > "u" && (m = sP({
      commitments: x
    })), typeof h > "u") {
      const N = o8({ blobs: A, commitments: x, kzg: B });
      h = lP({ blobs: A, commitments: x, proofs: N });
    }
  }
  const b = ad(l), y = [
    W(n),
    s ? W(s) : "0x",
    u ? W(u) : "0x",
    c ? W(c) : "0x",
    r ? W(r) : "0x",
    a ?? "0x",
    i ? W(i) : "0x",
    d ?? "0x",
    b,
    o ? W(o) : "0x",
    m ?? [],
    ...Xc(t, e)
  ], g = [], w = [], v = [];
  if (h)
    for (let A = 0; A < h.length; A++) {
      const { blob: B, commitment: x, proof: N } = h[A];
      g.push(B), w.push(x), v.push(N);
    }
  return _n([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    Lr(h ? [y, g, w, v] : y)
  ]);
}
function OP(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, data: l } = t;
  Kg(t);
  const d = ad(u), m = [
    W(n),
    s ? W(s) : "0x",
    c ? W(c) : "0x",
    o ? W(o) : "0x",
    r ? W(r) : "0x",
    a ?? "0x",
    i ? W(i) : "0x",
    l ?? "0x",
    d,
    ...Xc(t, e)
  ];
  return _n([
    "0x02",
    Lr(m)
  ]);
}
function BP(t, e) {
  const { chainId: n, gas: r, data: s, nonce: a, to: i, value: o, accessList: c, gasPrice: u } = t;
  kP(t);
  const l = ad(c), d = [
    W(n),
    a ? W(a) : "0x",
    u ? W(u) : "0x",
    r ? W(r) : "0x",
    i ?? "0x",
    o ? W(o) : "0x",
    s ?? "0x",
    l,
    ...Xc(t, e)
  ];
  return _n([
    "0x01",
    Lr(d)
  ]);
}
function IP(t, e) {
  const { chainId: n = 0, gas: r, data: s, nonce: a, to: i, value: o, gasPrice: c } = t;
  vP(t);
  let u = [
    a ? W(a) : "0x",
    c ? W(c) : "0x",
    r ? W(r) : "0x",
    i ?? "0x",
    o ? W(o) : "0x",
    s ?? "0x"
  ];
  if (e) {
    const l = (() => {
      if (e.v >= 35n)
        return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + e.v - 27n);
      const h = 27n + (e.v === 27n ? 0n : 1n);
      if (e.v !== h)
        throw new UI({ v: e.v });
      return h;
    })(), d = bs(e.r), m = bs(e.s);
    u = [
      ...u,
      W(l),
      d === "0x00" ? "0x" : d,
      m === "0x00" ? "0x" : m
    ];
  } else n > 0 && (u = [
    ...u,
    W(n),
    "0x",
    "0x"
  ]);
  return Lr(u);
}
function Xc(t, e) {
  const n = e ?? t, { v: r, yParity: s } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof s > "u")
    return [];
  const a = bs(n.r), i = bs(n.s);
  return [typeof s == "number" ? s ? W(1) : "0x" : r === 0n ? "0x" : r === 1n ? W(1) : r === 27n ? "0x" : W(1), a === "0x00" ? "0x" : a, i === "0x00" ? "0x" : i];
}
class PP extends H {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join(`
`), { name: "InvalidEip712TransactionError" });
  }
}
function S8(t) {
  return !!(t.type === "eip712" || "customSignature" in t && t.customSignature || "paymaster" in t && t.paymaster || "paymasterInput" in t && t.paymasterInput || "gasPerPubdata" in t && typeof t.gasPerPubdata == "bigint" || "factoryDeps" in t && t.factoryDeps);
}
function O8(t) {
  const { chainId: e, to: n, from: r, paymaster: s, paymasterInput: a } = t;
  if (!S8(t))
    throw new PP();
  if (!e || e <= 0)
    throw new Zc({ chainId: e });
  if (n && !He(n))
    throw new Ye({ address: n });
  if (r && !He(r))
    throw new Ye({ address: r });
  if (s && !He(s))
    throw new Ye({ address: s });
  if (s && !a)
    throw new H("`paymasterInput` must be provided when `paymaster` is defined");
  if (!s && a)
    throw new H("`paymaster` must be provided when `paymasterInput` is defined");
}
function UP(t, e) {
  return S8(t) ? RP(t) : Wg(t, e);
}
const NP = {
  transaction: UP
};
function RP(t) {
  const { chainId: e, gas: n, nonce: r, to: s, from: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, customSignature: u, factoryDeps: l, paymaster: d, paymasterInput: m, gasPerPubdata: h, data: b } = t;
  O8(t);
  const y = [
    r ? Pe(r) : "0x",
    c ? Pe(c) : "0x",
    o ? Pe(o) : "0x",
    n ? Pe(n) : "0x",
    s ?? "0x",
    i ? Pe(i) : "0x",
    b ?? "0x",
    Pe(e),
    Pe(""),
    Pe(""),
    Pe(e),
    a ?? "0x",
    Pe(h || Hg),
    l ?? [],
    u ?? "0x",
    // EIP712 signature
    d && m ? [d, m] : []
  ];
  return _n([
    "0x71",
    Lr(y)
  ]);
}
class FP extends H {
  constructor({ givenLength: e, maxBytecodeSize: n }) {
    super(`Bytecode cannot be longer than ${n} bytes. Given length: ${e}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
}
class DP extends H {
  constructor({ givenLengthInWords: e }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${e}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
}
class MP extends H {
  constructor({ givenLength: e }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${e}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
}
function LP(t) {
  const e = vo(t);
  if (e.length % 32 !== 0)
    throw new MP({
      givenLength: e.length
    });
  if (e.length > KE)
    throw new FP({
      givenLength: e.length,
      maxBytecodeSize: KE
    });
  const n = f8(e), r = vo(n), s = e.length / 32;
  if (s % 2 === 0)
    throw new DP({
      givenLengthInWords: s
    });
  const a = vo(s), i = vt(a, { size: 2 }), o = new Uint8Array([1, 0]);
  return r.set(o, 0), r.set(i, 2), r;
}
const HP = (t) => {
  O8(t);
  const e = $P(t);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: t.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message: e
  };
};
function $P(t) {
  const { gas: e, nonce: n, to: r, from: s, value: a, maxFeePerGas: i, maxPriorityFeePerGas: o, factoryDeps: c, paymaster: u, paymasterInput: l, gasPerPubdata: d, data: m } = t;
  return {
    txType: 113n,
    from: BigInt(s),
    to: r ? BigInt(r) : 0n,
    gasLimit: e ?? 0n,
    gasPerPubdataByteLimit: d ?? Hg,
    maxFeePerGas: i ?? 0n,
    maxPriorityFeePerGas: o ?? 0n,
    paymaster: u ? BigInt(u) : 0n,
    nonce: n ? BigInt(n) : 0n,
    value: a ?? 0n,
    data: m ?? "0x",
    factoryDeps: (c == null ? void 0 : c.map((h) => Pe(LP(h)))) ?? [],
    paymasterInput: l || "0x"
  };
}
const bn = {
  blockTime: 1e3,
  formatters: n8,
  serializers: NP,
  custom: {
    getEip712Domain: HP
  }
}, ty = /* @__PURE__ */ f({
  ...bn,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
}), _P = /* @__PURE__ */ f({
  ...bn,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
}), GP = /* @__PURE__ */ f({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: !1
}), zP = /* @__PURE__ */ f({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: !1
}), VP = /* @__PURE__ */ f({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: !1
}), jP = /* @__PURE__ */ f({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: !1
}), qP = /* @__PURE__ */ f({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
}), KP = /* @__PURE__ */ f({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: !0
}), WP = /* @__PURE__ */ f({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: !1
}), QP = /* @__PURE__ */ f({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: !0
}), B8 = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, Qg = {
  block: /* @__PURE__ */ Dg({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const s = Vp(r);
          return s.typeHex === "0x7e" && (s.isSystemTx = r.isSystemTx, s.mint = r.mint ? Re(r.mint) : void 0, s.sourceHash = r.sourceHash, s.type = "deposit"), s;
        }),
        stateRoot: t.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ Fg({
    format(t) {
      const e = {};
      return t.type === "0x7e" && (e.isSystemTx = t.isSystemTx, e.mint = t.mint ? Re(t.mint) : void 0, e.sourceHash = t.sourceHash, e.type = "deposit"), e;
    }
  }),
  transactionReceipt: /* @__PURE__ */ e8({
    format(t) {
      return {
        l1GasPrice: t.l1GasPrice ? Re(t.l1GasPrice) : null,
        l1GasUsed: t.l1GasUsed ? Re(t.l1GasUsed) : null,
        l1Fee: t.l1Fee ? Re(t.l1Fee) : null,
        l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null
      };
    }
  })
};
function I8(t, e) {
  return XP(t) ? ZP(t) : Wg(t, e);
}
const JP = {
  transaction: I8
};
function ZP(t) {
  YP(t);
  const { sourceHash: e, data: n, from: r, gas: s, isSystemTx: a, mint: i, to: o, value: c } = t, u = [
    e,
    r,
    o ?? "0x",
    i ? Pe(i) : "0x",
    c ? Pe(c) : "0x",
    s ? Pe(s) : "0x",
    a ? "0x1" : "0x",
    n ?? "0x"
  ];
  return _n([
    "0x7e",
    Lr(u)
  ]);
}
function XP(t) {
  return t.type === "deposit" || typeof t.sourceHash < "u";
}
function YP(t) {
  const { from: e, to: n } = t;
  if (e && !He(e))
    throw new Ye({ address: e });
  if (n && !He(n))
    throw new Ye({ address: n });
}
const q = {
  blockTime: 2e3,
  contracts: B8,
  formatters: Qg,
  serializers: JP
}, Pd = 1, ny = /* @__PURE__ */ f({
  ...q,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Pd]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [Pd]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [Pd]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId: Pd
}), Ud = 11155111, e4 = /* @__PURE__ */ f({
  ...q,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Ud]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [Ud]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [Ud]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: Ud
}), t4 = /* @__PURE__ */ f({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), n4 = 42161, Jf = /* @__PURE__ */ f({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: n4
}), r4 = /* @__PURE__ */ f({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: !0
}), cr = /* @__PURE__ */ f({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), s4 = /* @__PURE__ */ f({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: !0
}), Gc = /* @__PURE__ */ f({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
}), Hi = /* @__PURE__ */ f({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: !0
}), ry = /* @__PURE__ */ f({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
}), a4 = /* @__PURE__ */ f({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: !1
}), i4 = /* @__PURE__ */ f({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: !0
}), o4 = /* @__PURE__ */ f({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: !0
}), c4 = /* @__PURE__ */ f({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
}), l4 = /* @__PURE__ */ f({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
}), u4 = /* @__PURE__ */ f({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: !1,
  contracts: {}
}), d4 = /* @__PURE__ */ f({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
}), f4 = /* @__PURE__ */ f({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: !1
}), p4 = /* @__PURE__ */ f({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: !1
}), h4 = /* @__PURE__ */ f({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: !0
}), m4 = /* @__PURE__ */ f({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: !0
}), y4 = /* @__PURE__ */ f({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
}), b4 = /* @__PURE__ */ f({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: !0
}), g4 = /* @__PURE__ */ f({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: !0
}), gs = /* @__PURE__ */ f({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), $i = /* @__PURE__ */ f({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: !0
}), w4 = 8453, gu = /* @__PURE__ */ f({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: w4
}), E4 = 168587773, sy = /* @__PURE__ */ f({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: !0,
  sourceId: E4
}), x4 = /* @__PURE__ */ f({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
}), pl = 1, Hr = /* @__PURE__ */ f({
  ...q,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [pl]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [pl]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [pl]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [pl]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: pl
}), A4 = /* @__PURE__ */ f({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: !0
}), Nd = 5, P8 = /* @__PURE__ */ f({
  ...q,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Nd]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [Nd]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [Nd]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: !0,
  sourceId: Nd
}), hl = 11155111, _i = /* @__PURE__ */ f({
  ...q,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [hl]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [hl]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [hl]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [hl]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: !0,
  sourceId: hl
}), k4 = /* @__PURE__ */ f({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
}), v4 = /* @__PURE__ */ f({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: !0
}), C4 = /* @__PURE__ */ f({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
}), T4 = /* @__PURE__ */ f({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: !0
}), ay = /* @__PURE__ */ f({
  id: 80094,
  name: "Berachain",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 877008
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: !1
}), S4 = /* @__PURE__ */ f({
  id: 80069,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: !0
}), O4 = /* @__PURE__ */ f({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: !0
}), B4 = /* @__PURE__ */ f({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: !0
}), I4 = /* @__PURE__ */ f({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
}), P4 = /* @__PURE__ */ f({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: !1
}), U4 = /* @__PURE__ */ f({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: !1
}), N4 = /* @__PURE__ */ f({
  id: 96,
  name: "KUB Mainnet",
  nativeCurrency: { name: "KUB Coin", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KUB Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
}), R4 = /* @__PURE__ */ f({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: !0
}), F4 = /* @__PURE__ */ f({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
}), D4 = /* @__PURE__ */ f({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: !0
}), M4 = /* @__PURE__ */ f({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: !1
}), L4 = /* @__PURE__ */ f({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
}), H4 = /* @__PURE__ */ f({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: !0
}), $4 = f({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
}), Rd = 1, Zf = /* @__PURE__ */ f({
  ...q,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    },
    l2OutputOracle: {
      [Rd]: {
        address: "0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76",
        blockCreated: 19300358
      }
    },
    portal: {
      [Rd]: {
        address: "0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb",
        blockCreated: 19300357
      }
    },
    l1StandardBridge: {
      [Rd]: {
        address: "0x697402166Fbf2F22E970df8a6486Ef171dbfc524",
        blockCreated: 19300360
      }
    }
  },
  sourceId: Rd
}), _4 = 11155111, iy = /* @__PURE__ */ f({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: !0,
  sourceId: _4
}), mm = 1, oy = f({
  ...q,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [mm]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [mm]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: mm
}), cy = /* @__PURE__ */ f({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
}), G4 = /* @__PURE__ */ f({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: !0
}), ym = 11155111, z4 = f({
  ...q,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [ym]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [ym]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: !0,
  sourceId: ym
}), V4 = /* @__PURE__ */ f({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: !1
}), j4 = /* @__PURE__ */ f({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Botanix", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: !0
}), q4 = /* @__PURE__ */ f({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: !1
}), K4 = /* @__PURE__ */ f({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: !0
}), W4 = /* @__PURE__ */ f({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
}), Q4 = /* @__PURE__ */ f({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: !0
}), J4 = /* @__PURE__ */ f({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), Z4 = /* @__PURE__ */ f({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: !1
}), X4 = /* @__PURE__ */ f({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: !0
}), Y4 = /* @__PURE__ */ f({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
}), eU = /* @__PURE__ */ f({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: !0
}), tU = /* @__PURE__ */ f({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
}), nU = /* @__PURE__ */ f({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: !0
}), rU = /* @__PURE__ */ f({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
}), sU = /* @__PURE__ */ f({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: !0
}), aU = /* @__PURE__ */ f({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), iU = /* @__PURE__ */ f({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
}), oU = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (t) => {
    var s;
    if (!((s = t.request) != null && s.feeCurrency))
      return null;
    const [e, n] = await Promise.all([
      cU(t.client, t.request.feeCurrency),
      lU(t.client, t.request.feeCurrency)
    ]);
    return {
      maxFeePerGas: t.multiply(e - n) + n,
      maxPriorityFeePerGas: n
    };
  }
};
async function cU(t, e) {
  const n = await t.request({
    method: "eth_gasPrice",
    params: [e]
  });
  return BigInt(n);
}
async function lU(t, e) {
  const n = await t.request({
    method: "eth_maxPriorityFeePerGas",
    params: [e]
  });
  return BigInt(n);
}
function U8(t) {
  return t === 0 || t === 0n || t === void 0 || t === null || t === "0" || t === "" || typeof t == "string" && (bs(t).toLowerCase() === "0x" || bs(t).toLowerCase() === "0x00");
}
function Ml(t) {
  return !U8(t);
}
function uU(t) {
  return typeof t.maxFeePerGas < "u" && typeof t.maxPriorityFeePerGas < "u";
}
function N8(t) {
  return t.type === "cip64" ? !0 : uU(t) && Ml(t.feeCurrency);
}
const dU = {
  block: /* @__PURE__ */ Dg({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : {
          ...Vp(r),
          ...r.gatewayFee ? {
            gatewayFee: Re(r.gatewayFee),
            gatewayFeeRecipient: r.gatewayFeeRecipient
          } : {},
          feeCurrency: r.feeCurrency
        })
      };
    }
  }),
  transaction: /* @__PURE__ */ Fg({
    format(t) {
      if (t.type === "0x7e")
        return {
          isSystemTx: t.isSystemTx,
          mint: t.mint ? Re(t.mint) : void 0,
          sourceHash: t.sourceHash,
          type: "deposit"
        };
      const e = { feeCurrency: t.feeCurrency };
      return t.type === "0x7b" ? e.type = "cip64" : (t.type === "0x7c" && (e.type = "cip42"), e.gatewayFee = t.gatewayFee ? Re(t.gatewayFee) : null, e.gatewayFeeRecipient = t.gatewayFeeRecipient), e;
    }
  }),
  transactionRequest: /* @__PURE__ */ t8({
    format(t) {
      const e = {};
      return t.feeCurrency && (e.feeCurrency = t.feeCurrency), N8(t) && (e.type = "0x7b"), e;
    }
  })
};
function fU(t, e) {
  return N8(t) ? hU(t, e) : I8(t, e);
}
const pU = {
  transaction: fU
};
function hU(t, e) {
  yU(t);
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, feeCurrency: l, data: d } = t, m = [
    Pe(n),
    s ? Pe(s) : "0x",
    c ? Pe(c) : "0x",
    o ? Pe(o) : "0x",
    r ? Pe(r) : "0x",
    a ?? "0x",
    i ? Pe(i) : "0x",
    d ?? "0x",
    ad(u),
    l,
    ...Xc(t, e)
  ];
  return _n([
    "0x7b",
    Lr(m)
  ]);
}
const mU = sd;
function yU(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a, feeCurrency: i } = t;
  if (e <= 0)
    throw new Zc({ chainId: e });
  if (a && !He(a))
    throw new Ye({ address: a });
  if (r)
    throw new H("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (Ml(s) && s > mU)
    throw new Ca({ maxFeePerGas: s });
  if (Ml(n) && Ml(s) && n > s)
    throw new _c({ maxFeePerGas: s, maxPriorityFeePerGas: n });
  if (Ml(i) && !He(i))
    throw new H("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  if (U8(i))
    throw new H("`feeCurrency` must be provided for CIP-64 transactions.");
}
const ly = {
  blockTime: 1e3,
  contracts: B8,
  formatters: dU,
  serializers: pU,
  fees: oU
}, uy = /* @__PURE__ */ f({
  ...ly,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: !1
}), Fd = 17e3, bU = /* @__PURE__ */ f({
  ...ly,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...ly.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [Fd]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [Fd]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [Fd]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [Fd]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: !0
}), gU = /* @__PURE__ */ f({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
}), wU = /* @__PURE__ */ f({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiliz.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8080847
    }
  }
}), EU = /* @__PURE__ */ f({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
}), xU = /* @__PURE__ */ f({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: !0
}), AU = /* @__PURE__ */ f({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
}), kU = /* @__PURE__ */ f({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: !1
}), vU = /* @__PURE__ */ f({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: !1
}), CU = /* @__PURE__ */ f({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
}), TU = /* @__PURE__ */ f({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: !0,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
}), SU = /* @__PURE__ */ f({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: !1
}), OU = /* @__PURE__ */ f({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: !0
}), BU = /* @__PURE__ */ f({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: !0
}), IU = 1, dy = /* @__PURE__ */ f({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: IU
}), PU = 11155111, UU = /* @__PURE__ */ f({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: !0,
  sourceId: PU
}), NU = f({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
}), RU = f({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), FU = /* @__PURE__ */ f({
  id: 102030,
  name: "Creditcoin3 Mainnet",
  nativeCurrency: { name: "Creditcoin3 Mainnet", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: !1
}), DU = /* @__PURE__ */ f({
  id: 102031,
  name: "Creditcoin3 Testnet",
  nativeCurrency: { name: "Creditcoin3 Testnet", symbol: "TCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: !0
}), fy = /* @__PURE__ */ f({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
}), MU = /* @__PURE__ */ f({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer (Testnet)",
      url: "https://explorer.cronos.org/testnet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: !0
}), LU = /* @__PURE__ */ f({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
}), HU = /* @__PURE__ */ f({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: !0
}), $U = /* @__PURE__ */ f({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
}), _U = /* @__PURE__ */ f({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: !0
}), py = /* @__PURE__ */ f({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), GU = /* @__PURE__ */ f({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: !0
}), zU = /* @__PURE__ */ f({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: !1
}), VU = /* @__PURE__ */ f({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: !0
}), jU = /* @__PURE__ */ f({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
}), qU = /* @__PURE__ */ f({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: !1
}), KU = /* @__PURE__ */ f({
  ...q,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...q.contracts
  }
}), WU = /* @__PURE__ */ f({
  ...q,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...q.contracts
  }
}), QU = /* @__PURE__ */ f({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
}), JU = /* @__PURE__ */ f({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: !0
}), hy = /* @__PURE__ */ f({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
}), ZU = /* @__PURE__ */ f({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
}), XU = /* @__PURE__ */ f({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: !1
}), YU = /* @__PURE__ */ f({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
}), eN = f({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: !0
}), tN = /* @__PURE__ */ f({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
}), nN = /* @__PURE__ */ f({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), rN = /* @__PURE__ */ f({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
}), sN = /* @__PURE__ */ f({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: !0
}), aN = /* @__PURE__ */ f({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});
function iN({ blockNumber: t, chain: e, contract: n }) {
  var s;
  const r = (s = e == null ? void 0 : e.contracts) == null ? void 0 : s[n];
  if (!r)
    throw new q0({
      chain: e,
      contract: { name: n }
    });
  if (t && r.blockCreated && r.blockCreated > t)
    throw new q0({
      blockNumber: t,
      chain: e,
      contract: {
        name: n,
        blockCreated: r.blockCreated
      }
    });
  return r.address;
}
const oN = /* @__PURE__ */ f({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: !0
}), cN = /* @__PURE__ */ f({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: !1
}), lN = /* @__PURE__ */ f({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: !1
}), uN = /* @__PURE__ */ f({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: !0
}), dN = /* @__PURE__ */ f({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
}), fN = /* @__PURE__ */ f({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
}), pN = /* @__PURE__ */ f({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
}), hN = /* @__PURE__ */ f({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
}), mN = /* @__PURE__ */ f({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
}), yN = /* @__PURE__ */ f({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: !1
}), bN = /* @__PURE__ */ f({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: !0
}), gN = /* @__PURE__ */ f({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
}), wN = /* @__PURE__ */ f({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: !0
}), EN = /* @__PURE__ */ f({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: !1
}), xN = /* @__PURE__ */ f({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: !0
}), AN = /* @__PURE__ */ f({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: !1
}), kN = /* @__PURE__ */ f({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: !0
}), vN = /* @__PURE__ */ f({
  ...q,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: !0
}), CN = /* @__PURE__ */ f({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: !1
}), TN = /* @__PURE__ */ f({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: !1
}), SN = /* @__PURE__ */ f({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
}), ON = /* @__PURE__ */ f({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
}), BN = /* @__PURE__ */ f({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: !0
}), IN = /* @__PURE__ */ f({
  id: 42793,
  name: "Etherlink",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
}), PN = /* @__PURE__ */ f({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: !0
}), UN = /* @__PURE__ */ f({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), NN = /* @__PURE__ */ f({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
}), RN = /* @__PURE__ */ f({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
}), FN = /* @__PURE__ */ f({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
}), DN = /* @__PURE__ */ f({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
}), MN = /* @__PURE__ */ f({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: !1
}), LN = /* @__PURE__ */ f({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
}), HN = /* @__PURE__ */ f({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
}), $N = /* @__PURE__ */ f({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
}), _N = /* @__PURE__ */ f({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: !0
}), GN = /* @__PURE__ */ f({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: !0
}), zN = /* @__PURE__ */ f({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
}), VN = /* @__PURE__ */ f({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
}), jN = /* @__PURE__ */ f({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: !0
}), qN = /* @__PURE__ */ f({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: !0
}), KN = /* @__PURE__ */ f({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: !1
}), WN = /* @__PURE__ */ f({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
}), QN = /* @__PURE__ */ f({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
}), JN = /* @__PURE__ */ f({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: !0
}), my = /* @__PURE__ */ f({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  },
  blockTime: 800
}), ZN = /* @__PURE__ */ f({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
}), XN = /* @__PURE__ */ f({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: !0,
  blockTime: 800
}), YN = /* @__PURE__ */ f({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
}), eR = /* @__PURE__ */ f({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: !0
}), tR = /* @__PURE__ */ f({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: !0
}), nR = /* @__PURE__ */ f({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: !0
}), yy = /* @__PURE__ */ f({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
}), io = 1, rR = /* @__PURE__ */ f({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...q.contracts,
    addressManager: {
      [io]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [io]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [io]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [io]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [io]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: io
}), sR = /* @__PURE__ */ f({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: !0
}), oo = 11155111, aR = /* @__PURE__ */ f({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...q.contracts,
    addressManager: {
      [oo]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [oo]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [oo]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [oo]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [oo]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0,
  sourceId: oo
}), iR = /* @__PURE__ */ f({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
}), oR = /* @__PURE__ */ f({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), Dd = 1, cR = /* @__PURE__ */ f({
  ...q,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Dd]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Dd]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [Dd]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: Dd
}), Md = 17e3, lR = /* @__PURE__ */ f({
  ...q,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Md]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Md]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [Md]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: Md
}), uR = 1, by = /* @__PURE__ */ f({
  ...q,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...q.contracts
  },
  sourceId: uR
}), dR = 11155111, fR = f({
  ...q,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: !0,
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: dR
}), pR = /* @__PURE__ */ f({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
}), hR = /* @__PURE__ */ f({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
}), mR = /* @__PURE__ */ f({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: !1
}), yR = /* @__PURE__ */ f({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: !0
}), Ld = 17e3, bR = f({
  ...q,
  name: "Garnet Testnet",
  testnet: !0,
  id: 17069,
  sourceId: Ld,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Ld]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [Ld]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [Ld]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
}), gR = /* @__PURE__ */ f({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
}), wR = /* @__PURE__ */ f({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: !1
}), ER = /* @__PURE__ */ f({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), xR = /* @__PURE__ */ f({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), wu = /* @__PURE__ */ f({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
}), gy = /* @__PURE__ */ f({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: !0
}), AR = /* @__PURE__ */ f({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), kR = /* @__PURE__ */ f({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: !0
}), vR = /* @__PURE__ */ f({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: !1
}), CR = /* @__PURE__ */ f({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: !1
}), TR = /* @__PURE__ */ f({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), SR = /* @__PURE__ */ f({
  id: 440017,
  name: "Graphite Network",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Spectre",
      url: "https://main.atgraphite.com",
      apiUrl: "https://api.main.atgraphite.com/api"
    }
  },
  testnet: !1
}), OR = /* @__PURE__ */ f({
  id: 54170,
  name: "Graphite Network Testnet",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-test-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-test-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Testnet Spectre",
      url: "https://test.atgraphite.com",
      apiUrl: "https://api.test.atgraphite.com/api"
    }
  },
  testnet: !0
}), wy = /* @__PURE__ */ f({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
}), BR = /* @__PURE__ */ f({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
}), IR = /* @__PURE__ */ f({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: !1
}), PR = /* @__PURE__ */ f({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: !0
}), UR = /* @__PURE__ */ f({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
}), NR = /* @__PURE__ */ f({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0
}), RR = /* @__PURE__ */ f({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
}), FR = /* @__PURE__ */ f({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
}), DR = /* @__PURE__ */ f({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), MR = /* @__PURE__ */ f({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
}), LR = /* @__PURE__ */ f({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), HR = /* @__PURE__ */ f({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://hashkeychain-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkeychain-testnet-explorer.alt.technology"
    }
  },
  testnet: !0
}), $R = /* @__PURE__ */ f({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: !0
}), _R = /* @__PURE__ */ f({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: !1
}), GR = /* @__PURE__ */ f({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: !0
}), zR = /* @__PURE__ */ f({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: !0
}), VR = /* @__PURE__ */ f({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: !1
}), Ey = /* @__PURE__ */ f({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: !1
}), jR = /* @__PURE__ */ f({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: !0
}), qR = /* @__PURE__ */ f({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: !0
}), KR = /* @__PURE__ */ f({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: !0
}), WR = /* @__PURE__ */ f({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: !1
}), QR = 42161, JR = /* @__PURE__ */ f({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: QR
}), ZR = 421614, XR = /* @__PURE__ */ f({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: ZR
}), YR = /* @__PURE__ */ f({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
}), eF = /* @__PURE__ */ f({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), xy = /* @__PURE__ */ f({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: !1
}), tF = /* @__PURE__ */ f({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: !0
}), nF = /* @__PURE__ */ f({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: !1
}), rF = /* @__PURE__ */ f({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
}), sF = /* @__PURE__ */ f({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: !0
}), aF = /* @__PURE__ */ f({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
}), iF = /* @__PURE__ */ f({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
}), oF = /* @__PURE__ */ f({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: !0
}), Hd = 1, Ay = /* @__PURE__ */ f({
  ...q,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...q.contracts,
    disputeGameFactory: {
      [Hd]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [Hd]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [Hd]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: !1,
  sourceId: Hd
}), $d = 11155111, cF = /* @__PURE__ */ f({
  ...q,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [$d]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [$d]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [$d]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: !0,
  sourceId: $d
}), lF = /* @__PURE__ */ f({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
}), uF = /* @__PURE__ */ f({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: !0
}), dF = /* @__PURE__ */ f({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
}), fF = /* @__PURE__ */ f({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: !0
}), pF = /* @__PURE__ */ f({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
}), hF = /* @__PURE__ */ f({
  id: 8899,
  name: "JB Chain",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: !1
}), mF = /* @__PURE__ */ f({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: !0
}), yF = /* @__PURE__ */ f({
  id: 81,
  name: "Japan Open Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Token",
    symbol: "JOC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.japanopenchain.org:8545",
        "https://rpc-2.japanopenchain.org:8545",
        "https://rpc-3.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.japanopenchain.org"
    }
  },
  testnet: !1
}), bF = /* @__PURE__ */ f({
  id: 10081,
  name: "Japan Open Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Testnet Token",
    symbol: "JOCT"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.testnet.japanopenchain.org:8545",
        "https://rpc-2.testnet.japanopenchain.org:8545",
        "https://rpc-3.testnet.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Testnet Block Explorer",
      url: "https://explorer.testnet.japanopenchain.org"
    }
  },
  testnet: !0
}), gF = /* @__PURE__ */ f({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
}), wF = /* @__PURE__ */ f({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
}), EF = /* @__PURE__ */ f({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
}), xF = /* @__PURE__ */ f({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
}), AF = /* @__PURE__ */ f({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
}), kF = /* @__PURE__ */ f({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
}), vF = /* @__PURE__ */ f({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
}), CF = /* @__PURE__ */ f({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
}), TF = /* @__PURE__ */ f({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
}), SF = /* @__PURE__ */ f({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
}), OF = /* @__PURE__ */ f({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: !0
}), BF = /* @__PURE__ */ f({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
}), IF = /* @__PURE__ */ f({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
}), PF = /* @__PURE__ */ f({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: !1
}), UF = /* @__PURE__ */ f({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), NF = /* @__PURE__ */ f({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), RF = /* @__PURE__ */ f({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: !1
}), FF = /* @__PURE__ */ f({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: !1
}), DF = /* @__PURE__ */ f({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: !0
}), MF = /* @__PURE__ */ f({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: !1
}), LF = /* @__PURE__ */ f({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: !1
}), HF = /* @__PURE__ */ f({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), $F = /* @__PURE__ */ f({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), _F = /* @__PURE__ */ f({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), GF = /* @__PURE__ */ f({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), zF = f({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: !0
}), VF = /* @__PURE__ */ f({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: !1
}), jF = /* @__PURE__ */ f({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: !0
}), qF = /* @__PURE__ */ f({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: !1
}), KF = /* @__PURE__ */ f({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: !0
}), WF = /* @__PURE__ */ f({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: !1
}), QF = /* @__PURE__ */ f({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
}), JF = /* @__PURE__ */ f({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: !0
}), ZF = /* @__PURE__ */ f({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: !0
}), XF = /* @__PURE__ */ f({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: !0
}), YF = /* @__PURE__ */ f({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: !1
});
function Hn(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
class no extends H {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
const eD = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, tD = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, nD = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function zc(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new mD(t.type);
  return `${t.name}(${Jg(t.inputs, { includeName: e })})`;
}
function Jg(t, { includeName: e = !1 } = {}) {
  return t ? t.map((n) => rD(n, { includeName: e })).join(e ? ", " : ",") : "";
}
function rD(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${Jg(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
class sD extends H {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class nx extends H {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class aD extends H {
  constructor({ data: e, params: n, size: r }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${Jg(n, { includeName: !0 })})`,
        `Data:   ${e} (${r} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = n, this.size = r;
  }
}
class Zg extends H {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class iD extends H {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super([
      `ABI encoding array length mismatch for type ${r}.`,
      `Expected length: ${e}`,
      `Given length: ${n}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class oD extends H {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${Xe(n)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class cD extends H {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class tY extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,
      "Cannot encode error result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the inputs exist on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorInputsNotFoundError"
    });
  }
}
class nY extends H {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Error ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorNotFoundError"
    });
  }
}
class R8 extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class Xf extends H {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class lD extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Function "${e}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class rY extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded function signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionSignatureNotFoundError"
    });
  }
}
class uD extends H {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${zc(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${zc(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
let dD = class extends H {
  constructor({ expectedSize: e, givenSize: n }) {
    super(`Expected bytes${e}, got bytes${n}.`, {
      name: "BytesSizeMismatchError"
    });
  }
};
class fD extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiEncodingType" });
  }
}
class pD extends H {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiDecodingType" });
  }
}
let hD = class extends H {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
};
class mD extends H {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
const yD = (t) => We(vo(t));
function bD(t) {
  return yD(t);
}
const gD = "1.0.8";
let gn = class ky extends Error {
  constructor(e, n = {}) {
    var i;
    const r = n.cause instanceof ky ? n.cause.details : (i = n.cause) != null && i.message ? n.cause.message : n.details, s = n.cause instanceof ky && n.cause.docsPath || n.docsPath, a = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...s ? [`Docs: https://abitype.dev${s}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: abitype@${gD}`
    ].join(`
`);
    super(a), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.shortMessage = e;
  }
};
function As(t, e) {
  const n = t.exec(e);
  return n == null ? void 0 : n.groups;
}
const F8 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, D8 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, M8 = /^\(.+?\).*?$/, rx = /^tuple(?<array>(\[(\d*)\])*)$/;
function vy(t) {
  let e = t.type;
  if (rx.test(t.type) && "components" in t) {
    e = "(";
    const n = t.components.length;
    for (let s = 0; s < n; s++) {
      const a = t.components[s];
      e += vy(a), s < n - 1 && (e += ", ");
    }
    const r = As(rx, t.type);
    return e += `)${(r == null ? void 0 : r.array) ?? ""}`, vy({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function ml(t) {
  let e = "";
  const n = t.length;
  for (let r = 0; r < n; r++) {
    const s = t[r];
    e += vy(s), r !== n - 1 && (e += ", ");
  }
  return e;
}
function Yf(t) {
  var e;
  return t.type === "function" ? `function ${t.name}(${ml(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${(e = t.outputs) != null && e.length ? ` returns (${ml(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${ml(t.inputs)})` : t.type === "error" ? `error ${t.name}(${ml(t.inputs)})` : t.type === "constructor" ? `constructor(${ml(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? `fallback() external${t.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
const L8 = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function wD(t) {
  return L8.test(t);
}
function ED(t) {
  return As(L8, t);
}
const H8 = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function xD(t) {
  return H8.test(t);
}
function AD(t) {
  return As(H8, t);
}
const $8 = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function kD(t) {
  return $8.test(t);
}
function vD(t) {
  return As($8, t);
}
const _8 = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function G8(t) {
  return _8.test(t);
}
function CD(t) {
  return As(_8, t);
}
const z8 = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function TD(t) {
  return z8.test(t);
}
function SD(t) {
  return As(z8, t);
}
const V8 = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function OD(t) {
  return V8.test(t);
}
function BD(t) {
  return As(V8, t);
}
const ID = /^receive\(\) external payable$/;
function PD(t) {
  return ID.test(t);
}
const UD = /* @__PURE__ */ new Set(["indexed"]), Cy = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class ND extends gn {
  constructor({ signature: e }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,
      docsPath: "/api/human#parseabiitem-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiItemError"
    });
  }
}
class RD extends gn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class FD extends gn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class DD extends gn {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class MD extends gn {
  constructor({ param: e, name: n }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class LD extends gn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class HD extends gn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class $D extends gn {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class Yc extends gn {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class _D extends gn {
  constructor({ signature: e }) {
    super("Unknown signature.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class GD extends gn {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class zD extends gn {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class VD extends gn {
  constructor({ current: e, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function jD(t, e, n) {
  let r = "";
  if (n)
    for (const s of Object.entries(n)) {
      if (!s)
        continue;
      let a = "";
      for (const i of s[1])
        a += `[${i.type}${i.name ? `:${i.name}` : ""}]`;
      r += `(${s[0]}{${a}})`;
    }
  return e ? `${e}:${t}${r}` : t;
}
const bm = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function j8(t, e = {}) {
  if (kD(t))
    return qD(t, e);
  if (xD(t))
    return KD(t, e);
  if (wD(t))
    return WD(t, e);
  if (TD(t))
    return QD(t, e);
  if (OD(t))
    return JD(t);
  if (PD(t))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new _D({ signature: t });
}
function qD(t, e = {}) {
  const n = vD(t);
  if (!n)
    throw new Yc({ signature: t, type: "function" });
  const r = nr(n.parameters), s = [], a = r.length;
  for (let o = 0; o < a; o++)
    s.push(Gi(r[o], {
      modifiers: Cy,
      structs: e,
      type: "function"
    }));
  const i = [];
  if (n.returns) {
    const o = nr(n.returns), c = o.length;
    for (let u = 0; u < c; u++)
      i.push(Gi(o[u], {
        modifiers: Cy,
        structs: e,
        type: "function"
      }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s,
    outputs: i
  };
}
function KD(t, e = {}) {
  const n = AD(t);
  if (!n)
    throw new Yc({ signature: t, type: "event" });
  const r = nr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Gi(r[i], {
      modifiers: UD,
      structs: e,
      type: "event"
    }));
  return { name: n.name, type: "event", inputs: s };
}
function WD(t, e = {}) {
  const n = ED(t);
  if (!n)
    throw new Yc({ signature: t, type: "error" });
  const r = nr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Gi(r[i], { structs: e, type: "error" }));
  return { name: n.name, type: "error", inputs: s };
}
function QD(t, e = {}) {
  const n = SD(t);
  if (!n)
    throw new Yc({ signature: t, type: "constructor" });
  const r = nr(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(Gi(r[i], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s
  };
}
function JD(t) {
  const e = BD(t);
  if (!e)
    throw new Yc({ signature: t, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable"
  };
}
const ZD = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, XD = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, YD = /^u?int$/;
function Gi(t, e) {
  var d, m;
  const n = jD(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs);
  if (bm.has(n))
    return bm.get(n);
  const r = M8.test(t), s = As(r ? XD : ZD, t);
  if (!s)
    throw new DD({ param: t });
  if (s.name && tM(s.name))
    throw new MD({ param: t, name: s.name });
  const a = s.name ? { name: s.name } : {}, i = s.modifier === "indexed" ? { indexed: !0 } : {}, o = (e == null ? void 0 : e.structs) ?? {};
  let c, u = {};
  if (r) {
    c = "tuple";
    const h = nr(s.type), b = [], y = h.length;
    for (let g = 0; g < y; g++)
      b.push(Gi(h[g], { structs: o }));
    u = { components: b };
  } else if (s.type in o)
    c = "tuple", u = { components: o[s.type] };
  else if (YD.test(s.type))
    c = `${s.type}256`;
  else if (c = s.type, (e == null ? void 0 : e.type) !== "struct" && !q8(c))
    throw new FD({ type: c });
  if (s.modifier) {
    if (!((m = (d = e == null ? void 0 : e.modifiers) == null ? void 0 : d.has) != null && m.call(d, s.modifier)))
      throw new LD({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
    if (Cy.has(s.modifier) && !nM(c, !!s.array))
      throw new HD({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
  }
  const l = {
    type: `${c}${s.array ?? ""}`,
    ...a,
    ...i,
    ...u
  };
  return bm.set(n, l), l;
}
function nr(t, e = [], n = "", r = 0) {
  const s = t.trim().length;
  for (let a = 0; a < s; a++) {
    const i = t[a], o = t.slice(a + 1);
    switch (i) {
      case ",":
        return r === 0 ? nr(o, [...e, n.trim()]) : nr(o, e, `${n}${i}`, r);
      case "(":
        return nr(o, e, `${n}${i}`, r + 1);
      case ")":
        return nr(o, e, `${n}${i}`, r - 1);
      default:
        return nr(o, e, `${n}${i}`, r);
    }
  }
  if (n === "")
    return e;
  if (r !== 0)
    throw new VD({ current: n, depth: r });
  return e.push(n.trim()), e;
}
function q8(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || F8.test(t) || D8.test(t);
}
const eM = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function tM(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || t === "tuple" || F8.test(t) || D8.test(t) || eM.test(t);
}
function nM(t, e) {
  return e || t === "bytes" || t === "string" || t === "tuple";
}
function rM(t) {
  const e = {}, n = t.length;
  for (let i = 0; i < n; i++) {
    const o = t[i];
    if (!G8(o))
      continue;
    const c = CD(o);
    if (!c)
      throw new Yc({ signature: o, type: "struct" });
    const u = c.properties.split(";"), l = [], d = u.length;
    for (let m = 0; m < d; m++) {
      const b = u[m].trim();
      if (!b)
        continue;
      const y = Gi(b, {
        type: "struct"
      });
      l.push(y);
    }
    if (!l.length)
      throw new GD({ signature: o });
    e[c.name] = l;
  }
  const r = {}, s = Object.entries(e), a = s.length;
  for (let i = 0; i < a; i++) {
    const [o, c] = s[i];
    r[o] = K8(c, e);
  }
  return r;
}
const sM = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function K8(t, e, n = /* @__PURE__ */ new Set()) {
  const r = [], s = t.length;
  for (let a = 0; a < s; a++) {
    const i = t[a];
    if (M8.test(i.type))
      r.push(i);
    else {
      const c = As(sM, i.type);
      if (!(c != null && c.type))
        throw new $D({ abiParameter: i });
      const { array: u, type: l } = c;
      if (l in e) {
        if (n.has(l))
          throw new zD({ type: l });
        r.push({
          ...i,
          type: `tuple${u ?? ""}`,
          components: K8(e[l] ?? [], e, /* @__PURE__ */ new Set([...n, l]))
        });
      } else if (q8(l))
        r.push(i);
      else
        throw new RD({ type: l });
    }
  }
  return r;
}
function Wp(t) {
  const e = rM(t), n = [], r = t.length;
  for (let s = 0; s < r; s++) {
    const a = t[s];
    G8(a) || n.push(j8(a, e));
  }
  return n;
}
function sx(t) {
  let e;
  if (e = j8(t), !e)
    throw new ND({ signature: t });
  return e;
}
function aM(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new H("Unable to normalize signature.");
  return s;
}
const iM = (t) => {
  const e = typeof t == "string" ? t : Yf(t);
  return aM(e);
};
function W8(t) {
  return bD(iM(t));
}
const Xg = (t) => bu(W8(t), 0, 4);
function oM(t, e = {}) {
  typeof e.size < "u" && Gr(t, { size: e.size });
  const n = It(t, e);
  return Re(n, e);
}
function cM(t, e = {}) {
  let n = t;
  if (typeof e.size < "u" && (Gr(n, { size: e.size }), n = bs(n)), n.length > 1 || n[0] > 1)
    throw new lI(n);
  return !!n[0];
}
function ms(t, e = {}) {
  typeof e.size < "u" && Gr(t, { size: e.size });
  const n = It(t, e);
  return va(n, e);
}
function lM(t, e = {}) {
  let n = t;
  return typeof e.size < "u" && (Gr(n, { size: e.size }), n = bs(n, { dir: "right" })), new TextDecoder().decode(n);
}
const uM = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, Q8 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function ma(t, e) {
  if (t.length !== e.length)
    throw new cD({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = dM({
    params: t,
    values: e
  }), r = e1(n);
  return r.length === 0 ? "0x" : r;
}
function dM({ params: t, values: e }) {
  const n = [];
  for (let r = 0; r < t.length; r++)
    n.push(Yg({ param: t[r], value: e[r] }));
  return n;
}
function Yg({ param: t, value: e }) {
  const n = t1(t.type);
  if (n) {
    const [r, s] = n;
    return pM(e, { length: r, param: { ...t, type: s } });
  }
  if (t.type === "tuple")
    return gM(e, {
      param: t
    });
  if (t.type === "address")
    return fM(e);
  if (t.type === "bool")
    return mM(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const r = t.type.startsWith("int"), [, , s = "256"] = Q8.exec(t.type) ?? [];
    return yM(e, {
      signed: r,
      size: Number(s)
    });
  }
  if (t.type.startsWith("bytes"))
    return hM(e, { param: t });
  if (t.type === "string")
    return bM(e);
  throw new fD(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function e1(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += Xe(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(W(e + s, { size: 32 })), r.push(o), s += Xe(o)) : n.push(o);
  }
  return rn([...n, ...r]);
}
function fM(t) {
  if (!He(t))
    throw new Ye({ address: t });
  return { dynamic: !1, encoded: ha(t.toLowerCase()) };
}
function pM(t, { length: e, param: n }) {
  const r = e === null;
  if (!Array.isArray(t))
    throw new hD(t);
  if (!r && t.length !== e)
    throw new iD({
      expectedLength: e,
      givenLength: t.length,
      type: `${n.type}[${e}]`
    });
  let s = !1;
  const a = [];
  for (let i = 0; i < t.length; i++) {
    const o = Yg({ param: n, value: t[i] });
    o.dynamic && (s = !0), a.push(o);
  }
  if (r || s) {
    const i = e1(a);
    if (r) {
      const o = W(a.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: a.length > 0 ? rn([o, i]) : o
      };
    }
    if (s)
      return { dynamic: !0, encoded: i };
  }
  return {
    dynamic: !1,
    encoded: rn(a.map(({ encoded: i }) => i))
  };
}
function hM(t, { param: e }) {
  const [, n] = e.type.split("bytes"), r = Xe(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = ha(s, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: rn([ha(W(r, { size: 32 })), s])
    };
  }
  if (r !== Number.parseInt(n))
    throw new oD({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: ha(t, { dir: "right" }) };
}
function mM(t) {
  if (typeof t != "boolean")
    throw new H(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: ha(Qk(t)) };
}
function yM(t, { signed: e, size: n = 256 }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new qk({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: W(t, {
      size: 32,
      signed: e
    })
  };
}
function bM(t) {
  const e = hu(t), n = Math.ceil(Xe(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(ha(bu(e, s * 32, (s + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: rn([
      ha(W(Xe(e), { size: 32 })),
      ...r
    ])
  };
}
function gM(t, { param: e }) {
  let n = !1;
  const r = [];
  for (let s = 0; s < e.components.length; s++) {
    const a = e.components[s], i = Array.isArray(t) ? s : a.name, o = Yg({
      param: a,
      value: t[i]
    });
    r.push(o), o.dynamic && (n = !0);
  }
  return {
    dynamic: n,
    encoded: n ? e1(r) : rn(r.map(({ encoded: s }) => s))
  };
}
function t1(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function J8(t, e) {
  const n = typeof e == "string" ? nn(e) : e, r = $g(n);
  if (Xe(n) === 0 && t.length > 0)
    throw new Zg();
  if (Xe(e) && Xe(e) < 32)
    throw new aD({
      data: typeof e == "string" ? e : It(e),
      params: t,
      size: Xe(e)
    });
  let s = 0;
  const a = [];
  for (let i = 0; i < t.length; ++i) {
    const o = t[i];
    r.setPosition(s);
    const [c, u] = Co(r, o, {
      staticPosition: 0
    });
    s += u, a.push(c);
  }
  return a;
}
function Co(t, e, { staticPosition: n }) {
  const r = t1(e.type);
  if (r) {
    const [s, a] = r;
    return EM(t, { ...e, type: a }, { length: s, staticPosition: n });
  }
  if (e.type === "tuple")
    return vM(t, e, { staticPosition: n });
  if (e.type === "address")
    return wM(t);
  if (e.type === "bool")
    return xM(t);
  if (e.type.startsWith("bytes"))
    return AM(t, e, { staticPosition: n });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return kM(t, e);
  if (e.type === "string")
    return CM(t, { staticPosition: n });
  throw new pD(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const ax = 32, Ty = 32;
function wM(t) {
  const e = t.readBytes(32);
  return [Kp(It(T8(e, -20))), 32];
}
function EM(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const i = ms(t.readBytes(Ty)), o = r + i, c = o + ax;
    t.setPosition(o);
    const u = ms(t.readBytes(ax)), l = Eu(e);
    let d = 0;
    const m = [];
    for (let h = 0; h < u; ++h) {
      t.setPosition(c + (l ? h * 32 : d));
      const [b, y] = Co(t, e, {
        staticPosition: c
      });
      d += y, m.push(b);
    }
    return t.setPosition(r + 32), [m, 32];
  }
  if (Eu(e)) {
    const i = ms(t.readBytes(Ty)), o = r + i, c = [];
    for (let u = 0; u < n; ++u) {
      t.setPosition(o + u * 32);
      const [l] = Co(t, e, {
        staticPosition: o
      });
      c.push(l);
    }
    return t.setPosition(r + 32), [c, 32];
  }
  let s = 0;
  const a = [];
  for (let i = 0; i < n; ++i) {
    const [o, c] = Co(t, e, {
      staticPosition: r + s
    });
    s += c, a.push(o);
  }
  return [a, s];
}
function xM(t) {
  return [cM(t.readBytes(32), { size: 32 }), 32];
}
function AM(t, e, { staticPosition: n }) {
  const [r, s] = e.type.split("bytes");
  if (!s) {
    const i = ms(t.readBytes(32));
    t.setPosition(n + i);
    const o = ms(t.readBytes(32));
    if (o === 0)
      return t.setPosition(n + 32), ["0x", 32];
    const c = t.readBytes(o);
    return t.setPosition(n + 32), [It(c), 32];
  }
  return [It(t.readBytes(Number.parseInt(s), 32)), 32];
}
function kM(t, e) {
  const n = e.type.startsWith("int"), r = Number.parseInt(e.type.split("int")[1] || "256"), s = t.readBytes(32);
  return [
    r > 48 ? oM(s, { signed: n }) : ms(s, { signed: n }),
    32
  ];
}
function vM(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: i }) => !i), s = r ? [] : {};
  let a = 0;
  if (Eu(e)) {
    const i = ms(t.readBytes(Ty)), o = n + i;
    for (let c = 0; c < e.components.length; ++c) {
      const u = e.components[c];
      t.setPosition(o + a);
      const [l, d] = Co(t, u, {
        staticPosition: o
      });
      a += d, s[r ? c : u == null ? void 0 : u.name] = l;
    }
    return t.setPosition(n + 32), [s, 32];
  }
  for (let i = 0; i < e.components.length; ++i) {
    const o = e.components[i], [c, u] = Co(t, o, {
      staticPosition: n
    });
    s[r ? i : o == null ? void 0 : o.name] = c, a += u;
  }
  return [s, a];
}
function CM(t, { staticPosition: e }) {
  const n = ms(t.readBytes(32)), r = e + n;
  t.setPosition(r);
  const s = ms(t.readBytes(32));
  if (s === 0)
    return t.setPosition(e + 32), ["", 32];
  const a = t.readBytes(s, 32), i = lM(bs(a));
  return t.setPosition(e + 32), [i, 32];
}
function Eu(t) {
  var r;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (r = t.components) == null ? void 0 : r.some(Eu);
  const n = t1(t.type);
  return !!(n && Eu({ ...t, type: n[1] }));
}
function Z8(t) {
  const { abi: e, data: n } = t, r = bu(n, 0, 4);
  if (r === "0x")
    throw new Zg();
  const a = [...e || [], tD, nD].find((i) => i.type === "error" && r === Xg(zc(i)));
  if (!a)
    throw new R8(r, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: a,
    args: "inputs" in a && a.inputs && a.inputs.length > 0 ? J8(a.inputs, bu(n, 4)) : void 0,
    errorName: a.name
  };
}
const el = (t, e, n) => JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() : s, n);
function X8({ abiItem: t, args: e, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${n ? t.name : ""}(${t.inputs.map((s, a) => `${r && s.name ? `${s.name}: ` : ""}${typeof e[a] == "object" ? el(e[a]) : e[a]}`).join(", ")})`;
}
const TM = W8;
function n1(t) {
  const { abi: e, args: n = [], name: r } = t, s = Jc(r, { strict: !1 }), a = e.filter((o) => s ? o.type === "function" ? Xg(o) === r : o.type === "event" ? TM(o) === r : !1 : "name" in o && o.name === r);
  if (a.length === 0)
    return;
  if (a.length === 1)
    return a[0];
  let i;
  for (const o of a) {
    if (!("inputs" in o))
      continue;
    if (!n || n.length === 0) {
      if (!o.inputs || o.inputs.length === 0)
        return o;
      continue;
    }
    if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== n.length)
      continue;
    if (n.every((u, l) => {
      const d = "inputs" in o && o.inputs[l];
      return d ? Sy(u, d) : !1;
    })) {
      if (i && "inputs" in i && i.inputs) {
        const u = Y8(o.inputs, i.inputs, n);
        if (u)
          throw new uD({
            abiItem: o,
            type: u[0]
          }, {
            abiItem: i,
            type: u[1]
          });
      }
      i = o;
    }
  }
  return i || a[0];
}
function Sy(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return He(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => Sy(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => Sy(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function Y8(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return Y8(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? He(n[r], { strict: !1 }) : i.includes("address") && i.includes("bytes") ? He(n[r], { strict: !1 }) : !1)
      return i;
  }
}
class SM extends H {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class OM extends H {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function ix(t) {
  return t.reduce((e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`, "");
}
function BM(t) {
  return t.reduce((e, { address: n, ...r }) => {
    let s = `${e}    ${n}:
`;
    return r.nonce && (s += `      nonce: ${r.nonce}
`), r.balance && (s += `      balance: ${r.balance}
`), r.code && (s += `      code: ${r.code}
`), r.state && (s += `      state:
`, s += ix(r.state)), r.stateDiff && (s += `      stateDiff:
`, s += ix(r.stateDiff)), s;
  }, `  State Override:
`).slice(0, -1);
}
const IM = (t) => t, ev = (t) => t;
class PM extends H {
  constructor(e, { account: n, docsPath: r, chain: s, data: a, gas: i, gasPrice: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, to: d, value: m, stateOverride: h }) {
    var g;
    const b = n ? Hn(n) : void 0;
    let y = jp({
      from: b == null ? void 0 : b.address,
      to: d,
      value: typeof m < "u" && `${II(m)} ${((g = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : g.symbol) || "ETH"}`,
      data: a,
      gas: i,
      gasPrice: typeof o < "u" && `${hs(o)} gwei`,
      maxFeePerGas: typeof c < "u" && `${hs(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${hs(u)} gwei`,
      nonce: l
    });
    h && (y += `
${BM(h)}`), super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Raw Call Arguments:",
        y
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class tv extends H {
  constructor(e, { abi: n, args: r, contractAddress: s, docsPath: a, functionName: i, sender: o }) {
    const c = n1({ abi: n, args: r, name: i }), u = c ? X8({
      abiItem: c,
      args: r,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, l = c ? zc(c, { includeName: !0 }) : void 0, d = jp({
      address: s && IM(s),
      function: l,
      args: u && u !== "()" && `${[...Array((i == null ? void 0 : i.length) ?? 0).keys()].map(() => " ").join("")}${u}`,
      sender: o
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${i}".`, {
      cause: e,
      docsPath: a,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        d && "Contract Call:",
        d
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = n, this.args = r, this.cause = e, this.contractAddress = s, this.functionName = i, this.sender = o;
  }
}
class nv extends H {
  constructor({ abi: e, data: n, functionName: r, message: s }) {
    let a, i, o, c;
    if (n && n !== "0x")
      try {
        i = Z8({ abi: e, data: n });
        const { abiItem: l, errorName: d, args: m } = i;
        if (d === "Error")
          c = m[0];
        else if (d === "Panic") {
          const [h] = m;
          c = eD[h];
        } else {
          const h = l ? zc(l, { includeName: !0 }) : void 0, b = l && m ? X8({
            abiItem: l,
            args: m,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          o = [
            h ? `Error: ${h}` : "",
            b && b !== "()" ? `       ${[...Array((d == null ? void 0 : d.length) ?? 0).keys()].map(() => " ").join("")}${b}` : ""
          ];
        }
      } catch (l) {
        a = l;
      }
    else s && (c = s);
    let u;
    a instanceof R8 && (u = a.signature, o = [
      `Unable to decode signature "${u}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`
    ]), super(c && c !== "execution reverted" || u ? [
      `The contract function "${r}" reverted with the following ${u ? "signature" : "reason"}:`,
      c || u
    ].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: a,
      metaMessages: o,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "raw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = i, this.raw = n, this.reason = c, this.signature = u;
  }
}
class rv extends H {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class UM extends H {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class sv extends H {
  constructor({ data: e, message: n }) {
    super(n || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class iY extends H {
  constructor({ body: e, cause: n, details: r, headers: s, status: a, url: i }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        a && `Status: ${a}`,
        `URL: ${ev(i)}`,
        e && `Request body: ${el(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = s, this.status = a, this.url = i;
  }
}
class av extends H {
  constructor({ body: e, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${ev(r)}`, `Request body: ${el(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code, this.data = n.data;
  }
}
const NM = -1;
class RM extends H {
  constructor(e, { code: n, docsPath: r, metaMessages: s, name: a, shortMessage: i }) {
    super(i, {
      cause: e,
      docsPath: r,
      metaMessages: s || (e == null ? void 0 : e.metaMessages),
      name: a || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = a || e.name, this.code = e instanceof av ? e.code : n ?? NM;
  }
}
class Qp extends RM {
  constructor(e) {
    super(e, {
      code: Qp.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(Qp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
function FM(t, e) {
  const n = (t.details || "").toLowerCase(), r = t instanceof H ? t.walk((s) => (s == null ? void 0 : s.code) === mo.code) : t;
  return r instanceof H ? new mo({
    cause: t,
    message: r.details
  }) : mo.nodeMessage.test(n) ? new mo({
    cause: t,
    message: t.details
  }) : Ca.nodeMessage.test(n) ? new Ca({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : K0.nodeMessage.test(n) ? new K0({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : W0.nodeMessage.test(n) ? new W0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : Q0.nodeMessage.test(n) ? new Q0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : J0.nodeMessage.test(n) ? new J0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : Z0.nodeMessage.test(n) ? new Z0({ cause: t }) : X0.nodeMessage.test(n) ? new X0({ cause: t, gas: e == null ? void 0 : e.gas }) : Y0.nodeMessage.test(n) ? new Y0({ cause: t, gas: e == null ? void 0 : e.gas }) : ey.nodeMessage.test(n) ? new ey({ cause: t }) : _c.nodeMessage.test(n) ? new _c({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new g8({
    cause: t
  });
}
function iv(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = FM(t, n);
    return s instanceof g8 ? t : s;
  })();
  return new PM(r, {
    docsPath: e,
    ...n
  });
}
function ov(t, { format: e }) {
  if (!e)
    return {};
  const n = {};
  function r(a) {
    const i = Object.keys(a);
    for (const o of i)
      o in t && (n[o] = t[o]), a[o] && typeof a[o] == "object" && !Array.isArray(a[o]) && r(a[o]);
  }
  const s = e(t || {});
  return r(s), n;
}
function cv(t) {
  const { account: e, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: s, to: a } = t, i = e ? Hn(e) : void 0;
  if (i && !He(i.address))
    throw new Ye({ address: i.address });
  if (a && !He(a))
    throw new Ye({ address: a });
  if (typeof n < "u" && (typeof r < "u" || typeof s < "u"))
    throw new PI();
  if (r && r > sd)
    throw new Ca({ maxFeePerGas: r });
  if (s && r && s > r)
    throw new _c({ maxFeePerGas: r, maxPriorityFeePerGas: s });
}
async function DM(t, e) {
  var s, a, i;
  const { account: n = t.account } = e;
  if (!n)
    throw new no();
  const r = Hn(n);
  try {
    const { accessList: o, blockNumber: c, blockTag: u, data: l, gas: d, gasPrice: m, maxFeePerGas: h, maxPriorityFeePerGas: b, nonce: y, to: g, value: w, ...v } = e, B = (typeof c == "bigint" ? W(c) : void 0) || u;
    cv(e);
    const x = (i = (a = (s = t.chain) == null ? void 0 : s.formatters) == null ? void 0 : a.transactionRequest) == null ? void 0 : i.format, I = (x || Lg)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...ov(v, { format: x }),
      from: r == null ? void 0 : r.address,
      accessList: o,
      data: l,
      gas: d,
      gasPrice: m,
      maxFeePerGas: h,
      maxPriorityFeePerGas: b,
      nonce: y,
      to: g,
      value: w
    }), { baseFeePerGas: O, gasLimit: C, priorityFeePerGas: U } = await t.request({
      method: "linea_estimateGas",
      params: B ? [I, B] : [I]
    });
    return {
      baseFeePerGas: BigInt(O),
      gasLimit: BigInt(C),
      priorityFeePerGas: BigInt(U)
    };
  } catch (o) {
    throw iv(o, {
      ...e,
      account: r,
      chain: t.chain
    });
  }
}
const r1 = {
  fees: {
    estimateFeesPerGas: ox,
    async maxPriorityFeePerGas({ block: t, client: e, request: n }) {
      const r = await ox({
        block: t,
        client: e,
        multiply: (s) => s,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function ox({ client: t, multiply: e, request: n, type: r }) {
  try {
    const s = await DM(t, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: a } = s, o = e(BigInt(s.baseFeePerGas)) + a;
    return r === "legacy" ? { gasPrice: o } : {
      maxFeePerGas: o,
      maxPriorityFeePerGas: a
    };
  } catch {
    return null;
  }
}
const zi = /* @__PURE__ */ f({
  ...r1,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x3aA974fb3f8C1E02796048BDCdeD79e9D53a6965",
      blockCreated: 6683e3
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !1
}), MM = /* @__PURE__ */ f({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), id = /* @__PURE__ */ f({
  ...r1,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x72560a31B3DAEE82B984a7F51c6b3b1bb7CC9F50",
      blockCreated: 2395255
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !0
}), LM = /* @__PURE__ */ f({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), _d = 1, Oy = /* @__PURE__ */ f({
  ...q,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [_d]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [_d]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [_d]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: _d
}), Gd = 11155111, HM = /* @__PURE__ */ f({
  ...q,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Gd]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Gd]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [Gd]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: !0,
  sourceId: Gd
}), $M = /* @__PURE__ */ f({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), _M = /* @__PURE__ */ f({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: !1
}), GM = /* @__PURE__ */ f({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
}), zM = /* @__PURE__ */ f({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: !0
}), VM = /* @__PURE__ */ f({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: !1
}), jM = /* @__PURE__ */ f({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: !0
}), qM = /* @__PURE__ */ f({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: !1
}), KM = /* @__PURE__ */ f({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: !0
}), WM = /* @__PURE__ */ f({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
}), QM = /* @__PURE__ */ f({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
}), Ln = /* @__PURE__ */ f({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), JM = /* @__PURE__ */ f({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: !0
}), By = /* @__PURE__ */ f({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
}), ZM = /* @__PURE__ */ f({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: !0
}), XM = /* @__PURE__ */ f({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: !0
}), Iy = /* @__PURE__ */ f({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
}), YM = /* @__PURE__ */ f({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: !0
}), eL = /* @__PURE__ */ f({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: !0
}), tL = /* @__PURE__ */ f({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: !1
}), nL = /* @__PURE__ */ f({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
}), rL = /* @__PURE__ */ f({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: !0
}), sL = /* @__PURE__ */ f({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: !1
}), aL = /* @__PURE__ */ f({
  id: 6342,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), iL = /* @__PURE__ */ f({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: !0
}), oL = /* @__PURE__ */ f({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
}), cL = /* @__PURE__ */ f({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
}), lL = /* @__PURE__ */ f({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
}), uL = /* @__PURE__ */ f({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: !0
}), dL = /* @__PURE__ */ f({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
}), fL = /* @__PURE__ */ f({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: !0
}), pL = /* @__PURE__ */ f({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: !1
}), zd = 1, hL = /* @__PURE__ */ f({
  ...q,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [zd]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [zd]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [zd]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: zd
}), mL = /* @__PURE__ */ f({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
}), yL = /* @__PURE__ */ f({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
}), Py = /* @__PURE__ */ f({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
}), bL = /* @__PURE__ */ f({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
}), gL = /* @__PURE__ */ f({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
}), wL = /* @__PURE__ */ f({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
}), EL = /* @__PURE__ */ f({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: !0
}), Uy = /* @__PURE__ */ f({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: !1
}), xL = /* @__PURE__ */ f({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: !0
}), AL = /* @__PURE__ */ f({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: !0
}), Vd = 1, Ny = /* @__PURE__ */ f({
  ...q,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [Vd]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [Vd]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [Vd]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: Vd
}), jd = 11155111, kL = /* @__PURE__ */ f({
  ...q,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [jd]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [jd]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [jd]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: !0,
  sourceId: jd
}), vL = /* @__PURE__ */ f({
  id: 10143,
  name: "Monad Testnet",
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: !0
}), CL = /* @__PURE__ */ f({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: !0
}), TL = /* @__PURE__ */ f({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: !1
}), SL = /* @__PURE__ */ f({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
}), OL = /* @__PURE__ */ f({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: !1
}), Ry = /* @__PURE__ */ f({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3654913
    }
  },
  testnet: !1
}), BL = /* @__PURE__ */ f({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: !0
}), IL = /* @__PURE__ */ f({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: !0
}), PL = /* @__PURE__ */ f({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: !1
}), UL = /* @__PURE__ */ f({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
}), NL = /* @__PURE__ */ f({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: !1
}), RL = /* @__PURE__ */ f({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: !0
}), FL = /* @__PURE__ */ f({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: !0
}), DL = /* @__PURE__ */ f({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: !1
}), ML = /* @__PURE__ */ f({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: !1
}), LL = /* @__PURE__ */ f({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: !0
}), HL = /* @__PURE__ */ f({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: !1
}), $L = /* @__PURE__ */ f({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
}), _L = /* @__PURE__ */ f({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
}), GL = /* @__PURE__ */ f({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
}), zL = /* @__PURE__ */ f({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: !0
}), VL = /* @__PURE__ */ f({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
}), jL = /* @__PURE__ */ f({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: !0
}), qL = /* @__PURE__ */ f({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
}), KL = /* @__PURE__ */ f({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: !1
}), WL = f({
  id: 166,
  name: "Omni",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.omni.network"],
      webSocket: ["wss://mainnet.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "OmniScan",
      url: "https://omniscan.network"
    }
  },
  testnet: !1
}), QL = /* @__PURE__ */ f({
  id: 164,
  name: "Omni Omega",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://omega.omni.network"],
      webSocket: ["wss://omega.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Omega OmniScan",
      url: "https://omega.omniscan.network/"
    }
  },
  testnet: !0
}), JL = /* @__PURE__ */ f({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: !1
}), ZL = /* @__PURE__ */ f({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
}), qd = 56, Fy = /* @__PURE__ */ f({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [qd]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [qd]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [qd]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: qd
}), Kd = 97, Dy = /* @__PURE__ */ f({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [Kd]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [Kd]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [Kd]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: !0,
  sourceId: Kd
}), yl = 1, lr = /* @__PURE__ */ f({
  ...q,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [yl]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [yl]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [yl]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [yl]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: yl
}), Wd = 5, XL = /* @__PURE__ */ f({
  ...q,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Wd]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [Wd]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [Wd]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: !0,
  sourceId: Wd
}), bl = 11155111, Vi = /* @__PURE__ */ f({
  ...q,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [bl]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [bl]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [bl]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [bl]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: !0,
  sourceId: bl
}), YL = /* @__PURE__ */ f({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: !1
}), eH = /* @__PURE__ */ f({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: !0
}), tH = /* @__PURE__ */ f({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: !1
}), nH = /* @__PURE__ */ f({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: !0
}), rH = /* @__PURE__ */ f({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
}), sH = /* @__PURE__ */ f({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
}), aH = /* @__PURE__ */ f({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: !0
}), iH = /* @__PURE__ */ f({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://peaq-rpc.publicnode.com",
        "https://peaq.api.onfinality.io/public",
        "https://peaq-rpc.dwellir.com",
        "https://evm.peaq.network"
      ],
      webSocket: [
        "wss://peaq-rpc.publicnode.com",
        "wss://peaq.api.onfinality.io/public",
        "wss://peaq-rpc.dwellir.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
}), Qd = 1, oH = /* @__PURE__ */ f({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [Qd]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [Qd]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [Qd]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: Qg,
  sourceId: Qd
}), Jd = 11155111, cH = /* @__PURE__ */ f({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [Jd]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [Jd]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [Jd]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: Qg,
  sourceId: Jd,
  testnet: !0
}), lH = /* @__PURE__ */ f({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
}), uH = /* @__PURE__ */ f({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: !1
}), dH = /* @__PURE__ */ f({
  id: 9746,
  name: "Plasma Testnet",
  nativeCurrency: {
    name: "Testnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "RouteScan",
      url: "https://testnet.plasmaexplorer.io"
    }
  },
  testnet: !0
}), fH = /* @__PURE__ */ f({
  ...bn,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: !0
}), pH = /* @__PURE__ */ f({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
}), hH = 1, My = /* @__PURE__ */ f({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: hH
}), mH = 11155111, yH = /* @__PURE__ */ f({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: !0,
  sourceId: mH
}), bH = 1, gH = /* @__PURE__ */ f({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: bH
}), wH = 11155111, EH = /* @__PURE__ */ f({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: !0,
  sourceId: wH
}), xH = 11155111, AH = /* @__PURE__ */ f({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: !0,
  sourceId: xH
}), kH = /* @__PURE__ */ f({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: !0
}), ar = /* @__PURE__ */ f({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
}), ji = /* @__PURE__ */ f({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: !0
}), vH = /* @__PURE__ */ f({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
}), Ly = /* @__PURE__ */ f({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
}), CH = /* @__PURE__ */ f({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
}), TH = /* @__PURE__ */ f({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
}), SH = /* @__PURE__ */ f({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: !1,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), OH = /* @__PURE__ */ f({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), BH = /* @__PURE__ */ f({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: !0
}), IH = /* @__PURE__ */ f({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: !1,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), PH = /* @__PURE__ */ f({
  id: 943,
  name: "PulseChain V4",
  testnet: !0,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), UH = /* @__PURE__ */ f({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: !0
}), cx = 11155111, NH = f({
  ...q,
  name: "Pyrope Testnet",
  testnet: !0,
  id: 695569,
  sourceId: cx,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...q.contracts,
    l1StandardBridge: {
      [cx]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
}), RH = /* @__PURE__ */ f({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: !1
}), FH = /* @__PURE__ */ f({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
}), DH = /* @__PURE__ */ f({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: !0
}), MH = /* @__PURE__ */ f({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
}), LH = /* @__PURE__ */ f({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: !1
}), HH = /* @__PURE__ */ f({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: !0
}), Zd = 1, Hy = f({
  ...q,
  name: "Redstone",
  id: 690,
  sourceId: Zd,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Zd]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [Zd]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [Zd]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
}), $H = /* @__PURE__ */ f({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: !1
}), _H = /* @__PURE__ */ f({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: !1
}), GH = /* @__PURE__ */ f({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: !0
}), zH = /* @__PURE__ */ f({
  id: 11155931,
  name: "RISE Testnet",
  nativeCurrency: { name: "RISE Testnet Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.riselabs.xyz"],
      webSocket: ["wss://testnet.riselabs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.testnet.riselabs.xyz/",
      apiUrl: "https://explorer.testnet.riselabs.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  },
  testnet: !0
}), VH = /* @__PURE__ */ f({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), jH = /* @__PURE__ */ f({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
}), qH = /* @__PURE__ */ f({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
}), $y = /* @__PURE__ */ f({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
}), KH = /* @__PURE__ */ f({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
}), WH = /* @__PURE__ */ f({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: !0
}), QH = /* @__PURE__ */ f({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
}), JH = /* @__PURE__ */ f({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: !0
}), Xd = 1, ZH = /* @__PURE__ */ f({
  ...q,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Xd]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [Xd]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [Xd]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: Xd
}), Yd = 11155111, XH = /* @__PURE__ */ f({
  ...q,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Yd]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [Yd]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [Yd]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: !0,
  sourceId: Yd
}), YH = /* @__PURE__ */ f({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: !1
}), e$ = /* @__PURE__ */ f({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
}), t$ = /* @__PURE__ */ f({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: !0
}), _y = /* @__PURE__ */ f({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: !1
}), n$ = /* @__PURE__ */ f({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
}), r$ = /* @__PURE__ */ f({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: !0
}), s$ = /* @__PURE__ */ f({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
}), a$ = /* @__PURE__ */ f({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: !0
}), Gy = /* @__PURE__ */ f({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: !1
}), i$ = /* @__PURE__ */ f({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: !0
}), zy = /* @__PURE__ */ f({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
}), o$ = /* @__PURE__ */ f({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: !0
}), c$ = /* @__PURE__ */ f({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: !0
}), l$ = /* @__PURE__ */ f({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 98697651
    }
  },
  testnet: !0
}), Ta = /* @__PURE__ */ f({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: !0
}), ef = 1, Vy = /* @__PURE__ */ f({
  ...q,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [ef]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [ef]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [ef]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: ef
}), u$ = 11155111, d$ = /* @__PURE__ */ f({
  ...q,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: u$
}), f$ = /* @__PURE__ */ f({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: !1
}), p$ = /* @__PURE__ */ f({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: !0
}), h$ = /* @__PURE__ */ f({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
}), m$ = /* @__PURE__ */ f({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: !0
}), y$ = /* @__PURE__ */ f({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: !1
}), b$ = /* @__PURE__ */ f({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
}), g$ = /* @__PURE__ */ f({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: !0
}), w$ = /* @__PURE__ */ f({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
}), E$ = /* @__PURE__ */ f({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
}), x$ = /* @__PURE__ */ f({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: !0
}), A$ = /* @__PURE__ */ f({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: !1
}), k$ = /* @__PURE__ */ f({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), v$ = /* @__PURE__ */ f({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
}), C$ = /* @__PURE__ */ f({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: !0
}), T$ = /* @__PURE__ */ f({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), S$ = /* @__PURE__ */ f({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), O$ = /* @__PURE__ */ f({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
}), B$ = /* @__PURE__ */ f({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: !0
}), I$ = /* @__PURE__ */ f({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), P$ = /* @__PURE__ */ f({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), U$ = /* @__PURE__ */ f({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
}), N$ = /* @__PURE__ */ f({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: !0
}), R$ = /* @__PURE__ */ f({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), F$ = /* @__PURE__ */ f({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
}), D$ = /* @__PURE__ */ f({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: !0
}), M$ = /* @__PURE__ */ f({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: !0
}), gl = 1, L$ = /* @__PURE__ */ f({
  ...q,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [gl]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [gl]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [gl]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [gl]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: gl
}), wl = 11155111, H$ = /* @__PURE__ */ f({
  ...q,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [wl]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [wl]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [wl]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [wl]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: !0,
  sourceId: wl
}), $$ = /* @__PURE__ */ f({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://shannon-explorer.somnia.network/",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x841b8199E6d3Db3C6f264f6C2bd8848b3cA64223",
      blockCreated: 71314235
    }
  },
  testnet: !0
}), El = 1, xu = /* @__PURE__ */ f({
  ...q,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [El]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [El]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [El]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [El]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: El
}), xl = 11155111, jy = /* @__PURE__ */ f({
  ...q,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [xl]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [xl]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [xl]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [xl]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: xl
}), qy = /* @__PURE__ */ f({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: !1
}), _$ = /* @__PURE__ */ f({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: !0
}), G$ = /* @__PURE__ */ f({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: !0
}), z$ = /* @__PURE__ */ f({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
}), V$ = /* @__PURE__ */ f({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: !0
}), j$ = /* @__PURE__ */ f({
  ...bn,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: !1
}), q$ = /* @__PURE__ */ f({
  ...bn,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: !0
}), K$ = /* @__PURE__ */ f({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: !0
}), lx = /* @__PURE__ */ f({
  ...r1,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: !0
}), W$ = /* @__PURE__ */ f({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: !1
}), Ky = /* @__PURE__ */ f({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.xyz",
      apiUrl: "https://storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !1
}), Q$ = /* @__PURE__ */ f({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.xyz",
      apiUrl: "https://aeneid.storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !0
}), J$ = /* @__PURE__ */ f({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: !0
}), Z$ = /* @__PURE__ */ f({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: !0
}), X$ = /* @__PURE__ */ f({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
}), Y$ = /* @__PURE__ */ f({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: !1
}), Wy = /* @__PURE__ */ f({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: !1
}), Al = 1, Qy = /* @__PURE__ */ f({
  ...q,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Al]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [Al]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [Al]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [Al]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: Al
}), gm = 11155111, e_ = /* @__PURE__ */ f({
  ...q,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [gm]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [gm]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: !0,
  sourceId: gm
}), t_ = /* @__PURE__ */ f({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: !1
}), n_ = /* @__PURE__ */ f({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io	"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: !0
}), r_ = /* @__PURE__ */ f({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: !0
}), Jy = /* @__PURE__ */ f({
  ...q,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), s_ = /* @__PURE__ */ f({
  ...q,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), a_ = /* @__PURE__ */ f({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: !1
}), i_ = /* @__PURE__ */ f({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
}), o_ = /* @__PURE__ */ f({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
}), c_ = /* @__PURE__ */ f({
  id: 239,
  name: "TAC",
  nativeCurrency: { name: "TAC", symbol: "TAC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/tac"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://tac.blockscout.com",
      apiUrl: "https://tac.blockscout.com/api"
    },
    native: {
      name: "TAC Explorer",
      url: "https://explorer.tac.build",
      apiUrl: "https://explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), l_ = /* @__PURE__ */ f({
  id: 2391,
  name: "TAC SPB Testnet",
  nativeCurrency: {
    name: "TAC",
    symbol: "TAC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://spb.rpc.tac.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "TAC",
      url: "https://spb.explorer.tac.build",
      apiUrl: "https://spb.explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 471429
    }
  },
  testnet: !0
}), Zy = /* @__PURE__ */ f({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
}), u_ = /* @__PURE__ */ f({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: !0
}), d_ = /* @__PURE__ */ f({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: !0
}), f_ = /* @__PURE__ */ f({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
}), p_ = /* @__PURE__ */ f({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
}), h_ = /* @__PURE__ */ f({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
}), m_ = /* @__PURE__ */ f({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: !0
}), y_ = /* @__PURE__ */ f({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: !0
}), b_ = /* @__PURE__ */ f({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
}), g_ = /* @__PURE__ */ f({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: !0
}), w_ = /* @__PURE__ */ f({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: !1
}), E_ = /* @__PURE__ */ f({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: !1
}), x_ = /* @__PURE__ */ f({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: !1
}), A_ = /* @__PURE__ */ f({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: !1
}), k_ = /* @__PURE__ */ f({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: !1
}), v_ = /* @__PURE__ */ f({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: !0
}), C_ = /* @__PURE__ */ f({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), T_ = /* @__PURE__ */ f({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: !0
}), S_ = /* @__PURE__ */ f({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: !0
}), O_ = /* @__PURE__ */ f({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: !1
}), B_ = /* @__PURE__ */ f({
  ...bn,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: !1
}), I_ = /* @__PURE__ */ f({
  ...bn,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: !0
}), Xy = /* @__PURE__ */ f({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
}), P_ = /* @__PURE__ */ f({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: !0
}), U_ = /* @__PURE__ */ f({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: !1
}), N_ = /* @__PURE__ */ f({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
}), R_ = /* @__PURE__ */ f({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: !0
}), F_ = /* @__PURE__ */ f({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: !1
}), D_ = /* @__PURE__ */ f({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: !0
}), tf = 1, qi = /* @__PURE__ */ f({
  ...q,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [tf]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [tf]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [tf]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: tf
}), nf = 11155111, od = /* @__PURE__ */ f({
  ...q,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [nf]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [nf]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [nf]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: !0,
  sourceId: nf
}), M_ = /* @__PURE__ */ f({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
}), L_ = /* @__PURE__ */ f({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: !0
}), H_ = /* @__PURE__ */ f({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
}), $_ = /* @__PURE__ */ f({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
}), __ = /* @__PURE__ */ f({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: !1
}), G_ = /* @__PURE__ */ f({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
}), z_ = /* @__PURE__ */ f({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: !1
}), V_ = /* @__PURE__ */ f({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: !1
}), j_ = /* @__PURE__ */ f({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: !0
}), q_ = /* @__PURE__ */ f({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: !1
}), K_ = /* @__PURE__ */ f({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: !0
}), W_ = /* @__PURE__ */ f({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
}), Q_ = /* @__PURE__ */ f({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: !0
}), J_ = /* @__PURE__ */ f({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: !0
}), Z_ = /* @__PURE__ */ f({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
}), X_ = /* @__PURE__ */ f({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: !0
}), Y_ = /* @__PURE__ */ f({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: !0
}), eG = /* @__PURE__ */ f({
  testnet: !1,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
}), tG = /* @__PURE__ */ f({
  testnet: !0,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
}), nG = /* @__PURE__ */ f({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: !0
}), kl = 1, Ki = /* @__PURE__ */ f({
  ...q,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [kl]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [kl]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [kl]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [kl]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: !1,
  sourceId: kl
}), vl = 11155111, cd = /* @__PURE__ */ f({
  ...q,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [vl]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [vl]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [vl]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [vl]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: !0,
  sourceId: vl
}), rG = /* @__PURE__ */ f({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: !1
}), Au = /* @__PURE__ */ f({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: !1
}), Yy = /* @__PURE__ */ f({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: !0
}), sG = /* @__PURE__ */ f({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
}), aG = /* @__PURE__ */ f({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
}), iG = /* @__PURE__ */ f({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
}), ux = /* @__PURE__ */ f({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: !0
}), oG = /* @__PURE__ */ f({
  id: 20250217,
  name: "Xphere Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "XP",
    symbol: "XP"
  },
  rpcUrls: {
    default: {
      http: ["https://en-bkk.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xp.tamsa.io"
    }
  },
  testnet: !1
}), cG = /* @__PURE__ */ f({
  id: 1998991,
  name: "Xphere Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "XPT",
    symbol: "XPT"
  },
  rpcUrls: {
    default: {
      http: ["http://testnet.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xpt.tamsa.io"
    }
  },
  testnet: !0
}), lG = /* @__PURE__ */ f({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), uG = /* @__PURE__ */ f({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: !0
}), dG = /* @__PURE__ */ f({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: !0
}), fG = /* @__PURE__ */ f({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: !0
}), pG = /* @__PURE__ */ f({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
}), hG = /* @__PURE__ */ f({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: !0
}), mG = /* @__PURE__ */ f({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: !0
}), yG = /* @__PURE__ */ f({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: !1
}), eb = /* @__PURE__ */ f({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: !0
}), bG = /* @__PURE__ */ f({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: !1
}), gG = /* @__PURE__ */ f({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://explorer.zetachain.com"
    }
  },
  testnet: !1
}), wG = /* @__PURE__ */ f({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://athens.explorer.zetachain.com"
    }
  },
  testnet: !0
}), EG = /* @__PURE__ */ f({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: !0
}), xG = /* @__PURE__ */ f({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: !1
}), AG = /* @__PURE__ */ f({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: !0
}), wm = 1, tb = /* @__PURE__ */ f({
  ...q,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [wm]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [wm]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [wm]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: !1
}), Em = 11155111, kG = /* @__PURE__ */ f({
  ...q,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [Em]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [Em]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [Em]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: !0
}), xm = 11155111, vG = /* @__PURE__ */ f({
  ...q,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [xm]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [xm]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [xm]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: !0
}), CG = /* @__PURE__ */ f({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: !1
}), TG = /* @__PURE__ */ f({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: !0
}), SG = /* @__PURE__ */ f({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
}), OG = /* @__PURE__ */ f({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
}), ep = /* @__PURE__ */ f({
  ...bn,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
}), dx = /* @__PURE__ */ f({
  ...bn,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: !0
}), BG = /* @__PURE__ */ f({
  ...bn,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), IG = /* @__PURE__ */ f({
  ...bn,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), PG = /* @__PURE__ */ f({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: !0
}), fx = /* @__PURE__ */ f({
  ...bn,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: !0
}), px = /* @__PURE__ */ f({
  ...bn,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: !0
}), rf = 1, tp = /* @__PURE__ */ f({
  ...q,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [rf]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [rf]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [rf]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: rf
}), sf = 11155111, UG = /* @__PURE__ */ f({
  ...q,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [sf]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [sf]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [sf]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: sf,
  testnet: !0
}), hx = 5, NG = /* @__PURE__ */ f({
  ...q,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [hx]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: hx,
  testnet: !0
}), Jp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abey: cI,
  abstract: ty,
  abstractTestnet: _P,
  acala: GP,
  acria: zP,
  adf: VP,
  aioz: jP,
  alephZero: qP,
  alephZeroTestnet: KP,
  alienx: WP,
  alienxHalTestnet: QP,
  ancient8: ny,
  ancient8Sepolia: e4,
  anvil: t4,
  apeChain: Jf,
  apexTestnet: r4,
  arbitrum: cr,
  arbitrumGoerli: s4,
  arbitrumNova: Gc,
  arbitrumSepolia: Hi,
  arenaz: ry,
  areonNetwork: a4,
  areonNetworkTestnet: i4,
  artelaTestnet: o4,
  arthera: c4,
  artheraTestnet: l4,
  assetChain: u4,
  assetChainTestnet: d4,
  astar: f4,
  astarZkEVM: p4,
  astarZkyoto: h4,
  atletaOlympia: m4,
  aurora: y4,
  auroraTestnet: b4,
  auroria: g4,
  avalanche: gs,
  avalancheFuji: $i,
  b3: gu,
  b3Sepolia: sy,
  bahamut: x4,
  base: Hr,
  baseGoerli: P8,
  baseSepolia: _i,
  basecampTestnet: A4,
  beam: k4,
  beamTestnet: v4,
  bearNetworkChainMainnet: C4,
  bearNetworkChainTestnet: T4,
  berachain: ay,
  berachainBepolia: S4,
  berachainTestnet: O4,
  berachainTestnetbArtio: B4,
  bevmMainnet: I4,
  bifrost: P4,
  birdlayer: $4,
  bitTorrent: L4,
  bitTorrentTestnet: H4,
  bitgert: U4,
  bitkub: N4,
  bitkubTestnet: R4,
  bitlayer: F4,
  bitlayerTestnet: D4,
  bitrock: M4,
  blast: Zf,
  blastSepolia: iy,
  bob: oy,
  bobSepolia: z4,
  boba: cy,
  bobaSepolia: G4,
  boolBetaMainnet: V4,
  botanixTestnet: j4,
  bounceBit: q4,
  bounceBitTestnet: K4,
  bronos: W4,
  bronosTestnet: Q4,
  bsc: J4,
  bscGreenfield: Z4,
  bscTestnet: X4,
  bsquared: Y4,
  bsquaredTestnet: eU,
  btr: tU,
  btrTestnet: nU,
  bxn: rU,
  bxnTestnet: sU,
  cannon: aU,
  canto: iU,
  celo: uy,
  celoAlfajores: bU,
  chang: gU,
  chiliz: wU,
  chips: EU,
  citreaTestnet: xU,
  classic: AU,
  coinbit: kU,
  coinex: vU,
  confluxESpace: CU,
  confluxESpaceTestnet: TU,
  coreDao: SU,
  coreTestnet1: OU,
  coreTestnet2: BU,
  corn: dy,
  cornTestnet: UU,
  crab: NU,
  creatorTestnet: RU,
  creditCoin3Mainnet: FU,
  creditCoin3Testnet: DU,
  cronos: fy,
  cronosTestnet: MU,
  cronoszkEVM: LU,
  cronoszkEVMTestnet: HU,
  crossbell: $U,
  curtis: _U,
  cyber: py,
  cyberTestnet: GU,
  dailyNetwork: zU,
  dailyNetworkTestnet: VU,
  darwinia: jU,
  dbkchain: qU,
  dchain: KU,
  dchainTestnet: WU,
  defichainEvm: QU,
  defichainEvmTestnet: JU,
  degen: hy,
  dfk: ZU,
  diode: XU,
  disChain: YU,
  dodochainTestnet: eN,
  dogechain: tN,
  donatuz: nN,
  dosChain: rN,
  dosChainTestnet: sN,
  dreyerxMainnet: aN,
  dreyerxTestnet: oN,
  dustboyIoT: cN,
  dymension: lN,
  edexa: dN,
  edexaTestnet: uN,
  edgeless: fN,
  edgelessTestnet: pN,
  edgeware: hN,
  edgewareTestnet: mN,
  eduChain: yN,
  eduChainTestnet: bN,
  ekta: gN,
  ektaTestnet: wN,
  elastos: EN,
  elastosTestnet: xN,
  electroneum: AN,
  electroneumTestnet: kN,
  elysiumTestnet: vN,
  energy: CN,
  enuls: TN,
  eon: SN,
  eos: ON,
  eosTestnet: BN,
  etherlink: IN,
  etherlinkTestnet: PN,
  ethernity: UN,
  etp: NN,
  evmos: RN,
  evmosTestnet: FN,
  excelonMainnet: DN,
  expanse: MN,
  exsat: LN,
  exsatTestnet: HN,
  fantom: $N,
  fantomSonicTestnet: _N,
  fantomTestnet: GN,
  fibo: zN,
  filecoin: VN,
  filecoinCalibration: jN,
  filecoinHyperspace: qN,
  fireChain: KN,
  flame: WN,
  flare: QN,
  flareTestnet: JN,
  flowMainnet: my,
  flowPreviewnet: ZN,
  flowTestnet: XN,
  fluence: YN,
  fluenceStage: eR,
  fluenceTestnet: tR,
  fluentTestnet: nR,
  form: rR,
  formTestnet: aR,
  forma: yy,
  formicarium: sR,
  forta: iR,
  foundry: oR,
  fraxtal: cR,
  fraxtalTestnet: lR,
  funkiMainnet: by,
  funkiSepolia: fR,
  fuse: pR,
  fuseSparknet: hR,
  fusion: mR,
  fusionTestnet: yR,
  garnet: bR,
  geist: gR,
  genesys: wR,
  glideL1Protocol: ER,
  glideL2Protocol: xR,
  gnosis: wu,
  gnosisChiado: gy,
  goChain: vR,
  goat: AR,
  gobi: kR,
  godwoken: CR,
  goerli: TR,
  graphite: SR,
  graphiteTestnet: OR,
  gravity: wy,
  gunz: BR,
  guruNetwork: IR,
  guruTestnet: PR,
  ham: UR,
  happychainTestnet: NR,
  haqqMainnet: RR,
  haqqTestedge2: FR,
  hardhat: DR,
  harmonyOne: MR,
  hashkey: LR,
  hashkeyTestnet: HR,
  haustTestnet: $R,
  hedera: _R,
  hederaPreviewnet: GR,
  hederaTestnet: zR,
  hela: VR,
  hemi: Ey,
  hemiSepolia: jR,
  holesky: qR,
  hoodi: KR,
  hpb: WR,
  huddle01Mainnet: JR,
  huddle01Testnet: XR,
  humanode: YR,
  humanodeTestnet5: eF,
  hychain: xy,
  hychainTestnet: tF,
  iSunCoin: pF,
  idchain: nF,
  immutableZkEvm: rF,
  immutableZkEvmTestnet: sF,
  inEVM: aF,
  initVerse: iF,
  initVerseGenesis: oF,
  ink: Ay,
  inkSepolia: cF,
  iota: lF,
  iotaTestnet: uF,
  iotex: dF,
  iotexTestnet: fF,
  jbc: hF,
  jbcTestnet: mF,
  jocMainnet: yF,
  jocTestnet: bF,
  juneo: gF,
  juneoBCH1Chain: wF,
  juneoDAI1Chain: EF,
  juneoDOGE1Chain: xF,
  juneoEUR1Chain: AF,
  juneoGLD1Chain: kF,
  juneoLINK1Chain: vF,
  juneoLTC1Chain: CF,
  juneoSGD1Chain: SF,
  juneoSocotraTestnet: OF,
  juneoUSD1Chain: BF,
  juneoUSDT1Chain: IF,
  juneomBTC1Chain: TF,
  kaia: $F,
  kairos: _F,
  kakarotSepolia: UF,
  kakarotStarknetSepolia: NF,
  kardiaChain: RF,
  karura: PF,
  kava: FF,
  kavaTestnet: DF,
  kcc: MF,
  kinto: LF,
  klaytn: HF,
  klaytnBaobab: GF,
  koi: zF,
  kroma: VF,
  kromaSepolia: jF,
  l3x: qF,
  l3xTestnet: KF,
  lavita: WF,
  lens: QF,
  lensTestnet: JF,
  lestnet: ZF,
  lightlinkPegasus: XF,
  lightlinkPhoenix: YF,
  linea: zi,
  lineaGoerli: MM,
  lineaSepolia: id,
  lineaTestnet: LM,
  lisk: Oy,
  liskSepolia: HM,
  localhost: $M,
  loop: _M,
  lukso: GM,
  luksoTestnet: zM,
  lumiaMainnet: VM,
  lumiaTestnet: jM,
  lumoz: qM,
  lumozTestnet: KM,
  lycan: WM,
  lyra: QM,
  mainnet: Ln,
  mandala: JM,
  manta: By,
  mantaSepoliaTestnet: ZM,
  mantaTestnet: XM,
  mantle: Iy,
  mantleSepoliaTestnet: YM,
  mantleTestnet: eL,
  mapProtocol: tL,
  matchain: nL,
  matchainTestnet: rL,
  mchVerse: sL,
  megaethTestnet: aL,
  mekong: iL,
  meld: oL,
  memecore: cL,
  merlin: lL,
  merlinErigonTestnet: uL,
  metachain: dL,
  metachainIstanbul: fL,
  metadium: pL,
  metalL2: hL,
  meter: mL,
  meterTestnet: yL,
  metis: Py,
  metisGoerli: gL,
  metisSepolia: bL,
  mev: wL,
  mevTestnet: EL,
  mint: Uy,
  mintSepoliaTestnet: xL,
  mitosisTestnet: AL,
  mode: Ny,
  modeTestnet: kL,
  monadTestnet: vL,
  moonbaseAlpha: CL,
  moonbeam: TL,
  moonbeamDev: SL,
  moonriver: OL,
  morph: Ry,
  morphHolesky: BL,
  morphSepolia: IL,
  nahmii: PL,
  nautilus: UL,
  near: NL,
  nearTestnet: RL,
  neonDevnet: FL,
  neonMainnet: DL,
  neoxMainnet: ML,
  neoxT4: LL,
  newton: HL,
  nexi: $L,
  nexilix: _L,
  nibiru: GL,
  oasisTestnet: zL,
  oasys: VL,
  odysseyTestnet: jL,
  okc: qL,
  omax: KL,
  omni: WL,
  omniOmega: QL,
  oneWorld: JL,
  oortMainnetDev: ZL,
  opBNB: Fy,
  opBNBTestnet: Dy,
  optimism: lr,
  optimismGoerli: XL,
  optimismSepolia: Vi,
  optopia: YL,
  optopiaTestnet: eH,
  orderly: tH,
  orderlySepolia: nH,
  otimDevnet: rH,
  palm: sH,
  palmTestnet: aH,
  peaq: iH,
  pgn: oH,
  pgnTestnet: cH,
  phoenix: lH,
  planq: uH,
  plasmaTestnet: dH,
  playfiAlbireo: fH,
  plinga: pH,
  plume: My,
  plumeDevnet: yH,
  plumeMainnet: gH,
  plumeSepolia: EH,
  plumeTestnet: AH,
  polterTestnet: kH,
  polygon: ar,
  polygonAmoy: ji,
  polygonMumbai: vH,
  polygonZkEvm: Ly,
  polygonZkEvmCardona: CH,
  polygonZkEvmTestnet: TH,
  polynomial: SH,
  polynomialSepolia: OH,
  premiumBlockTestnet: BH,
  pulsechain: IH,
  pulsechainV4: PH,
  pumpfiTestnet: UH,
  pyrope: NH,
  qMainnet: FH,
  qTestnet: DH,
  ql1: RH,
  real: MH,
  redbellyMainnet: LH,
  redbellyTestnet: HH,
  reddioSepolia: GH,
  redstone: Hy,
  rei: $H,
  reyaNetwork: _H,
  riseTestnet: zH,
  rivalz: VH,
  rollux: jH,
  rolluxTestnet: qH,
  ronin: $y,
  root: KH,
  rootPorcini: WH,
  rootstock: QH,
  rootstockTestnet: JH,
  rss3: ZH,
  rss3Sepolia: XH,
  saakuru: YH,
  saga: e$,
  saigon: t$,
  sanko: _y,
  sapphire: n$,
  sapphireTestnet: r$,
  satoshiVM: s$,
  satoshiVMTestnet: a$,
  scroll: Gy,
  scrollSepolia: i$,
  sei: zy,
  seiDevnet: o$,
  seiTestnet: l$,
  seismicDevnet: c$,
  sepolia: Ta,
  shape: Vy,
  shapeSepolia: d$,
  shardeum: f$,
  shardeumSphinx: p$,
  shibarium: h$,
  shibariumTestnet: m$,
  shiden: y$,
  shimmer: b$,
  shimmerTestnet: g$,
  sidraChain: w$,
  silicon: E$,
  siliconSepolia: x$,
  sixProtocol: A$,
  skaleBlockBrawlers: k$,
  skaleCalypso: v$,
  skaleCalypsoTestnet: C$,
  skaleCryptoBlades: T$,
  skaleCryptoColosseum: S$,
  skaleEuropa: O$,
  skaleEuropaTestnet: B$,
  skaleExorde: I$,
  skaleHumanProtocol: P$,
  skaleNebula: U$,
  skaleNebulaTestnet: N$,
  skaleRazor: R$,
  skaleTitan: F$,
  skaleTitanTestnet: D$,
  sketchpad: M$,
  snax: L$,
  snaxTestnet: H$,
  somniaTestnet: $$,
  soneium: xu,
  soneiumMinato: jy,
  songbird: z$,
  songbirdTestnet: V$,
  sonic: qy,
  sonicBlazeTestnet: G$,
  sonicTestnet: _$,
  sophon: j$,
  sophonTestnet: q$,
  spicy: K$,
  statusNetworkSepolia: lx,
  statusSepolia: lx,
  step: W$,
  story: Ky,
  storyAeneid: Q$,
  storyOdyssey: J$,
  storyTestnet: Z$,
  stratis: X$,
  superlumio: Y$,
  superposition: Wy,
  superseed: Qy,
  superseedSepolia: e_,
  swan: t_,
  swanProximaTestnet: n_,
  swanSaturnTestnet: r_,
  swellchain: Jy,
  swellchainTestnet: s_,
  swissdlt: a_,
  syscoin: i_,
  syscoinTestnet: o_,
  tac: c_,
  tacSPB: l_,
  taiko: Zy,
  taikoHekla: u_,
  taikoJolnir: d_,
  taikoKatla: f_,
  taikoTestnetSepolia: p_,
  taraxa: h_,
  taraxaTestnet: m_,
  telcoinTestnet: y_,
  telos: b_,
  telosTestnet: g_,
  tenet: w_,
  ternoa: E_,
  thaiChain: x_,
  that: A_,
  theta: k_,
  thetaTestnet: v_,
  thunderCore: C_,
  thunderTestnet: T_,
  tiktrixTestnet: S_,
  tomb: O_,
  treasure: B_,
  treasureTopaz: I_,
  tron: Xy,
  tronShasta: P_,
  ubiq: U_,
  ultra: N_,
  ultraTestnet: R_,
  ultron: F_,
  ultronTestnet: D_,
  unichain: qi,
  unichainSepolia: od,
  unique: M_,
  uniqueOpal: L_,
  uniqueQuartz: H_,
  unreal: $_,
  vanar: __,
  vechain: G_,
  velas: z_,
  viction: V_,
  victionTestnet: j_,
  vision: q_,
  visionTestnet: K_,
  wanchain: W_,
  wanchainTestnet: Q_,
  weaveVMAlphanet: J_,
  wemix: Z_,
  wemixTestnet: X_,
  westendAssetHub: Y_,
  whitechain: eG,
  whitechainTestnet: tG,
  wmcTestnet: nG,
  worldLand: rG,
  worldchain: Ki,
  worldchainSepolia: cd,
  x1Testnet: ux,
  xLayer: iG,
  xLayerTestnet: ux,
  xai: Au,
  xaiTestnet: Yy,
  xdc: sG,
  xdcTestnet: aG,
  xphereMainnet: oG,
  xphereTestnet: cG,
  xrOne: lG,
  xrSepolia: fG,
  xrplevmDevnet: uG,
  xrplevmTestnet: dG,
  yooldoVerse: pG,
  yooldoVerseTestnet: hG,
  zenchainTestnet: mG,
  zeniq: yG,
  zeroG: eb,
  zeroNetwork: bG,
  zetachain: gG,
  zetachainAthensTestnet: wG,
  zhejiang: EG,
  zilliqa: xG,
  zilliqaTestnet: AG,
  zircuit: tb,
  zircuitGarfieldTestnet: kG,
  zircuitTestnet: vG,
  zkFair: CG,
  zkFairTestnet: TG,
  zkLinkNova: SG,
  zkLinkNovaSepoliaTestnet: OG,
  zkSync: ep,
  zkSyncInMemoryNode: dx,
  zkSyncLocalNode: fx,
  zkSyncSepoliaTestnet: px,
  zksync: ep,
  zksyncInMemoryNode: dx,
  zksyncLocalCustomHyperchain: BG,
  zksyncLocalHyperchain: IG,
  zksyncLocalHyperchainL1: PG,
  zksyncLocalNode: fx,
  zksyncSepoliaTestnet: px,
  zora: tp,
  zoraSepolia: UG,
  zoraTestnet: NG
}, Symbol.toStringTag, { value: "Module" }));
var ye;
(function(t) {
  t[t.Verbose = 4] = "Verbose", t[t.Info = 3] = "Info", t[t.Warn = 2] = "Warn", t[t.Error = 1] = "Error", t[t.None = 0] = "None";
})(ye || (ye = {}));
const nb = (t, e, n) => {
  if (n >= e) {
    const r = t.reduce((s, a, i) => ((i + 1) % 2 && s.push(`
`), s.push(a), s), []);
    switch (e) {
      case ye.Info:
        console.info(...r);
        break;
      case ye.Error:
        console.error(...r);
        break;
      case ye.Warn:
        console.warn(...r);
        break;
      default:
        console.log(...r);
        break;
    }
  }
};
function lv(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: RG } = Object.prototype, { getPrototypeOf: s1 } = Object, { iterator: Zp, toStringTag: uv } = Symbol, Xp = /* @__PURE__ */ ((t) => (e) => {
  const n = RG.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), fr = (t) => (t = t.toLowerCase(), (e) => Xp(e) === t), Yp = (t) => (e) => typeof e === t, { isArray: tl } = Array, ku = Yp("undefined");
function FG(t) {
  return t !== null && !ku(t) && t.constructor !== null && !ku(t.constructor) && sn(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const dv = fr("ArrayBuffer");
function DG(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && dv(t.buffer), e;
}
const MG = Yp("string"), sn = Yp("function"), fv = Yp("number"), eh = (t) => t !== null && typeof t == "object", LG = (t) => t === !0 || t === !1, kf = (t) => {
  if (Xp(t) !== "object")
    return !1;
  const e = s1(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(uv in t) && !(Zp in t);
}, HG = fr("Date"), $G = fr("File"), _G = fr("Blob"), GG = fr("FileList"), zG = (t) => eh(t) && sn(t.pipe), VG = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || sn(t.append) && ((e = Xp(t)) === "formdata" || // detect form-data instance
  e === "object" && sn(t.toString) && t.toString() === "[object FormData]"));
}, jG = fr("URLSearchParams"), [qG, KG, WG, QG] = ["ReadableStream", "Request", "Response", "Headers"].map(fr), JG = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ld(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), tl(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    const a = n ? Object.getOwnPropertyNames(t) : Object.keys(t), i = a.length;
    let o;
    for (r = 0; r < i; r++)
      o = a[r], e.call(null, t[o], o, t);
  }
}
function pv(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const Ga = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, hv = (t) => !ku(t) && t !== Ga;
function rb() {
  const { caseless: t } = hv(this) && this || {}, e = {}, n = (r, s) => {
    const a = t && pv(e, s) || s;
    kf(e[a]) && kf(r) ? e[a] = rb(e[a], r) : kf(r) ? e[a] = rb({}, r) : tl(r) ? e[a] = r.slice() : e[a] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && ld(arguments[r], n);
  return e;
}
const ZG = (t, e, n, { allOwnKeys: r } = {}) => (ld(e, (s, a) => {
  n && sn(s) ? t[a] = lv(s, n) : t[a] = s;
}, { allOwnKeys: r }), t), XG = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), YG = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, ez = (t, e, n, r) => {
  let s, a, i;
  const o = {};
  if (e = e || {}, t == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(t), a = s.length; a-- > 0; )
      i = s[a], (!r || r(i, t, e)) && !o[i] && (e[i] = t[i], o[i] = !0);
    t = n !== !1 && s1(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, tz = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, nz = (t) => {
  if (!t) return null;
  if (tl(t)) return t;
  let e = t.length;
  if (!fv(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, rz = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && s1(Uint8Array)), sz = (t, e) => {
  const r = (t && t[Zp]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const a = s.value;
    e.call(t, a[0], a[1]);
  }
}, az = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, iz = fr("HTMLFormElement"), oz = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), mx = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), cz = fr("RegExp"), mv = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  ld(n, (s, a) => {
    let i;
    (i = e(s, a, t)) !== !1 && (r[a] = i || s);
  }), Object.defineProperties(t, r);
}, lz = (t) => {
  mv(t, (e, n) => {
    if (sn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (sn(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, uz = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((a) => {
      n[a] = !0;
    });
  };
  return tl(t) ? r(t) : r(String(t).split(e)), n;
}, dz = () => {
}, fz = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
function pz(t) {
  return !!(t && sn(t.append) && t[uv] === "FormData" && t[Zp]);
}
const hz = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (eh(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const a = tl(r) ? [] : {};
        return ld(r, (i, o) => {
          const c = n(i, s + 1);
          !ku(c) && (a[o] = c);
        }), e[s] = void 0, a;
      }
    }
    return r;
  };
  return n(t, 0);
}, mz = fr("AsyncFunction"), yz = (t) => t && (eh(t) || sn(t)) && sn(t.then) && sn(t.catch), yv = ((t, e) => t ? setImmediate : e ? ((n, r) => (Ga.addEventListener("message", ({ source: s, data: a }) => {
  s === Ga && a === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), Ga.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  sn(Ga.postMessage)
), bz = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ga) : typeof process < "u" && process.nextTick || yv, gz = (t) => t != null && sn(t[Zp]), L = {
  isArray: tl,
  isArrayBuffer: dv,
  isBuffer: FG,
  isFormData: VG,
  isArrayBufferView: DG,
  isString: MG,
  isNumber: fv,
  isBoolean: LG,
  isObject: eh,
  isPlainObject: kf,
  isReadableStream: qG,
  isRequest: KG,
  isResponse: WG,
  isHeaders: QG,
  isUndefined: ku,
  isDate: HG,
  isFile: $G,
  isBlob: _G,
  isRegExp: cz,
  isFunction: sn,
  isStream: zG,
  isURLSearchParams: jG,
  isTypedArray: rz,
  isFileList: GG,
  forEach: ld,
  merge: rb,
  extend: ZG,
  trim: JG,
  stripBOM: XG,
  inherits: YG,
  toFlatObject: ez,
  kindOf: Xp,
  kindOfTest: fr,
  endsWith: tz,
  toArray: nz,
  forEachEntry: sz,
  matchAll: az,
  isHTMLForm: iz,
  hasOwnProperty: mx,
  hasOwnProp: mx,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: mv,
  freezeMethods: lz,
  toObjectSet: uz,
  toCamelCase: oz,
  noop: dz,
  toFiniteNumber: fz,
  findKey: pv,
  global: Ga,
  isContextDefined: hv,
  isSpecCompliantForm: pz,
  toJSONObject: hz,
  isAsyncFn: mz,
  isThenable: yz,
  setImmediate: yv,
  asap: bz,
  isIterable: gz
};
function pe(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
L.inherits(pe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: L.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const bv = pe.prototype, gv = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  gv[t] = { value: t };
});
Object.defineProperties(pe, gv);
Object.defineProperty(bv, "isAxiosError", { value: !0 });
pe.from = (t, e, n, r, s, a) => {
  const i = Object.create(bv);
  return L.toFlatObject(t, i, function(c) {
    return c !== Error.prototype;
  }, (o) => o !== "isAxiosError"), pe.call(i, t.message, e, n, r, s), i.cause = t, i.name = t.name, a && Object.assign(i, a), i;
};
const wz = null;
function sb(t) {
  return L.isPlainObject(t) || L.isArray(t);
}
function wv(t) {
  return L.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function yx(t, e, n) {
  return t ? t.concat(e).map(function(s, a) {
    return s = wv(s), !n && a ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function Ez(t) {
  return L.isArray(t) && !t.some(sb);
}
const xz = L.toFlatObject(L, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function th(t, e, n) {
  if (!L.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = L.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, g) {
    return !L.isUndefined(g[y]);
  });
  const r = n.metaTokens, s = n.visitor || l, a = n.dots, i = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && L.isSpecCompliantForm(e);
  if (!L.isFunction(s))
    throw new TypeError("visitor must be a function");
  function u(b) {
    if (b === null) return "";
    if (L.isDate(b))
      return b.toISOString();
    if (L.isBoolean(b))
      return b.toString();
    if (!c && L.isBlob(b))
      throw new pe("Blob is not supported. Use a Buffer instead.");
    return L.isArrayBuffer(b) || L.isTypedArray(b) ? c && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b;
  }
  function l(b, y, g) {
    let w = b;
    if (b && !g && typeof b == "object") {
      if (L.endsWith(y, "{}"))
        y = r ? y : y.slice(0, -2), b = JSON.stringify(b);
      else if (L.isArray(b) && Ez(b) || (L.isFileList(b) || L.endsWith(y, "[]")) && (w = L.toArray(b)))
        return y = wv(y), w.forEach(function(A, B) {
          !(L.isUndefined(A) || A === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? yx([y], B, a) : i === null ? y : y + "[]",
            u(A)
          );
        }), !1;
    }
    return sb(b) ? !0 : (e.append(yx(g, y, a), u(b)), !1);
  }
  const d = [], m = Object.assign(xz, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: sb
  });
  function h(b, y) {
    if (!L.isUndefined(b)) {
      if (d.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      d.push(b), L.forEach(b, function(w, v) {
        (!(L.isUndefined(w) || w === null) && s.call(
          e,
          w,
          L.isString(v) ? v.trim() : v,
          y,
          m
        )) === !0 && h(w, y ? y.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!L.isObject(t))
    throw new TypeError("data must be an object");
  return h(t), e;
}
function bx(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function a1(t, e) {
  this._pairs = [], t && th(t, this, e);
}
const Ev = a1.prototype;
Ev.append = function(e, n) {
  this._pairs.push([e, n]);
};
Ev.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, bx);
  } : bx;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function Az(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function xv(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || Az;
  L.isFunction(n) && (n = {
    serialize: n
  });
  const s = n && n.serialize;
  let a;
  if (s ? a = s(e, n) : a = L.isURLSearchParams(e) ? e.toString() : new a1(e, n).toString(r), a) {
    const i = t.indexOf("#");
    i !== -1 && (t = t.slice(0, i)), t += (t.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return t;
}
class gx {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    L.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const Av = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, kz = typeof URLSearchParams < "u" ? URLSearchParams : a1, vz = typeof FormData < "u" ? FormData : null, Cz = typeof Blob < "u" ? Blob : null, Tz = {
  isBrowser: !0,
  classes: {
    URLSearchParams: kz,
    FormData: vz,
    Blob: Cz
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, i1 = typeof window < "u" && typeof document < "u", ab = typeof navigator == "object" && navigator || void 0, Sz = i1 && (!ab || ["ReactNative", "NativeScript", "NS"].indexOf(ab.product) < 0), Oz = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Bz = i1 && window.location.href || "http://localhost", Iz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: i1,
  hasStandardBrowserEnv: Sz,
  hasStandardBrowserWebWorkerEnv: Oz,
  navigator: ab,
  origin: Bz
}, Symbol.toStringTag, { value: "Module" })), Ct = {
  ...Iz,
  ...Tz
};
function Pz(t, e) {
  return th(t, new Ct.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, s, a) {
      return Ct.isNode && L.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function Uz(t) {
  return L.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Nz(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let a;
  for (r = 0; r < s; r++)
    a = n[r], e[a] = t[a];
  return e;
}
function kv(t) {
  function e(n, r, s, a) {
    let i = n[a++];
    if (i === "__proto__") return !0;
    const o = Number.isFinite(+i), c = a >= n.length;
    return i = !i && L.isArray(s) ? s.length : i, c ? (L.hasOwnProp(s, i) ? s[i] = [s[i], r] : s[i] = r, !o) : ((!s[i] || !L.isObject(s[i])) && (s[i] = []), e(n, r, s[i], a) && L.isArray(s[i]) && (s[i] = Nz(s[i])), !o);
  }
  if (L.isFormData(t) && L.isFunction(t.entries)) {
    const n = {};
    return L.forEachEntry(t, (r, s) => {
      e(Uz(r), s, n, 0);
    }), n;
  }
  return null;
}
function Rz(t, e, n) {
  if (L.isString(t))
    try {
      return (e || JSON.parse)(t), L.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const ud = {
  transitional: Av,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, a = L.isObject(e);
    if (a && L.isHTMLForm(e) && (e = new FormData(e)), L.isFormData(e))
      return s ? JSON.stringify(kv(e)) : e;
    if (L.isArrayBuffer(e) || L.isBuffer(e) || L.isStream(e) || L.isFile(e) || L.isBlob(e) || L.isReadableStream(e))
      return e;
    if (L.isArrayBufferView(e))
      return e.buffer;
    if (L.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Pz(e, this.formSerializer).toString();
      if ((o = L.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return th(
          o ? { "files[]": e } : e,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || s ? (n.setContentType("application/json", !1), Rz(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || ud.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (L.isResponse(e) || L.isReadableStream(e))
      return e;
    if (e && L.isString(e) && (r && !this.responseType || s)) {
      const i = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (i)
          throw o.name === "SyntaxError" ? pe.from(o, pe.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ct.classes.FormData,
    Blob: Ct.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  ud.headers[t] = {};
});
const Fz = L.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Dz = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), n = i.substring(0, s).trim().toLowerCase(), r = i.substring(s + 1).trim(), !(!n || e[n] && Fz[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, wx = Symbol("internals");
function Cl(t) {
  return t && String(t).trim().toLowerCase();
}
function vf(t) {
  return t === !1 || t == null ? t : L.isArray(t) ? t.map(vf) : String(t);
}
function Mz(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const Lz = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Am(t, e, n, r, s) {
  if (L.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!L.isString(e)) {
    if (L.isString(r))
      return e.indexOf(r) !== -1;
    if (L.isRegExp(r))
      return r.test(e);
  }
}
function Hz(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function $z(t, e) {
  const n = L.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, a, i) {
        return this[r].call(this, e, s, a, i);
      },
      configurable: !0
    });
  });
}
let an = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function a(o, c, u) {
      const l = Cl(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = L.findKey(s, l);
      (!d || s[d] === void 0 || u === !0 || u === void 0 && s[d] !== !1) && (s[d || c] = vf(o));
    }
    const i = (o, c) => L.forEach(o, (u, l) => a(u, l, c));
    if (L.isPlainObject(e) || e instanceof this.constructor)
      i(e, n);
    else if (L.isString(e) && (e = e.trim()) && !Lz(e))
      i(Dz(e), n);
    else if (L.isObject(e) && L.isIterable(e)) {
      let o = {}, c, u;
      for (const l of e) {
        if (!L.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        o[u = l[0]] = (c = o[u]) ? L.isArray(c) ? [...c, l[1]] : [c, l[1]] : l[1];
      }
      i(o, n);
    } else
      e != null && a(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = Cl(e), e) {
      const r = L.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return Mz(s);
        if (L.isFunction(n))
          return n.call(this, s, r);
        if (L.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = Cl(e), e) {
      const r = L.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || Am(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function a(i) {
      if (i = Cl(i), i) {
        const o = L.findKey(r, i);
        o && (!n || Am(r, r[o], o, n)) && (delete r[o], s = !0);
      }
    }
    return L.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const a = n[r];
      (!e || Am(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return L.forEach(this, (s, a) => {
      const i = L.findKey(r, a);
      if (i) {
        n[i] = vf(s), delete n[a];
        return;
      }
      const o = e ? Hz(a) : String(a).trim();
      o !== a && delete n[a], n[o] = vf(s), r[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return L.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && L.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[wx] = this[wx] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(i) {
      const o = Cl(i);
      r[o] || ($z(s, i), r[o] = !0);
    }
    return L.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
an.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
L.reduceDescriptors(an.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
L.freezeMethods(an);
function km(t, e) {
  const n = this || ud, r = e || n, s = an.from(r.headers);
  let a = r.data;
  return L.forEach(t, function(o) {
    a = o.call(n, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function vv(t) {
  return !!(t && t.__CANCEL__);
}
function nl(t, e, n) {
  pe.call(this, t ?? "canceled", pe.ERR_CANCELED, e, n), this.name = "CanceledError";
}
L.inherits(nl, pe, {
  __CANCEL__: !0
});
function Cv(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new pe(
    "Request failed with status code " + n.status,
    [pe.ERR_BAD_REQUEST, pe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function _z(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function Gz(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, a = 0, i;
  return e = e !== void 0 ? e : 1e3, function(c) {
    const u = Date.now(), l = r[a];
    i || (i = u), n[s] = c, r[s] = u;
    let d = a, m = 0;
    for (; d !== s; )
      m += n[d++], d = d % t;
    if (s = (s + 1) % t, s === a && (a = (a + 1) % t), u - i < e)
      return;
    const h = l && u - l;
    return h ? Math.round(m * 1e3 / h) : void 0;
  };
}
function zz(t, e) {
  let n = 0, r = 1e3 / e, s, a;
  const i = (u, l = Date.now()) => {
    n = l, s = null, a && (clearTimeout(a), a = null), t.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), d = l - n;
    d >= r ? i(u, l) : (s = u, a || (a = setTimeout(() => {
      a = null, i(s);
    }, r - d)));
  }, () => s && i(s)];
}
const np = (t, e, n = 3) => {
  let r = 0;
  const s = Gz(50, 250);
  return zz((a) => {
    const i = a.loaded, o = a.lengthComputable ? a.total : void 0, c = i - r, u = s(c), l = i <= o;
    r = i;
    const d = {
      loaded: i,
      total: o,
      progress: o ? i / o : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && o && l ? (o - i) / u : void 0,
      event: a,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    t(d);
  }, n);
}, Ex = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, xx = (t) => (...e) => L.asap(() => t(...e)), Vz = Ct.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, Ct.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(
  new URL(Ct.origin),
  Ct.navigator && /(msie|trident)/i.test(Ct.navigator.userAgent)
) : () => !0, jz = Ct.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, s, a) {
      const i = [t + "=" + encodeURIComponent(e)];
      L.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()), L.isString(r) && i.push("path=" + r), L.isString(s) && i.push("domain=" + s), a === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function qz(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function Kz(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function Tv(t, e, n) {
  let r = !qz(e);
  return t && (r || n == !1) ? Kz(t, e) : e;
}
const Ax = (t) => t instanceof an ? { ...t } : t;
function Wi(t, e) {
  e = e || {};
  const n = {};
  function r(u, l, d, m) {
    return L.isPlainObject(u) && L.isPlainObject(l) ? L.merge.call({ caseless: m }, u, l) : L.isPlainObject(l) ? L.merge({}, l) : L.isArray(l) ? l.slice() : l;
  }
  function s(u, l, d, m) {
    if (L.isUndefined(l)) {
      if (!L.isUndefined(u))
        return r(void 0, u, d, m);
    } else return r(u, l, d, m);
  }
  function a(u, l) {
    if (!L.isUndefined(l))
      return r(void 0, l);
  }
  function i(u, l) {
    if (L.isUndefined(l)) {
      if (!L.isUndefined(u))
        return r(void 0, u);
    } else return r(void 0, l);
  }
  function o(u, l, d) {
    if (d in e)
      return r(u, l);
    if (d in t)
      return r(void 0, u);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: o,
    headers: (u, l, d) => s(Ax(u), Ax(l), d, !0)
  };
  return L.forEach(Object.keys(Object.assign({}, t, e)), function(l) {
    const d = c[l] || s, m = d(t[l], e[l], l);
    L.isUndefined(m) && d !== o || (n[l] = m);
  }), n;
}
const Sv = (t) => {
  const e = Wi({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: a, headers: i, auth: o } = e;
  e.headers = i = an.from(i), e.url = xv(Tv(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), o && i.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let c;
  if (L.isFormData(n)) {
    if (Ct.hasStandardBrowserEnv || Ct.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((c = i.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      i.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (Ct.hasStandardBrowserEnv && (r && L.isFunction(r) && (r = r(e)), r || r !== !1 && Vz(e.url))) {
    const u = s && a && jz.read(a);
    u && i.set(s, u);
  }
  return e;
}, Wz = typeof XMLHttpRequest < "u", Qz = Wz && function(t) {
  return new Promise(function(n, r) {
    const s = Sv(t);
    let a = s.data;
    const i = an.from(s.headers).normalize();
    let { responseType: o, onUploadProgress: c, onDownloadProgress: u } = s, l, d, m, h, b;
    function y() {
      h && h(), b && b(), s.cancelToken && s.cancelToken.unsubscribe(l), s.signal && s.signal.removeEventListener("abort", l);
    }
    let g = new XMLHttpRequest();
    g.open(s.method.toUpperCase(), s.url, !0), g.timeout = s.timeout;
    function w() {
      if (!g)
        return;
      const A = an.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), x = {
        data: !o || o === "text" || o === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: A,
        config: t,
        request: g
      };
      Cv(function(I) {
        n(I), y();
      }, function(I) {
        r(I), y();
      }, x), g = null;
    }
    "onloadend" in g ? g.onloadend = w : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, g.onabort = function() {
      g && (r(new pe("Request aborted", pe.ECONNABORTED, t, g)), g = null);
    }, g.onerror = function() {
      r(new pe("Network Error", pe.ERR_NETWORK, t, g)), g = null;
    }, g.ontimeout = function() {
      let B = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const x = s.transitional || Av;
      s.timeoutErrorMessage && (B = s.timeoutErrorMessage), r(new pe(
        B,
        x.clarifyTimeoutError ? pe.ETIMEDOUT : pe.ECONNABORTED,
        t,
        g
      )), g = null;
    }, a === void 0 && i.setContentType(null), "setRequestHeader" in g && L.forEach(i.toJSON(), function(B, x) {
      g.setRequestHeader(x, B);
    }), L.isUndefined(s.withCredentials) || (g.withCredentials = !!s.withCredentials), o && o !== "json" && (g.responseType = s.responseType), u && ([m, b] = np(u, !0), g.addEventListener("progress", m)), c && g.upload && ([d, h] = np(c), g.upload.addEventListener("progress", d), g.upload.addEventListener("loadend", h)), (s.cancelToken || s.signal) && (l = (A) => {
      g && (r(!A || A.type ? new nl(null, t, g) : A), g.abort(), g = null);
    }, s.cancelToken && s.cancelToken.subscribe(l), s.signal && (s.signal.aborted ? l() : s.signal.addEventListener("abort", l)));
    const v = _z(s.url);
    if (v && Ct.protocols.indexOf(v) === -1) {
      r(new pe("Unsupported protocol " + v + ":", pe.ERR_BAD_REQUEST, t));
      return;
    }
    g.send(a || null);
  });
}, Jz = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), s;
    const a = function(u) {
      if (!s) {
        s = !0, o();
        const l = u instanceof Error ? u : this.reason;
        r.abort(l instanceof pe ? l : new nl(l instanceof Error ? l.message : l));
      }
    };
    let i = e && setTimeout(() => {
      i = null, a(new pe(`timeout ${e} of ms exceeded`, pe.ETIMEDOUT));
    }, e);
    const o = () => {
      t && (i && clearTimeout(i), i = null, t.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(a) : u.removeEventListener("abort", a);
      }), t = null);
    };
    t.forEach((u) => u.addEventListener("abort", a));
    const { signal: c } = r;
    return c.unsubscribe = () => L.asap(o), c;
  }
}, Zz = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, Xz = async function* (t, e) {
  for await (const n of Yz(t))
    yield* Zz(n, e);
}, Yz = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, kx = (t, e, n, r) => {
  const s = Xz(t, e);
  let a = 0, i, o = (c) => {
    i || (i = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await s.next();
        if (u) {
          o(), c.close();
          return;
        }
        let d = l.byteLength;
        if (n) {
          let m = a += d;
          n(m);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw o(u), u;
      }
    },
    cancel(c) {
      return o(c), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, nh = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Ov = nh && typeof ReadableStream == "function", eV = nh && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), Bv = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, tV = Ov && Bv(() => {
  let t = !1;
  const e = new Request(Ct.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), vx = 64 * 1024, ib = Ov && Bv(() => L.isReadableStream(new Response("").body)), rp = {
  stream: ib && ((t) => t.body)
};
nh && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !rp[e] && (rp[e] = L.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new pe(`Response type '${e}' is not supported`, pe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const nV = async (t) => {
  if (t == null)
    return 0;
  if (L.isBlob(t))
    return t.size;
  if (L.isSpecCompliantForm(t))
    return (await new Request(Ct.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (L.isArrayBufferView(t) || L.isArrayBuffer(t))
    return t.byteLength;
  if (L.isURLSearchParams(t) && (t = t + ""), L.isString(t))
    return (await eV(t)).byteLength;
}, rV = async (t, e) => {
  const n = L.toFiniteNumber(t.getContentLength());
  return n ?? nV(e);
}, sV = nh && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: a,
    timeout: i,
    onDownloadProgress: o,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: m
  } = Sv(t);
  u = u ? (u + "").toLowerCase() : "text";
  let h = Jz([s, a && a.toAbortSignal()], i), b;
  const y = h && h.unsubscribe && (() => {
    h.unsubscribe();
  });
  let g;
  try {
    if (c && tV && n !== "get" && n !== "head" && (g = await rV(l, r)) !== 0) {
      let x = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), N;
      if (L.isFormData(r) && (N = x.headers.get("content-type")) && l.setContentType(N), x.body) {
        const [I, O] = Ex(
          g,
          np(xx(c))
        );
        r = kx(x.body, vx, I, O);
      }
    }
    L.isString(d) || (d = d ? "include" : "omit");
    const w = "credentials" in Request.prototype;
    b = new Request(e, {
      ...m,
      signal: h,
      method: n.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: w ? d : void 0
    });
    let v = await fetch(b, m);
    const A = ib && (u === "stream" || u === "response");
    if (ib && (o || A && y)) {
      const x = {};
      ["status", "statusText", "headers"].forEach((C) => {
        x[C] = v[C];
      });
      const N = L.toFiniteNumber(v.headers.get("content-length")), [I, O] = o && Ex(
        N,
        np(xx(o), !0)
      ) || [];
      v = new Response(
        kx(v.body, vx, I, () => {
          O && O(), y && y();
        }),
        x
      );
    }
    u = u || "text";
    let B = await rp[L.findKey(rp, u) || "text"](v, t);
    return !A && y && y(), await new Promise((x, N) => {
      Cv(x, N, {
        data: B,
        headers: an.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: t,
        request: b
      });
    });
  } catch (w) {
    throw y && y(), w && w.name === "TypeError" && /Load failed|fetch/i.test(w.message) ? Object.assign(
      new pe("Network Error", pe.ERR_NETWORK, t, b),
      {
        cause: w.cause || w
      }
    ) : pe.from(w, w && w.code, t, b);
  }
}), ob = {
  http: wz,
  xhr: Qz,
  fetch: sV
};
L.forEach(ob, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const Cx = (t) => `- ${t}`, aV = (t) => L.isFunction(t) || t === null || t === !1, Iv = {
  getAdapter: (t) => {
    t = L.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let a = 0; a < e; a++) {
      n = t[a];
      let i;
      if (r = n, !aV(n) && (r = ob[(i = String(n)).toLowerCase()], r === void 0))
        throw new pe(`Unknown adapter '${i}'`);
      if (r)
        break;
      s[i || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(s).map(
        ([o, c]) => `adapter ${o} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = e ? a.length > 1 ? `since :
` + a.map(Cx).join(`
`) : " " + Cx(a[0]) : "as no adapter specified";
      throw new pe(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: ob
};
function vm(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new nl(null, t);
}
function Tx(t) {
  return vm(t), t.headers = an.from(t.headers), t.data = km.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Iv.getAdapter(t.adapter || ud.adapter)(t).then(function(r) {
    return vm(t), r.data = km.call(
      t,
      t.transformResponse,
      r
    ), r.headers = an.from(r.headers), r;
  }, function(r) {
    return vv(r) || (vm(t), r && r.response && (r.response.data = km.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = an.from(r.response.headers))), Promise.reject(r);
  });
}
const Pv = "1.10.0", rh = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  rh[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const Sx = {};
rh.transitional = function(e, n, r) {
  function s(a, i) {
    return "[Axios v" + Pv + "] Transitional option '" + a + "'" + i + (r ? ". " + r : "");
  }
  return (a, i, o) => {
    if (e === !1)
      throw new pe(
        s(i, " has been removed" + (n ? " in " + n : "")),
        pe.ERR_DEPRECATED
      );
    return n && !Sx[i] && (Sx[i] = !0, console.warn(
      s(
        i,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(a, i, o) : !0;
  };
};
rh.spelling = function(e) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function iV(t, e, n) {
  if (typeof t != "object")
    throw new pe("options must be an object", pe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const a = r[s], i = e[a];
    if (i) {
      const o = t[a], c = o === void 0 || i(o, a, t);
      if (c !== !0)
        throw new pe("option " + a + " must be " + c, pe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new pe("Unknown option " + a, pe.ERR_BAD_OPTION);
  }
}
const Cf = {
  assertOptions: iV,
  validators: rh
}, br = Cf.validators;
let Bi = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new gx(),
      response: new gx()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Wi(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: a } = n;
    r !== void 0 && Cf.assertOptions(r, {
      silentJSONParsing: br.transitional(br.boolean),
      forcedJSONParsing: br.transitional(br.boolean),
      clarifyTimeoutError: br.transitional(br.boolean)
    }, !1), s != null && (L.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : Cf.assertOptions(s, {
      encode: br.function,
      serialize: br.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Cf.assertOptions(n, {
      baseUrl: br.spelling("baseURL"),
      withXsrfToken: br.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let i = a && L.merge(
      a.common,
      a[n.method]
    );
    a && L.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete a[b];
      }
    ), n.headers = an.concat(i, a);
    const o = [];
    let c = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(n) === !1 || (c = c && y.synchronous, o.unshift(y.fulfilled, y.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(y) {
      u.push(y.fulfilled, y.rejected);
    });
    let l, d = 0, m;
    if (!c) {
      const b = [Tx.bind(this), void 0];
      for (b.unshift.apply(b, o), b.push.apply(b, u), m = b.length, l = Promise.resolve(n); d < m; )
        l = l.then(b[d++], b[d++]);
      return l;
    }
    m = o.length;
    let h = n;
    for (d = 0; d < m; ) {
      const b = o[d++], y = o[d++];
      try {
        h = b(h);
      } catch (g) {
        y.call(this, g);
        break;
      }
    }
    try {
      l = Tx.call(this, h);
    } catch (b) {
      return Promise.reject(b);
    }
    for (d = 0, m = u.length; d < m; )
      l = l.then(u[d++], u[d++]);
    return l;
  }
  getUri(e) {
    e = Wi(this.defaults, e);
    const n = Tv(e.baseURL, e.url, e.allowAbsoluteUrls);
    return xv(n, e.params, e.paramsSerializer);
  }
};
L.forEach(["delete", "get", "head", "options"], function(e) {
  Bi.prototype[e] = function(n, r) {
    return this.request(Wi(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
L.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(a, i, o) {
      return this.request(Wi(o || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: i
      }));
    };
  }
  Bi.prototype[e] = n(), Bi.prototype[e + "Form"] = n(!0);
});
let oV = class Uv {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const i = new Promise((o) => {
        r.subscribe(o), a = o;
      }).then(s);
      return i.cancel = function() {
        r.unsubscribe(a);
      }, i;
    }, e(function(a, i, o) {
      r.reason || (r.reason = new nl(a, i, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Uv(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function cV(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function lV(t) {
  return L.isObject(t) && t.isAxiosError === !0;
}
const cb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(cb).forEach(([t, e]) => {
  cb[e] = t;
});
function Nv(t) {
  const e = new Bi(t), n = lv(Bi.prototype.request, e);
  return L.extend(n, Bi.prototype, e, { allOwnKeys: !0 }), L.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return Nv(Wi(t, s));
  }, n;
}
const et = Nv(ud);
et.Axios = Bi;
et.CanceledError = nl;
et.CancelToken = oV;
et.isCancel = vv;
et.VERSION = Pv;
et.toFormData = th;
et.AxiosError = pe;
et.Cancel = et.CanceledError;
et.all = function(e) {
  return Promise.all(e);
};
et.spread = cV;
et.isAxiosError = lV;
et.mergeConfig = Wi;
et.AxiosHeaders = an;
et.formToJSON = (t) => kv(L.isHTMLForm(t) ? new FormData(t) : t);
et.getAdapter = Iv.getAdapter;
et.HttpStatusCode = cb;
et.default = et;
const {
  Axios: lY,
  AxiosError: uY,
  CanceledError: dY,
  isCancel: fY,
  CancelToken: pY,
  VERSION: hY,
  all: mY,
  Cancel: yY,
  isAxiosError: bY,
  spread: gY,
  toFormData: wY,
  AxiosHeaders: EY,
  HttpStatusCode: xY,
  formToJSON: AY,
  getAdapter: kY,
  mergeConfig: vY
} = et;
function uV(t = {}) {
  return Pt.request(t);
}
function dV(t) {
  return t && t.cause === "APIError";
}
class rl extends Error {
  constructor(e = "Unknown Reason", n, r, s = "APIError", a = {}) {
    super(e, { ...a, cause: "APIError" }), Object.defineProperty(this, "type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "statusCode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "rawError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "APIError", this.type = s, this.statusCode = n, this.endpoint = r == null ? void 0 : r.endpoint, this.rawError = r;
  }
}
const Pt = et.create();
Pt.interceptors.response.use((t) => (t.headers.Deprecation === "true" && console.warn(`Warning: API ${t.config.url} is deprecated. Stability and performance may be affected.`), t), (t) => {
  var e, n, r, s, a, i;
  return Promise.reject(new rl((n = (e = t.response) == null ? void 0 : e.data) == null ? void 0 : n.message, ((s = (r = t.response) == null ? void 0 : r.data) == null ? void 0 : s.statusCode) || 500, {
    ...(a = t.response) == null ? void 0 : a.data,
    endpoint: (i = t.config) == null ? void 0 : i.url
  }));
});
async function o1(t, e, n = 15, r = 0) {
  if (r >= n)
    throw `Failed to get data after ${r} attempt(s), aborting`;
  async function s() {
    return (await Pt.request(t)).data;
  }
  const a = await s();
  if (e(a))
    return a;
  await new Promise((o) => setTimeout(o, 5e3)), r++, await o1(t, e, n, r);
}
async function c1(t, e, n = 15, r = 0, s = 5e3) {
  if (r >= n)
    throw `Failed to get an ok response after ${r} attempt(s), aborting`;
  const a = await Pt.request(t);
  if (e || (e = (i) => i.status === 200), e(a))
    return !0;
  await new Promise((i) => setTimeout(i, s)), r++, await c1(t, e, n, r, s);
}
class fV extends Error {
  constructor(e, n) {
    super(`Failed to receive a successful response for solver status check with hash '${e}' after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "SolverStatusTimeoutError", this.txHash = e;
  }
}
class pV extends Error {
  constructor(e, n) {
    super(`Deposit transaction with hash '${e}' is pending after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "DepositTransactionTimeoutError", this.txHash = e;
  }
}
class hV extends Error {
  constructor(e, n, r) {
    super(e), Object.defineProperty(this, "receipt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tenderlyError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TransactionConfirmationError", this.receipt = n, this.tenderlyError = r ?? void 0;
  }
}
async function l1(t, e = 15, n = 0, r = 5e3) {
  if (n >= e)
    throw `Failed to get an ok response after ${n} attempt(s), aborting`;
  if (await t())
    return !0;
  await new Promise((a) => setTimeout(a, r)), n++, await l1(t, e, n, r);
}
const mV = (t) => new Promise((e) => {
  Pt.get(`https://api.tenderly.co/api/v1/explorer/${t}`, {
    timeout: 5e3
  }).then((n) => {
    n && n.data && n.data.error_info && e(n.data.error_info), e(null);
  }).catch((n) => {
    console.warn(`Tenderly api failed: ${n}`), e(null);
  });
});
async function yV(t, e, n, r, s, a, i, o, c, u, l, d, m) {
  var P, D, $, K, F, M, V, z, X, Y, Q, le;
  const h = Fe();
  try {
    await l1(async () => await r.getChainId() === t, 10, void 0, 250);
  } catch {
    throw `Current chain id: ${await r.getChainId()} does not match expected chain id: ${t} `;
  }
  let b, y = !1, g = !1;
  const w = h.pollingInterval ?? 5e3, v = h.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / w;
  let A = !0, B = 0, x;
  const N = !!(Array.isArray(e) && e.length > 1 && r.handleBatchTransactionStep);
  if (N ? x = await ((P = r.handleBatchTransactionStep) == null ? void 0 : P.call(r, t, e)) : x = await r.handleSendTransactionStep(t, Array.isArray(e) ? e[0] : e, n), x === "null")
    throw "User rejected the request";
  const I = Array.isArray(e) ? (D = e.find((Z) => Z.check)) == null ? void 0 : D.check : e.check;
  if (Bx({
    txHash: x,
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: h.source
  }), x && !N && !Array.isArray(e) && t === ((K = ($ = l == null ? void 0 : l.currencyOut) == null ? void 0 : $.currency) == null ? void 0 : K.chainId) && Ox({
    calldata: JSON.stringify({ ...e.data, txHash: x }),
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: h.source
  }), !x)
    throw Error("Transaction hash not returned from handleSendTransactionStep method");
  s([
    { txHash: x, chainId: t, isBatchTx: N }
  ]);
  const O = (Z) => {
    var ce, te, ie, fe, he, Ae, $e;
    if ((ce = Fe()) == null || ce.log(["Execute Steps: Polling for confirmation", Z], ye.Verbose), m == null || m((te = Z.data) == null ? void 0 : te.status), Z.status === 200 && Z.data && Z.data.status === "failure")
      throw Error("Transaction failed");
    if (Z.status === 200 && Z.data && Z.data.status === "fallback")
      throw Error("Transaction failed: Refunded");
    if (Z.status === 200 && Z.data && Z.data.status === "success") {
      if (x)
        a([
          { txHash: x, chainId: t, isBatchTx: N }
        ]);
      else if ((ie = Z == null ? void 0 : Z.data) != null && ie.inTxHashes) {
        const Nt = (he = (fe = Z.data) == null ? void 0 : fe.inTxHashes) == null ? void 0 : he.map((_e) => {
          var wn;
          return {
            txHash: _e,
            chainId: ((wn = Z == null ? void 0 : Z.data) == null ? void 0 : wn.originChainId) ?? t,
            isBatchTx: N
          };
        });
        a(Nt);
      }
      const tt = ($e = (Ae = Z.data) == null ? void 0 : Ae.txHashes) == null ? void 0 : $e.map((Nt) => {
        var _e;
        return {
          txHash: Nt,
          chainId: ((_e = Z == null ? void 0 : Z.data) == null ? void 0 : _e.destinationChainId) ?? c
        };
      });
      return s(tt), !0;
    }
    return !1;
  }, C = async (Z) => {
    var ce, te, ie;
    for (u == null || u(); A && B < v && !y && !g; ) {
      let fe;
      if (I != null && I.endpoint && !((ce = i == null ? void 0 : i.data) != null && ce.useExternalLiquidity)) {
        let he = I == null ? void 0 : I.endpoint;
        h.source && !he.includes("referrer") && (I == null ? void 0 : I.method) === "GET" && (he = he.includes("?") ? `${he}&referrer=${h.source}` : `${he}?referrer=${h.source}`);
        try {
          fe = await Pt.request({
            url: `${i.baseURL}${he}`,
            method: I == null ? void 0 : I.method,
            headers: o
          });
        } catch (Ae) {
          (te = Fe()) == null || te.log(["Execute Steps: Polling for confirmation api error", Ae], ye.Verbose), fe = {
            data: {},
            status: 200,
            statusText: "OK",
            headers: {},
            config: {
              headers: {}
            }
          };
        }
      }
      ((ie = fe == null ? void 0 : fe.data) == null ? void 0 : ie.status) === "pending" && A && (Z == null || Z.abort()), !fe || O(fe) ? A = !1 : fe && (fe.data.status !== "pending" && (u == null || u(fe), B++), await new Promise((he) => setTimeout(he, w)));
    }
    if (B >= v)
      throw b ? new fV(x, B) : new pV(x, B);
    if (y)
      throw Error("Transaction was cancelled");
    return !0;
  }, U = () => {
    const Z = new AbortController(), ce = Z.signal;
    return {
      promise: r.handleConfirmTransactionStep(x, t, (te) => {
        var ie, fe, he;
        ce.aborted || (s([{ txHash: te, chainId: t }]), x = te, B = 0, (ie = Fe()) == null || ie.log(["Transaction replaced", te], ye.Verbose), Bx({
          txHash: te,
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: h.source
        }), !N && !Array.isArray(e) && t === ((he = (fe = l == null ? void 0 : l.currencyOut) == null ? void 0 : fe.currency) == null ? void 0 : he.chainId) && Ox({
          calldata: JSON.stringify({ ...e.data, replacementTxHash: te }),
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: h.source
        }));
      }, () => {
        var te;
        ce.aborted || (y = !0, (te = Fe()) == null || te.log(["Transaction cancelled"], ye.Verbose));
      }).then((te) => {
        var ie;
        if (!ce.aborted) {
          if (b = te, d == null || d(b), b && typeof b == "object" && "status" in b && b.status === "reverted")
            throw "Transaction Reverted";
          (ie = Fe()) == null || ie.log(["Transaction Receipt obtained", b], ye.Verbose);
        }
      }).catch(async (te) => {
        var fe;
        if (ce.aborted)
          return;
        let ie = null;
        if (b && b.transactionHash && (ie = await mV(b.transactionHash)), (fe = Fe()) == null || fe.log(["Error in handleConfirmTransactionStep", te], ye.Error), te.message === "Transaction cancelled")
          y = !0;
        else
          throw g = !0, new hV(te, b, ie);
      }),
      controller: Z
    };
  };
  if (t === 8253038)
    return !0;
  if (N)
    await C();
  else if (
    //Sequence internal functions
    // We want synchronous execution in the following cases:
    // - Approval Signature step required first
    // - Bitcoin is the destination
    // - Canonical route used
    n.id === "approve" || ((M = (F = l == null ? void 0 : l.currencyOut) == null ? void 0 : F.currency) == null ? void 0 : M.chainId) === 8253038 || (V = i == null ? void 0 : i.data) != null && V.useExternalLiquidity
  )
    await U().promise, ((X = (z = l == null ? void 0 : l.currencyOut) == null ? void 0 : z.currency) == null ? void 0 : X.chainId) !== 8253038 && !((Y = i == null ? void 0 : i.data) != null && Y.useExternalLiquidity) && await C();
  else {
    const { promise: Z, controller: ce } = U(), te = C(ce);
    await Promise.race([Z, te]);
    const ie = ((le = (Q = l == null ? void 0 : l.currencyOut) == null ? void 0 : Q.currency) == null ? void 0 : le.chainId) === t;
    A && (ie ? A = !1 : await te), b || (I ? ce.abort() : await Z);
  }
  return !0;
}
const Ox = async ({ calldata: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (t && s.requestId && e) {
    (i = Fe()) == null || i.log(["Posting same chain transaction to notify the solver"], ye.Verbose);
    try {
      const c = {
        tx: t,
        chainId: e.toString(),
        requestId: s.requestId,
        referrer: a
      };
      Pt.request({
        url: `${n.baseURL}/transactions/single`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Fe()) == null || u.log(["Same chain transaction notified to the solver"], ye.Verbose);
      });
    } catch (c) {
      (o = Fe()) == null || o.log(["Failed to post same chain transaction to solver", c], ye.Warn);
    }
  }
}, Bx = async ({ txHash: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (s.id === "deposit" && t) {
    (i = Fe()) == null || i.log(["Posting transaction to notify the solver"], ye.Verbose);
    try {
      const c = {
        txHash: t,
        chainId: e.toString(),
        referrer: a
      };
      Pt.request({
        url: `${n.baseURL}/transactions/index`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Fe()) == null || u.log(["Transaction notified to the solver"], ye.Verbose);
      });
    } catch (c) {
      (o = Fe()) == null || o.log(["Failed to post transaction to solver", c], ye.Warn);
    }
  }
};
function bV(t) {
  var a, i;
  const e = t[0], n = t[1], r = (a = e == null ? void 0 : e.items) == null ? void 0 : a.some((o) => o.status === "incomplete"), s = (i = n == null ? void 0 : n.items) == null ? void 0 : i.some((o) => o.status === "incomplete");
  return (e == null ? void 0 : e.id) === "approve" && ((n == null ? void 0 : n.id) === "deposit" || (n == null ? void 0 : n.id) === "swap") && r && s;
}
function gV(t) {
  var r;
  const e = (r = t[1]) == null ? void 0 : r.id;
  return {
    id: `approve-and-${e}`,
    action: "Confirm transaction in your wallet",
    description: `Batching approval and ${e} transactions`,
    kind: "transaction",
    items: [
      ...t[0].items || [],
      ...(t[1].items || []).map((s) => (s.status = "complete", s.progressState = "complete", s))
    ],
    requestId: t[1].requestId ?? t[0].requestId
  };
}
async function sh(t, e = {}, n, r, s, a) {
  var m, h;
  const i = Fe();
  i != null && i.baseApiUrl && (e.baseURL = i.baseApiUrl);
  const o = i.pollingInterval ?? 5e3, c = i.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / o, u = i.chains.find((b) => b.id === t);
  if (!u)
    throw `Unable to find chain: Chain id ${t}`;
  let l = s, d = !1;
  try {
    if (!l) {
      i.log(["Execute Steps: Fetching Steps", e], ye.Verbose);
      const x = await Pt.request(e);
      if (l = x.data, x.status !== 200)
        throw l;
      i.log(["Execute Steps: Steps retrieved", l], ye.Verbose);
    }
    if (l.error || !l.steps)
      throw l;
    if (bV(l.steps) && (d = !!(n != null && n.supportsAtomicBatch && await (n == null ? void 0 : n.supportsAtomicBatch(t))), d)) {
      const x = gV(l.steps);
      l.steps = [x];
    }
    r({
      steps: [...l == null ? void 0 : l.steps],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details
    });
    let b = -1, y = -1;
    if (l.steps.find((x, N) => {
      if (!x.items)
        return !1;
      if (y = x.items.findIndex((I) => I.status == "incomplete"), y !== -1)
        return b = N, !0;
    }), b === -1)
      return i.log(["Execute Steps: all steps complete"], ye.Verbose), l;
    const g = l.steps[b];
    if (a && a[g.id]) {
      const x = a[g.id];
      (m = g.items) == null || m.forEach((N) => {
        x.gasLimit && (N.data.gas = x.gasLimit);
      });
    }
    let w = l.steps[b].items;
    if (!w)
      return i.log(["Execute Steps: skipping step, no items in step"], ye.Verbose), l;
    let { kind: v } = g, A = w[y];
    if (!A.data) {
      if (i.log(["Execute Steps: step item data is missing, begin polling"], ye.Verbose), l = await o1(e, (N) => {
        var O, C, U, P;
        i.log(["Execute Steps: step item data is missing, polling", N], ye.Verbose);
        const I = N;
        return !!((C = (O = I == null ? void 0 : I.steps) == null ? void 0 : O[b].items) != null && C[y].data || ((P = (U = I == null ? void 0 : I.steps) == null ? void 0 : U[b].items) == null ? void 0 : P[y].status) === "complete");
      }), !l.steps || !l.steps[b].items)
        throw l;
      const x = l.steps[b].items;
      if (!x || !x[y] || !x[y].data)
        throw l;
      w = x, A = x[y], r({
        steps: [...l == null ? void 0 : l.steps],
        fees: { ...l == null ? void 0 : l.fees },
        breakdown: l == null ? void 0 : l.breakdown,
        details: l == null ? void 0 : l.details
      });
    }
    i.log([`Execute Steps: Begin processing step items for: ${g.action}`], ye.Verbose);
    const B = w.filter((x) => x.status === "incomplete").map((x) => new Promise(async (N, I) => {
      var O, C;
      try {
        const U = x.data;
        if (!l)
          return;
        switch (v) {
          case "transaction": {
            try {
              i.log([
                "Execute Steps: Begin transaction step for, sending transaction"
              ], ye.Verbose);
              const P = ((O = x == null ? void 0 : x.data) == null ? void 0 : O.chainId) ?? t, D = t;
              x.progressState = "confirming", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              }), await yV(P, d && y === 0 ? w : x, g, n, (K) => {
                i.log([
                  "Execute Steps: Transaction step, got transactions",
                  K
                ], ye.Verbose), x.txHashes = K, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (K) => {
                x.internalTxHashes = K, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, e, void 0, D, (K) => {
                K && K.data.status === "delayed" ? x.progressState = "validating_delayed" : x.progressState = "validating", l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, l == null ? void 0 : l.details, (K) => {
                x.receipt = K, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (K) => {
                K != x.checkStatus && (x.checkStatus = K, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }));
              });
            } catch (P) {
              throw P;
            }
            break;
          }
          case "signature": {
            let P;
            const D = U.sign, $ = U.post;
            if (i.log(["Execute Steps: Begin signature step"], ye.Verbose), D && (x.progressState = "signing", r({
              steps: [...l.steps],
              fees: { ...l == null ? void 0 : l.fees },
              breakdown: l == null ? void 0 : l.breakdown,
              details: l == null ? void 0 : l.details
            }), P = await n.handleSignMessageStep(x, g), P && (e.params = {
              ...e.params,
              signature: P
            })), $) {
              i.log(["Execute Steps: Posting order"], ye.Verbose), x.progressState = "posting", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              });
              const K = new URL(`${e.baseURL}${$.endpoint}`), F = {
                "Content-Type": "application/json"
              };
              $.body && !$.body.referrer && ($.body.referrer = i.source);
              try {
                const V = await async function() {
                  return await Pt.request({
                    url: K.href,
                    data: $.body ? JSON.stringify($.body) : void 0,
                    method: $.method,
                    params: e.params,
                    headers: F
                  });
                }();
                if (V.data && V.data.steps && Array.isArray(V.data.steps)) {
                  l.steps = [...l.steps, ...V.data.steps], r({
                    steps: [...l.steps, ...V.data.steps],
                    fees: { ...l.fees },
                    breakdown: l.breakdown,
                    details: l.details
                  }), i.log([
                    `Execute Steps: New steps appended from ${$.endpoint}`,
                    V.data.steps
                  ], ye.Verbose);
                  break;
                }
                if (x != null && x.check && (x.progressState = "validating", r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }), x.isValidatingSignature = !0, r({
                  steps: [...l == null ? void 0 : l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }), await c1({
                  url: `${e.baseURL}${x == null ? void 0 : x.check.endpoint}`,
                  method: x == null ? void 0 : x.check.method,
                  headers: F
                }, (z) => {
                  var X, Y, Q, le, Z, ce, te, ie, fe, he;
                  if (i.log([
                    "Execute Steps: Polling execute status to check if indexed",
                    z
                  ], ye.Verbose), ((X = z == null ? void 0 : z.data) == null ? void 0 : X.status) === "success" && ((Y = z == null ? void 0 : z.data) != null && Y.txHashes)) {
                    const Ae = (le = (Q = z.data) == null ? void 0 : Q.txHashes) == null ? void 0 : le.map(($e) => ({
                      txHash: $e,
                      chainId: z.data.destinationChainId ?? (u == null ? void 0 : u.id)
                    }));
                    if ((Z = z == null ? void 0 : z.data) != null && Z.inTxHashes) {
                      const $e = (te = (ce = z.data) == null ? void 0 : ce.inTxHashes) == null ? void 0 : te.map((tt) => ({
                        txHash: tt,
                        chainId: (u == null ? void 0 : u.id) ?? z.data.originChainId
                      }));
                      x.internalTxHashes = $e;
                    }
                    return x.txHashes = Ae, !0;
                  } else {
                    if (((ie = z == null ? void 0 : z.data) == null ? void 0 : ie.status) === "failure")
                      throw Error(((fe = z == null ? void 0 : z.data) == null ? void 0 : fe.details) || "Transaction failed");
                    ((he = z == null ? void 0 : z.data) == null ? void 0 : he.status) === "delayed" && (x.progressState = "validating_delayed");
                  }
                  return !1;
                }, c, 0, o)), V.status > 299 || V.status < 200)
                  throw V.data;
                V.data.results ? x.orderData = V.data.results : V.data && V.data.orderId && (x.orderData = [
                  {
                    orderId: V.data.orderId,
                    crossPostingOrderId: V.data.crossPostingOrderId,
                    orderIndex: V.data.orderIndex || 0
                  }
                ]), r({
                  steps: [...l == null ? void 0 : l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              } catch (M) {
                throw M;
              }
            }
            break;
          }
          default:
            break;
        }
        x.status = "complete", x.progressState = "complete", x.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        }), N(x);
      } catch (U) {
        const P = U, D = P ? P.message : "Error: something went wrong";
        P && (l != null && l.steps) && (l.steps[b].error = D, x.error = D, x.errorData = ((C = U == null ? void 0 : U.response) == null ? void 0 : C.data) || U, x.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        })), I(P);
      }
    }));
    return await Promise.all(B), await sh(t, e, n, r, l, a);
  } catch (b) {
    i.log(["Execute Steps: An error occurred", b], ye.Error);
    const y = b && ((h = b == null ? void 0 : b.response) != null && h.data) ? b.response.data : b;
    let g = !1;
    throw y && y.message ? g = y.message.includes("Refunded") : y && y.includes && (g = y.includes("Refunded")), l ? (l.error = y, r({
      steps: l.steps ? [...l.steps] : [{}],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details,
      refunded: g,
      error: y
    })) : (l = {
      error: y,
      steps: [],
      refunded: g
    }, r(l)), b;
  }
}
function wV(t, e) {
  Object.keys(e).map((n) => {
    var s;
    let r = e[n];
    return r !== void 0 && (Array.isArray(r) ? r.forEach((a) => {
      t.searchParams.append(n, a);
    }) : t.searchParams.append(n, (s = e[n]) == null ? void 0 : s.toString())), t;
  });
}
function u1(t) {
  var a;
  const { abi: e, functionName: n, args: r } = t, s = mn({ abi: e, functionName: n, args: r });
  return {
    to: t.address,
    value: ((a = t == null ? void 0 : t.value) == null ? void 0 : a.toString()) ?? "0",
    data: s
  };
}
function d1(t) {
  return t.extend !== void 0 && t.getPermissions !== void 0;
}
const ah = (t) => ({
  vmType: "evm",
  getChainId: async () => t.getChainId(),
  transport: Ol(t.transport),
  address: async () => {
    var n;
    let e = (n = t.account) == null ? void 0 : n.address;
    return e || ([e] = await t.getAddresses()), e;
  },
  handleSignMessageStep: async (e) => {
    var a;
    const n = Fe(), r = (a = e.data) == null ? void 0 : a.sign;
    let s;
    return r && (r.signatureKind === "eip191" ? (n.log(["Execute Steps: Signing with eip191"], ye.Verbose), r.message.match(/0x[0-9a-fA-F]{64}/) ? s = await t.signMessage({
      account: t.account,
      message: {
        raw: r.message
      }
    }) : s = await t.signMessage({
      account: t.account,
      message: r.message
    })) : r.signatureKind === "eip712" && (n.log(["Execute Steps: Signing with eip712"], ye.Verbose), s = await t.signTypedData({
      account: t.account,
      domain: r.domain,
      types: r.types,
      primaryType: r.primaryType,
      message: r.value
    }))), s;
  },
  handleSendTransactionStep: async (e, n) => {
    var o;
    const r = n.data, s = Fe(), a = (o = Fe().chains.find((c) => c.id === e)) == null ? void 0 : o.viemChain;
    if (!a)
      throw "Chain not found when sending transaction";
    return await Qu({
      account: t.account ?? r.from,
      chain: a,
      transport: Ol(t.transport, { retryCount: 10, retryDelay: 200 })
    }).sendTransaction({
      chain: a,
      data: r.data,
      account: t.account ?? r.from,
      // use signer.account if it's defined
      to: r.to,
      value: Os(r.value || 0),
      ...r.maxFeePerGas && s.useGasFeeEstimations && {
        maxFeePerGas: Os(r.maxFeePerGas)
      },
      ...r.maxPriorityFeePerGas && s.useGasFeeEstimations && {
        maxPriorityFeePerGas: Os(r.maxPriorityFeePerGas)
      },
      ...r.gas && s.useGasFeeEstimations && {
        gas: Os(r.gas)
      }
    });
  },
  handleConfirmTransactionStep: async (e, n, r, s) => {
    const a = Fe(), i = a.chains.find((l) => l.id === n), o = i == null ? void 0 : i.httpRpcUrl;
    return await wa({
      chain: i == null ? void 0 : i.viemChain,
      transport: t.transport ? Ew(o ? [ct(o), Ol(t.transport), ct()] : [Ol(t.transport), ct()]) : Ew([ct(o), ct()]),
      pollingInterval: a.confirmationPollingInterval
    }).waitForTransactionReceipt({
      hash: e,
      onReplaced: (l) => {
        if (l.reason === "cancelled")
          throw s(), Error("Transaction cancelled");
        r(l.transaction.hash);
      }
    });
  },
  switchChain: async (e) => {
    var n;
    try {
      await t.switchChain({
        id: e
      });
      return;
    } catch (r) {
      if (r && (r != null && r.message)) {
        if (r.message.includes("does not support the requested chain"))
          throw new Error("Wallet does not support chain");
        if (r.message.includes("rejected"))
          throw r;
        if (r.message.includes("already pending"))
          return;
      }
      const a = Fe().chains.find((i) => i.id === e);
      if (!a)
        throw "Chain missing from Relay Client";
      try {
        await t.addChain({
          chain: a == null ? void 0 : a.viemChain
        });
      } catch (i) {
        if (i instanceof Error && i.name && i.name === "InternalRpcError" && i.message.includes("is not a function")) {
          (n = Fe()) == null || n.log([
            "Execute Steps: Detected internal RPC Error when adding a chain to the wallet",
            i
          ], ye.Verbose);
          return;
        } else
          throw i;
      }
      return;
    }
  },
  supportsAtomicBatch: async (e) => {
    var n;
    if (!t.account)
      return !1;
    try {
      const r = await t.getCapabilities({
        account: t.account,
        chainId: e
      });
      return (n = r == null ? void 0 : r.atomicBatch) == null ? void 0 : n.supported;
    } catch {
      return !1;
    }
  },
  handleBatchTransactionStep: async (e, n) => {
    var o;
    const r = n.map((c) => ({
      to: c.data.to,
      data: c.data.data,
      value: Os(c.data.value || 0),
      ...c.data.maxFeePerGas && {
        maxFeePerGas: Os(c.data.maxFeePerGas)
      },
      ...c.data.maxPriorityFeePerGas && {
        maxPriorityFeePerGas: Os(c.data.maxPriorityFeePerGas)
      },
      ...c.data.gas && {
        gas: Os(c.data.gas)
      }
    })), a = (o = Fe().chains.find((c) => c.id === e)) == null ? void 0 : o.viemChain;
    if (!a)
      throw "Chain not found when sending transaction";
    const { id: i } = await t.sendCalls({
      chain: a,
      account: t.account,
      calls: r
    });
    return i;
  }
}), Rv = "https://api.relay.link", ua = "https://assets.relay.link", EV = Object.values(Jp).reduce((t, e) => (t[e.id] = e, t), {}), Fv = (t) => {
  let e;
  const r = [999].includes(t.id) ? void 0 : EV[t.id];
  return r ? e = r : e = {
    id: t.id,
    name: t.displayName,
    nativeCurrency: {
      name: t.currency.name ?? "Ethereum",
      decimals: t.currency.decimals ?? 18,
      symbol: t.currency.symbol ?? "ETH"
    },
    rpcUrls: {
      default: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      },
      public: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      }
    },
    blockExplorers: {
      etherscan: {
        name: t.explorerName,
        url: t.explorerUrl
      },
      default: {
        name: t.explorerName,
        url: t.explorerUrl
      }
    }
  }, {
    ...t,
    viemChain: e,
    icon: {
      dark: `${ua}/icons/${t.id}/dark.png`,
      light: t.iconUrl ?? `${ua}/icons/${t.id}/light.png`,
      squaredDark: `${ua}/icons/square/${t.id}/dark.png`,
      squaredLight: `${ua}/icons/square/${t.id}/light.png`
    }
  };
}, ih = (t) => {
  var e;
  return {
    id: t.id,
    name: t.name.replace(" ", "-"),
    displayName: t.name,
    httpRpcUrl: t.rpcUrls.default && t.rpcUrls.default && t.rpcUrls.default ? t.rpcUrls.default.http[0] ?? "" : "",
    wsRpcUrl: t.rpcUrls && t.rpcUrls.default.webSocket ? t.rpcUrls.default.webSocket[0] ?? "" : "",
    icon: {
      dark: `${ua}/icons/${t.id}/dark.png`,
      light: `${ua}/icons/${t.id}/light.png`,
      squaredDark: `${ua}/icons/square/${t.id}/dark.png`,
      squaredLight: `${ua}/icons/square/${t.id}/light.png`
    },
    currency: {
      address: Me,
      ...t.nativeCurrency
    },
    explorerUrl: ((e = t.blockExplorers) == null ? void 0 : e.default.url) ?? "",
    vmType: "evm",
    depositEnabled: !0,
    viemChain: t
  };
}, xV = async (t, e) => {
  let n = "";
  if (e) {
    const s = new URLSearchParams();
    s.set("referrer", e), n = `?${s.toString()}`;
  }
  const r = await Pt.get(`${t}/chains${n}`);
  if (r.data && r.data.chains)
    return r.data.chains.map((s) => Fv(s));
  throw "No Chain Data";
}, Dv = (t) => {
  let e = null, n, r = [];
  for (const s of t) {
    for (const a of s.items || [])
      if (a.txHashes && a.txHashes.length > 0 && (r = a.txHashes.concat([...r])), a.internalTxHashes && a.internalTxHashes.length > 0 && (r = a.internalTxHashes.concat([...r])), a.status === "incomplete") {
        e = s, n = a;
        break;
      }
    if (e && n)
      break;
  }
  return { currentStep: e, currentStepItem: n, txHashes: r };
};
function f1(t) {
  return t.abi !== void 0;
}
function p1(t) {
  return typeof structuredClone == "function" ? structuredClone(t) : JSON.parse(JSON.stringify(t));
}
const AV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APIError: rl,
  get LogLevel() {
    return ye;
  },
  adaptViemWallet: ah,
  axios: Pt,
  configureViemChain: Fv,
  convertViemChainToRelayChain: ih,
  executeSteps: sh,
  fetchChainConfigs: xV,
  getCurrentStepData: Dv,
  isAPIError: dV,
  isSimulateContractRequest: f1,
  log: nb,
  pollUntilHasData: o1,
  pollUntilOk: c1,
  prepareCallTransaction: u1,
  repeatUntilOk: l1,
  request: uV,
  safeStructuredClone: p1,
  setParams: wV
}, Symbol.toStringTag, { value: "Module" })), kV = "2.3.0";
let Ll;
const vV = [
  Ln,
  Hr,
  tp,
  lr,
  cr,
  Gc
].map((t) => ih(t)), CV = [Ta, P8].map((t) => ih(t));
class TV {
  log(e, n = ye.Info) {
    return nb(e, n, this.logLevel);
  }
  constructor(e) {
    var n;
    if (Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uiVersion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "baseApiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "source", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logLevel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "confirmationPollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxPollingAttemptsBeforeTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useGasFeeEstimations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utils", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { ...AV }
    }), Object.defineProperty(this, "actions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: X5
    }), this.version = kV, this.uiVersion = e.uiVersion, this.baseApiUrl = e.baseApiUrl ?? Rv, this.logLevel = e.logLevel !== void 0 ? e.logLevel : ye.None, this.pollingInterval = e.pollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations ?? !0, e.chains ? this.chains = e.chains : (n = e.baseApiUrl) != null && n.includes("testnets") ? this.chains = CV : this.chains = vV, e.source)
      this.source = e.source;
    else if (typeof window < "u") {
      let r = location.hostname;
      r.indexOf("www.") === 0 && (r = r.replace("www.", "")), this.source = r, console.warn("RelaySDK automatically generated a source based on the url, we recommend providing a source when initializing the sdk. Refer to our docs for steps on how to do this: https://docs.relay.link/references/sdk/getting-started#configuration");
    }
  }
  configure(e) {
    this.baseApiUrl = e.baseApiUrl ? e.baseApiUrl : this.baseApiUrl, this.source = e.source ? e.source : this.source, this.logLevel = e.logLevel !== void 0 ? e.logLevel : ye.None, this.pollingInterval = e.pollingInterval ? e.pollingInterval : this.pollingInterval, this.confirmationPollingInterval = e.confirmationPollingInterval ? e.confirmationPollingInterval : this.confirmationPollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout ? e.maxPollingAttemptsBeforeTimeout : this.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations !== void 0 ? e.useGasFeeEstimations : this.useGasFeeEstimations, e.logger ? this.log = e.logger : this.log = (n, r = ye.Info) => {
      nb(n, r, this.logLevel);
    }, e.chains && (this.chains = e.chains);
  }
}
function Fe() {
  return Ll;
}
function SV(t) {
  return Ll ? Ll.configure(t) : Ll = new TV({ ...t }), Ll;
}
const Mv = "0x000000000000000000000000000000000000dead", Lv = "CbKGgVKLJFb8bBrf58DnAkdryX6ubewVytn7X957YwNr", Hv = "CrfbABN2sSvmoZLu9eDDfXpaC2nHg42R7AXbHs9eg4S9", $v = "bc1q4vxn43l44h30nkluqfxd9eckf45vr2awz38lwa", OV = "THa7BwoPfacfiELa63pbmm3g5PGKYmtJyt", BV = "0x00000000000000000000000000000000000dead0", _v = "0x000000000000000000000000000000000000000000000000000000000000dead", IV = 9286185, PV = 543210, lb = (t, e) => t === "svm" ? e === IV ? Hv : Lv : t === "bvm" ? $v : e === PV ? BV : t === "tvm" ? OV : t === "suivm" ? _v : Mv, Ix = (t) => t ? t === Hv || t === Lv || t === $v || t === Mv || t === _v : !1;
function UV(t) {
  var o, c, u, l, d;
  const { quote: e, wallet: n, depositGasLimit: r, onProgress: s } = t, a = Fe();
  if (!a.baseApiUrl || !a.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let i;
  n && (i = d1(n) ? ah(n) : n);
  try {
    if (!i)
      throw new Error("AdaptedWallet is required to execute steps");
    const m = new AbortController(), h = (u = (c = (o = e.details) == null ? void 0 : o.currencyIn) == null ? void 0 : c.currency) == null ? void 0 : u.chainId;
    if (h === void 0)
      throw new Error("Missing chainId from quote");
    if (Ix((l = e == null ? void 0 : e.details) == null ? void 0 : l.recipient))
      throw new Error("Recipient should never be burn address");
    if (Ix((d = e == null ? void 0 : e.details) == null ? void 0 : d.sender))
      throw new Error("Sender should never be burn address");
    const { request: b, ...y } = e, g = p1(y), w = new Promise((v, A) => {
      sh(h, b, i, ({ steps: B, fees: x, breakdown: N, details: I, refunded: O, error: C }) => {
        if (m.signal.aborted) {
          console.log("Relay SDK: Execution aborted, skipping progress callback");
          return;
        }
        const { currentStep: U, currentStepItem: P, txHashes: D } = Dv(B);
        s == null || s({
          steps: B,
          fees: x,
          breakdown: N,
          details: I,
          currentStep: U,
          currentStepItem: P,
          txHashes: D,
          refunded: O,
          error: C
        });
      }, g, r ? {
        deposit: {
          gasLimit: r
        }
      } : void 0).then((B) => {
        v({ data: B, abortController: m });
      }).catch(A);
    });
    return w.abortController = m, w;
  } catch (m) {
    throw console.error(m), m;
  }
}
const NV = async (t, e, n, r, s) => {
  const a = t.chains.find((l) => l.id === n), i = t.chains.find((l) => l.id === e), o = a ? lb(a.vmType, a.id) : void 0, c = i ? lb(i.vmType, i.id) : void 0;
  let u;
  return s && (u = await s.address()), {
    user: u || o || Me,
    recipient: r || u || c || Me
  };
};
async function RV(t, e) {
  var B;
  const { toChainId: n, toCurrency: r, wallet: s, chainId: a, currency: i, tradeType: o, amount: c = "0", recipient: u, options: l, txs: d, user: m } = t, h = Fe();
  if (!h.baseApiUrl || !h.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let b;
  s && (b = d1(s) ? ah(s) : s);
  let y;
  d && d.length > 0 && (y = d.map((x) => f1(x) ? u1(x) : x));
  let g;
  if (e && (g = await NV(h, n, a, u, b)), !m && !(g != null && g.user))
    throw new Error("User is required");
  if (!u && !(g != null && g.recipient))
    throw new Error("Recipient is required");
  const w = {
    user: e ? g == null ? void 0 : g.user : m,
    destinationCurrency: r,
    destinationChainId: n,
    originCurrency: i,
    originChainId: a,
    amount: c,
    recipient: e ? g == null ? void 0 : g.recipient : u,
    tradeType: o,
    referrer: h.source || void 0,
    txs: y,
    ...l
  }, v = {
    url: `${h.baseApiUrl}/quote`,
    method: "post",
    data: w
  }, A = await Pt.request(v);
  if (A.status !== 200)
    throw new rl((B = A == null ? void 0 : A.data) == null ? void 0 : B.message, A.status, A.data);
  return { ...A.data, request: v };
}
async function FV(t) {
  var v;
  const { destinationChainId: e, destinationCurrency: n, originChainId: r, originCurrency: s, tradeType: a, amount: i = "0", user: o, recipient: c, options: u, txs: l } = t, d = Fe();
  if (!d.baseApiUrl || !d.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let m;
  l && l.length > 0 && (m = l.map((A) => f1(A) ? u1(A) : A));
  const h = d.chains.find((A) => A.id === r), b = lb(h == null ? void 0 : h.vmType, h == null ? void 0 : h.id), y = {
    user: o ?? b,
    destinationCurrency: n,
    destinationChainId: e,
    originCurrency: s,
    originChainId: r,
    amount: i,
    recipient: c || (o ?? b),
    tradeType: a,
    referrer: d.source || void 0,
    txs: m,
    ...u
  }, g = {
    url: `${d.baseApiUrl}/price`,
    method: "post",
    data: y
  }, w = await Pt.request(g);
  if (w.status !== 200)
    throw new rl((v = w == null ? void 0 : w.data) == null ? void 0 : v.message, w.status, w.data);
  return { ...w.data, request: g };
}
async function DV(t, e = Pt) {
  const n = Fe();
  if (!n)
    throw new Error("Client not initialized");
  t.user = t.user || Me, t.currency = t.currency;
  const r = await e.get(`${n.baseApiUrl}/config/v2`, { params: t });
  if (r.data)
    return r.data;
  throw "No solver capacity data";
}
async function MV(t) {
  var a;
  const { wallet: e } = t, n = Fe();
  if (!n.baseApiUrl || !n.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  const r = {
    url: `${n.baseApiUrl}/app-fees/${e}/balances`,
    method: "get"
  }, s = await Pt.request(r);
  if (s.status !== 200)
    throw new rl((a = s == null ? void 0 : s.data) == null ? void 0 : a.message, s.status, s.data);
  return s.data.balances || [];
}
async function LV(t) {
  var d;
  const { wallet: e, chainId: n, currency: r, recipient: s, onProgress: a } = t, i = Fe();
  if (!i.baseApiUrl || !i.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let o;
  if (e && (o = d1(e) ? ah(e) : e), !o)
    throw new Error("AdaptedWallet is required to execute claim steps");
  const c = await o.address(), u = new AbortController(), l = {
    url: `${i.baseApiUrl}/app-fees/${c}/claim`,
    method: "post",
    data: { chainId: n, currency: r, recipient: s || c },
    signal: u.signal
  };
  try {
    const m = await i.utils.axios.request(l);
    if (m.status !== 200)
      throw new rl((d = m == null ? void 0 : m.data) == null ? void 0 : d.message, m.status, m.data);
    const h = m.data.steps || [], b = p1({
      steps: h
    });
    return { data: await sh(n, l, o, (g) => {
      u.signal.aborted || a == null || a(g);
    }, b), abortController: u };
  } catch (m) {
    throw console.error(m), m;
  }
}
SV({
  baseApiUrl: Rv,
  source: "Trails",
  chains: Object.values(Jp).map(
    (t) => ih(t)
  )
});
async function HV(t) {
  try {
    const e = Fe();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("[trails-sdk] getRelaySDKQuote", t), await e.actions.getQuote({
      wallet: t.wallet,
      chainId: t.chainId,
      toChainId: t.toChainId || t.chainId,
      amount: t.amount,
      currency: t.currency,
      toCurrency: t.toCurrency || t.currency,
      tradeType: t.tradeType || "EXACT_OUTPUT",
      txs: t.txs,
      user: t.wallet.account.address,
      recipient: t.recipient || t.wallet.account.address
    });
  } catch (e) {
    throw console.error("[trails-sdk] Error getting relay quote:", e), e;
  }
}
async function $V(t) {
  try {
    const e = Fe();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("[trails-sdk] relaysdkclient", e.chains, t.quote), await e.actions.execute({
      quote: t.quote,
      wallet: t.wallet,
      onProgress: t.onProgress || ((r) => {
        console.log("[trails-sdk] Relay progress:", r);
      })
    });
  } catch (e) {
    throw console.error("[trails-sdk] Error executing relay transaction:", e), e;
  }
}
async function _V(t, e, n) {
  return await $V({
    quote: t,
    wallet: e,
    onProgress: n
  });
}
function GV(t) {
  var e, n, r, s, a, i, o, c;
  return (c = (o = (i = (a = (s = (r = (e = t == null ? void 0 : t.data) == null ? void 0 : e.steps) == null ? void 0 : r[((n = t == null ? void 0 : t.data) == null ? void 0 : n.steps.length) - 1]) == null ? void 0 : s.items) == null ? void 0 : a[0]) == null ? void 0 : i.txHashes) == null ? void 0 : o[0]) == null ? void 0 : c.txHash;
}
const zV = {
  [ty.id]: ty,
  [ny.id]: ny,
  [Jf.id]: Jf,
  [cr.id]: cr,
  [Gc.id]: Gc,
  [ry.id]: ry,
  [gs.id]: gs,
  [gu.id]: gu,
  [Hr.id]: Hr,
  [ay.id]: ay,
  [Zf.id]: Zf,
  [Fy.id]: Fy,
  [oy.id]: oy,
  [cy.id]: cy,
  [uy.id]: uy,
  [dy.id]: dy,
  [fy.id]: fy,
  [py.id]: py,
  [hy.id]: hy,
  [Ln.id]: Ln,
  [my.id]: my,
  [yy.id]: yy,
  [by.id]: by,
  [wu.id]: wu,
  [wy.id]: wy,
  [Ey.id]: Ey,
  [xy.id]: xy,
  [Ay.id]: Ay,
  [zi.id]: zi,
  [Oy.id]: Oy,
  [By.id]: By,
  [Iy.id]: Iy,
  [Py.id]: Py,
  [Uy.id]: Uy,
  [Ny.id]: Ny,
  [Ry.id]: Ry,
  [lr.id]: lr,
  [My.id]: My,
  [ar.id]: ar,
  [Ly.id]: Ly,
  [$y.id]: $y,
  [Hy.id]: Hy,
  [_y.id]: _y,
  [Gy.id]: Gy,
  [zy.id]: zy,
  [Vy.id]: Vy,
  [xu.id]: xu,
  [qy.id]: qy,
  [Ky.id]: Ky,
  [Wy.id]: Wy,
  [Qy.id]: Qy,
  [Jy.id]: Jy,
  [Zy.id]: Zy,
  [Xy.id]: Xy,
  [qi.id]: qi,
  [Ki.id]: Ki,
  [Au.id]: Au,
  [eb.id]: eb,
  [tb.id]: tb,
  [ep.id]: ep,
  [tp.id]: tp
};
async function VV() {
  return Object.values(zV);
}
async function jV() {
  try {
    const t = await KV(), e = [];
    t.forEach((r) => {
      r.disabled || (e.push({
        id: r.currency.id,
        symbol: r.currency.symbol,
        name: r.currency.name,
        contractAddress: r.currency.address,
        decimals: r.currency.decimals,
        chainId: r.id,
        chainName: r.displayName || r.name,
        imageUrl: ""
        // Native currencies typically don't have logoURI
      }), r.featuredTokens.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }), r.erc20Currencies.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }), r.solverCurrencies.forEach((s) => {
        var a;
        e.push({
          id: s.id,
          symbol: s.symbol,
          name: s.name,
          contractAddress: s.address,
          decimals: s.decimals,
          chainId: r.id,
          chainName: r.displayName || r.name,
          imageUrl: ((a = s.metadata) == null ? void 0 : a.logoURI) || ""
        });
      }));
    });
    const n = e.filter(
      (r, s, a) => s === a.findIndex(
        (i) => i.chainId === r.chainId && i.contractAddress.toLowerCase() === r.contractAddress.toLowerCase()
      )
    );
    return console.log(
      `[trails-sdk] Fetched ${n.length} unique tokens from Relay API`
    ), n;
  } catch (t) {
    return console.error("[trails-sdk] Error fetching Relay supported tokens:", t), [];
  }
}
let Tl = null, Px = 0;
const qV = 5 * 60 * 1e3;
async function KV() {
  const t = Date.now();
  if (Tl && t - Px < qV)
    return Tl;
  try {
    const e = await fetch("https://api.relay.link/chains");
    if (!e.ok)
      throw new Error(`Failed to fetch chains: ${e.status}`);
    const n = await e.json();
    return Tl = n.chains, Px = t, n.chains;
  } catch (e) {
    if (console.error("[trails-sdk] Error fetching Relay chains:", e), Tl)
      return Tl;
    throw e;
  }
}
const WV = {
  [Jf.id]: Ln,
  [cr.id]: cr,
  [Gc.id]: Gc,
  [gs.id]: gs,
  [gu.id]: gu,
  [Hr.id]: Hr,
  [Zf.id]: ar,
  // [chains.opBNB.id]: chains.opBNB, // Needs chain image
  [Ln.id]: Ln,
  [wu.id]: wu,
  [lr.id]: lr,
  [ar.id]: ar,
  [xu.id]: xu,
  [Au.id]: Au
}, Ux = {
  [Hi.id]: Hi,
  [$i.id]: $i,
  [sy.id]: sy,
  [_i.id]: _i,
  [iy.id]: iy,
  [Dy.id]: Dy,
  [Ta.id]: Ta,
  [gy.id]: gy,
  [ji.id]: ji,
  [Vi.id]: Vi,
  [jy.id]: jy,
  [Yy.id]: Yy
};
function ws(t) {
  return Object.values(Jp).find(
    (e) => e.id === t
  ) || null;
}
function Cm(t) {
  return typeof t == "number" ? Ux[t] || null : Ux[t.id] || null;
}
async function QV() {
  return Object.values(WV);
}
const Nx = [1, 8453, 42161, 10, 137];
function JV(t) {
  return t.sort((e, n) => {
    const r = Nx.indexOf(e.id), s = Nx.indexOf(n.id);
    return r !== -1 && s !== -1 ? r - s : r !== -1 ? -1 : s !== -1 ? 1 : e.name.localeCompare(n.name);
  });
}
async function ZV() {
  const t = await QV(), e = await VV(), r = t.filter(
    (s) => e.some((a) => a.id === s.id)
  ).filter(
    (s, a, i) => a === i.findIndex((o) => o.id === s.id)
  );
  return JV(r);
}
function CY() {
  const { data: t = [], isLoading: e } = yn({
    queryKey: ["supportedChains"],
    queryFn: ZV,
    staleTime: 36e5,
    // 1 hour - chains rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return {
    supportedChains: t || [],
    isLoadingChains: e
  };
}
function XV({
  indexerGatewayUrl: t = rI,
  projectAccessKey: e,
  jwt: n
}) {
  return new cS(
    t,
    e,
    n
  );
}
const dd = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = _2();
  return Wu(() => XV({
    indexerGatewayUrl: (t == null ? void 0 : t.indexerGatewayUrl) ?? r.indexerGatewayUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.indexerGatewayUrl, t]);
};
function YV(t) {
  for (const e of t)
    if (typeof e != "string")
      return !1;
  return !0;
}
function ej(t) {
  return YV(t) ? Wp(t) : t;
}
const tj = "0.1.1";
function nj() {
  return tj;
}
let Ke = class ub extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof ub) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof ub && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${nj()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return Gv(this, e);
  }
};
function Gv(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? Gv(t.cause, e) : e ? null : t;
}
const rj = "#__bigint";
function zv(t, e, n) {
  return JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() + rj : s, n);
}
function sj(t, e) {
  if (Mx(t) > e)
    throw new gj({
      givenSize: Mx(t),
      maxSize: e
    });
}
const jr = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Rx(t) {
  if (t >= jr.zero && t <= jr.nine)
    return t - jr.zero;
  if (t >= jr.A && t <= jr.F)
    return t - (jr.A - 10);
  if (t >= jr.a && t <= jr.f)
    return t - (jr.a - 10);
}
function Vv(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  if (t.length > r)
    throw new wj({
      size: t.length,
      targetSize: r,
      type: "Bytes"
    });
  const s = new Uint8Array(r);
  for (let a = 0; a < r; a++) {
    const i = n === "right";
    s[i ? a : r - a - 1] = t[i ? a : t.length - a - 1];
  }
  return s;
}
function h1(t, e) {
  if ($n(t) > e)
    throw new dj({
      givenSize: $n(t),
      maxSize: e
    });
}
function aj(t, e) {
  if (typeof e == "number" && e > 0 && e > $n(t) - 1)
    throw new Wv({
      offset: e,
      position: "start",
      size: $n(t)
    });
}
function ij(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && $n(t) !== n - e)
    throw new Wv({
      offset: n,
      position: "end",
      size: $n(t)
    });
}
function jv(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new fj({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
const oj = /* @__PURE__ */ new TextEncoder(), cj = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function lj(t, e = {}) {
  const { strict: n = !1 } = e;
  if (!t)
    throw new Fx(t);
  if (typeof t != "string")
    throw new Fx(t);
  if (n && !/^0x[0-9a-fA-F]*$/.test(t))
    throw new Dx(t);
  if (!t.startsWith("0x"))
    throw new Dx(t);
}
function Es(...t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
function qv(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (h1(n, e.size), Qi(n, e.size)) : n;
}
function m1(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += cj[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (h1(r, e.size), Ji(r, e.size)) : r;
}
function sl(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new Kv({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? Qi(c, r) : c;
}
function y1(t, e = {}) {
  return m1(oj.encode(t), e);
}
function Qi(t, e) {
  return jv(t, { dir: "left", size: e });
}
function Ji(t, e) {
  return jv(t, { dir: "right", size: e });
}
function oh(t, e, n, r = {}) {
  const { strict: s } = r;
  aj(t, e);
  const a = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return s && ij(a, e, n), a;
}
function $n(t) {
  return Math.ceil((t.length - 2) / 2);
}
function uj(t, e = {}) {
  const { strict: n = !1 } = e;
  try {
    return lj(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
let Kv = class extends Ke {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
class Fx extends Ke {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? zv(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexTypeError"
    });
  }
}
class Dx extends Ke {
  constructor(e) {
    super(`Value \`${e}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexValueError"
    });
  }
}
let dj = class extends Ke {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeOverflowError"
    });
  }
};
class Wv extends Ke {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${r}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}
let fj = class extends Ke {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};
const pj = /* @__PURE__ */ new TextEncoder();
function hj(t) {
  if (!(t instanceof Uint8Array)) {
    if (!t)
      throw new af(t);
    if (typeof t != "object")
      throw new af(t);
    if (!("BYTES_PER_ELEMENT" in t))
      throw new af(t);
    if (t.BYTES_PER_ELEMENT !== 1 || t.constructor.name !== "Uint8Array")
      throw new af(t);
  }
}
function Qv(...t) {
  let e = 0;
  for (const r of t)
    e += r.length;
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
function vu(t) {
  return t instanceof Uint8Array ? t : typeof t == "string" ? Hl(t) : mj(t);
}
function mj(t) {
  return t instanceof Uint8Array ? t : new Uint8Array(t);
}
function Hl(t, e = {}) {
  const { size: n } = e;
  let r = t;
  n && (h1(t, n), r = Ji(t, n));
  let s = r.slice(2);
  s.length % 2 && (s = `0${s}`);
  const a = s.length / 2, i = new Uint8Array(a);
  for (let o = 0, c = 0; o < a; o++) {
    const u = Rx(s.charCodeAt(c++)), l = Rx(s.charCodeAt(c++));
    if (u === void 0 || l === void 0)
      throw new Ke(`Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`);
    i[o] = u * 16 + l;
  }
  return i;
}
function yj(t, e = {}) {
  const { size: n } = e, r = pj.encode(t);
  return typeof n == "number" ? (sj(r, n), bj(r, n)) : r;
}
function Jv(t, e) {
  return Vv(t, { dir: "left", size: e });
}
function bj(t, e) {
  return Vv(t, { dir: "right", size: e });
}
function Mx(t) {
  return t.length;
}
function Tf(t, e = {}) {
  return m1(t, e);
}
function Lx(t) {
  try {
    return hj(t), !0;
  } catch {
    return !1;
  }
}
class af extends Ke {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? zv(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
}
class gj extends Ke {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeOverflowError"
    });
  }
}
let wj = class extends Ke {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};
function Cu(t, e = {}) {
  const { as: n = typeof t == "string" ? "Hex" : "Bytes" } = e, r = k8(vu(t));
  return n === "Bytes" ? r : m1(r);
}
class Ej extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
const xj = {
  checksum: /* @__PURE__ */ new Ej(8192)
}, Tm = xj.checksum, Aj = /^0x[a-fA-F0-9]{40}$/;
function fd(t, e = {}) {
  const { strict: n = !0 } = e;
  if (!Aj.test(t))
    throw new Hx({
      address: t,
      cause: new kj()
    });
  if (n) {
    if (t.toLowerCase() === t)
      return;
    if (Zv(t) !== t)
      throw new Hx({
        address: t,
        cause: new vj()
      });
  }
}
function Zv(t) {
  if (Tm.has(t))
    return Tm.get(t);
  fd(t, { strict: !1 });
  const e = t.substring(2).toLowerCase(), n = Cu(yj(e), { as: "Bytes" }), r = e.split("");
  for (let a = 0; a < 40; a += 2)
    n[a >> 1] >> 4 >= 8 && r[a] && (r[a] = r[a].toUpperCase()), (n[a >> 1] & 15) >= 8 && r[a + 1] && (r[a + 1] = r[a + 1].toUpperCase());
  const s = `0x${r.join("")}`;
  return Tm.set(t, s), s;
}
function Vc(t, e = {}) {
  const { checksum: n = !1 } = e;
  return fd(t), n ? Zv(t) : t;
}
function db(t, e = {}) {
  const { strict: n = !0 } = e ?? {};
  try {
    return fd(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
class Hx extends Ke {
  constructor({ address: e, cause: n }) {
    super(`Address "${e}" is invalid.`, {
      cause: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidAddressError"
    });
  }
}
class kj extends Ke {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidInputError"
    });
  }
}
class vj extends Ke {
  constructor() {
    super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidChecksumError"
    });
  }
}
function fb(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", "error", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new Ke("Unable to normalize signature.");
  return s;
}
function pb(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return db(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => pb(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => pb(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function Xv(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return Xv(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? db(n[r], {
      strict: !1
    }) : i.includes("address") && i.includes("bytes") ? db(n[r], {
      strict: !1
    }) : !1)
      return i;
  }
}
function Cj(t, e = {}) {
  const { prepare: n = !0 } = e, r = (Array.isArray(t), sx(t));
  return {
    ...r,
    ...n ? { hash: yo(r) } : {}
  };
}
function Tj(t, e, n) {
  const { args: r = [], prepare: s = !0 } = n ?? {}, a = uj(e, { strict: !1 }), i = t.filter((u) => a ? u.type === "function" || u.type === "error" ? Yv(u) === oh(e, 0, 4) : u.type === "event" ? yo(u) === e : !1 : "name" in u && u.name === e);
  if (i.length === 0)
    throw new hb({ name: e });
  if (i.length === 1)
    return {
      ...i[0],
      ...s ? { hash: yo(i[0]) } : {}
    };
  let o;
  for (const u of i) {
    if (!("inputs" in u))
      continue;
    if (!r || r.length === 0) {
      if (!u.inputs || u.inputs.length === 0)
        return {
          ...u,
          ...s ? { hash: yo(u) } : {}
        };
      continue;
    }
    if (!u.inputs || u.inputs.length === 0 || u.inputs.length !== r.length)
      continue;
    if (r.every((d, m) => {
      const h = "inputs" in u && u.inputs[m];
      return h ? pb(d, h) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const d = Xv(u.inputs, o.inputs, r);
        if (d)
          throw new Oj({
            abiItem: u,
            type: d[0]
          }, {
            abiItem: o,
            type: d[1]
          });
      }
      o = u;
    }
  }
  const c = (() => {
    if (o)
      return o;
    const [u, ...l] = i;
    return { ...u, overloads: l };
  })();
  if (!c)
    throw new hb({ name: e });
  return {
    ...c,
    ...s ? { hash: yo(c) } : {}
  };
}
function Yv(t) {
  return oh(yo(t), 0, 4);
}
function Sj(t) {
  const e = typeof t == "string" ? t : Yf(t);
  return fb(e);
}
function yo(t) {
  return typeof t != "string" && "hash" in t && t.hash ? t.hash : Cu(y1(Sj(t)));
}
class Oj extends Ke {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${e.type}\` in \`${fb(Yf(e.abiItem))}\`, and`,
        `\`${n.type}\` in \`${fb(Yf(n.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.AmbiguityError"
    });
  }
}
let hb = class extends Ke {
  constructor({ name: e, data: n, type: r = "item" }) {
    const s = e ? ` with name "${e}"` : n ? ` with data "${n}"` : "";
    super(`ABI ${r}${s} not found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.NotFoundError"
    });
  }
};
const Bj = /^(.*)\[([0-9]*)\]$/, Ij = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, e3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function Pj({ checksumAddress: t, parameters: e, values: n }) {
  const r = [];
  for (let s = 0; s < e.length; s++)
    r.push(b1({
      checksumAddress: t,
      parameter: e[s],
      value: n[s]
    }));
  return r;
}
function b1({ checksumAddress: t = !1, parameter: e, value: n }) {
  const r = e, s = Hj(r.type);
  if (s) {
    const [a, i] = s;
    return Nj(n, {
      checksumAddress: t,
      length: a,
      parameter: {
        ...r,
        type: i
      }
    });
  }
  if (r.type === "tuple")
    return Lj(n, {
      checksumAddress: t,
      parameter: r
    });
  if (r.type === "address")
    return Uj(n, {
      checksum: t
    });
  if (r.type === "bool")
    return Fj(n);
  if (r.type.startsWith("uint") || r.type.startsWith("int")) {
    const a = r.type.startsWith("int"), [, , i = "256"] = e3.exec(r.type) ?? [];
    return Dj(n, {
      signed: a,
      size: Number(i)
    });
  }
  if (r.type.startsWith("bytes"))
    return Rj(n, { type: r.type });
  if (r.type === "string")
    return Mj(n);
  throw new r3(r.type);
}
function g1(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += $n(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(sl(e + s, { size: 32 })), r.push(o), s += $n(o)) : n.push(o);
  }
  return Es(...n, ...r);
}
function Uj(t, e) {
  const { checksum: n = !1 } = e;
  return fd(t, { strict: n }), {
    dynamic: !1,
    encoded: Qi(t.toLowerCase())
  };
}
function Nj(t, e) {
  const { checksumAddress: n, length: r, parameter: s } = e, a = r === null;
  if (!Array.isArray(t))
    throw new Gj(t);
  if (!a && t.length !== r)
    throw new _j({
      expectedLength: r,
      givenLength: t.length,
      type: `${s.type}[${r}]`
    });
  let i = !1;
  const o = [];
  for (let c = 0; c < t.length; c++) {
    const u = b1({
      checksumAddress: n,
      parameter: s,
      value: t[c]
    });
    u.dynamic && (i = !0), o.push(u);
  }
  if (a || i) {
    const c = g1(o);
    if (a) {
      const u = sl(o.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: o.length > 0 ? Es(u, c) : u
      };
    }
    if (i)
      return { dynamic: !0, encoded: c };
  }
  return {
    dynamic: !1,
    encoded: Es(...o.map(({ encoded: c }) => c))
  };
}
function Rj(t, { type: e }) {
  const [, n] = e.split("bytes"), r = $n(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = Ji(s, Math.ceil((t.length - 2) / 2 / 32) * 32)), {
      dynamic: !0,
      encoded: Es(Qi(sl(r, { size: 32 })), s)
    };
  }
  if (r !== Number.parseInt(n))
    throw new t3({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: Ji(t) };
}
function Fj(t) {
  if (typeof t != "boolean")
    throw new Ke(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: Qi(qv(t)) };
}
function Dj(t, { signed: e, size: n }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new Kv({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: sl(t, {
      size: 32,
      signed: e
    })
  };
}
function Mj(t) {
  const e = y1(t), n = Math.ceil($n(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(Ji(oh(e, s * 32, (s + 1) * 32)));
  return {
    dynamic: !0,
    encoded: Es(Ji(sl($n(e), { size: 32 })), ...r)
  };
}
function Lj(t, e) {
  const { checksumAddress: n, parameter: r } = e;
  let s = !1;
  const a = [];
  for (let i = 0; i < r.components.length; i++) {
    const o = r.components[i], c = Array.isArray(t) ? i : o.name, u = b1({
      checksumAddress: n,
      parameter: o,
      value: t[c]
    });
    a.push(u), u.dynamic && (s = !0);
  }
  return {
    dynamic: s,
    encoded: s ? g1(a) : Es(...a.map(({ encoded: i }) => i))
  };
}
function Hj(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function $j(t, e, n) {
  const { checksumAddress: r = !1 } = {};
  if (t.length !== e.length)
    throw new n3({
      expectedLength: t.length,
      givenLength: e.length
    });
  const s = Pj({
    checksumAddress: r,
    parameters: t,
    values: e
  }), a = g1(s);
  return a.length === 0 ? "0x" : a;
}
function mb(t, e) {
  if (t.length !== e.length)
    throw new n3({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r], a = e[r];
    n.push(mb.encode(s, a));
  }
  return Es(...n);
}
(function(t) {
  function e(n, r, s = !1) {
    if (n === "address") {
      const c = r;
      return fd(c), Qi(c.toLowerCase(), s ? 32 : 0);
    }
    if (n === "string")
      return y1(r);
    if (n === "bytes")
      return r;
    if (n === "bool")
      return Qi(qv(r), s ? 32 : 1);
    const a = n.match(e3);
    if (a) {
      const [c, u, l = "256"] = a, d = Number.parseInt(l) / 8;
      return sl(r, {
        size: s ? 32 : d,
        signed: u === "int"
      });
    }
    const i = n.match(Ij);
    if (i) {
      const [c, u] = i;
      if (Number.parseInt(u) !== (r.length - 2) / 2)
        throw new t3({
          expectedSize: Number.parseInt(u),
          value: r
        });
      return Ji(r, s ? 32 : 0);
    }
    const o = n.match(Bj);
    if (o && Array.isArray(r)) {
      const [c, u] = o, l = [];
      for (let d = 0; d < r.length; d++)
        l.push(e(u, r[d], !0));
      return l.length === 0 ? "0x" : Es(...l);
    }
    throw new r3(n);
  }
  t.encode = e;
})(mb || (mb = {}));
class _j extends Ke {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(`Array length mismatch for type \`${r}\`. Expected: \`${e}\`. Given: \`${n}\`.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}
class t3 extends Ke {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${$n(n)}) does not match expected size (bytes${e}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
}
class n3 extends Ke {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}
class Gj extends Ke {
  constructor(e) {
    super(`Value \`${e}\` is not a valid array.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidArrayError"
    });
  }
}
class r3 extends Ke {
  constructor(e) {
    super(`Type \`${e}\` is not a valid ABI Type.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}
function s3(t, ...e) {
  const { overloads: n } = t, r = n ? Vj([t, ...n], t.name, {
    args: e[0]
  }) : t, s = jj(r), a = e.length > 0 ? $j(r.inputs, e[0]) : void 0;
  return a ? Es(s, a) : s;
}
function zj(t, e = {}) {
  return Cj(t, e);
}
function Vj(t, e, n) {
  const r = Tj(t, e, n);
  if (r.type !== "function")
    throw new hb({ name: e, type: "function" });
  return r;
}
function jj(t) {
  return Yv(t);
}
class a3 extends zg {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, DI(e);
    const r = qp(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), $c(a);
  }
  update(e) {
    return Hc(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Hc(this), or(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const i3 = (t, e, n) => new a3(t, e).update(n).digest();
i3.create = (t, e) => new a3(t, e);
function qj(t) {
  const e = Hl(Vc(t.from)), n = Jv(Lx(t.salt) ? t.salt : Hl(t.salt), 32), r = "bytecodeHash" in t ? Lx(t.bytecodeHash) ? t.bytecodeHash : Hl(t.bytecodeHash) : Cu(t.bytecode, { as: "Bytes" });
  return Vc(oh(Cu(Qv(Hl("0xff"), e, n, r), { as: "Hex" }), 12));
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const w1 = /* @__PURE__ */ BigInt(0), yb = /* @__PURE__ */ BigInt(1);
function sp(t, e) {
  if (typeof e != "boolean")
    throw new Error(t + " boolean expected, got " + e);
}
function of(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function o3(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? w1 : BigInt("0x" + t);
}
function ch(t) {
  return o3(yu(t));
}
function c3(t) {
  return or(t), o3(yu(Uint8Array.from(t).reverse()));
}
function E1(t, e) {
  return Gg(t.toString(16).padStart(e * 2, "0"));
}
function l3(t, e) {
  return E1(t, e).reverse();
}
function Tn(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = Gg(e);
    } catch (a) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + a);
    }
  else if (_g(e))
    r = Uint8Array.from(e);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(t + " of length " + n + " expected, got " + s);
  return r;
}
const Sm = (t) => typeof t == "bigint" && w1 <= t;
function Kj(t, e, n) {
  return Sm(t) && Sm(e) && Sm(n) && e <= t && t < n;
}
function Wj(t, e, n, r) {
  if (!Kj(e, n, r))
    throw new Error("expected valid " + t + ": " + n + " <= n < " + r + ", got " + e);
}
function Qj(t) {
  let e;
  for (e = 0; t > w1; t >>= yb, e += 1)
    ;
  return e;
}
const lh = (t) => (yb << BigInt(t)) - yb;
function Jj(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (h) => new Uint8Array(h), s = (h) => Uint8Array.of(h);
  let a = r(t), i = r(t), o = 0;
  const c = () => {
    a.fill(1), i.fill(0), o = 0;
  }, u = (...h) => n(i, a, ...h), l = (h = r(0)) => {
    i = u(s(0), h), a = u(), h.length !== 0 && (i = u(s(1), h), a = u());
  }, d = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let h = 0;
    const b = [];
    for (; h < e; ) {
      a = u();
      const y = a.slice();
      b.push(y), h += a.length;
    }
    return _a(...b);
  };
  return (h, b) => {
    c(), l(h);
    let y;
    for (; !(y = b(d())); )
      l();
    return c(), y;
  };
}
function x1(t, e, n = {}) {
  if (!t || typeof t != "object")
    throw new Error("expected valid options object");
  function r(s, a, i) {
    const o = t[s];
    if (i && o === void 0)
      return;
    const c = typeof o;
    if (c !== a || o === null)
      throw new Error(`param "${s}" is invalid: expected ${a}, got ${c}`);
  }
  Object.entries(e).forEach(([s, a]) => r(s, a, !1)), Object.entries(n).forEach(([s, a]) => r(s, a, !0));
}
function $x(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const s = e.get(n);
    if (s !== void 0)
      return s;
    const a = t(n, ...r);
    return e.set(n, a), a;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yt = BigInt(0), qt = BigInt(1), za = /* @__PURE__ */ BigInt(2), Zj = /* @__PURE__ */ BigInt(3), u3 = /* @__PURE__ */ BigInt(4), d3 = /* @__PURE__ */ BigInt(5), f3 = /* @__PURE__ */ BigInt(8);
function Dn(t, e) {
  const n = t % e;
  return n >= Yt ? n : e + n;
}
function xn(t, e, n) {
  let r = t;
  for (; e-- > Yt; )
    r *= r, r %= n;
  return r;
}
function _x(t, e) {
  if (t === Yt)
    throw new Error("invert: expected non-zero number");
  if (e <= Yt)
    throw new Error("invert: expected positive modulus, got " + e);
  let n = Dn(t, e), r = e, s = Yt, a = qt;
  for (; n !== Yt; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== qt)
    throw new Error("invert: does not exist");
  return Dn(s, e);
}
function p3(t, e) {
  const n = (t.ORDER + qt) / u3, r = t.pow(e, n);
  if (!t.eql(t.sqr(r), e))
    throw new Error("Cannot find square root");
  return r;
}
function Xj(t, e) {
  const n = (t.ORDER - d3) / f3, r = t.mul(e, za), s = t.pow(r, n), a = t.mul(e, s), i = t.mul(t.mul(a, za), s), o = t.mul(a, t.sub(i, t.ONE));
  if (!t.eql(t.sqr(o), e))
    throw new Error("Cannot find square root");
  return o;
}
function Yj(t) {
  if (t < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let e = t - qt, n = 0;
  for (; e % za === Yt; )
    e /= za, n++;
  let r = za;
  const s = uh(t);
  for (; Gx(s, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return p3;
  let a = s.pow(r, e);
  const i = (e + qt) / za;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (Gx(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, d = c.mul(c.ONE, a), m = c.pow(u, e), h = c.pow(u, i);
    for (; !c.eql(m, c.ONE); ) {
      if (c.is0(m))
        return c.ZERO;
      let b = 1, y = c.sqr(m);
      for (; !c.eql(y, c.ONE); )
        if (b++, y = c.sqr(y), b === l)
          throw new Error("Cannot find square root");
      const g = qt << BigInt(l - b - 1), w = c.pow(d, g);
      l = b, d = c.sqr(w), m = c.mul(m, d), h = c.mul(h, w);
    }
    return h;
  };
}
function eq(t) {
  return t % u3 === Zj ? p3 : t % f3 === d3 ? Xj : Yj(t);
}
const tq = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function nq(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = tq.reduce((r, s) => (r[s] = "function", r), e);
  return x1(t, n), t;
}
function rq(t, e, n) {
  if (n < Yt)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === Yt)
    return t.ONE;
  if (n === qt)
    return e;
  let r = t.ONE, s = e;
  for (; n > Yt; )
    n & qt && (r = t.mul(r, s)), s = t.sqr(s), n >>= qt;
  return r;
}
function h3(t, e, n = !1) {
  const r = new Array(e.length).fill(n ? t.ZERO : void 0), s = e.reduce((i, o, c) => t.is0(o) ? i : (r[c] = i, t.mul(i, o)), t.ONE), a = t.inv(s);
  return e.reduceRight((i, o, c) => t.is0(o) ? i : (r[c] = t.mul(i, r[c]), t.mul(i, o)), a), r;
}
function Gx(t, e) {
  const n = (t.ORDER - qt) / za, r = t.pow(e, n), s = t.eql(r, t.ONE), a = t.eql(r, t.ZERO), i = t.eql(r, t.neg(t.ONE));
  if (!s && !a && !i)
    throw new Error("invalid Legendre symbol result");
  return s ? 1 : a ? 0 : -1;
}
function sq(t, e) {
  e !== void 0 && mu(e);
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function uh(t, e, n = !1, r = {}) {
  if (t <= Yt)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  let s, a;
  if (typeof e == "object" && e != null) {
    if (r.sqrt || n)
      throw new Error("cannot specify opts in two arguments");
    const l = e;
    l.BITS && (s = l.BITS), l.sqrt && (a = l.sqrt), typeof l.isLE == "boolean" && (n = l.isLE);
  } else
    typeof e == "number" && (s = e), r.sqrt && (a = r.sqrt);
  const { nBitLength: i, nByteLength: o } = sq(t, s);
  if (o > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let c;
  const u = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: o,
    MASK: lh(i),
    ZERO: Yt,
    ONE: qt,
    create: (l) => Dn(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof l);
      return Yt <= l && l < t;
    },
    is0: (l) => l === Yt,
    // is valid and invertible
    isValidNot0: (l) => !u.is0(l) && u.isValid(l),
    isOdd: (l) => (l & qt) === qt,
    neg: (l) => Dn(-l, t),
    eql: (l, d) => l === d,
    sqr: (l) => Dn(l * l, t),
    add: (l, d) => Dn(l + d, t),
    sub: (l, d) => Dn(l - d, t),
    mul: (l, d) => Dn(l * d, t),
    pow: (l, d) => rq(u, l, d),
    div: (l, d) => Dn(l * _x(d, t), t),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, d) => l + d,
    subN: (l, d) => l - d,
    mulN: (l, d) => l * d,
    inv: (l) => _x(l, t),
    sqrt: a || ((l) => (c || (c = eq(t)), c(u, l))),
    toBytes: (l) => n ? l3(l, o) : E1(l, o),
    fromBytes: (l) => {
      if (l.length !== o)
        throw new Error("Field.fromBytes: expected " + o + " bytes, got " + l.length);
      return n ? c3(l) : ch(l);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (l) => h3(u, l),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (l, d, m) => m ? d : l
  });
  return Object.freeze(u);
}
function m3(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function y3(t) {
  const e = m3(t);
  return e + Math.ceil(e / 2);
}
function aq(t, e, n = !1) {
  const r = t.length, s = m3(e), a = y3(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error("expected " + a + "-1024 bytes of input, got " + r);
  const i = n ? c3(t) : ch(t), o = Dn(i, e - qt) + qt;
  return n ? l3(o, s) : E1(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const jc = BigInt(0), Va = BigInt(1);
function Gl(t, e) {
  const n = e.negate();
  return t ? n : e;
}
function iq(t, e, n) {
  const r = (i) => i.pz, s = h3(t.Fp, n.map(r));
  return n.map((i, o) => i.toAffine(s[o])).map(t.fromAffine);
}
function b3(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Om(t, e) {
  b3(t, e);
  const n = Math.ceil(e / t) + 1, r = 2 ** (t - 1), s = 2 ** t, a = lh(t), i = BigInt(t);
  return { windows: n, windowSize: r, mask: a, maxNumber: s, shiftBy: i };
}
function zx(t, e, n) {
  const { windowSize: r, mask: s, maxNumber: a, shiftBy: i } = n;
  let o = Number(t & s), c = t >> i;
  o > r && (o -= a, c += Va);
  const u = e * r, l = u + Math.abs(o) - 1, d = o === 0, m = o < 0, h = e % 2 !== 0;
  return { nextN: c, offset: l, isZero: d, isNeg: m, isNegF: h, offsetF: u };
}
function oq(t, e) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((n, r) => {
    if (!(n instanceof e))
      throw new Error("invalid point at index " + r);
  });
}
function cq(t, e) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((n, r) => {
    if (!e.isValid(n))
      throw new Error("invalid scalar at index " + r);
  });
}
const Bm = /* @__PURE__ */ new WeakMap(), g3 = /* @__PURE__ */ new WeakMap();
function Im(t) {
  return g3.get(t) || 1;
}
function Vx(t) {
  if (t !== jc)
    throw new Error("invalid wNAF");
}
function lq(t, e) {
  return {
    constTimeNegate: Gl,
    hasPrecomputes(n) {
      return Im(n) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(n, r, s = t.ZERO) {
      let a = n;
      for (; r > jc; )
        r & Va && (s = s.add(a)), a = a.double(), r >>= Va;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(n, r) {
      const { windows: s, windowSize: a } = Om(r, e), i = [];
      let o = n, c = o;
      for (let u = 0; u < s; u++) {
        c = o, i.push(c);
        for (let l = 1; l < a; l++)
          c = c.add(o), i.push(c);
        o = c.double();
      }
      return i;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(n, r, s) {
      let a = t.ZERO, i = t.BASE;
      const o = Om(n, e);
      for (let c = 0; c < o.windows; c++) {
        const { nextN: u, offset: l, isZero: d, isNeg: m, isNegF: h, offsetF: b } = zx(s, c, o);
        s = u, d ? i = i.add(Gl(h, r[b])) : a = a.add(Gl(m, r[l]));
      }
      return Vx(s), { p: a, f: i };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(n, r, s, a = t.ZERO) {
      const i = Om(n, e);
      for (let o = 0; o < i.windows && s !== jc; o++) {
        const { nextN: c, offset: u, isZero: l, isNeg: d } = zx(s, o, i);
        if (s = c, !l) {
          const m = r[u];
          a = a.add(d ? m.negate() : m);
        }
      }
      return Vx(s), a;
    },
    getPrecomputes(n, r, s) {
      let a = Bm.get(r);
      return a || (a = this.precomputeWindow(r, n), n !== 1 && (typeof s == "function" && (a = s(a)), Bm.set(r, a))), a;
    },
    wNAFCached(n, r, s) {
      const a = Im(n);
      return this.wNAF(a, this.getPrecomputes(a, n, s), r);
    },
    wNAFCachedUnsafe(n, r, s, a) {
      const i = Im(n);
      return i === 1 ? this.unsafeLadder(n, r, a) : this.wNAFUnsafe(i, this.getPrecomputes(i, n, s), r, a);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(n, r) {
      b3(r, e), g3.set(n, r), Bm.delete(n);
    }
  };
}
function uq(t, e, n, r) {
  let s = e, a = t.ZERO, i = t.ZERO;
  for (; n > jc || r > jc; )
    n & Va && (a = a.add(s)), r & Va && (i = i.add(s)), s = s.double(), n >>= Va, r >>= Va;
  return { p1: a, p2: i };
}
function dq(t, e, n, r) {
  oq(n, t), cq(r, e);
  const s = n.length, a = r.length;
  if (s !== a)
    throw new Error("arrays of points and scalars must have equal length");
  const i = t.ZERO, o = Qj(BigInt(s));
  let c = 1;
  o > 12 ? c = o - 3 : o > 4 ? c = o - 2 : o > 0 && (c = 2);
  const u = lh(c), l = new Array(Number(u) + 1).fill(i), d = Math.floor((e.BITS - 1) / c) * c;
  let m = i;
  for (let h = d; h >= 0; h -= c) {
    l.fill(i);
    for (let y = 0; y < a; y++) {
      const g = r[y], w = Number(g >> BigInt(h) & u);
      l[w] = l[w].add(n[y]);
    }
    let b = i;
    for (let y = l.length - 1, g = i; y > 0; y--)
      g = g.add(l[y]), b = b.add(g);
    if (m = m.add(b), h !== 0)
      for (let y = 0; y < c; y++)
        m = m.double();
  }
  return m;
}
function jx(t, e) {
  if (e) {
    if (e.ORDER !== t)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return nq(e), e;
  } else
    return uh(t);
}
function fq(t, e, n = {}) {
  if (!e || typeof e != "object")
    throw new Error(`expected valid ${t} CURVE object`);
  for (const o of ["p", "n", "h"]) {
    const c = e[o];
    if (!(typeof c == "bigint" && c > jc))
      throw new Error(`CURVE.${o} must be positive bigint`);
  }
  const r = jx(e.p, n.Fp), s = jx(e.n, n.Fn), i = ["Gx", "Gy", "a", "b"];
  for (const o of i)
    if (!r.isValid(e[o]))
      throw new Error(`CURVE.${o} must be valid field element of CURVE.Fp`);
  return { Fp: r, Fn: s };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function qx(t) {
  t.lowS !== void 0 && sp("lowS", t.lowS), t.prehash !== void 0 && sp("prehash", t.prehash);
}
class pq extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Zr = {
  // asn.1 DER encoding utils
  Err: pq,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (t, e) => {
      const { Err: n } = Zr;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = e.length / 2, s = of(r);
      if (s.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const a = r > 127 ? of(s.length / 2 | 128) : "";
      return of(t) + a + s + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(t, e) {
      const { Err: n } = Zr;
      let r = 0;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length < 2 || e[r++] !== t)
        throw new n("tlv.decode: wrong tlv");
      const s = e[r++], a = !!(s & 128);
      let i = 0;
      if (!a)
        i = s;
      else {
        const c = s & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = e.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          i = i << 8 | l;
        if (r += c, i < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const o = e.subarray(r, r + i);
      if (o.length !== i)
        throw new n("tlv.decode: wrong value length");
      return { v: o, l: e.subarray(r + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(t) {
      const { Err: e } = Zr;
      if (t < zl)
        throw new e("integer: negative integers are not allowed");
      let n = of(t);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(t) {
      const { Err: e } = Zr;
      if (t[0] & 128)
        throw new e("invalid signature integer: negative");
      if (t[0] === 0 && !(t[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return ch(t);
    }
  },
  toSig(t) {
    const { Err: e, _int: n, _tlv: r } = Zr, s = Tn("signature", t), { v: a, l: i } = r.decode(48, s);
    if (i.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: o, l: c } = r.decode(2, a), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: n.decode(o), s: n.decode(u) };
  },
  hexFromSig(t) {
    const { _tlv: e, _int: n } = Zr, r = e.encode(2, n.encode(t.r)), s = e.encode(2, n.encode(t.s)), a = r + s;
    return e.encode(48, a);
  }
}, zl = BigInt(0), Vl = BigInt(1), hq = BigInt(2), cf = BigInt(3), mq = BigInt(4);
function yq(t, e, n) {
  function r(s) {
    const a = t.sqr(s), i = t.mul(a, s);
    return t.add(t.add(i, t.mul(s, e)), n);
  }
  return r;
}
function w3(t, e, n) {
  const { BYTES: r } = t;
  function s(a) {
    let i;
    if (typeof a == "bigint")
      i = a;
    else {
      let o = Tn("private key", a);
      if (e) {
        if (!e.includes(o.length * 2))
          throw new Error("invalid private key");
        const c = new Uint8Array(r);
        c.set(o, c.length - o.length), o = c;
      }
      try {
        i = t.fromBytes(o);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof a}`);
      }
    }
    if (n && (i = t.create(i)), !t.isValidNot0(i))
      throw new Error("invalid private key: out of range [1..N-1]");
    return i;
  }
  return s;
}
function bq(t, e = {}) {
  const { Fp: n, Fn: r } = fq("weierstrass", t, e), { h: s, n: a } = t;
  x1(e, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: i } = e;
  if (i && (!n.is0(t.a) || typeof i.beta != "bigint" || typeof i.splitScalar != "function"))
    throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function o() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function c(O, C, U) {
    const { x: P, y: D } = C.toAffine(), $ = n.toBytes(P);
    if (sp("isCompressed", U), U) {
      o();
      const K = !n.isOdd(D);
      return _a(E3(K), $);
    } else
      return _a(Uint8Array.of(4), $, n.toBytes(D));
  }
  function u(O) {
    or(O);
    const C = n.BYTES, U = C + 1, P = 2 * C + 1, D = O.length, $ = O[0], K = O.subarray(1);
    if (D === U && ($ === 2 || $ === 3)) {
      const F = n.fromBytes(K);
      if (!n.isValid(F))
        throw new Error("bad point: is not on curve, wrong x");
      const M = m(F);
      let V;
      try {
        V = n.sqrt(M);
      } catch (Y) {
        const Q = Y instanceof Error ? ": " + Y.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Q);
      }
      o();
      const z = n.isOdd(V);
      return ($ & 1) === 1 !== z && (V = n.neg(V)), { x: F, y: V };
    } else if (D === P && $ === 4) {
      const F = n.fromBytes(K.subarray(C * 0, C * 1)), M = n.fromBytes(K.subarray(C * 1, C * 2));
      if (!h(F, M))
        throw new Error("bad point: is not on curve");
      return { x: F, y: M };
    } else
      throw new Error(`bad point: got length ${D}, expected compressed=${U} or uncompressed=${P}`);
  }
  const l = e.toBytes || c, d = e.fromBytes || u, m = yq(n, t.a, t.b);
  function h(O, C) {
    const U = n.sqr(C), P = m(O);
    return n.eql(U, P);
  }
  if (!h(t.Gx, t.Gy))
    throw new Error("bad curve params: generator point");
  const b = n.mul(n.pow(t.a, cf), mq), y = n.mul(n.sqr(t.b), BigInt(27));
  if (n.is0(n.add(b, y)))
    throw new Error("bad curve params: a or b");
  function g(O, C, U = !1) {
    if (!n.isValid(C) || U && n.is0(C))
      throw new Error(`bad point coordinate ${O}`);
    return C;
  }
  function w(O) {
    if (!(O instanceof x))
      throw new Error("ProjectivePoint expected");
  }
  const v = $x((O, C) => {
    const { px: U, py: P, pz: D } = O;
    if (n.eql(D, n.ONE))
      return { x: U, y: P };
    const $ = O.is0();
    C == null && (C = $ ? n.ONE : n.inv(D));
    const K = n.mul(U, C), F = n.mul(P, C), M = n.mul(D, C);
    if ($)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(M, n.ONE))
      throw new Error("invZ was invalid");
    return { x: K, y: F };
  }), A = $x((O) => {
    if (O.is0()) {
      if (e.allowInfinityPoint && !n.is0(O.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: C, y: U } = O.toAffine();
    if (!n.isValid(C) || !n.isValid(U))
      throw new Error("bad point: x or y not field elements");
    if (!h(C, U))
      throw new Error("bad point: equation left != right");
    if (!O.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function B(O, C, U, P, D) {
    return U = new x(n.mul(U.px, O), U.py, U.pz), C = Gl(P, C), U = Gl(D, U), C.add(U);
  }
  class x {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(C, U, P) {
      this.px = g("x", C), this.py = g("y", U, !0), this.pz = g("z", P), Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(C) {
      const { x: U, y: P } = C || {};
      if (!C || !n.isValid(U) || !n.isValid(P))
        throw new Error("invalid affine point");
      if (C instanceof x)
        throw new Error("projective point not allowed");
      return n.is0(U) && n.is0(P) ? x.ZERO : new x(U, P, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(C) {
      return iq(x, "pz", C);
    }
    static fromBytes(C) {
      return or(C), x.fromHex(C);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(C) {
      const U = x.fromAffine(d(Tn("pointHex", C)));
      return U.assertValidity(), U;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(C) {
      const U = w3(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return x.BASE.multiply(U(C));
    }
    /** Multiscalar Multiplication */
    static msm(C, U) {
      return dq(x, r, C, U);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(C = 8, U = !0) {
      return I.setWindowSize(this, C), U || this.multiply(cf), this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(C) {
      this.precompute(C);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      A(this);
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(C);
    }
    /** Compare one point to another. */
    equals(C) {
      w(C);
      const { px: U, py: P, pz: D } = this, { px: $, py: K, pz: F } = C, M = n.eql(n.mul(U, F), n.mul($, D)), V = n.eql(n.mul(P, F), n.mul(K, D));
      return M && V;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new x(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: C, b: U } = t, P = n.mul(U, cf), { px: D, py: $, pz: K } = this;
      let F = n.ZERO, M = n.ZERO, V = n.ZERO, z = n.mul(D, D), X = n.mul($, $), Y = n.mul(K, K), Q = n.mul(D, $);
      return Q = n.add(Q, Q), V = n.mul(D, K), V = n.add(V, V), F = n.mul(C, V), M = n.mul(P, Y), M = n.add(F, M), F = n.sub(X, M), M = n.add(X, M), M = n.mul(F, M), F = n.mul(Q, F), V = n.mul(P, V), Y = n.mul(C, Y), Q = n.sub(z, Y), Q = n.mul(C, Q), Q = n.add(Q, V), V = n.add(z, z), z = n.add(V, z), z = n.add(z, Y), z = n.mul(z, Q), M = n.add(M, z), Y = n.mul($, K), Y = n.add(Y, Y), z = n.mul(Y, Q), F = n.sub(F, z), V = n.mul(Y, X), V = n.add(V, V), V = n.add(V, V), new x(F, M, V);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(C) {
      w(C);
      const { px: U, py: P, pz: D } = this, { px: $, py: K, pz: F } = C;
      let M = n.ZERO, V = n.ZERO, z = n.ZERO;
      const X = t.a, Y = n.mul(t.b, cf);
      let Q = n.mul(U, $), le = n.mul(P, K), Z = n.mul(D, F), ce = n.add(U, P), te = n.add($, K);
      ce = n.mul(ce, te), te = n.add(Q, le), ce = n.sub(ce, te), te = n.add(U, D);
      let ie = n.add($, F);
      return te = n.mul(te, ie), ie = n.add(Q, Z), te = n.sub(te, ie), ie = n.add(P, D), M = n.add(K, F), ie = n.mul(ie, M), M = n.add(le, Z), ie = n.sub(ie, M), z = n.mul(X, te), M = n.mul(Y, Z), z = n.add(M, z), M = n.sub(le, z), z = n.add(le, z), V = n.mul(M, z), le = n.add(Q, Q), le = n.add(le, Q), Z = n.mul(X, Z), te = n.mul(Y, te), le = n.add(le, Z), Z = n.sub(Q, Z), Z = n.mul(X, Z), te = n.add(te, Z), Q = n.mul(le, te), V = n.add(V, Q), Q = n.mul(ie, te), M = n.mul(ce, M), M = n.sub(M, Q), Q = n.mul(ce, le), z = n.mul(ie, z), z = n.add(z, Q), new x(M, V, z);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(x.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(C) {
      const { endo: U } = e;
      if (!r.isValidNot0(C))
        throw new Error("invalid scalar: out of range");
      let P, D;
      const $ = (K) => I.wNAFCached(this, K, x.normalizeZ);
      if (U) {
        const { k1neg: K, k1: F, k2neg: M, k2: V } = U.splitScalar(C), { p: z, f: X } = $(F), { p: Y, f: Q } = $(V);
        D = X.add(Q), P = B(U.beta, z, Y, K, M);
      } else {
        const { p: K, f: F } = $(C);
        P = K, D = F;
      }
      return x.normalizeZ([P, D])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(C) {
      const { endo: U } = e, P = this;
      if (!r.isValid(C))
        throw new Error("invalid scalar: out of range");
      if (C === zl || P.is0())
        return x.ZERO;
      if (C === Vl)
        return P;
      if (I.hasPrecomputes(this))
        return this.multiply(C);
      if (U) {
        const { k1neg: D, k1: $, k2neg: K, k2: F } = U.splitScalar(C), { p1: M, p2: V } = uq(x, P, $, F);
        return B(U.beta, M, V, D, K);
      } else
        return I.wNAFCachedUnsafe(P, C);
    }
    multiplyAndAddUnsafe(C, U, P) {
      const D = this.multiplyUnsafe(U).add(C.multiplyUnsafe(P));
      return D.is0() ? void 0 : D;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(C) {
      return v(this, C);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: C } = e;
      return s === Vl ? !0 : C ? C(x, this) : I.wNAFCachedUnsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: C } = e;
      return s === Vl ? this : C ? C(x, this) : this.multiplyUnsafe(s);
    }
    toBytes(C = !0) {
      return sp("isCompressed", C), this.assertValidity(), l(x, this, C);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(C = !0) {
      return this.toBytes(C);
    }
    toHex(C = !0) {
      return yu(this.toBytes(C));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  x.BASE = new x(t.Gx, t.Gy, n.ONE), x.ZERO = new x(n.ZERO, n.ONE, n.ZERO), x.Fp = n, x.Fn = r;
  const N = r.BITS, I = lq(x, e.endo ? Math.ceil(N / 2) : N);
  return x;
}
function E3(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function gq(t, e, n = {}) {
  x1(e, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const r = e.randomBytes || zI, s = e.hmac || ((P, ...D) => i3(e.hash, P, _a(...D))), { Fp: a, Fn: i } = t, { ORDER: o, BITS: c } = i;
  function u(P) {
    const D = o >> Vl;
    return P > D;
  }
  function l(P) {
    return u(P) ? i.neg(P) : P;
  }
  function d(P, D) {
    if (!i.isValidNot0(D))
      throw new Error(`invalid signature ${P}: out of range 1..CURVE.n`);
  }
  class m {
    constructor(D, $, K) {
      d("r", D), d("s", $), this.r = D, this.s = $, K != null && (this.recovery = K), Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(D) {
      const $ = i.BYTES, K = Tn("compactSignature", D, $ * 2);
      return new m(i.fromBytes(K.subarray(0, $)), i.fromBytes(K.subarray($, $ * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(D) {
      const { r: $, s: K } = Zr.toSig(Tn("DER", D));
      return new m($, K);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(D) {
      return new m(this.r, this.s, D);
    }
    // ProjPointType<bigint>
    recoverPublicKey(D) {
      const $ = a.ORDER, { r: K, s: F, recovery: M } = this;
      if (M == null || ![0, 1, 2, 3].includes(M))
        throw new Error("recovery id invalid");
      if (o * hq < $ && M > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const z = M === 2 || M === 3 ? K + o : K;
      if (!a.isValid(z))
        throw new Error("recovery id 2 or 3 invalid");
      const X = a.toBytes(z), Y = t.fromHex(_a(E3((M & 1) === 0), X)), Q = i.inv(z), le = A(Tn("msgHash", D)), Z = i.create(-le * Q), ce = i.create(F * Q), te = t.BASE.multiplyUnsafe(Z).add(Y.multiplyUnsafe(ce));
      if (te.is0())
        throw new Error("point at infinify");
      return te.assertValidity(), te;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return u(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new m(this.r, i.neg(this.s), this.recovery) : this;
    }
    toBytes(D) {
      if (D === "compact")
        return _a(i.toBytes(this.r), i.toBytes(this.s));
      if (D === "der")
        return Gg(Zr.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return yu(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return yu(this.toBytes("compact"));
    }
  }
  const h = w3(i, n.allowedPrivateKeyLengths, n.wrapPrivateKey), b = {
    isValidPrivateKey(P) {
      try {
        return h(P), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: h,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const P = o;
      return aq(r(y3(P)), P);
    },
    precompute(P = 8, D = t.BASE) {
      return D.precompute(P, !1);
    }
  };
  function y(P, D = !0) {
    return t.fromPrivateKey(P).toBytes(D);
  }
  function g(P) {
    if (typeof P == "bigint")
      return !1;
    if (P instanceof t)
      return !0;
    const $ = Tn("key", P).length, K = a.BYTES, F = K + 1, M = 2 * K + 1;
    if (!(n.allowedPrivateKeyLengths || i.BYTES === F))
      return $ === F || $ === M;
  }
  function w(P, D, $ = !0) {
    if (g(P) === !0)
      throw new Error("first arg must be private key");
    if (g(D) === !1)
      throw new Error("second arg must be public key");
    return t.fromHex(D).multiply(h(P)).toBytes($);
  }
  const v = e.bits2int || function(P) {
    if (P.length > 8192)
      throw new Error("input is too large");
    const D = ch(P), $ = P.length * 8 - c;
    return $ > 0 ? D >> BigInt($) : D;
  }, A = e.bits2int_modN || function(P) {
    return i.create(v(P));
  }, B = lh(c);
  function x(P) {
    return Wj("num < 2^" + c, P, zl, B), i.toBytes(P);
  }
  function N(P, D, $ = I) {
    if (["recovered", "canonical"].some((ce) => ce in $))
      throw new Error("sign() legacy options not supported");
    const { hash: K } = e;
    let { lowS: F, prehash: M, extraEntropy: V } = $;
    F == null && (F = !0), P = Tn("msgHash", P), qx($), M && (P = Tn("prehashed msgHash", K(P)));
    const z = A(P), X = h(D), Y = [x(X), x(z)];
    if (V != null && V !== !1) {
      const ce = V === !0 ? r(a.BYTES) : V;
      Y.push(Tn("extraEntropy", ce));
    }
    const Q = _a(...Y), le = z;
    function Z(ce) {
      const te = v(ce);
      if (!i.isValidNot0(te))
        return;
      const ie = i.inv(te), fe = t.BASE.multiply(te).toAffine(), he = i.create(fe.x);
      if (he === zl)
        return;
      const Ae = i.create(ie * i.create(le + he * X));
      if (Ae === zl)
        return;
      let $e = (fe.x === he ? 0 : 2) | Number(fe.y & Vl), tt = Ae;
      return F && u(Ae) && (tt = l(Ae), $e ^= 1), new m(he, tt, $e);
    }
    return { seed: Q, k2sig: Z };
  }
  const I = { lowS: e.lowS, prehash: !1 }, O = { lowS: e.lowS, prehash: !1 };
  function C(P, D, $ = I) {
    const { seed: K, k2sig: F } = N(P, D, $);
    return Jj(e.hash.outputLen, i.BYTES, s)(K, F);
  }
  t.BASE.precompute(8);
  function U(P, D, $, K = O) {
    const F = P;
    D = Tn("msgHash", D), $ = Tn("publicKey", $), qx(K);
    const { lowS: M, prehash: V, format: z } = K;
    if ("strict" in K)
      throw new Error("options.strict was renamed to lowS");
    if (z !== void 0 && !["compact", "der", "js"].includes(z))
      throw new Error('format must be "compact", "der" or "js"');
    const X = typeof F == "string" || _g(F), Y = !X && !z && typeof F == "object" && F !== null && typeof F.r == "bigint" && typeof F.s == "bigint";
    if (!X && !Y)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let Q, le;
    try {
      if (Y)
        if (z === void 0 || z === "js")
          Q = new m(F.r, F.s);
        else
          throw new Error("invalid format");
      if (X) {
        try {
          z !== "compact" && (Q = m.fromDER(F));
        } catch (tt) {
          if (!(tt instanceof Zr.Err))
            throw tt;
        }
        !Q && z !== "der" && (Q = m.fromCompact(F));
      }
      le = t.fromHex($);
    } catch {
      return !1;
    }
    if (!Q || M && Q.hasHighS())
      return !1;
    V && (D = e.hash(D));
    const { r: Z, s: ce } = Q, te = A(D), ie = i.inv(ce), fe = i.create(te * ie), he = i.create(Z * ie), Ae = t.BASE.multiplyUnsafe(fe).add(le.multiplyUnsafe(he));
    return Ae.is0() ? !1 : i.create(Ae.x) === Z;
  }
  return Object.freeze({
    getPublicKey: y,
    getSharedSecret: w,
    sign: C,
    verify: U,
    utils: b,
    Point: t,
    Signature: m
  });
}
function wq(t) {
  const e = {
    a: t.a,
    b: t.b,
    p: t.Fp.ORDER,
    n: t.n,
    h: t.h,
    Gx: t.Gx,
    Gy: t.Gy
  }, n = t.Fp, r = uh(e.n, t.nBitLength), s = {
    Fp: n,
    Fn: r,
    allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
    allowInfinityPoint: t.allowInfinityPoint,
    endo: t.endo,
    wrapPrivateKey: t.wrapPrivateKey,
    isTorsionFree: t.isTorsionFree,
    clearCofactor: t.clearCofactor,
    fromBytes: t.fromBytes,
    toBytes: t.toBytes
  };
  return { CURVE: e, curveOpts: s };
}
function Eq(t) {
  const { CURVE: e, curveOpts: n } = wq(t), r = {
    hash: t.hash,
    hmac: t.hmac,
    randomBytes: t.randomBytes,
    lowS: t.lowS,
    bits2int: t.bits2int,
    bits2int_modN: t.bits2int_modN
  };
  return { CURVE: e, curveOpts: n, ecdsaOpts: r };
}
function xq(t, e) {
  return Object.assign({}, e, {
    ProjectivePoint: e.Point,
    CURVE: t
  });
}
function Aq(t) {
  const { CURVE: e, curveOpts: n, ecdsaOpts: r } = Eq(t), s = bq(e, n), a = gq(s, r, n);
  return xq(t, a);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function kq(t, e) {
  const n = (r) => Aq({ ...t, hash: r });
  return { ...n(e), create: n };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ap = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const vq = BigInt(1), bb = BigInt(2), Kx = (t, e) => (t + e / bb) / e;
function Cq(t) {
  const e = ap.p, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = xn(l, n, e) * l % e, m = xn(d, n, e) * l % e, h = xn(m, bb, e) * u % e, b = xn(h, s, e) * h % e, y = xn(b, a, e) * b % e, g = xn(y, o, e) * y % e, w = xn(g, c, e) * g % e, v = xn(w, o, e) * y % e, A = xn(v, n, e) * l % e, B = xn(A, i, e) * b % e, x = xn(B, r, e) * u % e, N = xn(x, bb, e);
  if (!gb.eql(gb.sqr(N), t))
    throw new Error("Cannot find square root");
  return N;
}
const gb = uh(ap.p, void 0, void 0, { sqrt: Cq }), dh = kq({
  ...ap,
  Fp: gb,
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = ap.n, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -vq * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = Kx(a * t, e), c = Kx(-r * t, e);
      let u = Dn(t - o * n - c * s, e), l = Dn(-o * r - c * a, e);
      const d = u > i, m = l > i;
      if (d && (u = e - u), m && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: m, k2: l };
    }
  }
}, d8);
var PY = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tq(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function UY(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
function Sq(t, e, n) {
  var a, i;
  const r = t.find(
    (o) => {
      var c;
      return o.chainId === e.toString() && ((c = o.data) == null ? void 0 : c.address);
    }
  ), s = t.find(
    (o) => {
      var c;
      return o.chainId === n.toString() && ((c = o.data) == null ? void 0 : c.address);
    }
  );
  return {
    originAddress: (a = r == null ? void 0 : r.data) == null ? void 0 : a.address,
    destinationAddress: (i = s == null ? void 0 : s.data) == null ? void 0 : i.address
  };
}
function Oq(t, e) {
  return t.find(
    (r) => (r.type === "erc20-balance" || r.type === "native-balance") && r.chainId === (e == null ? void 0 : e.toString())
  ) ?? null;
}
async function Bq(t, e) {
  return t.getIntentCallsPayloads(e);
}
function wb(t, e) {
  console.log("[trails-sdk] calculateIntentAddress inputs:", {
    mainSigner: t,
    calls: JSON.stringify(e, null, 2)
  });
  const n = {
    factory: "0xBd0F8abD58B4449B39C57Ac9D5C67433239aC447",
    stage1: "0x53bA242E7C2501839DF2972c75075dc693176Cd0",
    creationCode: "0x603e600e3d39601e805130553df33d3d34601c57363d3d373d363d30545af43d82803e903d91601c57fd5bf3"
  }, r = e.map((a) => ({
    type: "call",
    chainId: a.chainId.toString(),
    space: a.space ? a.space.toString() : "0",
    nonce: a.nonce ? a.nonce.toString() : "0",
    calls: a.calls.map((i) => {
      var o, c;
      return {
        to: Vc(i.to),
        value: ((o = i.value) == null ? void 0 : o.toString()) || "0",
        data: Tf(vu(i.data || "0x")),
        gasLimit: ((c = i.gasLimit) == null ? void 0 : c.toString()) || "0",
        delegateCall: !!i.delegateCall,
        onlyFallback: !!i.onlyFallback,
        behaviorOnError: i.behaviorOnError
      };
    })
  })), s = Nq(
    Vc(t),
    r,
    n
  );
  return console.log(
    "[trails-sdk] Final calculated address:",
    s.toString()
  ), s;
}
function Iq(t, e) {
  var c, u;
  const n = (c = e[0]) == null ? void 0 : c.chainId, r = (u = e[1]) == null ? void 0 : u.chainId;
  console.log("[trails-sdk] originChainId:", n), console.log("[trails-sdk] destinationChainId:", r);
  const s = e.filter((l) => l.chainId === n), a = e.filter((l) => l.chainId === r);
  console.log("[trails-sdk] originCalls:", s), console.log("[trails-sdk] destinationCalls:", a);
  const i = wb(t, s), o = wb(
    t,
    a
  );
  return console.log("[trails-sdk] originIntentAddress:", i), console.log(
    "[trails-sdk] destinationIntentAddress:",
    o
  ), { originIntentAddress: i, destinationIntentAddress: o };
}
function Pq(t, e, n, r) {
  var l, d;
  console.log("[trails-sdk] commitIntentConfig inputs:", {
    mainSignerAddress: e,
    calls: JSON.stringify(n, null, 2),
    preconditions: JSON.stringify(r, null, 2)
  });
  const { originIntentAddress: s, destinationIntentAddress: a } = Iq(e, n);
  console.log(
    "[trails-sdk] originIntentAddress:",
    s.toString()
  ), console.log(
    "[trails-sdk] destinationIntentAddress:",
    a.toString()
  );
  const i = (l = n[0]) == null ? void 0 : l.chainId, o = (d = n[1]) == null ? void 0 : d.chainId, { originAddress: c } = i && o ? Sq(
    r,
    Number(i),
    Number(o)
  ) : { originAddress: void 0 };
  console.log("[trails-sdk] Address comparison:", {
    receivedAddress: c,
    calculatedAddress: s.toString(),
    match: c && z5(Vc(c), s)
  });
  const u = {
    originIntentAddress: s.toString(),
    destinationIntentAddress: a.toString(),
    mainSigner: e,
    calls: n,
    preconditions: r
  };
  return t.commitIntentConfig(u);
}
async function Eb(t, e, n) {
  const r = await e.getChainId();
  r.toString() !== n.chain.id.toString() && (console.log(
    "[trails-sdk] sendOriginTransaction: switching chain",
    "want:",
    n.chain.id,
    "current:",
    r
  ), await e.switchChain({ id: n.chain.id }), console.log(
    "[trails-sdk] sendOriginTransaction: switched chain to",
    n.chain.id
  )), console.log("[trails-sdk] sending origin tx"), console.time("[trails-sdk] sendTx");
  const s = await e.sendTransaction({
    account: t,
    to: n.to,
    data: n.data,
    value: BigInt(n.value),
    chain: n.chain
  });
  return console.timeEnd("[trails-sdk] sendTx"), s;
}
function Uq(t, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function Nq(t, e, n) {
  const r = Rq(t, e), s = Q5.hashConfiguration(r);
  return qj({
    from: n.factory,
    bytecodeHash: Cu(
      Qv(
        vu(n.creationCode),
        Jv(vu(n.stage1), 32)
      ),
      { as: "Bytes" }
    ),
    salt: s
  });
}
function Rq(t, e) {
  const n = {
    type: "signer",
    address: t,
    weight: 1n
  };
  console.log("[trails-sdk] mainSignerLeaf:", n);
  const r = e.map(
    (i) => {
      const o = J5.hash(
        Vc("0x0000000000000000000000000000000000000000"),
        BigInt(i.chainId),
        {
          type: "call",
          space: BigInt(i.space || 0),
          nonce: BigInt(i.nonce || 0),
          calls: i.calls.map((c) => {
            var u, l;
            return {
              type: "call",
              to: c.to,
              value: BigInt(((u = c.value) == null ? void 0 : u.toString()) || "0"),
              data: Tf(vu(c.data || "0x")),
              gasLimit: BigInt(((l = c.gasLimit) == null ? void 0 : l.toString()) || "0"),
              delegateCall: !!c.delegateCall,
              onlyFallback: !!c.onlyFallback,
              behaviorOnError: c.behaviorOnError === 0 ? "ignore" : c.behaviorOnError === 1 ? "revert" : "abort"
            };
          })
        }
      );
      return console.log("[trails-sdk] digest:", Tf(o)), {
        type: "any-address-subdigest",
        digest: Tf(o)
      };
    }
  );
  console.log("[trails-sdk] calls:", e), console.log("[trails-sdk] subdigestLeaves:", r);
  const s = [...r];
  if (s.length === 0)
    throw new Error(
      "Intent configuration must have at least one call or LiFi information."
    );
  let a;
  return s.length === 1 ? a = s[0] : a = Fq(s), console.log(
    "[trails-sdk] Topology:",
    JSON.stringify([n, a], Uq, 2)
  ), {
    threshold: 1n,
    checkpoint: 0n,
    topology: [n, a]
  };
}
function Fq(t) {
  if (t.length === 0)
    throw new Error("Cannot create a tree from empty members");
  if (t.length === 1)
    return t[0];
  let e = [...t];
  for (; e.length > 1; ) {
    const n = [];
    for (let r = 0; r < e.length; r += 2) {
      const s = e[r];
      if (r + 1 < e.length) {
        const a = e[r + 1];
        n.push([s, a]);
      } else
        n.push(s);
    }
    e = n;
  }
  return e[0];
}
function A1() {
  return Pe(dh.utils.randomPrivateKey());
}
function x3(t) {
  if (typeof t == "string") {
    if (!He(t, { strict: !1 }))
      throw new Ye({ address: t });
    return {
      address: t,
      type: "json-rpc"
    };
  }
  if (!He(t.address, { strict: !1 }))
    throw new Ye({ address: t.address });
  return {
    address: t.address,
    nonceManager: t.nonceManager,
    sign: t.sign,
    signAuthorization: t.signAuthorization,
    signMessage: t.signMessage,
    signTransaction: t.signTransaction,
    signTypedData: t.signTypedData,
    source: "custom",
    type: "local"
  };
}
function Dq(t) {
  const e = We(`0x${t.substring(4)}`).substring(26);
  return Kp(`0x${e}`);
}
function Mq({ r: t, s: e, to: n = "hex", v: r, yParity: s }) {
  const a = (() => {
    if (s === 0 || s === 1)
      return s;
    if (r && (r === 27n || r === 28n || r >= 35n))
      return r % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), i = `0x${new dh.Signature(Re(t), Re(e)).toCompactHex()}${a === 0 ? "1b" : "1c"}`;
  return n === "hex" ? i : nn(i);
}
let Lq = !1;
async function pd({ hash: t, privateKey: e, to: n = "object" }) {
  const { r, s, recovery: a } = dh.sign(t.slice(2), e.slice(2), { lowS: !0, extraEntropy: Lq }), i = {
    r: W(r, { size: 32 }),
    s: W(s, { size: 32 }),
    v: a ? 28n : 27n,
    yParity: a
  };
  return n === "bytes" || n === "hex" ? Mq({ ...i, to: n }) : i;
}
function Hq(t) {
  const { chainId: e, nonce: n, to: r } = t, s = t.contractAddress ?? t.address, a = We(_n([
    "0x05",
    Lr([
      e ? W(e) : "0x",
      s,
      n ? W(n) : "0x"
    ])
  ]));
  return r === "bytes" ? nn(a) : a;
}
async function $q(t) {
  const { chainId: e, nonce: n, privateKey: r, to: s = "object" } = t, a = t.contractAddress ?? t.address, i = await pd({
    hash: Hq({ address: a, chainId: e, nonce: n }),
    privateKey: r,
    to: s
  });
  return s === "object" ? {
    address: a,
    chainId: e,
    nonce: n,
    ...i
  } : i;
}
const _q = `Ethereum Signed Message:
`;
function Gq(t) {
  const e = typeof t == "string" ? hu(t) : typeof t.raw == "string" ? t.raw : It(t.raw), n = hu(`${_q}${Xe(e)}`);
  return rn([n, e]);
}
function zq(t, e) {
  return We(Gq(t), e);
}
async function Vq({ message: t, privateKey: e }) {
  return await pd({ hash: zq(t), privateKey: e, to: "hex" });
}
async function jq(t) {
  const { privateKey: e, transaction: n, serializer: r = Wg } = t, s = n.type === "eip4844" ? {
    ...n,
    sidecars: !1
  } : n, a = await pd({
    hash: We(r(s)),
    privateKey: e
  });
  return r(n, a);
}
class qq extends H {
  constructor({ domain: e }) {
    super(`Invalid domain "${el(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class Kq extends H {
  constructor({ primaryType: e, types: n }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(n))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class Wq extends H {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function Qq(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (c, u) => {
    const l = { ...u };
    for (const d of c) {
      const { name: m, type: h } = d;
      h === "address" && (l[m] = l[m].toLowerCase());
    }
    return l;
  }, i = s.EIP712Domain ? e ? a(s.EIP712Domain, e) : {} : {}, o = (() => {
    if (r !== "EIP712Domain")
      return a(s[r], n);
  })();
  return el({ domain: i, message: o, primaryType: r, types: s });
}
function A3(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (i, o) => {
    for (const c of i) {
      const { name: u, type: l } = c, d = o[u], m = l.match(Q8);
      if (m && (typeof d == "number" || typeof d == "bigint")) {
        const [y, g, w] = m;
        W(d, {
          signed: g === "int",
          size: Number.parseInt(w) / 8
        });
      }
      if (l === "address" && typeof d == "string" && !He(d))
        throw new Ye({ address: d });
      const h = l.match(uM);
      if (h) {
        const [y, g] = h;
        if (g && Xe(d) !== Number.parseInt(g))
          throw new dD({
            expectedSize: Number.parseInt(g),
            givenSize: Xe(d)
          });
      }
      const b = s[l];
      b && (Jq(l), a(b, d));
    }
  };
  if (s.EIP712Domain && e) {
    if (typeof e != "object")
      throw new qq({ domain: e });
    a(s.EIP712Domain, e);
  }
  if (r !== "EIP712Domain")
    if (s[r])
      a(s[r], n);
    else
      throw new Kq({ primaryType: r, types: s });
}
function k3({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    (typeof (t == null ? void 0 : t.chainId) == "number" || typeof (t == null ? void 0 : t.chainId) == "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function Jq(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new Wq({ type: t });
}
function v3(t) {
  const { domain: e = {}, message: n, primaryType: r } = t, s = {
    EIP712Domain: k3({ domain: e }),
    ...t.types
  };
  A3({
    domain: e,
    message: n,
    primaryType: r,
    types: s
  });
  const a = ["0x1901"];
  return e && a.push(Zq({
    domain: e,
    types: s
  })), r !== "EIP712Domain" && a.push(C3({
    data: n,
    primaryType: r,
    types: s
  })), We(rn(a));
}
function Zq({ domain: t, types: e }) {
  return C3({
    data: t,
    primaryType: "EIP712Domain",
    types: e
  });
}
function C3({ data: t, primaryType: e, types: n }) {
  const r = T3({
    data: t,
    primaryType: e,
    types: n
  });
  return We(r);
}
function T3({ data: t, primaryType: e, types: n }) {
  const r = [{ type: "bytes32" }], s = [Xq({ primaryType: e, types: n })];
  for (const a of n[e]) {
    const [i, o] = O3({
      types: n,
      name: a.name,
      type: a.type,
      value: t[a.name]
    });
    r.push(i), s.push(o);
  }
  return ma(r, s);
}
function Xq({ primaryType: t, types: e }) {
  const n = Pe(Yq({ primaryType: t, types: e }));
  return We(n);
}
function Yq({ primaryType: t, types: e }) {
  let n = "";
  const r = S3({ primaryType: t, types: e });
  r.delete(t);
  const s = [t, ...Array.from(r).sort()];
  for (const a of s)
    n += `${a}(${e[a].map(({ name: i, type: o }) => `${o} ${i}`).join(",")})`;
  return n;
}
function S3({ primaryType: t, types: e }, n = /* @__PURE__ */ new Set()) {
  const r = t.match(/^\w*/u), s = r == null ? void 0 : r[0];
  if (n.has(s) || e[s] === void 0)
    return n;
  n.add(s);
  for (const a of e[s])
    S3({ primaryType: a.type, types: e }, n);
  return n;
}
function O3({ types: t, name: e, type: n, value: r }) {
  if (t[n] !== void 0)
    return [
      { type: "bytes32" },
      We(T3({ data: r, primaryType: n, types: t }))
    ];
  if (n === "bytes")
    return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`, [{ type: "bytes32" }, We(r)];
  if (n === "string")
    return [{ type: "bytes32" }, We(Pe(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const s = n.slice(0, n.lastIndexOf("[")), a = r.map((i) => O3({
      name: e,
      type: s,
      types: t,
      value: i
    }));
    return [
      { type: "bytes32" },
      We(ma(a.map(([i]) => i), a.map(([, i]) => i)))
    ];
  }
  return [{ type: n }, r];
}
async function eK(t) {
  const { privateKey: e, ...n } = t;
  return await pd({
    hash: v3(n),
    privateKey: e,
    to: "hex"
  });
}
function Tu(t, e = {}) {
  const { nonceManager: n } = e, r = Pe(dh.getPublicKey(t.slice(2), !1)), s = Dq(r);
  return {
    ...x3({
      address: s,
      nonceManager: n,
      async sign({ hash: i }) {
        return pd({ hash: i, privateKey: t, to: "hex" });
      },
      async signAuthorization(i) {
        return $q({ ...i, privateKey: t });
      },
      async signMessage({ message: i }) {
        return Vq({ message: i, privateKey: t });
      },
      async signTransaction(i, { serializer: o } = {}) {
        return jq({ privateKey: t, transaction: i, serializer: o });
      },
      async signTypedData(i) {
        return eK({ ...i, privateKey: t });
      }
    }),
    publicKey: r,
    source: "privateKey"
  };
}
async function tK(t, { address: e, blockTag: n = "latest", blockNumber: r }) {
  const s = await t.request({
    method: "eth_getTransactionCount",
    params: [
      e,
      typeof r == "bigint" ? W(r) : n
    ]
  }, {
    dedupe: !!r
  });
  return va(s);
}
function nK(t) {
  const { source: e } = t, n = /* @__PURE__ */ new Map(), r = new jg(8192), s = /* @__PURE__ */ new Map(), a = ({ address: i, chainId: o }) => `${i}.${o}`;
  return {
    async consume({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o }), l = this.get({ address: i, chainId: o, client: c });
      this.increment({ address: i, chainId: o });
      const d = await l;
      return await e.set({ address: i, chainId: o }, d), r.set(u, d), d;
    },
    async increment({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o }), u = n.get(c) ?? 0;
      n.set(c, u + 1);
    },
    async get({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o });
      let l = s.get(u);
      return l || (l = (async () => {
        try {
          const m = await e.get({ address: i, chainId: o, client: c }), h = r.get(u) ?? 0;
          return h > 0 && m <= h ? h + 1 : (r.delete(u), m);
        } finally {
          this.reset({ address: i, chainId: o });
        }
      })(), s.set(u, l)), (n.get(u) ?? 0) + await l;
    },
    reset({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o });
      n.delete(c), s.delete(c);
    }
  };
}
async function ks({
  walletClient: t,
  desiredChainId: e
}) {
  try {
    let n = await t.getChainId();
    if (n === e) {
      console.log("[trails-sdk] Chain already switched to:", e);
      return;
    }
    if (console.log(
      "[trails-sdk] Switching to chain:",
      e,
      "currentChainId",
      n
    ), await t.switchChain({ id: e }), n = await t.getChainId(), n !== e)
      throw new Error("Failed to switch chain");
    console.log("[trails-sdk] Chain switched to:", e);
  } catch (n) {
    if (n instanceof Error && n.message.includes("wallet_addEthereumChain")) {
      const r = ws(e);
      if (r)
        return await t.addChain({
          chain: r
        }), ks({ walletClient: t, desiredChainId: e });
    }
    throw console.error("[trails-sdk] Chain switch failed:", n), new Error(
      `[trails-sdk] Failed to switch chain: ${n instanceof Error ? n.message : "Unknown error"}`
    );
  }
}
const rK = {
  [Ln.id]: 0,
  [Ta.id]: 0,
  [gs.id]: 1,
  [$i.id]: 1,
  [lr.id]: 2,
  [Vi.id]: 2,
  [cr.id]: 3,
  [Hi.id]: 3,
  [Hr.id]: 6,
  [_i.id]: 6,
  [ar.id]: 7,
  [ji.id]: 7,
  [qi.id]: 10,
  [od.id]: 10,
  [zi.id]: 11,
  [id.id]: 11,
  [Ki.id]: 14,
  [cd.id]: 14
}, B3 = {
  [Ln.id]: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  [Ta.id]: "0x1c7d4b196cb0c7b01d743fbc6116a902379c7238",
  [gs.id]: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  [$i.id]: "0x5425890298aed601595a70AB815c96711a31Bc65",
  [lr.id]: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
  [Vi.id]: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
  [cr.id]: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  [Hi.id]: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
  [Hr.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
  [_i.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  [ar.id]: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
  [ji.id]: "0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582",
  [qi.id]: "0x078D782b760474a361dDA0AF3839290b0EF57AD6",
  [od.id]: "0x31d0220469e10c4E71834a79b1f276d740d3768F",
  [zi.id]: "0x176211869cA2b568f2A7D4EE941E073a821EE1ff",
  [id.id]: "0xFEce4462D57bD51A6A552365A011b95f0E16d9B7",
  [Ki.id]: "0x79A02482A880bCe3F13E09da970dC34dB4cD24D1",
  [cd.id]: "0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88"
}, sK = {
  [Ln.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [Ta.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [gs.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [$i.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [lr.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [Vi.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [cr.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [Hi.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [Hr.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [_i.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [ar.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [ji.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [qi.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [od.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [zi.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [id.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA",
  [Ki.id]: "0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d",
  [cd.id]: "0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA"
}, aK = {
  [Ln.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [Ta.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [gs.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [$i.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [lr.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [Vi.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [cr.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [Hi.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [Hr.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [_i.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [ar.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [ji.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [qi.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [od.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [zi.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [id.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275",
  [Ki.id]: "0x81D40F21F12A8F0E3252Bccb954D722d4c464B64",
  [cd.id]: "0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275"
};
function Wx(t) {
  return rK[t] ?? null;
}
function iK(t) {
  return B3[t] ?? null;
}
function oK(t) {
  return sK[t] ?? null;
}
function cK(t) {
  return aK[t] ?? null;
}
async function lK({
  walletClient: t,
  originChain: e,
  destinationChain: n,
  amount: r
}) {
  var y, g;
  const s = iK(e.id), a = Wx(e.id), i = Wx(n.id), o = oK(e.id), c = (y = t.account) == null ? void 0 : y.address;
  if (!s || !a || !o || !i || !c)
    throw new Error("Invalid origin chain");
  const u = wa({
    chain: e,
    transport: ct()
  });
  await ks({
    walletClient: t,
    desiredChainId: e.id
  });
  const l = (g = t.account) == null ? void 0 : g.address;
  if (!l)
    throw new Error("No account found");
  if (await dK({
    publicClient: u,
    token: s,
    account: l,
    spender: o,
    amount: r
  })) {
    const w = await fK({
      walletClient: t,
      tokenAddress: s,
      spender: o,
      amount: L2,
      chain: e
    });
    console.log("waiting for approve", w), await u.waitForTransactionReceipt({
      hash: w
    }), console.log("approve done");
  }
  const m = uK(), h = await hK({
    walletClient: t,
    tokenMessenger: o,
    destinationDomain: i,
    destinationAddress: c,
    amount: r,
    burnToken: s,
    maxFee: m,
    chain: e
  });
  await u.waitForTransactionReceipt({
    hash: h
  });
  const b = await gK({
    domain: a,
    transactionHash: h
  });
  if (!b)
    throw new Error("Failed to retrieve attestation");
  return {
    attestation: b,
    txHash: h
  };
}
function uK() {
  return 500n;
}
async function dK({
  publicClient: t,
  token: e,
  account: n,
  spender: r,
  amount: s
}) {
  return await t.readContract({
    address: e,
    abi: Ju,
    functionName: "allowance",
    args: [vi(n), vi(r)]
  }) < s;
}
async function fK({
  walletClient: t,
  tokenAddress: e,
  spender: n,
  amount: r,
  chain: s
}) {
  var o;
  const a = await pK({
    tokenAddress: e,
    spender: n,
    amount: r
  });
  console.log("[trails-sdk] approving USDC transfer", a), await ks({
    walletClient: t,
    desiredChainId: s.id
  });
  const i = (o = t.account) == null ? void 0 : o.address;
  if (!i)
    throw new Error("No account found");
  return t.sendTransaction({
    ...a,
    account: i,
    chain: s
  });
}
async function pK({
  tokenAddress: t,
  spender: e,
  amount: n
}) {
  return console.log("[trails-sdk] get approve USDC transfer data", {
    tokenAddress: t,
    spender: e,
    amount: n
  }), {
    to: t,
    value: BigInt(0),
    data: mn({
      abi: [
        {
          type: "function",
          name: "approve",
          stateMutability: "nonpayable",
          inputs: [
            { name: "spender", type: "address" },
            { name: "amount", type: "uint256" }
          ],
          outputs: [{ name: "", type: "bool" }]
        }
      ],
      functionName: "approve",
      args: [e, n]
    })
  };
}
async function hK({
  walletClient: t,
  tokenMessenger: e,
  destinationDomain: n,
  destinationAddress: r,
  amount: s,
  burnToken: a,
  maxFee: i,
  chain: o
}) {
  var l;
  const c = await mK({
    tokenMessenger: e,
    destinationDomain: n,
    destinationAddress: r,
    amount: s,
    burnToken: a,
    maxFee: i
  });
  await ks({
    walletClient: t,
    desiredChainId: o.id
  });
  const u = (l = t.account) == null ? void 0 : l.address;
  if (!u)
    throw new Error("No account found");
  return t.sendTransaction({
    ...c,
    account: u,
    chain: o
  });
}
async function mK({
  tokenMessenger: t,
  destinationDomain: e,
  destinationAddress: n,
  amount: r,
  burnToken: s,
  maxFee: a
}) {
  console.log("[trails-sdk] get burn USDC data", {
    tokenMessenger: t,
    destinationDomain: e,
    destinationAddress: n,
    amount: r,
    burnToken: s,
    maxFee: a
  });
  const i = `0x000000000000000000000000${n.slice(2)}`;
  return {
    to: t,
    value: BigInt(0),
    data: mn({
      abi: [
        {
          type: "function",
          name: "depositForBurn",
          stateMutability: "nonpayable",
          inputs: [
            { name: "amount", type: "uint256" },
            { name: "destinationDomain", type: "uint32" },
            { name: "mintRecipient", type: "bytes32" },
            { name: "burnToken", type: "address" },
            { name: "destinationCaller", type: "bytes32" },
            { name: "maxFee", type: "uint256" },
            { name: "minFinalityThreshold", type: "uint32" }
          ],
          outputs: []
        }
      ],
      functionName: "depositForBurn",
      args: [
        r,
        e,
        i,
        s,
        "0x0000000000000000000000000000000000000000000000000000000000000000",
        a,
        1e3
        // minFinalityThreshold (1000 or less for Fast Transfer)
      ]
    })
  };
}
async function yK({
  domain: t,
  transactionHash: e
}) {
  var r, s;
  console.log("[trails-sdk] retrieving attestation", {
    domain: t,
    transactionHash: e
  });
  const n = `https://iris-api-sandbox.circle.com/v2/messages/${t}?transactionHash=${e}`;
  for (; ; )
    try {
      const a = await fetch(n), i = await a.json();
      if (a.status === 404 && console.log("[trails-sdk] waiting for attestation..."), ((s = (r = i == null ? void 0 : i.messages) == null ? void 0 : r[0]) == null ? void 0 : s.status) === "complete")
        return console.log("[trails-sdk] attestation retrieved successfully!"), i.messages[0];
      console.log("[trails-sdk] waiting for attestation..."), await new Promise((o) => setTimeout(o, 5e3));
    } catch (a) {
      console.error(
        "[trails-sdk] error fetching attestation:",
        a instanceof Error ? a.message : String(a)
      ), await new Promise((i) => setTimeout(i, 5e3));
    }
}
async function bK({
  tokenMessenger: t,
  attestation: e
}) {
  return console.log("[trails-sdk] get mint USDC data", {
    tokenMessenger: t,
    attestation: e
  }), {
    to: t,
    value: BigInt(0),
    data: mn({
      abi: [
        {
          type: "function",
          name: "receiveMessage",
          stateMutability: "nonpayable",
          inputs: [
            { name: "message", type: "bytes" },
            { name: "attestation", type: "bytes" }
          ],
          outputs: []
        }
      ],
      functionName: "receiveMessage",
      args: [e.message, e.attestation]
    })
  };
}
async function gK({
  domain: t,
  transactionHash: e
}) {
  for (; ; ) {
    const n = await yK({
      domain: t,
      transactionHash: e
    });
    if (n)
      return n;
    console.log("[trails-sdk] waiting for attestation..."), await new Promise((r) => setTimeout(r, 1e3));
  }
}
function Qx(t, e) {
  var n;
  return (t == null ? void 0 : t.toLowerCase()) === ((n = B3[e]) == null ? void 0 : n.toLowerCase());
}
function k1({
  recipient: t,
  amount: e
}) {
  const n = zj(
    "function transfer(address,uint256) returns (bool)"
  );
  return s3(n, [
    t,
    e
  ]);
}
function I3(t) {
  var n, r;
  const e = Object.values(Jp);
  for (const s of e)
    if (s.id === t)
      return `${(r = (n = s.blockExplorers) == null ? void 0 : n.default) == null ? void 0 : r.url}`;
  return "";
}
function wK({ txHash: t, chainId: e }) {
  return `${I3(e)}/tx/${t}`;
}
function NY({
  address: t,
  chainId: e
}) {
  return `${I3(e)}/address/${t}`;
}
const EK = {
  name: "permit",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "owner", type: "address" },
    { name: "spender", type: "address" },
    { name: "value", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "v", type: "uint8" },
    { name: "r", type: "bytes32" },
    { name: "s", type: "bytes32" }
  ],
  outputs: []
}, xK = {
  name: "transferFrom",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
}, AK = {
  name: "transfer",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
};
function v1(t) {
  const e = t.slice(2), n = `0x${e.slice(0, 64)}`, r = `0x${e.slice(64, 128)}`, s = parseInt(e.slice(128, 130), 16);
  return { r: n, s: r, v: s };
}
function P3({
  signer: t,
  spender: e,
  amount: n,
  deadline: r,
  signature: s
}) {
  const { r: a, s: i, v: o } = v1(s);
  return mn({
    abi: [EK],
    functionName: "permit",
    args: [t, e, n, r, o, a, i]
  });
}
function U3({
  signer: t,
  spender: e,
  amount: n
}) {
  return mn({
    abi: [xK],
    functionName: "transferFrom",
    args: [t, e, n]
  });
}
function N3({
  recipient: t,
  amount: e
}) {
  return mn({
    abi: [AK],
    functionName: "transfer",
    args: [t, e]
  });
}
function kK(t, e, n, r, s, a, i) {
  const o = P3({
    signer: t,
    spender: e,
    amount: n,
    deadline: r,
    signature: s
  }), c = U3({
    signer: t,
    spender: e,
    amount: n
  }), u = N3({ recipient: a, amount: n });
  return [o, c, u].map(
    (l) => ({
      to: i,
      data: l,
      value: "0"
    })
  );
}
async function C1({
  publicClient: t,
  walletClient: e,
  signer: n,
  spender: r,
  tokenAddress: s,
  amount: a,
  chain: i,
  deadline: o = BigInt(Math.floor(Date.now() / 1e3) + 3600)
  // 1 hour from now
}) {
  if (!e.account)
    throw new Error("No account found");
  const c = await t.readContract({
    address: s,
    abi: [
      {
        name: "nonces",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "owner", type: "address" }],
        outputs: [{ name: "", type: "uint256" }]
      }
    ],
    functionName: "nonces",
    args: [n]
  }), u = await t.readContract({
    address: s,
    abi: [
      {
        name: "name",
        type: "function",
        stateMutability: "view",
        inputs: [],
        outputs: [{ name: "", type: "string" }]
      }
    ],
    functionName: "name"
  });
  let l = "1";
  try {
    l = await t.readContract({
      address: s,
      abi: [
        {
          name: "version",
          type: "function",
          stateMutability: "view",
          inputs: [],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "version"
    });
  } catch {
    console.warn(
      "[trails-sdk] Token does not implement version(), defaulting to '1'"
    );
  }
  const d = {
    name: u,
    version: l,
    chainId: i.id,
    verifyingContract: s
  }, m = {
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  }, h = {
    owner: n,
    spender: r,
    value: a,
    nonce: c,
    deadline: o
  };
  await ks({
    walletClient: e,
    desiredChainId: i.id
  }), console.log("[trails-sdk] Requesting permit signature...");
  const b = await e.signTypedData({
    account: e.account,
    domain: d,
    types: m,
    primaryType: "Permit",
    message: h
  }), { v: y, r: g, s: w } = v1(b);
  return { signature: b, deadline: o, v: y, r: g, s: w };
}
function vK({
  user: t,
  token: e,
  amount: n,
  intentAddress: r,
  deadline: s,
  permitAmount: a,
  v: i,
  r: o,
  s: c,
  sigV: u,
  sigR: l,
  sigS: d
}) {
  const m = H2([
    "function depositToIntentWithPermit(address user, address token, uint256 amount, uint256 permitAmount, address intentAddress, uint256 deadline, uint8 v, bytes32 r, bytes32 s, uint8 sigV, bytes32 sigR, bytes32 sigS)"
  ]);
  return mn({
    abi: m,
    functionName: "depositToIntentWithPermit",
    args: [
      t,
      e,
      n,
      a,
      r,
      s,
      i,
      o,
      c,
      u,
      l,
      d
    ]
  });
}
function CK({
  user: t,
  token: e,
  amount: n,
  intentAddress: r,
  deadline: s,
  sigV: a,
  sigR: i,
  sigS: o
}) {
  const c = H2([
    "function depositToIntent(address user, address token, uint256 amount, address intentAddress, uint256 deadline, uint8 sigV, bytes32 sigR, bytes32 sigS)"
  ]);
  return mn({
    abi: c,
    functionName: "depositToIntent",
    args: [t, e, n, r, s, a, i, o]
  });
}
async function Jx({
  publicClient: t,
  walletClient: e,
  account: n,
  intentEntrypoint: r,
  depositTokenAddress: s,
  depositTokenAmount: a,
  depositRecipient: i,
  chain: o
}) {
  const c = L2, u = await TK({
    client: t,
    token: s,
    account: n.address,
    entrypoint: r,
    amount: BigInt(a)
  }), l = BigInt(Math.floor(Date.now() / 1e3) + 3600);
  let d = null;
  u && (d = await C1({
    publicClient: t,
    walletClient: e,
    signer: n.address,
    spender: r,
    tokenAddress: s,
    amount: c,
    chain: o,
    deadline: l
  }));
  const {
    v: m,
    r: h,
    s: b
  } = await SK({
    client: e,
    intentParams: {
      user: n.address,
      token: s,
      amount: BigInt(a),
      intentAddress: i,
      deadline: l,
      chainId: o.id,
      contractAddress: r
    }
  });
  let y = null;
  return d ? y = vK({
    user: n.address,
    token: s,
    amount: BigInt(a),
    permitAmount: c,
    intentAddress: i,
    deadline: l,
    v: d.v,
    r: d.r,
    s: d.s,
    sigV: m,
    sigR: h,
    sigS: b
  }) : y = CK({
    user: n.address,
    token: s,
    amount: BigInt(a),
    intentAddress: i,
    deadline: l,
    sigV: m,
    sigR: h,
    sigS: b
  }), [
    {
      to: r,
      data: y,
      value: "0"
    }
  ];
}
async function TK({
  client: t,
  token: e,
  account: n,
  entrypoint: r,
  amount: s
}) {
  return await t.readContract({
    address: e,
    abi: Ju,
    functionName: "allowance",
    args: [vi(n), vi(r)]
  }) < s;
}
async function SK({
  client: t,
  intentParams: e
}) {
  const {
    user: n,
    token: r,
    amount: s,
    intentAddress: a,
    deadline: i,
    chainId: o,
    contractAddress: c
  } = e, u = {
    name: "IntentEntrypoint",
    version: "1",
    chainId: o,
    verifyingContract: c
    //  This fixes the signature mismatch
  }, l = {
    Intent: [
      { name: "user", type: "address" },
      { name: "token", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "intentAddress", type: "address" },
      { name: "deadline", type: "uint256" }
    ]
  }, d = {
    user: vi(n),
    token: vi(r),
    amount: BigInt(s),
    intentAddress: vi(a),
    deadline: BigInt(i)
  }, m = await t.signTypedData({
    account: t.account,
    domain: u,
    types: l,
    primaryType: "Intent",
    message: d
  }), { v: h, r: b, s: y } = v1(m);
  return { signature: m, v: h, r: b, s: y };
}
const Zx = 3e3, OK = async (t, e, n) => t.status(e, BigInt(n)), RY = (t, e) => {
  const n = kT({
    queries: (t || []).map((s) => {
      const a = s.id;
      return {
        queryKey: ["metaTxnStatus", s.chainId, s.id],
        queryFn: async () => {
          const i = e(parseInt(s.chainId));
          if (!a)
            return {
              status: "failed",
              reason: "Missing operation hash for monitoring."
            };
          if (!i)
            return {
              status: "failed",
              reason: `Relayer not available for chain ${s.chainId}.`
            };
          const o = await i.status(
            a,
            BigInt(s.chainId)
          );
          let c;
          if (o.status === "confirmed")
            c = {
              status: "confirmed",
              transactionHash: o.transactionHash,
              data: o.data
            };
          else if (o.status === "failed")
            c = {
              status: "failed",
              reason: o.reason,
              data: o.data
            };
          else if (o.status === "pending")
            c = {
              status: "pending"
            };
          else if (o.status === "unknown")
            c = {
              status: "unknown"
            };
          else {
            const u = o.status;
            console.warn(
              `[trails-sdk]  Unexpected relayer status "${u}" for ${a}:`,
              o
            ), c = {
              status: "unknown"
            };
          }
          return c;
        },
        refetchInterval: (i) => {
          const o = i.state.data;
          return o && o.status === "confirmed" ? !1 : Zx;
        },
        enabled: !!s && !!s.id && !!s.chainId,
        retry: (i, o) => i >= 30 ? (console.error(
          `[trails-sdk]  Giving up on transaction ${a} after 3 failed API attempts:`,
          o
        ), !1) : !0
      };
    })
  });
  return Wu(() => {
    const s = {};
    return (t || []).forEach((a, i) => {
      var u;
      const o = `${a.chainId}-${a.id}`, c = n[i];
      c ? c.isLoading && c.fetchStatus !== "idle" && !c.data ? s[o] = {
        status: "pending"
      } : c.isError ? s[o] = {
        status: "failed",
        reason: ((u = c.error) == null ? void 0 : u.message) || "An unknown error occurred"
      } : c.data ? s[o] = c.data : s[o] = {
        status: "unknown"
      } : s[o] = {
        status: "failed",
        reason: "Query result unexpectedly missing"
      };
    }), s;
  }, [t, n]);
};
async function BK(t, e, n) {
  const { opHash: r } = await t.sendMetaTxn(
    e.walletAddress,
    e.contract,
    e.input,
    BigInt(e.chainId),
    void 0,
    n
  );
  return r;
}
const IK = "0.1.1";
function PK() {
  return IK;
}
class Su extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof Su) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof Su && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${PK()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return R3(this, e);
  }
}
function R3(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? R3(t.cause, e) : e ? null : t;
}
function UK(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new FK({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function Xr(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new RK({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? NK(c, r) : c;
}
function NK(t, e) {
  return UK(t, { dir: "left", size: e });
}
class RK extends Su {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class FK extends Su {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}
const Pm = "/docs/contract/decodeFunctionResult";
function F3(t) {
  const { abi: e, args: n, functionName: r, data: s } = t;
  let a = e[0];
  if (r) {
    const o = n1({ abi: e, args: n, name: r });
    if (!o)
      throw new Xf(r, { docsPath: Pm });
    a = o;
  }
  if (a.type !== "function")
    throw new Xf(void 0, { docsPath: Pm });
  if (!a.outputs)
    throw new lD(a.name, { docsPath: Pm });
  const i = J8(a.outputs, s);
  if (i && i.length > 1)
    return i;
  if (i && i.length === 1)
    return i[0];
}
const Xx = "/docs/contract/encodeFunctionData";
function DK(t) {
  const { abi: e, args: n, functionName: r } = t;
  let s = e[0];
  if (r) {
    const a = n1({
      abi: e,
      args: n,
      name: r
    });
    if (!a)
      throw new Xf(r, { docsPath: Xx });
    s = a;
  }
  if (s.type !== "function")
    throw new Xf(void 0, { docsPath: Xx });
  return {
    abi: [s],
    functionName: Xg(zc(s))
  };
}
function T1(t) {
  const { args: e } = t, { abi: n, functionName: r } = (() => {
    var o;
    return t.abi.length === 1 && ((o = t.functionName) != null && o.startsWith("0x")) ? t : DK(t);
  })(), s = n[0], a = r, i = "inputs" in s && s.inputs ? ma(s.inputs, e ?? []) : void 0;
  return _n([a, i ?? "0x"]);
}
const MK = 3;
function LK(t, { abi: e, address: n, args: r, docsPath: s, functionName: a, sender: i }) {
  const o = t instanceof sv ? t : t instanceof H ? t.walk((b) => "data" in b) || t.walk() : {}, { code: c, data: u, details: l, message: d, shortMessage: m } = o, h = t instanceof Zg ? new rv({ functionName: a }) : [MK, Qp.code].includes(c) && (u || l || d || m) ? new nv({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: a,
    message: o instanceof av ? l : m ?? d
  }) : t;
  return new tv(h, {
    abi: e,
    args: r,
    contractAddress: n,
    docsPath: s,
    functionName: a,
    sender: i
  });
}
function Ze(t, e, n) {
  const r = t[e.name];
  if (typeof r == "function")
    return r;
  const s = t[n];
  return typeof s == "function" ? s : (a) => e(t, a);
}
function HK(t) {
  return {
    address: t.address,
    amount: Xr(t.amount),
    index: Xr(t.index),
    validatorIndex: Xr(t.validatorIndex)
  };
}
function $K(t) {
  return {
    ...typeof t.baseFeePerGas == "bigint" && {
      baseFeePerGas: Xr(t.baseFeePerGas)
    },
    ...typeof t.blobBaseFee == "bigint" && {
      blobBaseFee: Xr(t.blobBaseFee)
    },
    ...typeof t.feeRecipient == "string" && {
      feeRecipient: t.feeRecipient
    },
    ...typeof t.gasLimit == "bigint" && {
      gasLimit: Xr(t.gasLimit)
    },
    ...typeof t.number == "bigint" && {
      number: Xr(t.number)
    },
    ...typeof t.prevRandao == "bigint" && {
      prevRandao: Xr(t.prevRandao)
    },
    ...typeof t.time == "bigint" && {
      time: Xr(t.time)
    },
    ...t.withdrawals && {
      withdrawals: t.withdrawals.map(HK)
    }
  };
}
const Yx = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], FY = [
  {
    name: "query",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "tuple[]",
        name: "queries",
        components: [
          {
            type: "address",
            name: "sender"
          },
          {
            type: "string[]",
            name: "urls"
          },
          {
            type: "bytes",
            name: "data"
          }
        ]
      }
    ],
    outputs: [
      {
        type: "bool[]",
        name: "failures"
      },
      {
        type: "bytes[]",
        name: "responses"
      }
    ]
  },
  {
    name: "HttpError",
    type: "error",
    inputs: [
      {
        type: "uint16",
        name: "status"
      },
      {
        type: "string",
        name: "message"
      }
    ]
  }
], _K = "0x82ad56cb", GK = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", zK = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", Um = "/docs/contract/encodeDeployData";
function D3(t) {
  const { abi: e, args: n, bytecode: r } = t;
  if (!n || n.length === 0)
    return r;
  const s = e.find((i) => "type" in i && i.type === "constructor");
  if (!s)
    throw new sD({ docsPath: Um });
  if (!("inputs" in s))
    throw new nx({ docsPath: Um });
  if (!s.inputs || s.inputs.length === 0)
    throw new nx({ docsPath: Um });
  const a = ma(s.inputs, n);
  return _n([r, a]);
}
function VK() {
  let t = () => {
  }, e = () => {
  };
  return { promise: new Promise((r, s) => {
    t = r, e = s;
  }), resolve: t, reject: e };
}
const Nm = /* @__PURE__ */ new Map();
function jK({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: s }) {
  const a = async () => {
    const l = c();
    i();
    const d = l.map(({ args: m }) => m);
    d.length !== 0 && t(d).then((m) => {
      s && Array.isArray(m) && m.sort(s);
      for (let h = 0; h < l.length; h++) {
        const { resolve: b } = l[h];
        b == null || b([m[h], m]);
      }
    }).catch((m) => {
      for (let h = 0; h < l.length; h++) {
        const { reject: b } = l[h];
        b == null || b(m);
      }
    });
  }, i = () => Nm.delete(e), o = () => c().map(({ args: l }) => l), c = () => Nm.get(e) || [], u = (l) => Nm.set(e, [...c(), l]);
  return {
    flush: i,
    async schedule(l) {
      const { promise: d, resolve: m, reject: h } = VK();
      return (n == null ? void 0 : n([...o(), l])) && a(), c().length > 0 ? (u({ args: l, resolve: m, reject: h }), d) : (u({ args: l, resolve: m, reject: h }), setTimeout(a, r), d);
    }
  };
}
function e2(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new jE({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new jE({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return e[n] = r, e;
    }, {});
}
function qK(t) {
  const { balance: e, nonce: n, state: r, stateDiff: s, code: a } = t, i = {};
  if (a !== void 0 && (i.code = a), e !== void 0 && (i.balance = W(e)), n !== void 0 && (i.nonce = W(n)), r !== void 0 && (i.state = e2(r)), s !== void 0) {
    if (i.state)
      throw new OM();
    i.stateDiff = e2(s);
  }
  return i;
}
function M3(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: n, ...r } of t) {
    if (!He(n, { strict: !1 }))
      throw new Ye({ address: n });
    if (e[n])
      throw new SM({ address: n });
    e[n] = qK(r);
  }
  return e;
}
async function L3(t, e) {
  var $, K, F, M;
  const { account: n = t.account, authorizationList: r, batch: s = !!(($ = t.batch) != null && $.multicall), blockNumber: a, blockTag: i = "latest", accessList: o, blobs: c, blockOverrides: u, code: l, data: d, factory: m, factoryData: h, gas: b, gasPrice: y, maxFeePerBlobGas: g, maxFeePerGas: w, maxPriorityFeePerGas: v, nonce: A, to: B, value: x, stateOverride: N, ...I } = e, O = n ? Hn(n) : void 0;
  if (l && (m || h))
    throw new H("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (l && B)
    throw new H("Cannot provide both `code` & `to` as parameters.");
  const C = l && d, U = m && h && B && d, P = C || U, D = C ? QK({
    code: l,
    data: d
  }) : U ? JK({
    data: d,
    factory: m,
    factoryData: h,
    to: B
  }) : d;
  try {
    cv(e);
    const z = (typeof a == "bigint" ? W(a) : void 0) || i, X = u ? $K(u) : void 0, Y = M3(N), Q = (M = (F = (K = t.chain) == null ? void 0 : K.formatters) == null ? void 0 : F.transactionRequest) == null ? void 0 : M.format, Z = (Q || Lg)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...ov(I, { format: Q }),
      from: O == null ? void 0 : O.address,
      accessList: o,
      authorizationList: r,
      blobs: c,
      data: D,
      gas: b,
      gasPrice: y,
      maxFeePerBlobGas: g,
      maxFeePerGas: w,
      maxPriorityFeePerGas: v,
      nonce: A,
      to: P ? void 0 : B,
      value: x
    });
    if (s && KK({ request: Z }) && !Y && !X)
      try {
        return await WK(t, {
          ...Z,
          blockNumber: a,
          blockTag: i
        });
      } catch (ie) {
        if (!(ie instanceof b8) && !(ie instanceof q0))
          throw ie;
      }
    const ce = (() => {
      const ie = [
        Z,
        z
      ];
      return Y && X ? [...ie, Y, X] : Y ? [...ie, Y] : X ? [...ie, {}, X] : ie;
    })(), te = await t.request({
      method: "eth_call",
      params: ce
    });
    return te === "0x" ? { data: void 0 } : { data: te };
  } catch (V) {
    const z = ZK(V), { offchainLookup: X, offchainLookupSignature: Y } = await import("./ccip-BEz0wM1T.js");
    if (t.ccipRead !== !1 && (z == null ? void 0 : z.slice(0, 10)) === Y && B)
      return { data: await X(t, { data: z, to: B }) };
    throw P && (z == null ? void 0 : z.slice(0, 10)) === "0x101bb98d" ? new UM({ factory: m }) : iv(V, {
      ...e,
      account: O,
      chain: t.chain
    });
  }
}
function KK({ request: t }) {
  const { data: e, to: n, ...r } = t;
  return !(!e || e.startsWith(_K) || !n || Object.values(r).filter((s) => typeof s < "u").length > 0);
}
async function WK(t, e) {
  var y;
  const { batchSize: n = 1024, wait: r = 0 } = typeof ((y = t.batch) == null ? void 0 : y.multicall) == "object" ? t.batch.multicall : {}, { blockNumber: s, blockTag: a = "latest", data: i, multicallAddress: o, to: c } = e;
  let u = o;
  if (!u) {
    if (!t.chain)
      throw new b8();
    u = iN({
      blockNumber: s,
      chain: t.chain,
      contract: "multicall3"
    });
  }
  const d = (typeof s == "bigint" ? W(s) : void 0) || a, { schedule: m } = jK({
    id: `${t.uid}.${d}`,
    wait: r,
    shouldSplitBatch(g) {
      return g.reduce((v, { data: A }) => v + (A.length - 2), 0) > n * 2;
    },
    fn: async (g) => {
      const w = g.map((B) => ({
        allowFailure: !0,
        callData: B.data,
        target: B.to
      })), v = T1({
        abi: Yx,
        args: [w],
        functionName: "aggregate3"
      }), A = await t.request({
        method: "eth_call",
        params: [
          {
            data: v,
            to: u
          },
          d
        ]
      });
      return F3({
        abi: Yx,
        args: [w],
        functionName: "aggregate3",
        data: A || "0x"
      });
    }
  }), [{ returnData: h, success: b }] = await m({ data: i, to: c });
  if (!b)
    throw new sv({ data: h });
  return h === "0x" ? { data: void 0 } : { data: h };
}
function QK(t) {
  const { code: e, data: n } = t;
  return D3({
    abi: Wp(["constructor(bytes, bytes)"]),
    bytecode: GK,
    args: [e, n]
  });
}
function JK(t) {
  const { data: e, factory: n, factoryData: r, to: s } = t;
  return D3({
    abi: Wp(["constructor(address, bytes, address, bytes)"]),
    bytecode: zK,
    args: [s, e, n, r]
  });
}
function ZK(t) {
  var n;
  if (!(t instanceof H))
    return;
  const e = t.walk();
  return typeof (e == null ? void 0 : e.data) == "object" ? (n = e.data) == null ? void 0 : n.data : e.data;
}
async function H3(t, e) {
  const { abi: n, address: r, args: s, functionName: a, ...i } = e, o = T1({
    abi: n,
    args: s,
    functionName: a
  });
  try {
    const { data: c } = await Ze(t, L3, "call")({
      ...i,
      data: o,
      to: r
    });
    return F3({
      abi: n,
      args: s,
      functionName: a,
      data: c || "0x"
    });
  } catch (c) {
    throw LK(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/readContract",
      functionName: a
    });
  }
}
const t2 = [
  {
    inputs: [
      { name: "success", type: "bool" },
      { name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" },
      { name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "factory",
        type: "address"
      },
      {
        indexed: !1,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: !1, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !0,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      { indexed: !1, name: "success", type: "bool" },
      {
        indexed: !1,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint256" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint256" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "gasFees", type: "bytes32" },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
function $3(t) {
  const { authorization: e, factory: n, factoryData: r } = t;
  if (n === "0x7702" || n === "0x7702000000000000000000000000000000000000") {
    if (!e)
      return "0x7702000000000000000000000000000000000000";
    const s = e.address;
    return rn([s, r ?? "0x"]);
  }
  return n ? rn([n, r ?? "0x"]) : "0x";
}
async function n2(t) {
  return new Promise((e) => setTimeout(e, t));
}
function XK(t, e) {
  if (!He(t, { strict: !1 }))
    throw new Ye({ address: t });
  if (!He(e, { strict: !1 }))
    throw new Ye({ address: e });
  return t.toLowerCase() === e.toLowerCase();
}
const YK = "0x6492649264926492649264926492649264926492649264926492649264926492";
function Rm(t) {
  const { address: e, data: n, signature: r, to: s = "hex" } = t, a = _n([
    ma([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [e, n, r]),
    YK
  ]);
  return s === "hex" ? a : nn(a);
}
function _3(t) {
  const { callGasLimit: e, callData: n, maxPriorityFeePerGas: r, maxFeePerGas: s, paymaster: a, paymasterData: i, paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, sender: u, signature: l = "0x", verificationGasLimit: d } = t, m = rn([
    vt(W(d || 0n), { size: 16 }),
    vt(W(e || 0n), { size: 16 })
  ]), h = $3(t), b = rn([
    vt(W(r || 0n), { size: 16 }),
    vt(W(s || 0n), { size: 16 })
  ]), y = t.nonce ?? 0n, g = a ? rn([
    a,
    vt(W(c || 0n), {
      size: 16
    }),
    vt(W(o || 0n), {
      size: 16
    }),
    i || "0x"
  ]) : "0x", w = t.preVerificationGas ?? 0n;
  return {
    accountGasLimits: m,
    callData: n,
    initCode: h,
    gasFees: b,
    nonce: y,
    paymasterAndData: g,
    preVerificationGas: w,
    sender: u,
    signature: l
  };
}
const eW = {
  PackedUserOperation: [
    { type: "address", name: "sender" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "bytes32", name: "accountGasLimits" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "bytes32", name: "gasFees" },
    { type: "bytes", name: "paymasterAndData" }
  ]
};
function tW(t) {
  const { chainId: e, entryPointAddress: n, userOperation: r } = t, s = _3(r);
  return {
    types: eW,
    primaryType: "PackedUserOperation",
    domain: {
      name: "ERC4337",
      version: "1",
      chainId: e,
      verifyingContract: n
    },
    message: s
  };
}
function nW(t) {
  const { chainId: e, entryPointAddress: n, entryPointVersion: r } = t, s = t.userOperation, { authorization: a, callData: i = "0x", callGasLimit: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymasterAndData: d = "0x", preVerificationGas: m, sender: h, verificationGasLimit: b } = s;
  if (r === "0.8")
    return v3(tW({
      chainId: e,
      entryPointAddress: n,
      userOperation: s
    }));
  const y = (() => {
    var g, w;
    if (r === "0.6") {
      const v = (g = s.initCode) == null ? void 0 : g.slice(0, 42), A = (w = s.initCode) == null ? void 0 : w.slice(42), B = $3({
        authorization: a,
        factory: v,
        factoryData: A
      });
      return ma([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        h,
        l,
        We(B),
        We(i),
        o,
        b,
        m,
        c,
        u,
        We(d)
      ]);
    }
    if (r === "0.7") {
      const v = _3(s);
      return ma([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        v.sender,
        v.nonce,
        We(v.initCode),
        We(v.callData),
        v.accountGasLimits,
        v.preVerificationGas,
        v.gasFees,
        We(v.paymasterAndData)
      ]);
    }
    throw new Error(`entryPointVersion "${r}" not supported.`);
  })();
  return We(ma([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [We(y), n, BigInt(e)]));
}
async function rW(t, { address: e, blockNumber: n, blockTag: r = "latest" }) {
  const s = n !== void 0 ? W(n) : void 0, a = await t.request({
    method: "eth_getCode",
    params: [e, s || r]
  }, { dedupe: !!s });
  if (a !== "0x")
    return a;
}
async function sW(t) {
  const { extend: e, nonceKeyManager: n = nK({
    source: {
      get() {
        return Date.now();
      },
      set() {
      }
    }
  }), ...r } = t;
  let s = !1;
  const a = await t.getAddress();
  return {
    ...e,
    ...r,
    address: a,
    async getFactoryArgs() {
      return "isDeployed" in this && await this.isDeployed() ? { factory: void 0, factoryData: void 0 } : t.getFactoryArgs();
    },
    async getNonce(i) {
      const o = (i == null ? void 0 : i.key) ?? BigInt(await n.consume({
        address: a,
        chainId: t.client.chain.id,
        client: t.client
      }));
      return t.getNonce ? await t.getNonce({ ...i, key: o }) : await H3(t.client, {
        abi: Wp([
          "function getNonce(address, uint192) pure returns (uint256)"
        ]),
        address: t.entryPoint.address,
        functionName: "getNonce",
        args: [a, o]
      });
    },
    async isDeployed() {
      return s ? !0 : (s = !!await Ze(t.client, rW, "getCode")({
        address: a
      }), s);
    },
    ...t.sign ? {
      async sign(i) {
        const [{ factory: o, factoryData: c }, u] = await Promise.all([
          this.getFactoryArgs(),
          t.sign(i)
        ]);
        return o && c ? Rm({
          address: o,
          data: c,
          signature: u
        }) : u;
      }
    } : {},
    async signMessage(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signMessage(i)
      ]);
      return o && c && o !== "0x7702" ? Rm({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    async signTypedData(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signTypedData(i)
      ]);
      return o && c && o !== "0x7702" ? Rm({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    type: "smart"
  };
}
async function aW(t, { account: e = t.account, message: n }) {
  if (!e)
    throw new no({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const r = Hn(e);
  if (r.signMessage)
    return r.signMessage({ message: n });
  const s = typeof n == "string" ? hu(n) : n.raw instanceof Uint8Array ? Pe(n.raw) : n.raw;
  return t.request({
    method: "personal_sign",
    params: [s, r.address]
  }, { retryCount: 0 });
}
async function iW(t, e) {
  const { account: n = t.account, domain: r, message: s, primaryType: a } = e;
  if (!n)
    throw new no({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const i = Hn(n), o = {
    EIP712Domain: k3({ domain: r }),
    ...e.types
  };
  if (A3({ domain: r, message: s, primaryType: a, types: o }), i.signTypedData)
    return i.signTypedData({ domain: r, message: s, primaryType: a, types: o });
  const c = Qq({ domain: r, message: s, primaryType: a, types: o });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [i.address, c]
  }, { retryCount: 0 });
}
class xb extends H {
  constructor({ cause: e }) {
    super("Smart Account is not deployed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.",
        "- An incorrect `sender` address is provided."
      ],
      name: "AccountNotDeployedError"
    });
  }
}
Object.defineProperty(xb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa20/
});
class qc extends H {
  constructor({ cause: e, data: n, message: r } = {}) {
    var a;
    const s = (a = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : a.replace("execution reverted", "");
    super(`Execution reverted ${s ? `with reason: ${s}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n;
  }
}
Object.defineProperty(qc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32521
});
Object.defineProperty(qc, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Ab extends H {
  constructor({ cause: e }) {
    super("Failed to send funds to beneficiary.", {
      cause: e,
      name: "FailedToSendToBeneficiaryError"
    });
  }
}
Object.defineProperty(Ab, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa91/
});
class kb extends H {
  constructor({ cause: e }) {
    super("Gas value overflowed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- one of the gas values exceeded 2**120 (uint120)"
      ].filter(Boolean),
      name: "GasValuesOverflowError"
    });
  }
}
Object.defineProperty(kb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa94/
});
class vb extends H {
  constructor({ cause: e }) {
    super("The `handleOps` function was called by the Bundler with a gas limit too low.", {
      cause: e,
      name: "HandleOpsOutOfGasError"
    });
  }
}
Object.defineProperty(vb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa95/
});
class Cb extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Failed to simulate deployment for Smart Account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- Invalid `factory`/`factoryData` or `initCode` properties are present",
        "- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)",
        `- Smart Account deployment execution reverted with an error
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeFailedError"
    });
  }
}
Object.defineProperty(Cb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa13/
});
class Tb extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account initialization implementation did not create an account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- `factory`/`factoryData` or `initCode` properties are invalid",
        `- Smart Account initialization implementation is incorrect
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeMustCreateSenderError"
    });
  }
}
Object.defineProperty(Tb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa15/
});
class Sb extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s, sender: a }) {
    super("Smart Account initialization implementation does not return the expected sender.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        `Smart Account initialization implementation does not return a sender address
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`,
        a && `sender: ${a}`
      ].filter(Boolean),
      name: "InitCodeMustReturnSenderError"
    });
  }
}
Object.defineProperty(Sb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa14/
});
class Ob extends H {
  constructor({ cause: e }) {
    super("Smart Account does not have sufficient funds to execute the User Operation.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Smart Account does not have sufficient funds to cover the required prefund, or",
        "- a Paymaster was not provided"
      ].filter(Boolean),
      name: "InsufficientPrefundError"
    });
  }
}
Object.defineProperty(Ob, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa21/
});
class Bb extends H {
  constructor({ cause: e }) {
    super("Bundler attempted to call an invalid function on the EntryPoint.", {
      cause: e,
      name: "InternalCallOnlyError"
    });
  }
}
Object.defineProperty(Bb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa92/
});
class Ib extends H {
  constructor({ cause: e }) {
    super("Bundler used an invalid aggregator for handling aggregated User Operations.", {
      cause: e,
      name: "InvalidAggregatorError"
    });
  }
}
Object.defineProperty(Ib, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa96/
});
class Pb extends H {
  constructor({ cause: e, nonce: n }) {
    super("Invalid Smart Account nonce used for User Operation.", {
      cause: e,
      metaMessages: [n && `nonce: ${n}`].filter(Boolean),
      name: "InvalidAccountNonceError"
    });
  }
}
Object.defineProperty(Pb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa25/
});
class Ub extends H {
  constructor({ cause: e }) {
    super("Bundler has not set a beneficiary address.", {
      cause: e,
      name: "InvalidBeneficiaryError"
    });
  }
}
Object.defineProperty(Ub, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa90/
});
class ip extends H {
  constructor({ cause: e }) {
    super("Invalid fields set on User Operation.", {
      cause: e,
      name: "InvalidFieldsError"
    });
  }
}
Object.defineProperty(ip, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class Nb extends H {
  constructor({ cause: e, paymasterAndData: n }) {
    super("Paymaster properties provided are invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `paymasterAndData` property is of an incorrect length\n",
        n && `paymasterAndData: ${n}`
      ].filter(Boolean),
      name: "InvalidPaymasterAndDataError"
    });
  }
}
Object.defineProperty(Nb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa93/
});
class ja extends H {
  constructor({ cause: e }) {
    super("Paymaster deposit for the User Operation is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Paymaster has deposited less than the expected amount via the `deposit` function"
      ].filter(Boolean),
      name: "PaymasterDepositTooLowError"
    });
  }
}
Object.defineProperty(ja, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32508
});
Object.defineProperty(ja, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa31/
});
class Rb extends H {
  constructor({ cause: e }) {
    super("The `validatePaymasterUserOp` function on the Paymaster reverted.", {
      cause: e,
      name: "PaymasterFunctionRevertedError"
    });
  }
}
Object.defineProperty(Rb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa33/
});
class Fb extends H {
  constructor({ cause: e }) {
    super("The Paymaster contract has not been deployed.", {
      cause: e,
      name: "PaymasterNotDeployedError"
    });
  }
}
Object.defineProperty(Fb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa30/
});
class op extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterRateLimitError"
    });
  }
}
Object.defineProperty(op, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32504
});
class cp extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterStakeTooLowError"
    });
  }
}
Object.defineProperty(cp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32505
});
class Db extends H {
  constructor({ cause: e }) {
    super("Paymaster `postOp` function reverted.", {
      cause: e,
      name: "PaymasterPostOpFunctionRevertedError"
    });
  }
}
Object.defineProperty(Db, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa50/
});
class Mb extends H {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account has already been deployed.", {
      cause: e,
      metaMessages: [
        "Remove the following properties and try again:",
        n && "`factory`",
        r && "`factoryData`",
        s && "`initCode`"
      ].filter(Boolean),
      name: "SenderAlreadyConstructedError"
    });
  }
}
Object.defineProperty(Mb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa10/
});
class lp extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).", {
      cause: e,
      name: "SignatureCheckFailedError"
    });
  }
}
Object.defineProperty(lp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32507
});
class Lb extends H {
  constructor({ cause: e }) {
    super("The `validateUserOp` function on the Smart Account reverted.", {
      cause: e,
      name: "SmartAccountFunctionRevertedError"
    });
  }
}
Object.defineProperty(Lb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa23/
});
class up extends H {
  constructor({ cause: e }) {
    super("UserOperation rejected because account specified unsupported signature aggregator.", {
      cause: e,
      name: "UnsupportedSignatureAggregatorError"
    });
  }
}
Object.defineProperty(up, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32506
});
class Hb extends H {
  constructor({ cause: e }) {
    super("User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied"
      ].filter(Boolean),
      name: "UserOperationExpiredError"
    });
  }
}
Object.defineProperty(Hb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa22/
});
class $b extends H {
  constructor({ cause: e }) {
    super("Paymaster for User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied"
      ].filter(Boolean),
      name: "UserOperationPaymasterExpiredError"
    });
  }
}
Object.defineProperty($b, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa32/
});
class _b extends H {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account"
      ].filter(Boolean),
      name: "UserOperationSignatureError"
    });
  }
}
Object.defineProperty(_b, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa24/
});
class Gb extends H {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster"
      ].filter(Boolean),
      name: "UserOperationPaymasterSignatureError"
    });
  }
}
Object.defineProperty(Gb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa34/
});
class dp extends H {
  constructor({ cause: e }) {
    super("User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.", {
      cause: e,
      name: "UserOperationRejectedByEntryPointError"
    });
  }
}
Object.defineProperty(dp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32500
});
class fp extends H {
  constructor({ cause: e }) {
    super("User Operation rejected by Paymaster's `validatePaymasterUserOp`.", {
      cause: e,
      name: "UserOperationRejectedByPaymasterError"
    });
  }
}
Object.defineProperty(fp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32501
});
class pp extends H {
  constructor({ cause: e }) {
    super("User Operation rejected with op code validation error.", {
      cause: e,
      name: "UserOperationRejectedByOpCodeError"
    });
  }
}
Object.defineProperty(pp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32502
});
class hp extends H {
  constructor({ cause: e }) {
    super("UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).", {
      cause: e,
      name: "UserOperationOutOfTimeRangeError"
    });
  }
}
Object.defineProperty(hp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32503
});
class oW extends H {
  constructor({ cause: e }) {
    super(`An error occurred while executing user operation: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownBundlerError"
    });
  }
}
class zb extends H {
  constructor({ cause: e }) {
    super("User Operation verification gas limit exceeded.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the gas used for verification exceeded the `verificationGasLimit`"
      ].filter(Boolean),
      name: "VerificationGasLimitExceededError"
    });
  }
}
Object.defineProperty(zb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa40/
});
class Vb extends H {
  constructor({ cause: e }) {
    super("User Operation verification gas limit is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `verificationGasLimit` is too low to verify the User Operation"
      ].filter(Boolean),
      name: "VerificationGasLimitTooLowError"
    });
  }
}
Object.defineProperty(Vb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa41/
});
class cW extends H {
  constructor(e, { callData: n, callGasLimit: r, docsPath: s, factory: a, factoryData: i, initCode: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymaster: d, paymasterAndData: m, paymasterData: h, paymasterPostOpGasLimit: b, paymasterVerificationGasLimit: y, preVerificationGas: g, sender: w, signature: v, verificationGasLimit: A }) {
    const B = jp({
      callData: n,
      callGasLimit: r,
      factory: a,
      factoryData: i,
      initCode: o,
      maxFeePerGas: typeof c < "u" && `${hs(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${hs(u)} gwei`,
      nonce: l,
      paymaster: d,
      paymasterAndData: m,
      paymasterData: h,
      paymasterPostOpGasLimit: b,
      paymasterVerificationGasLimit: y,
      preVerificationGas: g,
      sender: w,
      signature: v,
      verificationGasLimit: A
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        B
      ].filter(Boolean),
      name: "UserOperationExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class lW extends H {
  constructor({ hash: e }) {
    super(`User Operation receipt with hash "${e}" could not be found. The User Operation may not have been processed yet.`, { name: "UserOperationReceiptNotFoundError" });
  }
}
class uW extends H {
  constructor({ hash: e }) {
    super(`User Operation with hash "${e}" could not be found.`, {
      name: "UserOperationNotFoundError"
    });
  }
}
class r2 extends H {
  constructor({ hash: e }) {
    super(`Timed out while waiting for User Operation with hash "${e}" to be confirmed.`, { name: "WaitForUserOperationReceiptTimeoutError" });
  }
}
const dW = [
  qc,
  ip,
  ja,
  op,
  cp,
  lp,
  up,
  hp,
  dp,
  fp,
  pp
];
function fW(t, e) {
  const n = (t.details || "").toLowerCase();
  if (xb.message.test(n))
    return new xb({
      cause: t
    });
  if (Ab.message.test(n))
    return new Ab({
      cause: t
    });
  if (kb.message.test(n))
    return new kb({
      cause: t
    });
  if (vb.message.test(n))
    return new vb({
      cause: t
    });
  if (Cb.message.test(n))
    return new Cb({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Tb.message.test(n))
    return new Tb({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Sb.message.test(n))
    return new Sb({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode,
      sender: e.sender
    });
  if (Ob.message.test(n))
    return new Ob({
      cause: t
    });
  if (Bb.message.test(n))
    return new Bb({
      cause: t
    });
  if (Pb.message.test(n))
    return new Pb({
      cause: t,
      nonce: e.nonce
    });
  if (Ib.message.test(n))
    return new Ib({
      cause: t
    });
  if (Ub.message.test(n))
    return new Ub({
      cause: t
    });
  if (Nb.message.test(n))
    return new Nb({
      cause: t
    });
  if (ja.message.test(n))
    return new ja({
      cause: t
    });
  if (Rb.message.test(n))
    return new Rb({
      cause: t
    });
  if (Fb.message.test(n))
    return new Fb({
      cause: t
    });
  if (Db.message.test(n))
    return new Db({
      cause: t
    });
  if (Lb.message.test(n))
    return new Lb({
      cause: t
    });
  if (Mb.message.test(n))
    return new Mb({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Hb.message.test(n))
    return new Hb({
      cause: t
    });
  if ($b.message.test(n))
    return new $b({
      cause: t
    });
  if (Gb.message.test(n))
    return new Gb({
      cause: t
    });
  if (_b.message.test(n))
    return new _b({
      cause: t
    });
  if (zb.message.test(n))
    return new zb({
      cause: t
    });
  if (Vb.message.test(n))
    return new Vb({
      cause: t
    });
  const r = t.walk((s) => dW.some((a) => a.code === s.code));
  if (r) {
    if (r.code === qc.code)
      return new qc({
        cause: t,
        data: r.data,
        message: r.details
      });
    if (r.code === ip.code)
      return new ip({
        cause: t
      });
    if (r.code === ja.code)
      return new ja({
        cause: t
      });
    if (r.code === op.code)
      return new op({
        cause: t
      });
    if (r.code === cp.code)
      return new cp({
        cause: t
      });
    if (r.code === lp.code)
      return new lp({
        cause: t
      });
    if (r.code === up.code)
      return new up({
        cause: t
      });
    if (r.code === hp.code)
      return new hp({
        cause: t
      });
    if (r.code === dp.code)
      return new dp({
        cause: t
      });
    if (r.code === fp.code)
      return new fp({
        cause: t
      });
    if (r.code === pp.code)
      return new pp({
        cause: t
      });
  }
  return new oW({
    cause: t
  });
}
function G3(t, { calls: e, docsPath: n, ...r }) {
  const s = (() => {
    const a = fW(t, r);
    if (e && a instanceof qc) {
      const i = pW(a), o = e == null ? void 0 : e.filter((c) => c.abi);
      if (i && o.length > 0)
        return hW({ calls: o, revertData: i });
    }
    return a;
  })();
  return new cW(s, {
    docsPath: n,
    ...r
  });
}
function pW(t) {
  let e;
  return t.walk((n) => {
    var s, a, i, o;
    const r = n;
    if (typeof r.data == "string" || typeof ((s = r.data) == null ? void 0 : s.revertData) == "string" || !(r instanceof H) && typeof r.message == "string") {
      const c = (o = (i = ((a = r.data) == null ? void 0 : a.revertData) || r.data || r.message).match) == null ? void 0 : o.call(i, /(0x[A-Za-z0-9]*)/);
      if (c)
        return e = c[1], !0;
    }
    return !1;
  }), e;
}
function hW(t) {
  const { calls: e, revertData: n } = t, { abi: r, functionName: s, args: a, to: i } = (() => {
    const c = e == null ? void 0 : e.filter((l) => !!l.abi);
    if (c.length === 1)
      return c[0];
    const u = c.filter((l) => {
      try {
        return !!Z8({
          abi: l.abi,
          data: n
        });
      } catch {
        return !1;
      }
    });
    return u.length === 1 ? u[0] : {
      abi: [],
      functionName: c.reduce((l, d) => `${l ? `${l} | ` : ""}${d.functionName}`, ""),
      args: void 0,
      to: void 0
    };
  })(), o = n === "0x" ? new rv({ functionName: s }) : new nv({
    abi: r,
    data: n,
    functionName: s
  });
  return new tv(o, {
    abi: r,
    args: a,
    contractAddress: i,
    functionName: s
  });
}
function mW(t) {
  const e = {};
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), e;
}
function fh(t) {
  const e = {};
  return typeof t.callData < "u" && (e.callData = t.callData), typeof t.callGasLimit < "u" && (e.callGasLimit = W(t.callGasLimit)), typeof t.factory < "u" && (e.factory = t.factory), typeof t.factoryData < "u" && (e.factoryData = t.factoryData), typeof t.initCode < "u" && (e.initCode = t.initCode), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = W(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = W(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = W(t.nonce)), typeof t.paymaster < "u" && (e.paymaster = t.paymaster), typeof t.paymasterAndData < "u" && (e.paymasterAndData = t.paymasterAndData || "0x"), typeof t.paymasterData < "u" && (e.paymasterData = t.paymasterData), typeof t.paymasterPostOpGasLimit < "u" && (e.paymasterPostOpGasLimit = W(t.paymasterPostOpGasLimit)), typeof t.paymasterVerificationGasLimit < "u" && (e.paymasterVerificationGasLimit = W(t.paymasterVerificationGasLimit)), typeof t.preVerificationGas < "u" && (e.preVerificationGas = W(t.preVerificationGas)), typeof t.sender < "u" && (e.sender = t.sender), typeof t.signature < "u" && (e.signature = t.signature), typeof t.verificationGasLimit < "u" && (e.verificationGasLimit = W(t.verificationGasLimit)), typeof t.authorization < "u" && (e.eip7702Auth = yW(t.authorization)), e;
}
function yW(t) {
  return {
    address: t.address,
    chainId: W(t.chainId),
    nonce: W(t.nonce),
    r: t.r ? W(BigInt(t.r), { size: 32 }) : vt("0x", { size: 32 }),
    s: t.s ? W(BigInt(t.s), { size: 32 }) : vt("0x", { size: 32 }),
    yParity: t.yParity ? W(t.yParity, { size: 1 }) : vt("0x", { size: 32 })
  };
}
async function ph(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return va(e);
}
class bW extends H {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class z3 extends H {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class gW extends H {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = "Block";
    e && (r = `Block at hash "${e}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
async function jb(t, { blockHash: e, blockNumber: n, blockTag: r, includeTransactions: s } = {}) {
  var l, d, m;
  const a = r ?? "latest", i = s ?? !1, o = n !== void 0 ? W(n) : void 0;
  let c = null;
  if (e ? c = await t.request({
    method: "eth_getBlockByHash",
    params: [e, i]
  }, { dedupe: !0 }) : c = await t.request({
    method: "eth_getBlockByNumber",
    params: [o || a, i]
  }, { dedupe: !!o }), !c)
    throw new gW({ blockHash: e, blockNumber: n });
  return (((m = (d = (l = t.chain) == null ? void 0 : l.formatters) == null ? void 0 : d.block) == null ? void 0 : m.format) || Xk)(c);
}
async function V3(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function wW(t, e) {
  var a, i;
  const { block: n, chain: r = t.chain, request: s } = e || {};
  try {
    const o = ((a = r == null ? void 0 : r.fees) == null ? void 0 : a.maxPriorityFeePerGas) ?? ((i = r == null ? void 0 : r.fees) == null ? void 0 : i.defaultPriorityFee);
    if (typeof o == "function") {
      const u = n || await Ze(t, jb, "getBlock")({}), l = await o({
        block: u,
        client: t,
        request: s
      });
      if (l === null)
        throw new Error();
      return l;
    }
    if (typeof o < "u")
      return o;
    const c = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Re(c);
  } catch {
    const [o, c] = await Promise.all([
      n ? Promise.resolve(n) : Ze(t, jb, "getBlock")({}),
      Ze(t, V3, "getGasPrice")({})
    ]);
    if (typeof o.baseFeePerGas != "bigint")
      throw new z3();
    const u = c - o.baseFeePerGas;
    return u < 0n ? 0n : u;
  }
}
async function EW(t, e) {
  return xW(t, e);
}
async function xW(t, e) {
  var m, h;
  const { block: n, chain: r = t.chain, request: s, type: a = "eip1559" } = e || {}, i = await (async () => {
    var b, y;
    return typeof ((b = r == null ? void 0 : r.fees) == null ? void 0 : b.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: t,
      request: s
    }) : ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.baseFeeMultiplier) ?? 1.2;
  })();
  if (i < 1)
    throw new bW();
  const c = 10 ** (((m = i.toString().split(".")[1]) == null ? void 0 : m.length) ?? 0), u = (b) => b * BigInt(Math.ceil(i * c)) / BigInt(c), l = n || await Ze(t, jb, "getBlock")({});
  if (typeof ((h = r == null ? void 0 : r.fees) == null ? void 0 : h.estimateFeesPerGas) == "function") {
    const b = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: u,
      request: s,
      type: a
    });
    if (b !== null)
      return b;
  }
  if (a === "eip1559") {
    if (typeof l.baseFeePerGas != "bigint")
      throw new z3();
    const b = typeof (s == null ? void 0 : s.maxPriorityFeePerGas) == "bigint" ? s.maxPriorityFeePerGas : await wW(t, {
      block: l,
      chain: r,
      request: s
    }), y = u(l.baseFeePerGas);
    return {
      maxFeePerGas: (s == null ? void 0 : s.maxFeePerGas) ?? y + b,
      maxPriorityFeePerGas: b
    };
  }
  return {
    gasPrice: (s == null ? void 0 : s.gasPrice) ?? u(await Ze(t, V3, "getGasPrice")({}))
  };
}
const Fm = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map();
let AW = 0;
function kW(t, e, n) {
  const r = ++AW, s = () => Fm.get(t) || [], a = () => {
    const l = s();
    Fm.set(t, l.filter((d) => d.id !== r));
  }, i = () => {
    const l = s();
    if (!l.some((m) => m.id === r))
      return;
    const d = s2.get(t);
    if (l.length === 1 && d) {
      const m = d();
      m instanceof Promise && m.catch(() => {
      });
    }
    a();
  }, o = s();
  if (Fm.set(t, [
    ...o,
    { id: r, fns: e }
  ]), o && o.length > 0)
    return i;
  const c = {};
  for (const l in e)
    c[l] = (...d) => {
      var h, b;
      const m = s();
      if (m.length !== 0)
        for (const y of m)
          (b = (h = y.fns)[l]) == null || b.call(h, ...d);
    };
  const u = n(c);
  return typeof u == "function" && s2.set(t, u), i;
}
function vW(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let s = !0;
  const a = () => s = !1;
  return (async () => {
    let o;
    o = await t({ unpoll: a });
    const c = await (n == null ? void 0 : n(o)) ?? r;
    await n2(c);
    const u = async () => {
      s && (await t({ unpoll: a }), await n2(r), u());
    };
    u();
  })(), a;
}
async function CW(t, e) {
  var c;
  const { account: n = t.account, chainId: r, nonce: s } = e;
  if (!n)
    throw new no({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const a = Hn(n), i = (() => {
    if (e.executor)
      return e.executor === "self" ? e.executor : Hn(e.executor);
  })(), o = {
    address: e.contractAddress ?? e.address,
    chainId: r,
    nonce: s
  };
  return typeof o.chainId > "u" && (o.chainId = ((c = t.chain) == null ? void 0 : c.id) ?? await Ze(t, ph, "getChainId")({})), typeof o.nonce > "u" && (o.nonce = await Ze(t, tK, "getTransactionCount")({
    address: a.address,
    blockTag: "pending"
  }), (i === "self" || i != null && i.address && XK(i.address, a.address)) && (o.nonce += 1)), o;
}
async function j3(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = fh(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      W(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Re(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Re(c)
    }
  };
}
async function q3(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = fh(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterStubData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      W(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Re(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Re(c)
    }
  };
}
const TW = [
  "factory",
  "fees",
  "gas",
  "paymaster",
  "nonce",
  "signature",
  "authorization"
];
async function To(t, e) {
  var N;
  const n = e, { account: r = t.account, parameters: s = TW, stateOverride: a } = n;
  if (!r)
    throw new no();
  const i = Hn(r), o = t, c = n.paymaster ?? (o == null ? void 0 : o.paymaster), u = typeof c == "string" ? c : void 0, { getPaymasterStubData: l, getPaymasterData: d } = (() => {
    if (c === !0)
      return {
        getPaymasterStubData: (I) => Ze(o, q3, "getPaymasterStubData")(I),
        getPaymasterData: (I) => Ze(o, j3, "getPaymasterData")(I)
      };
    if (typeof c == "object") {
      const { getPaymasterStubData: I, getPaymasterData: O } = c;
      return {
        getPaymasterStubData: O && I ? I : O,
        getPaymasterData: O && I ? O : void 0
      };
    }
    return {
      getPaymasterStubData: void 0,
      getPaymasterData: void 0
    };
  })(), m = n.paymasterContext ? n.paymasterContext : o == null ? void 0 : o.paymasterContext;
  let h = {
    ...n,
    paymaster: u,
    sender: i.address
  };
  const [b, y, g, w, v] = await Promise.all([
    (async () => n.calls ? i.encodeCalls(n.calls.map((I) => {
      const O = I;
      return O.abi ? {
        data: T1(O),
        to: O.to,
        value: O.value
      } : O;
    })) : n.callData)(),
    (async () => {
      if (!s.includes("factory"))
        return;
      if (n.initCode)
        return { initCode: n.initCode };
      if (n.factory && n.factoryData)
        return {
          factory: n.factory,
          factoryData: n.factoryData
        };
      const { factory: I, factoryData: O } = await i.getFactoryArgs();
      return i.entryPoint.version === "0.6" ? {
        initCode: I && O ? rn([I, O]) : void 0
      } : {
        factory: I,
        factoryData: O
      };
    })(),
    (async () => {
      var I;
      if (s.includes("fees")) {
        if (typeof n.maxFeePerGas == "bigint" && typeof n.maxPriorityFeePerGas == "bigint")
          return h;
        if ((I = o == null ? void 0 : o.userOperation) != null && I.estimateFeesPerGas) {
          const O = await o.userOperation.estimateFeesPerGas({
            account: i,
            bundlerClient: o,
            userOperation: h
          });
          return {
            ...h,
            ...O
          };
        }
        try {
          const O = o.client ?? t, C = await Ze(O, EW, "estimateFeesPerGas")({
            chain: O.chain,
            type: "eip1559"
          });
          return {
            maxFeePerGas: typeof n.maxFeePerGas == "bigint" ? n.maxFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxFeePerGas
            ),
            maxPriorityFeePerGas: typeof n.maxPriorityFeePerGas == "bigint" ? n.maxPriorityFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxPriorityFeePerGas
            )
          };
        } catch {
          return;
        }
      }
    })(),
    (async () => {
      if (s.includes("nonce"))
        return typeof n.nonce == "bigint" ? n.nonce : i.getNonce();
    })(),
    (async () => {
      if (s.includes("authorization")) {
        if (typeof n.authorization == "object")
          return n.authorization;
        if (i.authorization && !await i.isDeployed())
          return {
            ...await CW(i.client, i.authorization),
            r: "0xfffffffffffffffffffffffffffffff000000000000000000000000000000000",
            s: "0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            yParity: 1
          };
      }
    })()
  ]);
  typeof b < "u" && (h.callData = b), typeof y < "u" && (h = { ...h, ...y }), typeof g < "u" && (h = { ...h, ...g }), typeof w < "u" && (h.nonce = w), typeof v < "u" && (h.authorization = v), s.includes("signature") && (typeof n.signature < "u" ? h.signature = n.signature : h.signature = await i.getStubSignature(h)), i.entryPoint.version === "0.6" && !h.initCode && (h.initCode = "0x");
  let A;
  async function B() {
    return A || (t.chain ? t.chain.id : (A = await Ze(t, ph, "getChainId")({}), A));
  }
  let x = !1;
  if (s.includes("paymaster") && l && !u && !n.paymasterAndData) {
    const { isFinal: I = !1, sponsor: O, ...C } = await l({
      chainId: await B(),
      entryPointAddress: i.entryPoint.address,
      context: m,
      ...h
    });
    x = I, h = {
      ...h,
      ...C
    };
  }
  if (i.entryPoint.version === "0.6" && !h.paymasterAndData && (h.paymasterAndData = "0x"), s.includes("gas")) {
    if ((N = i.userOperation) != null && N.estimateGas) {
      const I = await i.userOperation.estimateGas(h);
      h = {
        ...h,
        ...I
      };
    }
    if (typeof h.callGasLimit > "u" || typeof h.preVerificationGas > "u" || typeof h.verificationGasLimit > "u" || h.paymaster && typeof h.paymasterPostOpGasLimit > "u" || h.paymaster && typeof h.paymasterVerificationGasLimit > "u") {
      const I = await Ze(o, K3, "estimateUserOperationGas")({
        account: i,
        // Some Bundlers fail if nullish gas values are provided for gas estimation :') 
        // so we will need to set a default zeroish value.
        callGasLimit: 0n,
        preVerificationGas: 0n,
        verificationGasLimit: 0n,
        stateOverride: a,
        ...h.paymaster ? {
          paymasterPostOpGasLimit: 0n,
          paymasterVerificationGasLimit: 0n
        } : {},
        ...h
      });
      h = {
        ...h,
        callGasLimit: h.callGasLimit ?? I.callGasLimit,
        preVerificationGas: h.preVerificationGas ?? I.preVerificationGas,
        verificationGasLimit: h.verificationGasLimit ?? I.verificationGasLimit,
        paymasterPostOpGasLimit: h.paymasterPostOpGasLimit ?? I.paymasterPostOpGasLimit,
        paymasterVerificationGasLimit: h.paymasterVerificationGasLimit ?? I.paymasterVerificationGasLimit
      };
    }
  }
  if (s.includes("paymaster") && d && !u && !n.paymasterAndData && !x) {
    const I = await d({
      chainId: await B(),
      entryPointAddress: i.entryPoint.address,
      context: m,
      ...h
    });
    h = {
      ...h,
      ...I
    };
  }
  return delete h.calls, delete h.parameters, delete h.paymasterContext, typeof h.paymaster != "string" && delete h.paymaster, h;
}
async function K3(t, e) {
  var c;
  const { account: n = t.account, entryPointAddress: r, stateOverride: s } = e;
  if (!n && !e.sender)
    throw new no();
  const a = n ? Hn(n) : void 0, i = M3(s), o = a ? await Ze(t, To, "prepareUserOperation")({
    ...e,
    parameters: [
      "authorization",
      "factory",
      "nonce",
      "paymaster",
      "signature"
    ]
  }) : e;
  try {
    const u = [
      fh(o),
      r ?? ((c = a == null ? void 0 : a.entryPoint) == null ? void 0 : c.address)
    ], l = await t.request({
      method: "eth_estimateUserOperationGas",
      params: i ? [...u, i] : [...u]
    });
    return mW(l);
  } catch (u) {
    const l = e.calls;
    throw G3(u, {
      ...o,
      ...l ? { calls: l } : {}
    });
  }
}
function SW(t) {
  return t.request({ method: "eth_supportedEntryPoints" });
}
function OW(t) {
  const e = { ...t };
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.maxFeePerGas && (e.maxFeePerGas = BigInt(t.maxFeePerGas)), t.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = BigInt(t.maxPriorityFeePerGas)), t.nonce && (e.nonce = BigInt(t.nonce)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), e;
}
async function BW(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationByHash",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new uW({ hash: e });
  const { blockHash: r, blockNumber: s, entryPoint: a, transactionHash: i, userOperation: o } = n;
  return {
    blockHash: r,
    blockNumber: BigInt(s),
    entryPoint: a,
    transactionHash: i,
    userOperation: OW(o)
  };
}
function IW(t) {
  const e = { ...t };
  return t.actualGasCost && (e.actualGasCost = BigInt(t.actualGasCost)), t.actualGasUsed && (e.actualGasUsed = BigInt(t.actualGasUsed)), t.logs && (e.logs = t.logs.map((n) => Mg(n))), t.receipt && (e.receipt = Yk(e.receipt)), e;
}
async function W3(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationReceipt",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new lW({ hash: e });
  return IW(n);
}
async function PW(t, e) {
  var c, u;
  const { account: n = t.account, entryPointAddress: r } = e;
  if (!n && !e.sender)
    throw new no();
  const s = n ? Hn(n) : void 0, a = s ? await Ze(t, To, "prepareUserOperation")(e) : e, i = e.signature || await ((c = s == null ? void 0 : s.signUserOperation) == null ? void 0 : c.call(s, a)), o = fh({
    ...a,
    signature: i
  });
  try {
    return await t.request({
      method: "eth_sendUserOperation",
      params: [
        o,
        r ?? ((u = s == null ? void 0 : s.entryPoint) == null ? void 0 : u.address)
      ]
    }, { retryCount: 0 });
  } catch (l) {
    const d = e.calls;
    throw G3(l, {
      ...a,
      ...d ? { calls: d } : {},
      signature: i
    });
  }
}
function UW(t, e) {
  const { hash: n, pollingInterval: r = t.pollingInterval, retryCount: s, timeout: a = 12e4 } = e;
  let i = 0;
  const o = el([
    "waitForUserOperationReceipt",
    t.uid,
    n
  ]);
  return new Promise((c, u) => {
    const l = kW(o, { resolve: c, reject: u }, (d) => {
      const m = (b) => {
        h(), b(), l();
      }, h = vW(async () => {
        s && i >= s && m(() => d.reject(new r2({ hash: n })));
        try {
          const b = await Ze(t, W3, "getUserOperationReceipt")({ hash: n });
          m(() => d.resolve(b));
        } catch (b) {
          const y = b;
          y.name !== "UserOperationReceiptNotFoundError" && m(() => d.reject(y));
        }
        i++;
      }, {
        emitOnBegin: !0,
        interval: r
      });
      return a && setTimeout(() => m(() => d.reject(new r2({ hash: n }))), a), h;
    });
  });
}
function NW(t) {
  return {
    estimateUserOperationGas: (e) => K3(t, e),
    getChainId: () => ph(t),
    getSupportedEntryPoints: () => SW(t),
    getUserOperation: (e) => BW(t, e),
    getUserOperationReceipt: (e) => W3(t, e),
    prepareUserOperation: (e) => To(t, e),
    sendUserOperation: (e) => PW(t, e),
    waitForUserOperationReceipt: (e) => UW(t, e)
  };
}
function RW(t) {
  return {
    getPaymasterData: (e) => j3(t, e),
    getPaymasterStubData: (e) => q3(t, e)
  };
}
const qb = 256;
let lf = qb, uf;
function FW(t = 11) {
  if (!uf || lf + t > qb * 2) {
    uf = "", lf = 0;
    for (let e = 0; e < qb; e++)
      uf += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return uf.substring(lf, lf++ + t);
}
function Q3(t) {
  const { batch: e, chain: n, ccipRead: r, key: s = "base", name: a = "Base Client", type: i = "base" } = t, o = (n == null ? void 0 : n.blockTime) ?? 12e3, c = Math.min(Math.max(Math.floor(o / 2), 500), 4e3), u = t.pollingInterval ?? c, l = t.cacheTime ?? u, d = t.account ? Hn(t.account) : void 0, { config: m, request: h, value: b } = t.transport({
    chain: n,
    pollingInterval: u
  }), y = { ...m, ...b }, g = {
    account: d,
    batch: e,
    cacheTime: l,
    ccipRead: r,
    chain: n,
    key: s,
    name: a,
    pollingInterval: u,
    request: h,
    transport: y,
    type: i,
    uid: FW()
  };
  function w(v) {
    return (A) => {
      const B = A(v);
      for (const N in g)
        delete B[N];
      const x = { ...v, ...B };
      return Object.assign(x, { extend: w(x) });
    };
  }
  return Object.assign(g, { extend: w(g) });
}
function a2(t) {
  const { client: e, key: n = "bundler", name: r = "Bundler Client", paymaster: s, paymasterContext: a, transport: i, userOperation: o } = t;
  return Object.assign(Q3({
    ...t,
    chain: t.chain ?? (e == null ? void 0 : e.chain),
    key: n,
    name: r,
    transport: i,
    type: "bundlerClient"
  }), { client: e, paymaster: s, paymasterContext: a, userOperation: o }).extend(NW);
}
function DW(t) {
  const { key: e = "bundler", name: n = "Bundler Client", transport: r } = t;
  return Q3({
    ...t,
    key: e,
    name: n,
    transport: r,
    type: "PaymasterClient"
  }).extend(RW);
}
const MW = "0x0000000071727De22E5E9d8BAf0edAc6f37da032", LW = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      }
    ],
    name: "executeUserOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], i2 = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";
async function HW({
  userOp: t,
  relayerPrivateKey: e,
  chain: n
}) {
  console.log("[trails-sdk] userOp", t);
  const r = Tu(e), s = Qu({
    chain: n,
    transport: ct(),
    account: r
  }), a = wa({
    chain: n,
    transport: ct()
  }), i = J3(t), o = await VW({
    userOperation: i,
    entryPointAddress: i2,
    chainId: n.id
  });
  console.log("[trails-sdk] opHash", o), console.log("[trails-sdk] packedOp", i), console.log("[trails-sdk] relayerAccount", r);
  const c = jW({
    userOps: [t],
    beneficiary: r.address
  });
  console.log("[trails-sdk] handleOpsData", c);
  const u = await s.sendTransaction({
    to: i2,
    data: c,
    value: BigInt(0),
    gasLimit: 1e6,
    chain: n
  });
  console.log("[trails-sdk] Sent handleOps tx:", u);
  const l = await a.waitForTransactionReceipt({ hash: u });
  return console.log("[trails-sdk] Confirmed handleOps tx:", l.transactionHash), l.transactionHash;
}
function $W(t) {
  if (!t.verificationGasLimit)
    throw new Error("verificationGasLimit is required");
  if (!t.callGasLimit)
    throw new Error("callGasLimit is required");
  return Zu([
    Ni(Ea(t.verificationGasLimit), { size: 16 }),
    Ni(Ea(t.callGasLimit), { size: 16 })
  ]);
}
function _W(t) {
  if (!t.maxPriorityFeePerGas)
    throw new Error("maxPriorityFeePerGas is required");
  if (!t.maxFeePerGas)
    throw new Error("maxFeePerGas is required");
  return Zu([
    Ni(Ea(t.maxPriorityFeePerGas), { size: 16 }),
    Ni(Ea(t.maxFeePerGas), { size: 16 })
  ]);
}
function GW(t) {
  return t.factory ? Zu([
    t.factory === "0x7702" ? Ni(t.factory, { dir: "right", size: 20 }) : t.factory,
    t.factoryData || "0x"
  ]) : "0x";
}
function zW(t) {
  if (!t.paymaster) return "0x";
  if (!t.paymasterVerificationGasLimit)
    throw new Error("paymasterVerificationGasLimit is required");
  if (!t.paymasterPostOpGasLimit)
    throw new Error("paymasterPostOpGasLimit is required");
  return Zu([
    t.paymaster,
    Ni(Ea(t.paymasterVerificationGasLimit || 0n), { size: 16 }),
    Ni(Ea(t.paymasterPostOpGasLimit || 0n), { size: 16 }),
    t.paymasterData || "0x"
  ]);
}
function J3(t) {
  return {
    sender: t.sender,
    nonce: t.nonce,
    initCode: GW(t),
    callData: t.callData,
    accountGasLimits: $W(t),
    preVerificationGas: t.preVerificationGas,
    gasFees: _W(t),
    paymasterAndData: zW(t),
    signature: t.signature
  };
}
const VW = ({
  userOperation: t,
  entryPointAddress: e,
  chainId: n
}) => {
  const r = cl(
    xw(
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        t.sender,
        t.nonce,
        cl(t.initCode),
        cl(t.callData),
        t.accountGasLimits,
        t.preVerificationGas,
        t.gasFees,
        cl(t.paymasterAndData)
      ]
    )
  );
  return cl(
    xw(
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [r, e, BigInt(n)]
    )
  );
}, jW = ({
  userOps: t,
  beneficiary: e
}) => {
  const n = qW(t);
  return console.log(
    "[trails-sdk] encodeHandleOpsCalldata packedUserOps",
    n
  ), mn({
    abi: LW,
    functionName: "handleOps",
    args: [n, e]
  });
}, qW = (t) => t.map(
  (n) => J3(n)
), KW = async (t, e = BigInt(0)) => {
  if (!t) throw new Error("Owner account not found");
  return mn({
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          }
        ],
        name: "createAccount",
        outputs: [
          {
            internalType: "contract SimpleAccount",
            name: "ret",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    functionName: "createAccount",
    args: [t, e]
  });
}, WW = (t) => t || "0x91E60e0613810449d098b0b5Ec8b51A0FE8c8985";
async function QW(t) {
  const {
    client: e,
    owner: n,
    factoryAddress: r,
    index: s = BigInt(0),
    address: a,
    nonceKey: i
    // accountLogicAddress = "0xe6Cae83BdE06E4c305530e199D7217f42808555B",
  } = t, o = await eQ({ owner: n }), c = t.entryPoint ? {
    address: t.entryPoint.address,
    abi: t2,
    version: "0.7"
  } : {
    address: MW,
    abi: t2,
    version: "0.7"
  }, u = WW(r);
  let l;
  const d = async () => l || (l = e.chain ? e.chain.id : await Ze(e, ph, "getChainId")({}), l), m = () => async () => ({
    factory: u,
    factoryData: await KW(o.address, s)
  }), { accountAddress: h, getFactoryArgs: b } = await (async () => {
    const y = m();
    if (a)
      return { accountAddress: a, getFactoryArgs: y };
    const { factory: g, factoryData: w } = await y();
    return { accountAddress: await YW(e, {
      factory: g,
      factoryData: w,
      entryPointAddress: c.address
    }), getFactoryArgs: y };
  })();
  return sW({
    client: e,
    entryPoint: c,
    getFactoryArgs: b,
    async getAddress() {
      return h;
    },
    async encodeCalls(y) {
      if (y.length > 1)
        return mn({
          abi: c2,
          functionName: "executeBatch",
          args: [
            y.map((w) => w.to),
            y.map((w) => w.value ?? 0n),
            y.map((w) => w.data ?? "0x")
          ]
        });
      const g = y.length === 0 ? void 0 : y[0];
      if (!g)
        throw new Error("No calls to encode");
      return mn({
        abi: o2,
        functionName: "execute",
        args: [g.to, g.value ?? 0n, g.data ?? "0x"]
      });
    },
    decodeCalls: async (y) => {
      try {
        const g = [], w = Gm({
          abi: c2,
          data: y
        }), v = w.args[0], A = w.args[1], B = w.args[2];
        for (let x = 0; x < v.length; x++)
          g.push({
            to: v[x],
            data: B[x],
            value: A[x]
          });
        return g;
      } catch {
        const w = Gm({
          abi: o2,
          data: y
        });
        return [
          {
            to: w.args[0],
            value: w.args[1],
            data: w.args[2]
          }
        ];
      }
    },
    async getNonce(y) {
      return JW(e, {
        address: await this.getAddress(),
        entryPointAddress: c.address,
        key: i ?? (y == null ? void 0 : y.key)
      });
    },
    async getStubSignature() {
      return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    },
    async sign({ hash: y }) {
      return this.signMessage({ message: y });
    },
    signMessage: async (y) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    signTypedData: async (y) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    async signUserOperation(y) {
      const { chainId: g = await d(), ...w } = y;
      return aW(e, {
        account: o,
        message: {
          raw: nW({
            userOperation: {
              ...w,
              sender: w.sender ?? await this.getAddress(),
              signature: "0x"
            },
            entryPointAddress: c.address,
            entryPointVersion: c.version,
            chainId: g
          })
        }
      });
    }
  });
}
const o2 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dest",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "func",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], c2 = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "dest",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "value",
        type: "uint256[]"
      },
      {
        internalType: "bytes[]",
        name: "func",
        type: "bytes[]"
      }
    ],
    name: "executeBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], JW = async (t, e) => {
  const { address: n, entryPointAddress: r, key: s = BigInt(0) } = e;
  return await Ze(
    t,
    H3,
    "readContract"
  )({
    address: r,
    abi: [
      {
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "getNonce",
    args: [n, s]
  });
}, ZW = "0x60806040526102a28038038091610015826100ae565b6080396040816080019112610093576080516001600160a01b03811681036100935760a0516001600160401b0381116100935782609f82011215610093578060800151610061816100fc565b9361006f60405195866100d9565b81855260a082840101116100935761008e9160a0602086019101610117565b610196565b600080fd5b634e487b7160e01b600052604160045260246000fd5b6080601f91909101601f19168101906001600160401b038211908210176100d457604052565b610098565b601f909101601f19168101906001600160401b038211908210176100d457604052565b6001600160401b0381116100d457601f01601f191660200190565b60005b83811061012a5750506000910152565b818101518382015260200161011a565b6040916020825261015a8151809281602086015260208686019101610117565b601f01601f1916010190565b3d15610191573d90610177826100fc565b9161018560405193846100d9565b82523d6000602084013e565b606090565b600091908291826040516101cd816101bf6020820195639b249f6960e01b87526024830161013a565b03601f1981018352826100d9565b51925af16101d9610166565b906102485760048151116000146101f7576024015160005260206000f35b60405162461bcd60e51b8152602060048201526024808201527f67657453656e64657241646472657373206661696c656420776974686f7574206044820152636461746160e01b6064820152608490fd5b60405162461bcd60e51b815260206004820152602b60248201527f67657453656e6465724164647265737320646964206e6f74207265766572742060448201526a185cc8195e1c1958dd195960aa1b6064820152608490fdfe", XW = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_entryPoint",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "constructor"
  }
], YW = async (t, e) => {
  const { initCode: n, entryPointAddress: r, factory: s, factoryData: a } = e;
  if (!n && !s && !a)
    throw new Error(
      "Either `initCode` or `factory` and `factoryData` must be provided"
    );
  const i = n || Zu([s, a]), { data: o } = await Ze(
    t,
    L3,
    "call"
  )({
    data: V5({
      abi: XW,
      bytecode: ZW,
      args: [r, i]
    })
  });
  if (!o)
    throw new Error("Failed to get sender address");
  return j5([{ type: "address" }], o)[0];
};
async function eQ({
  owner: t,
  address: e
}) {
  if ("type" in t && t.type === "local")
    return t;
  let n;
  if ("request" in t) {
    if (!e)
      try {
        [e] = await t.request({
          method: "eth_requestAccounts"
        });
      } catch {
        [e] = await t.request({
          method: "eth_accounts"
        });
      }
    if (!e)
      throw new Error("address is required");
    n = Qu({
      account: e,
      transport: Ol(t)
    });
  }
  return n || (n = t), x3({
    address: n.account.address,
    async signMessage({ message: r }) {
      return n.signMessage({ message: r });
    },
    async signTypedData(r) {
      return Ze(
        n,
        iW,
        "signTypedData"
      )(r);
    },
    async signTransaction(r) {
      throw new Error("Smart account signer doesn't need to sign transactions");
    }
  });
}
const tQ = "0x0000000071727de22e5e9d8baf0edac6f37da032";
async function nQ({
  publicClient: t
}) {
  const e = A1(), n = Tu(e);
  console.log("[trails-sdk] Delegator account:", n.address), console.log("Creating smart account...");
  const r = await QW({
    client: t,
    entryPoint: {
      address: tQ,
      version: "0.7"
    },
    owner: Tu(e)
  });
  return console.log(
    "[trails-sdk] Smart account address:",
    r.address
  ), console.log(
    "[trails-sdk] delegatorSmartAccount.address",
    r.address
  ), r;
}
async function rQ({
  walletClient: t,
  chain: e,
  tokenAddress: n,
  amount: r,
  recipient: s,
  delegatorSmartAccount: a
}) {
  const i = wa({
    chain: e,
    transport: ct()
  });
  if (!t.account)
    throw new Error("No account found");
  const o = t.account.address;
  console.log("[trails-sdk] Transfer amount:", r.toString());
  const { signature: c, deadline: u } = await C1({
    publicClient: i,
    walletClient: t,
    signer: o,
    spender: a.address,
    tokenAddress: n,
    amount: r,
    chain: e
  });
  console.log("[trails-sdk] Received signature:", c);
  const l = P3({
    signer: o,
    spender: a.address,
    amount: r,
    deadline: u,
    signature: c
  }), d = U3({
    signer: o,
    spender: a.address,
    amount: r
  }), m = N3({ recipient: s, amount: r });
  return [
    { to: Me, data: "0x", value: "0x" },
    { to: n, data: l, value: "0x" },
    { to: n, data: d, value: "0x" },
    { to: n, data: m, value: "0x" }
  ];
}
async function sQ({
  walletClient: t,
  publicClient: e,
  chain: n,
  paymasterUrl: r,
  delegatorSmartAccount: s,
  calls: a
}) {
  try {
    if (!t.account)
      throw new Error("No account found");
    console.log("[trails-sdk] Estimating gas fees...");
    const i = await e.estimateFeesPerGas(), o = q5("1"), c = i.maxFeePerGas + o;
    if (r)
      if (r.includes("alchemy")) {
        const u = a2({
          chain: n,
          transport: ct(r)
        });
        console.log("[trails-sdk] preparing user op");
        const l = await To(e, {
          account: s,
          calls: a,
          maxFeePerGas: c,
          maxPriorityFeePerGas: o,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        }), d = await s.signUserOperation(l);
        l.signature = d, console.log("[trails-sdk] Signed user operation:", d), console.log("[trails-sdk] Sending user operation...");
        const m = await u.sendUserOperation(l);
        console.log("[trails-sdk] User operation sent! Hash:", m);
        const h = await u.waitForUserOperationReceipt({
          hash: m
        });
        return console.log("[trails-sdk] User operation receipt:", h), h.receipt.transactionHash;
      } else {
        const u = DW({
          transport: ct(r)
        }), l = a2({
          chain: n,
          paymaster: u,
          transport: ct(r)
        });
        console.log("[trails-sdk] preparing user op");
        let d = await To(e, {
          account: s,
          calls: a,
          maxFeePerGas: c,
          maxPriorityFeePerGas: o,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        });
        d = await l.prepareUserOperation({
          ...d
        }), console.log("[trails-sdk] preparedUserOp", d);
        const m = await s.signUserOperation(d);
        d.signature = m, console.log("[trails-sdk] Signed user operation:", m), console.log("[trails-sdk] Sending user operation...");
        const h = await l.sendUserOperation(d);
        console.log("[trails-sdk] User operation sent! Hash:", h);
        const b = await l.waitForUserOperationReceipt({
          hash: h
        });
        return console.log("[trails-sdk] User operation receipt:", b), b.receipt.transactionHash;
      }
    else {
      const u = "";
      console.log("[trails-sdk] preparing user op");
      const l = await To(e, {
        account: s,
        calls: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: o,
        callGasLimit: 500000n,
        verificationGasLimit: 500000n,
        preVerificationGas: 500000n,
        paymasterAndData: "0x"
      });
      console.log("[trails-sdk] preparedUserOp", l);
      const d = aQ(l);
      console.log("[trails-sdk] Required prefund:", d);
      const m = await e.getBalance({
        address: s.address
      });
      console.log("[trails-sdk] Balance:", m);
      const h = await s.signUserOperation(l);
      l.signature = h, console.log("[trails-sdk] Signed user operation:", h);
      const b = await HW({
        userOp: l,
        relayerPrivateKey: u,
        chain: n
      });
      return console.log("[trails-sdk] User operation submitted! Hash:", b), b;
    }
  } catch (i) {
    throw console.error("[trails-sdk] Gasless flow error:", i), i;
  }
}
const aQ = (t) => {
  const e = t;
  return (e.verificationGasLimit + e.callGasLimit + (e.paymasterVerificationGasLimit || 0n) + (e.paymasterPostOpGasLimit || 0n) + e.preVerificationGas) * e.maxFeePerGas;
}, Kr = {
  // Time configurations
  staleTime: 3e4,
  // 30 seconds - prices change frequently
  gcTime: 12e4,
  // 2 minutes cache time
  refetchInterval: 6e4,
  // Background refetch every minute for prices
  // Retry configurations
  retry: 2,
  retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
  // Refetch behaviors
  refetchOnWindowFocus: !1,
  refetchOnReconnect: !0,
  refetchIntervalInBackground: !0,
  // Retry logic for specific error types
  shouldRetry: (t, e) => e && "status" in e && e.status === 404 ? !1 : t < 2
}, hd = {
  staleTime: Kr.staleTime,
  gcTime: Kr.gcTime,
  retry: Kr.shouldRetry,
  retryDelay: Kr.retryDelay,
  refetchOnWindowFocus: Kr.refetchOnWindowFocus,
  refetchOnReconnect: Kr.refetchOnReconnect,
  refetchInterval: Kr.refetchInterval,
  refetchIntervalInBackground: Kr.refetchIntervalInBackground
}, Z3 = new cg({
  defaultOptions: {
    queries: {
      ...hd,
      // Override retry for QueryClient (use number instead of function)
      retry: Kr.retry
    }
  }
}), X3 = (t) => `${t.contractAddress}-${t.chainId}-${t.tokenId}`, Y3 = (t) => [
  "tokenPrices",
  "batch",
  t.length,
  t.map(X3).sort()
], eC = (t) => ["tokenPrices", "single", t ? X3(t) : null], iQ = async (t, e) => {
  if (!t)
    throw new Error("API client is required");
  if (e.length === 0)
    return [];
  try {
    const n = await t.getCoinPrices({ tokens: e });
    return (n == null ? void 0 : n.tokenPrices) || [];
  } catch (n) {
    throw console.error("[trails-sdk] Failed to fetch token prices:", n), n;
  }
};
function tC(t) {
  return {
    chainId: t.chainId,
    contractAddress: t.contractAddress || Me,
    tokenId: t.tokenId || t.tokenID || t.symbol
  };
}
const S1 = async (t, e) => (e = e.map(tC), Z3.fetchQuery({
  queryKey: Y3(e),
  queryFn: () => iQ(t, e),
  ...hd
})), oQ = async (t, e) => Z3.fetchQuery({
  queryKey: eC(e),
  queryFn: async () => {
    const n = await S1(t, [e]);
    return n != null && n.length ? n[0] : null;
  },
  ...hd
}), cQ = (t, e) => {
  t = t.map(tC);
  const { data: n, isLoading: r } = yn({
    queryKey: Y3(t),
    queryFn: () => S1(e, t),
    enabled: t.length > 0 && !!e,
    ...hd
  });
  return {
    tokenPrices: n,
    isLoadingTokenPrices: r
  };
}, lQ = (t, e) => {
  const { data: n, isLoading: r } = yn({
    queryKey: eC(t),
    queryFn: () => t && e ? oQ(e, t) : null,
    enabled: !!t && !!e,
    ...hd
  });
  return {
    tokenPrice: n,
    isLoadingTokenPrice: r
  };
};
function uQ(t) {
  return typeof window > "u" ? null : new URLSearchParams(window.location.search).get(t);
}
function DY() {
  const [t, e] = D2(
    typeof window < "u" ? new URLSearchParams(window.location.search) : new URLSearchParams()
  );
  return G5(() => {
    const i = () => {
      e(new URLSearchParams(window.location.search));
    };
    window.addEventListener("popstate", i);
    const o = window.history.pushState, c = window.history.replaceState;
    return window.history.pushState = function() {
      o.apply(this, arguments), i();
    }, window.history.replaceState = function() {
      c.apply(this, arguments), i();
    }, () => {
      window.removeEventListener("popstate", i), window.history.pushState = o, window.history.replaceState = c;
    };
  }, []), {
    queryParams: t,
    getParam: (i) => t.get(i),
    hasParam: (i, o) => o ? t.get(i) === o : t.has(i),
    setParam: (i, o) => {
      const c = new URLSearchParams(t);
      c.set(i, o);
      const u = new URL(window.location.href);
      u.search = c.toString(), window.history.pushState({}, "", u.toString()), e(c);
    },
    removeParam: (i) => {
      const o = new URLSearchParams(t);
      o.delete(i);
      const c = new URL(window.location.href);
      c.search = o.toString(), window.history.pushState({}, "", c.toString()), e(o);
    }
  };
}
var pt = typeof globalThis < "u" && globalThis || typeof self < "u" && self || // eslint-disable-next-line no-undef
typeof global < "u" && global || {}, Ht = {
  searchParams: "URLSearchParams" in pt,
  iterable: "Symbol" in pt && "iterator" in Symbol,
  blob: "FileReader" in pt && "Blob" in pt && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in pt,
  arrayBuffer: "ArrayBuffer" in pt
};
function dQ(t) {
  return t && DataView.prototype.isPrototypeOf(t);
}
if (Ht.arrayBuffer)
  var fQ = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], pQ = ArrayBuffer.isView || function(t) {
    return t && fQ.indexOf(Object.prototype.toString.call(t)) > -1;
  };
function al(t) {
  if (typeof t != "string" && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t) || t === "")
    throw new TypeError('Invalid character in header field name: "' + t + '"');
  return t.toLowerCase();
}
function O1(t) {
  return typeof t != "string" && (t = String(t)), t;
}
function B1(t) {
  var e = {
    next: function() {
      var n = t.shift();
      return { done: n === void 0, value: n };
    }
  };
  return Ht.iterable && (e[Symbol.iterator] = function() {
    return e;
  }), e;
}
function st(t) {
  this.map = {}, t instanceof st ? t.forEach(function(e, n) {
    this.append(n, e);
  }, this) : Array.isArray(t) ? t.forEach(function(e) {
    if (e.length != 2)
      throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + e.length);
    this.append(e[0], e[1]);
  }, this) : t && Object.getOwnPropertyNames(t).forEach(function(e) {
    this.append(e, t[e]);
  }, this);
}
st.prototype.append = function(t, e) {
  t = al(t), e = O1(e);
  var n = this.map[t];
  this.map[t] = n ? n + ", " + e : e;
};
st.prototype.delete = function(t) {
  delete this.map[al(t)];
};
st.prototype.get = function(t) {
  return t = al(t), this.has(t) ? this.map[t] : null;
};
st.prototype.has = function(t) {
  return this.map.hasOwnProperty(al(t));
};
st.prototype.set = function(t, e) {
  this.map[al(t)] = O1(e);
};
st.prototype.forEach = function(t, e) {
  for (var n in this.map)
    this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
};
st.prototype.keys = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push(n);
  }), B1(t);
};
st.prototype.values = function() {
  var t = [];
  return this.forEach(function(e) {
    t.push(e);
  }), B1(t);
};
st.prototype.entries = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push([n, e]);
  }), B1(t);
};
Ht.iterable && (st.prototype[Symbol.iterator] = st.prototype.entries);
function Dm(t) {
  if (!t._noBody) {
    if (t.bodyUsed)
      return Promise.reject(new TypeError("Already read"));
    t.bodyUsed = !0;
  }
}
function nC(t) {
  return new Promise(function(e, n) {
    t.onload = function() {
      e(t.result);
    }, t.onerror = function() {
      n(t.error);
    };
  });
}
function hQ(t) {
  var e = new FileReader(), n = nC(e);
  return e.readAsArrayBuffer(t), n;
}
function mQ(t) {
  var e = new FileReader(), n = nC(e), r = /charset=([A-Za-z0-9_-]+)/.exec(t.type), s = r ? r[1] : "utf-8";
  return e.readAsText(t, s), n;
}
function yQ(t) {
  for (var e = new Uint8Array(t), n = new Array(e.length), r = 0; r < e.length; r++)
    n[r] = String.fromCharCode(e[r]);
  return n.join("");
}
function l2(t) {
  if (t.slice)
    return t.slice(0);
  var e = new Uint8Array(t.byteLength);
  return e.set(new Uint8Array(t)), e.buffer;
}
function rC() {
  return this.bodyUsed = !1, this._initBody = function(t) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = t, t ? typeof t == "string" ? this._bodyText = t : Ht.blob && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : Ht.formData && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : Ht.searchParams && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : Ht.arrayBuffer && Ht.blob && dQ(t) ? (this._bodyArrayBuffer = l2(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Ht.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(t) || pQ(t)) ? this._bodyArrayBuffer = l2(t) : this._bodyText = t = Object.prototype.toString.call(t) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof t == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Ht.searchParams && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, Ht.blob && (this.blob = function() {
    var t = Dm(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }), this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var t = Dm(this);
      return t || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else {
      if (Ht.blob)
        return this.blob().then(hQ);
      throw new Error("could not read as ArrayBuffer");
    }
  }, this.text = function() {
    var t = Dm(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return mQ(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(yQ(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, Ht.formData && (this.formData = function() {
    return this.text().then(wQ);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var bQ = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function gQ(t) {
  var e = t.toUpperCase();
  return bQ.indexOf(e) > -1 ? e : t;
}
function Zi(t, e) {
  if (!(this instanceof Zi))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  e = e || {};
  var n = e.body;
  if (t instanceof Zi) {
    if (t.bodyUsed)
      throw new TypeError("Already read");
    this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new st(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, !n && t._bodyInit != null && (n = t._bodyInit, t.bodyUsed = !0);
  } else
    this.url = String(t);
  if (this.credentials = e.credentials || this.credentials || "same-origin", (e.headers || !this.headers) && (this.headers = new st(e.headers)), this.method = gQ(e.method || this.method || "GET"), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal || function() {
    if ("AbortController" in pt) {
      var a = new AbortController();
      return a.signal;
    }
  }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && n)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(n), (this.method === "GET" || this.method === "HEAD") && (e.cache === "no-store" || e.cache === "no-cache")) {
    var r = /([?&])_=[^&]*/;
    if (r.test(this.url))
      this.url = this.url.replace(r, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var s = /\?/;
      this.url += (s.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
Zi.prototype.clone = function() {
  return new Zi(this, { body: this._bodyInit });
};
function wQ(t) {
  var e = new FormData();
  return t.trim().split("&").forEach(function(n) {
    if (n) {
      var r = n.split("="), s = r.shift().replace(/\+/g, " "), a = r.join("=").replace(/\+/g, " ");
      e.append(decodeURIComponent(s), decodeURIComponent(a));
    }
  }), e;
}
function EQ(t) {
  var e = new st(), n = t.replace(/\r?\n[\t ]+/g, " ");
  return n.split("\r").map(function(r) {
    return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r;
  }).forEach(function(r) {
    var s = r.split(":"), a = s.shift().trim();
    if (a) {
      var i = s.join(":").trim();
      try {
        e.append(a, i);
      } catch (o) {
        console.warn("Response " + o.message);
      }
    }
  }), e;
}
rC.call(Zi.prototype);
function $r(t, e) {
  if (!(this instanceof $r))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  if (e || (e = {}), this.type = "default", this.status = e.status === void 0 ? 200 : e.status, this.status < 200 || this.status > 599)
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  this.ok = this.status >= 200 && this.status < 300, this.statusText = e.statusText === void 0 ? "" : "" + e.statusText, this.headers = new st(e.headers), this.url = e.url || "", this._initBody(t);
}
rC.call($r.prototype);
$r.prototype.clone = function() {
  return new $r(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new st(this.headers),
    url: this.url
  });
};
$r.error = function() {
  var t = new $r(null, { status: 200, statusText: "" });
  return t.ok = !1, t.status = 0, t.type = "error", t;
};
var xQ = [301, 302, 303, 307, 308];
$r.redirect = function(t, e) {
  if (xQ.indexOf(e) === -1)
    throw new RangeError("Invalid status code");
  return new $r(null, { status: e, headers: { location: t } });
};
var Ra = pt.DOMException;
try {
  new Ra();
} catch {
  Ra = function(e, n) {
    this.message = e, this.name = n;
    var r = Error(e);
    this.stack = r.stack;
  }, Ra.prototype = Object.create(Error.prototype), Ra.prototype.constructor = Ra;
}
function sC(t, e) {
  return new Promise(function(n, r) {
    var s = new Zi(t, e);
    if (s.signal && s.signal.aborted)
      return r(new Ra("Aborted", "AbortError"));
    var a = new XMLHttpRequest();
    function i() {
      a.abort();
    }
    a.onload = function() {
      var u = {
        statusText: a.statusText,
        headers: EQ(a.getAllResponseHeaders() || "")
      };
      s.url.indexOf("file://") === 0 && (a.status < 200 || a.status > 599) ? u.status = 200 : u.status = a.status, u.url = "responseURL" in a ? a.responseURL : u.headers.get("X-Request-URL");
      var l = "response" in a ? a.response : a.responseText;
      setTimeout(function() {
        n(new $r(l, u));
      }, 0);
    }, a.onerror = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, a.ontimeout = function() {
      setTimeout(function() {
        r(new TypeError("Network request timed out"));
      }, 0);
    }, a.onabort = function() {
      setTimeout(function() {
        r(new Ra("Aborted", "AbortError"));
      }, 0);
    };
    function o(u) {
      try {
        return u === "" && pt.location.href ? pt.location.href : u;
      } catch {
        return u;
      }
    }
    if (a.open(s.method, o(s.url), !0), s.credentials === "include" ? a.withCredentials = !0 : s.credentials === "omit" && (a.withCredentials = !1), "responseType" in a && (Ht.blob ? a.responseType = "blob" : Ht.arrayBuffer && (a.responseType = "arraybuffer")), e && typeof e.headers == "object" && !(e.headers instanceof st || pt.Headers && e.headers instanceof pt.Headers)) {
      var c = [];
      Object.getOwnPropertyNames(e.headers).forEach(function(u) {
        c.push(al(u)), a.setRequestHeader(u, O1(e.headers[u]));
      }), s.headers.forEach(function(u, l) {
        c.indexOf(l) === -1 && a.setRequestHeader(l, u);
      });
    } else
      s.headers.forEach(function(u, l) {
        a.setRequestHeader(l, u);
      });
    s.signal && (s.signal.addEventListener("abort", i), a.onreadystatechange = function() {
      a.readyState === 4 && s.signal.removeEventListener("abort", i);
    }), a.send(typeof s._bodyInit > "u" ? null : s._bodyInit);
  });
}
sC.polyfill = !0;
pt.fetch || (pt.fetch = sC, pt.Headers = st, pt.Request = Zi, pt.Response = $r);
var AQ = self.fetch.bind(self);
const kQ = /* @__PURE__ */ Tq(AQ);
function vQ(t) {
  if (t === 42161)
    return new jm.Standard.Rpc.RpcRelayer(
      "https://a1b4a8c5d856.ngrok.app/",
      t,
      "https://nodes.sequence.app/arbitrum"
    );
  if (t === 8453)
    return new jm.Standard.Rpc.RpcRelayer(
      "https://644a6aeb891e.ngrok.app/",
      t,
      "https://nodes.sequence.app/base"
    );
}
function aC(t, e) {
  var s, a;
  let n = "";
  if (t.env === "local") {
    if (e === 1)
      n = "http://0.0.0.0:9969";
    else if (e === 42161)
      n = "http://0.0.0.0:9997";
    else if (e === 10 || e === 420)
      n = "http://0.0.0.0:9998";
    else if (e === 137)
      n = "http://0.0.0.0:9999";
    else if (e === 8453)
      n = "http://0.0.0.0:9996";
    else
      return "";
    return n;
  }
  const r = t.env === "cors-anywhere" ? "http://localhost:8080/https://" : t.env === "dev" && t.useV3Relayers ? "https://v3-" : t.env === "dev" ? "https://dev-relayer.sequence.app" : "https://";
  return t.useV3Relayers = !0, t.env === "dev" && t.useV3Relayers ? (e === 42161 ? n = "https://v3-arbitrum-relayer.sequence.app" : e === 8453 ? n = "https://v3-base-relayer.sequence.app" : e === 84532 ? n = "https://base-sepolia-relayer.sequence.app" : e === 10 ? n = "https://v3-optimism-relayer.sequence.app" : e === 137 ? n = "https://v3-polygon-relayer.sequence.app" : e === 1 ? n = "https://v3-mainnet-relayer.sequence.app" : e === 33139 ? n = "https://v3-apechain-relayer.sequence.app" : e === 42170 ? n = "https://v3-arbitrum-nova-relayer.sequence.app" : e === 43114 ? n = "https://v3-avalanche-relayer.sequence.app" : e === 8333 ? n = "https://v3-b3-relayer.sequence.app" : e === 81457 ? n = "https://v3-blast-relayer.sequence.app" : e === 100 ? n = "https://v3-gnosis-relayer.sequence.app" : e === 1868 ? n = "https://v3-soneium-relayer.sequence.app" : e === 660279 ? n = "https://v3-xai-relayer.sequence.app" : n = `${r}${(s = ws(e).name) == null ? void 0 : s.replace(" ", "-")}-relayer.sequence.app`, n) : t.env === "dev" && !t.useV3Relayers ? (e === 42161 ? n = "https://dev-arbitrum-relayer.sequence.app" : e === 8453 ? n = "https://dev-base-relayer.sequence.app" : e === 84532 ? n = "https://dev-base-sepolia-relayer.sequence.app" : e === 10 ? n = "https://dev-optimism-relayer.sequence.app" : e === 137 ? n = "https://dev-polygon-relayer.sequence.app" : e === 1 ? n = "https://dev-mainnet-relayer.sequence.app" : e === 33139 ? n = "https://dev-apechain-relayer.sequence.app" : e === 42170 ? n = "https://dev-arbitrum-nova-relayer.sequence.app" : e === 43114 ? n = "https://dev-avalanche-relayer.sequence.app" : e === 8333 ? n = "https://dev-b3-relayer.sequence.app" : e === 81457 ? n = "https://dev-blast-relayer.sequence.app" : e === 100 ? n = "https://dev-gnosis-relayer.sequence.app" : e === 1868 ? n = "https://dev-soneium-relayer.sequence.app" : e === 660279 ? n = "https://dev-xai-relayer.sequence.app" : n = `${r}${(a = ws(e).name) == null ? void 0 : a.replace(" ", "-")}-relayer.sequence.app`, n) : (e === 42161 ? n = `${r}arbitrum-relayer.sequence.app` : e === 10 ? n = `${r}optimism-relayer.sequence.app` : e === 137 ? n = `${r}polygon-relayer.sequence.app` : e === 8453 ? n = `${r}base-relayer.sequence.app` : e === 43114 ? n = `${r}avalanche-relayer.sequence.app` : e === 56 ? n = `${r}bsc-relayer.sequence.app` : e === 1 ? n = `${r}mainnet-relayer.sequence.app` : n = `${r}relayer.sequence.app`, n);
}
function CQ(t, e) {
  const n = ws(e);
  if (!n)
    throw new Error(`Chain with id ${e} not found`);
  const r = n.rpcUrls.default.http[0];
  if (!r)
    throw new Error(`No RPC URL found for chain ${e}`);
  const s = aC(t, e);
  return new jm.Standard.Rpc.RpcRelayer(s, e, r, kQ);
}
function TQ(t) {
  const e = Wu(() => /* @__PURE__ */ new Map(), []);
  return {
    relayers: e,
    getRelayer: (r) => {
      let s = e.get(r);
      return s || (s = CQ(t, r), e.set(r, s)), s;
    },
    getBackupRelayer: vQ
  };
}
const SQ = [{
  type: "function",
  name: "isValidSignature",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }, {
    type: "bytes"
  }],
  outputs: [{
    type: "bytes4"
  }],
  payable: !1,
  stateMutability: "view"
}], OQ = {
  isValidSignatureBytes32: "0x1626ba7e"
};
var BQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: SQ,
  returns: OQ
});
const IQ = [{
  type: "function",
  name: "deploy",
  constant: !1,
  inputs: [{
    type: "address"
  }, {
    type: "bytes32"
  }],
  outputs: [],
  payable: !0,
  stateMutability: "payable"
}];
var PQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: IQ
});
const UQ = [{
  type: "function",
  name: "nonce",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "readNonce",
  constant: !0,
  inputs: [{
    type: "uint256"
  }],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "updateImplementation",
  constant: !1,
  inputs: [{
    type: "address"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "selfExecute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "execute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }, {
    type: "uint256"
  }, {
    type: "bytes"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "createContract",
  inputs: [{
    type: "bytes"
  }],
  payable: !0,
  stateMutability: "payable"
}, {
  type: "function",
  name: "setExtraImageHash",
  constant: !1,
  inputs: [{
    type: "bytes32",
    name: "imageHash"
  }, {
    type: "uint256",
    name: "expiration"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}];
var NQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: UQ
});
const RQ = [{
  type: "function",
  name: "updateImageHash",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "imageHash",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "bytes32"
  }],
  payable: !1,
  stateMutability: "view"
}];
var FQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: RQ
});
const DQ = [{
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookAlreadyExists",
  type: "error"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookDoesNotExist",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "_sender",
    type: "address"
  }, {
    internalType: "address",
    name: "_self",
    type: "address"
  }],
  name: "OnlySelfAuth",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
    indexed: !1,
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    indexed: !1,
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "DefinedHook",
  type: "event"
}, {
  stateMutability: "payable",
  type: "fallback"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "addHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155BatchReceived",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "readHook",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "removeHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  stateMutability: "payable",
  type: "receive"
}];
var MQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: DQ
});
const LQ = [{
  type: "function",
  name: "PROXY_getImplementation",
  inputs: [],
  outputs: [{
    name: "",
    type: "address",
    internalType: "address"
  }],
  stateMutability: "view"
}];
var HQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: LQ
});
const St = {
  erc1271: BQ,
  factory: PQ,
  mainModule: NQ,
  mainModuleUpgradable: FQ,
  moduleHooks: MQ,
  walletProxyHook: HQ
};
function yt() {
  return yt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, yt.apply(null, arguments);
}
function md(t) {
  return Si(["bytes", "uint256", "address", "bytes32"], ["0x1901", t.chainId, t.address, t.digest]);
}
function iC(t) {
  return t.digest !== void 0 && t.chainId !== void 0 && t.address !== void 0;
}
var $Q = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  subdigestOf: md,
  isSignedPayload: iC
});
const _Q = "0x1626ba7e", GQ = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }, {
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}];
async function oC(t, e, n, r) {
  return await new Rr(t, GQ, r).isValidSignature(e, n) === _Q;
}
var zQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isValidEIP1271Signature: oC
});
let ya = /* @__PURE__ */ function(t) {
  return t[t.EIP712 = 1] = "EIP712", t[t.ETH_SIGN = 2] = "ETH_SIGN", t[t.WALLET_BYTES32 = 3] = "WALLET_BYTES32", t;
}({});
function VQ(t) {
  const e = J(t), n = e[e.length - 1];
  return n === ya.EIP712 || n === ya.ETH_SIGN;
}
function yd(t, e) {
  const n = J(e), r = J(t), s = n[n.length - 1], a = G(n.slice(0, 32)), i = G(n.slice(32, 64)), o = Number(G(n.slice(64, 65))), c = {
    r: a,
    s: i,
    v: o
  };
  if (s === ya.EIP712)
    return A0(r, c);
  if (s === ya.ETH_SIGN)
    return A0(ck(r), c);
  throw new Error(`Unsupported signature type: ${s}`);
}
function I1(t, e, n, r) {
  const s = J(n), a = s[s.length - 1];
  if (a === ya.EIP712 || a === ya.ETH_SIGN)
    return t === yd(e, n);
  if (a === ya.WALLET_BYTES32)
    return oC(t, G(e), s.slice(0, -1), r);
  throw new Error(`Unsupported signature type: ${a}`);
}
function jQ(t, e) {
  const n = J(e);
  if (n.length === 66)
    try {
      return yd(t, n);
    } catch {
    }
}
var qQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigType: ya,
  canRecover: VQ,
  recoverSigner: yd,
  isValidSignature: I1,
  tryRecoverSigner: jQ
});
let Ii = /* @__PURE__ */ function(t) {
  return t[t.EOASignature = 0] = "EOASignature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t;
}({});
function P1(t) {
  return t.address !== void 0 && !cC(t);
}
function cC(t) {
  return t.signature !== void 0 && t.weight !== void 0 && t.isDynamic !== void 0;
}
function lC(t) {
  return t.threshold !== void 0 && t.signers !== void 0;
}
function uC(t) {
  const e = J(t), n = e[0] << 8 | e[1], r = [];
  for (let s = 2; s < e.length; ) {
    const a = e[s++], i = e[s++];
    switch (a) {
      case Ii.EOASignature:
        r.push({
          unrecovered: !0,
          weight: i,
          signature: G(e.slice(s, s + 66)),
          isDynamic: !1
        }), s += 66;
        break;
      case Ii.Address:
        r.push({
          weight: i,
          address: ue(G(e.slice(s, s + 20)))
        }), s += 20;
        break;
      case Ii.DynamicSignature:
        const o = ue(G(e.slice(s, s + 20)));
        s += 20;
        const c = e[s] << 8 | e[s + 1];
        s += 2, r.push({
          unrecovered: !0,
          weight: i,
          signature: G(e.slice(s, s + c)),
          address: o,
          isDynamic: !0
        }), s += c;
        break;
      default:
        throw new Error(`Unknown signature part type: ${a}`);
    }
  }
  return {
    version: 1,
    threshold: n,
    signers: r
  };
}
function U1(t) {
  if (Fi(t))
    return G(t);
  const {
    signers: e,
    threshold: n
  } = lC(t) ? t : t.config, r = e.map((s) => {
    if (P1(s))
      return xe(["uint8", "uint8", "address"], [Ii.Address, s.weight, s.address]);
    if (s.isDynamic) {
      const a = J(s.signature);
      return xe(["uint8", "uint8", "address", "uint16", "bytes"], [Ii.DynamicSignature, s.weight, s.address, a.length, a]);
    }
    return xe(["uint8", "uint8", "bytes"], [Ii.EOASignature, s.weight, s.signature]);
  });
  return xe(["uint16", ...new Array(r.length).fill("bytes")], [n, ...r]);
}
async function dC(t, e, n) {
  const r = md(e), s = await Promise.all(t.signers.map(async (a) => {
    if (P1(a))
      return a;
    if (a.isDynamic) {
      if (!a.address) throw new Error("Dynamic signature part must have address");
      if (!I1(a.address, r, a.signature, n))
        throw new Error(`Invalid dynamic signature part ${a.address}`);
      return {
        address: a.address,
        weight: a.weight,
        signature: a.signature
      };
    } else
      return {
        address: yd(r, a.signature),
        weight: a.weight,
        signature: a.signature
      };
  }));
  return {
    version: 1,
    payload: e,
    subdigest: r,
    config: {
      version: 1,
      threshold: t.threshold,
      signers: s
    }
  };
}
function jl(t, e, n, r) {
  if (n.length !== 0)
    throw new Error("Explicit subdigests not supported on v1");
  let s = 0n;
  const a = t.signers.map((o) => {
    if (!e.has(o.address))
      return o;
    const c = e.get(o.address), u = J(c.signature);
    return s += BigInt(o.weight), c.isDynamic || u.length !== 66 ? yt({}, o, {
      isDynamic: !0,
      signature: c.signature,
      address: o.address
    }) : yt({}, o, {
      isDynamic: !1,
      signature: c.signature
    });
  });
  return {
    encoded: U1({
      version: 1,
      threshold: t.threshold,
      signers: a
    }),
    weight: s
  };
}
const N1 = {
  decode: (t) => uC(t),
  encode: (t) => U1(t),
  trim: async (t) => t,
  supportsNoChainId: !0,
  recover: (t, e, n) => dC(t, e, n),
  encodeSigners: (t, e, n, r) => jl(t, e, n),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = N1.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    throw new Error("Signature chaining not supported on v1");
  },
  hashSetImageHash: function(t) {
    throw new Error("Image hash not supported on v1");
  },
  signaturesOf(t) {
    return t.signers.filter((e) => e.signature !== void 0).map((e) => ({
      address: e.address,
      signature: e.signature
    }));
  },
  signaturesOfDecoded: function(t) {
    return t.signers.map((e) => e.signature).filter((e) => e !== void 0);
  }
};
var KQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignaturePartType: Ii,
  isAddressMember: P1,
  isUnrecoveredSignatureMember: cC,
  isUnrecoveredSignature: lC,
  decodeSignature: uC,
  encodeSignature: U1,
  recoverSignature: dC,
  encodeSigners: jl,
  SignatureCoder: N1
});
const R1 = {
  isWalletConfig: (t) => t.version === 1 && t.threshold !== void 0 && t.signers !== void 0,
  imageHashOf: (t) => t.signers.reduce((e, n) => ke(Ot.defaultAbiCoder().encode(["bytes32", "uint8", "address"], [e, n.weight, n.address])), xe(["uint256"], [t.threshold])),
  hasSubdigest: (t, e) => !1,
  isComplete: (t) => !0,
  checkpointOf: (t) => 0n,
  signersOf: (t) => t.signers.map((e) => ({
    address: e.address,
    weight: Number(e.weight)
  })),
  fromSimple: (t) => {
    if (BigInt(t.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (t.subdigests && t.subdigests.length > 0)
      throw new Error("v1 wallet config does not support subdigests");
    return {
      version: 1,
      threshold: t.threshold,
      signers: t.signers
    };
  },
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Bt([...St.mainModule.abi, ...St.mainModuleUpgradable.abi]), a = [];
      return (!r || r === "first") && a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImplementation"), [n.mainModuleUpgradable]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImageHash"), [R1.imageHashOf(e)]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), {
        entrypoint: t,
        transactions: a
      };
    },
    decodeTransaction: function(t) {
      throw new Error("Function not implemented.");
    }
  },
  toJSON: function(t) {
    const e = t.signers.map((n) => ({
      weight: BigInt(n.weight).toString(),
      address: n.address
    }));
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      signers: e
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t), n = e.signers.map((r) => ({
      weight: BigInt(r.weight),
      address: r.address
    }));
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      signers: n
    };
  },
  editConfig: function(t, e) {
    var n;
    const r = t.signers.slice();
    if (e.checkpoint && BigInt(e.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (e.add)
      for (const s of e.add)
        r.find((a) => a.address === s.address) || r.push({
          weight: s.weight,
          address: s.address
        });
    if (e.remove)
      for (const s of e.remove) {
        const a = r.findIndex((i) => i.address === s);
        a >= 0 && r.splice(a, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      signers: r
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = jl(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = t.signers;
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => Number(a) - Number(i))) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = jl(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return jl(t, n, []).encoded;
  }
};
var WQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigCoder: R1
}), QQ = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const fC = 1, pC = {
  version: fC,
  factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
  guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
  mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
  mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var Fa = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: WQ,
  context: QQ,
  signature: KQ,
  version: fC,
  DeployedWalletContext: pC
});
const F1 = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function hC(t) {
  return ke(mC(t));
}
function mC(t) {
  return xe(["bytes32", "bytes32"], [F1, t]);
}
function yC(t) {
  const e = J(t);
  if (e.length === 64 && G(e.slice(0, 32)) === F1)
    return G(e.slice(32, 64));
}
function JQ(t) {
  return yC(t) !== void 0;
}
var ZQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SetImageHashPrefix: F1,
  hashSetImageHash: hC,
  messageSetImageHash: mC,
  decodeMessageSetImageHash: yC,
  isMessageSetImageHash: JQ
});
let ot = /* @__PURE__ */ function(t) {
  return t[t.Legacy = 0] = "Legacy", t[t.Dynamic = 1] = "Dynamic", t[t.NoChainIdDynamic = 2] = "NoChainIdDynamic", t[t.Chained = 3] = "Chained", t;
}({}), qe = /* @__PURE__ */ function(t) {
  return t[t.Signature = 0] = "Signature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t[t.Node = 3] = "Node", t[t.Branch = 4] = "Branch", t[t.Subdigest = 5] = "Subdigest", t[t.Nested = 6] = "Nested", t;
}({});
const mp = 66;
function Xi(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function il(t) {
  return t.tree !== void 0;
}
function bd(t) {
  return t.unrecovered && t.signature !== void 0 && t.isDynamic !== void 0;
}
function yp(t) {
  let e = J(t), n;
  const r = (s, a) => s ? s.right ? {
    left: s,
    right: a
  } : {
    left: s.left,
    right: a
  } : {
    left: a
  };
  for (; e.length > 0; ) {
    const s = e[0];
    switch (e = e.slice(1), s) {
      case qe.Signature:
        {
          const a = e[0], i = G(e.slice(1, mp + 1));
          n = r(n, {
            signature: i,
            weight: a,
            unrecovered: !0,
            isDynamic: !1
          }), e = e.slice(mp + 1);
        }
        break;
      case qe.Address:
        {
          const a = e[0], i = ue(G(e.slice(1, 21)));
          n = r(n, {
            address: i,
            weight: a
          }), e = e.slice(21);
        }
        break;
      case qe.DynamicSignature:
        {
          const a = e[0], i = ue(G(e.slice(1, 21))), o = e[21] << 16 | e[22] << 8 | e[23], c = G(e.slice(24, 24 + o));
          n = r(n, {
            address: i,
            signature: c,
            weight: a,
            unrecovered: !0,
            isDynamic: !0
          }), e = e.slice(24 + o);
        }
        break;
      case qe.Node:
        {
          const a = G(e.slice(0, 32));
          n = r(n, {
            nodeHash: a
          }), e = e.slice(32);
        }
        break;
      case qe.Branch:
        {
          const a = e[0] << 16 | e[1] << 8 | e[2], i = yp(e.slice(3, 3 + a));
          n = r(n, i), e = e.slice(3 + a);
        }
        break;
      case qe.Subdigest:
        {
          const a = G(e.slice(0, 32));
          n = r(n, {
            subdigest: a
          }), e = e.slice(32);
        }
        break;
      case qe.Nested:
        {
          const a = e[0], i = e[1] << 8 | e[2], o = e[3] << 16 | e[4] << 8 | e[5], c = yp(e.slice(6, 6 + o));
          n = r(n, {
            weight: a,
            threshold: i,
            tree: c
          }), e = e.slice(6 + o);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${s}: ${G(e)}`);
    }
  }
  if (!n)
    throw new Error("Empty signature tree");
  return n.right ? n : n.left;
}
class bC extends Error {
  constructor(e) {
    super(`Invalid signature leaf: ${JSON.stringify(e)}`), this.leaf = e;
  }
}
async function Pi(t, e, n) {
  if (Xi(t)) {
    const [r, s] = await Promise.all([Pi(t.left, e, n), Pi(t.right, e, n)]);
    return {
      left: r,
      right: s
    };
  }
  if (il(t))
    return {
      weight: t.weight,
      threshold: t.threshold,
      tree: await Pi(t.tree, e, n)
    };
  if (bd(t))
    if (t.isDynamic) {
      if (!t.address)
        throw new Error("Dynamic signature leaf without address");
      if (!await I1(t.address, e, t.signature, n))
        throw new bC(t);
      return {
        weight: t.weight,
        address: t.address,
        signature: t.signature,
        subdigest: e
      };
    } else
      return {
        weight: t.weight,
        address: yd(e, t.signature),
        signature: t.signature,
        subdigest: e
      };
  return t;
}
const wt = {
  concat: (t, e) => xe(["bytes", "bytes"], [t, e]),
  node: (t) => xe(["uint8", "bytes32"], [qe.Node, t]),
  branch: (t) => {
    const e = J(t);
    return xe(["uint8", "uint24", "bytes"], [qe.Branch, e.length, e]);
  },
  nested: (t, e, n) => {
    const r = J(n);
    return xe(["uint8", "uint8", "uint16", "uint24", "bytes"], [qe.Nested, t, e, r.length, r]);
  },
  subdigest: (t) => xe(["uint8", "bytes32"], [qe.Subdigest, t]),
  signature: (t, e) => xe(["uint8", "uint8", "bytes"], [qe.Signature, t, e]),
  dynamicSignature: (t, e, n) => {
    const r = J(n);
    return xe(["uint8", "uint8", "address", "uint24", "bytes"], [qe.DynamicSignature, t, e, r.length, r]);
  },
  address: (t, e) => xe(["uint8", "uint8", "address"], [qe.Address, t, e])
};
function ql(t, e, n, r, s = {}) {
  const a = Kl(t.tree, e, n, s);
  return BigInt(r) === 0n ? {
    encoded: xe(["uint8", "uint16", "uint32", "bytes"], [ot.NoChainIdDynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : BigInt(t.threshold) > 255n ? {
    encoded: xe(["uint8", "uint16", "uint32", "bytes"], [ot.Dynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : {
    encoded: xe(["uint8", "uint8", "uint32", "bytes"], [ot.Legacy, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  };
}
function Kl(t, e, n, r = {}) {
  const s = !r.disableTrim;
  if (ur(t)) {
    const a = Kl(t.left, e, n), i = Kl(t.right, e, n), o = Kt(t.left), c = Kt(t.right);
    return s && a.weight === 0n && i.weight === 0n && !o && !c ? {
      // We don't need to include anything for this node
      // just the hash will be enough
      encoded: wt.node(Mn(t)),
      weight: 0n
    } : s && i.weight === 0n && !c ? {
      // The right node doesn't have any weight
      // but we still need to include the left node encoded
      encoded: wt.concat(a.encoded, wt.node(Mn(t.right))),
      weight: a.weight
    } : s && a.weight === 0n && !o ? {
      // The left node doesn't have any weight
      // we can just append its hash, but for the right node
      // we need to create a new "branch"
      encoded: wt.concat(wt.node(Mn(t.left)), wt.branch(i.encoded)),
      weight: i.weight
    } : {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: wt.concat(a.encoded, wt.branch(i.encoded)),
      weight: a.weight + i.weight
    };
  }
  if (Cs(t)) {
    const a = Kl(t.tree, e, n);
    return s && a.weight === 0n ? {
      encoded: wt.node(Mn(t)),
      weight: 0n
    } : {
      encoded: wt.nested(t.weight, t.threshold, a.encoded),
      weight: a.weight
    };
  }
  if (Ts(t))
    return {
      encoded: wt.node(Mn(t)),
      weight: 0n
    };
  if (vs(t)) {
    const a = n.includes(t.subdigest);
    return {
      encoded: wt.subdigest(t.subdigest),
      weight: a ? V9 : 0n
    };
  }
  if (Kt(t))
    if (e.has(t.address)) {
      const i = e.get(t.address), o = i.signature;
      return r.forceDynamicEncoding || i.isDynamic ? {
        encoded: wt.dynamicSignature(t.weight, t.address, o),
        weight: BigInt(t.weight)
      } : {
        encoded: wt.signature(t.weight, o),
        weight: BigInt(t.weight)
      };
    } else
      return {
        encoded: wt.address(t.weight, t.address),
        weight: 0n
      };
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(t)}`);
}
function D1(t) {
  return L1(t) ? D1(t.suffix[t.suffix.length - 1]) : t.config;
}
function M1(t) {
  return t.type !== void 0 && t.decoded !== void 0 && t.version !== void 0 && t.version === 2;
}
function gd(t) {
  return t.suffix !== void 0 && Array.isArray(t.suffix) && t.suffix.every(M1);
}
function gC(t) {
  return t.type !== void 0 && t.config !== void 0 && t.digest !== void 0 && t.version !== void 0 && t.version === 2;
}
function L1(t) {
  return t.chain !== void 0 && Array.isArray(t.chain) && t.chain.every(gC);
}
function hh(t) {
  const e = J(t), n = e[0];
  switch (n) {
    case ot.Legacy:
      return {
        version: 2,
        type: ot.Legacy,
        decoded: Sf(e)
      };
    case ot.Dynamic:
      return {
        version: 2,
        type: ot.Dynamic,
        decoded: Sf(e.slice(1))
      };
    case ot.NoChainIdDynamic:
      return {
        version: 2,
        type: ot.NoChainIdDynamic,
        decoded: Sf(e.slice(1))
      };
    case ot.Chained:
      return wC(e);
    default:
      throw new Error(`Invalid signature type: ${n}`);
  }
}
function Sf(t) {
  const e = J(t), n = e[0] << 8 | e[1], r = e[2] << 24 | e[3] << 16 | e[4] << 8 | e[5], s = yp(e.slice(6));
  return {
    threshold: n,
    checkpoint: r,
    tree: s
  };
}
function wC(t) {
  const e = J(t), n = e[0];
  if (n !== ot.Chained)
    throw new Error(`Expected chained signature type: ${n}`);
  const r = [];
  let s = 1;
  for (; s < e.length; ) {
    const o = e[s] << 16 | e[s + 1] << 8 | e[s + 2];
    s += 3;
    const c = hh(e.slice(s, s + o));
    r.push(c), s += o;
  }
  const a = r[0];
  if (gd(a))
    throw new Error("Expected first link of chained signature to be a simple signature (not chained)");
  const i = r.slice(1);
  return yt({}, a, {
    suffix: i
  });
}
function EC(t) {
  return xe(["bytes32", "bytes32"], [Si(["string"], ["SetImageHash(bytes32 imageHash)"]), t]);
}
async function H1(t, e, n) {
  const r = e.subdigest === void 0 ? e : void 0;
  t.type === ot.NoChainIdDynamic && r && (r.chainId = 0);
  const a = r ? md(r) : e.subdigest;
  if (!gd(t)) {
    const l = await Pi(t.decoded.tree, a, n);
    return {
      version: 2,
      type: t.type,
      subdigest: a,
      config: yt({
        version: 2
      }, t.decoded, {
        tree: l
      })
    };
  }
  if (!iC(r))
    throw new Error("Chained signature recovery requires detailed signed payload, subdigest is not enough");
  const i = [];
  let o = r;
  for (const l of [yt({}, t, {
    suffix: void 0
  }), ...t.suffix]) {
    const d = await H1(l, o, n);
    i.unshift(d);
    const m = EC(_1(D1(d)));
    o = yt({}, o, {
      message: m,
      digest: ke(m)
    });
  }
  const c = i[0], u = i.slice(1);
  return yt({}, c, {
    suffix: u
  });
}
function mh(t, e) {
  const r = [t, ...e || []].map((a) => J(ba(a))), s = xe(r.map(() => ["uint24", "bytes"]).flat(), r.map((a) => [a.length, a]).flat());
  return xe(["uint8", "bytes"], [ot.Chained, s]);
}
function ba(t) {
  if (Fi(t)) return G(t);
  if (gd(t) || L1(t))
    return mh(ba(t), (t.suffix || []).map(ba));
  const e = M1(t) ? t.decoded : t.config;
  switch (t.type) {
    case ot.Legacy:
      if (BigInt(e.threshold) > 255n)
        throw new Error(`Legacy signature threshold is too large: ${e.threshold} (max 255)`);
      return Kb(e);
    case ot.NoChainIdDynamic:
    case ot.Dynamic:
      return xe(["uint8", "bytes"], [t.type, Kb(e)]);
    case ot.Chained:
      throw new Error("Unreachable code: Chained signature should be handled above");
    default:
      throw new Error(`Invalid signature type: ${t.type}`);
  }
}
function Kb(t) {
  return xe(["uint16", "uint32", "bytes"], [t.threshold, t.checkpoint, Wl(t.tree)]);
}
function Wl(t) {
  if (ur(t) || Xi(t)) {
    const e = J(Wl(t.right)), n = J(Wl(t.left));
    return ur(t.right) || Xi(t.right) ? xe(["bytes", "uint8", "uint24", "bytes"], [n, qe.Branch, e.length, e]) : xe(["bytes", "bytes"], [n, e]);
  }
  if (Cs(t) || il(t)) {
    const e = J(Wl(t.tree));
    return xe(["uint8", "uint8", "uint16", "uint24", "bytes"], [qe.Nested, t.weight, t.threshold, e.length, e]);
  }
  if (bd(t) || Kt(t) && t.signature !== void 0) {
    const e = J(t.signature);
    if (t.isDynamic || e.length !== mp) {
      if (!t.address) throw new Error("Dynamic signature leaf must have address");
      return xe(["uint8", "uint8", "address", "uint24", "bytes"], [qe.DynamicSignature, t.weight, t.address, e.length, e]);
    } else
      return xe(["uint8", "uint8", "bytes"], [qe.Signature, t.weight, e]);
  }
  if (Kt(t))
    return xe(["uint8", "uint8", "address"], [qe.Address, t.weight, t.address]);
  if (Ts(t))
    return xe(["uint8", "bytes32"], [qe.Node, t.nodeHash]);
  if (vs(t))
    return xe(["uint8", "bytes32"], [qe.Subdigest, t.subdigest]);
  throw new Error(`Unknown signature tree type: ${t}`);
}
function Ql(t) {
  return ur(t) ? [...Ql(t.left), ...Ql(t.right)] : Cs(t) ? Ql(t.tree) : Kt(t) && t.signature ? [{
    address: t.address,
    signature: t.signature
  }] : [];
}
function Jl(t) {
  return Xi(t) ? [...Jl(t.left), ...Jl(t.right)] : il(t) ? Jl(t.tree) : bd(t) ? [t.signature] : [];
}
function Of(t) {
  return Xi(t) ? [...Of(t.left), ...Of(t.right)] : il(t) ? Of(t.tree) : vs(t) ? [t.subdigest] : [];
}
async function bp(t) {
  const e = typeof t == "string" ? hh(t) : t;
  if (gd(e)) {
    const r = await Promise.all([bp(yt({}, e, {
      suffix: void 0
    })), ...e.suffix.map((s) => bp(s))]);
    return mh(r[0], r.slice(1));
  }
  const {
    trimmed: n
  } = await Zl(e.decoded.tree);
  return ba(yt({}, e, {
    decoded: yt({}, e.decoded, {
      tree: n
    })
  }));
}
async function Zl(t, e = !0) {
  if (Xi(t)) {
    const [n, r] = await Promise.all([Zl(t.left), Zl(t.right)]);
    if (n.weight === 0 && r.weight === 0)
      try {
        const s = await Pi(t, Hf, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: Mn(s)
          }
        };
      } catch {
      }
    else
      return {
        weight: n.weight + r.weight,
        trimmed: {
          left: n.trimmed,
          right: r.trimmed
        }
      };
  }
  if (il(t)) {
    const n = await Zl(t.tree);
    if (n.weight === 0)
      try {
        const r = await Pi(t, Hf, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: Mn(r)
          }
        };
      } catch {
      }
    return {
      weight: n.weight,
      trimmed: {
        weight: t.weight,
        threshold: t.threshold,
        tree: n.trimmed
      }
    };
  }
  return Ts(t) && kC(t.nodeHash) ? {
    weight: 0,
    trimmed: yt({}, AC(t.nodeHash))
  } : bd(t) || Kt(t) && t.signature !== void 0 ? {
    weight: Number(t.weight),
    trimmed: t
  } : !e && vs(t) ? {
    weight: 1 / 0,
    trimmed: t
  } : {
    weight: 0,
    trimmed: t
  };
}
const yh = {
  decode: (t) => hh(t),
  encode: (t) => ba(t),
  trim: (t) => bp(t),
  supportsNoChainId: !0,
  recover: (t, e, n) => H1(t, e, n),
  encodeSigners: (t, e, n, r) => ql(t, e, n, r),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = yh.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    const n = e.reverse(), r = Fi(t) ? t : ba(t), s = n.map((a) => Fi(a) ? a : ba(a));
    return mh(r, s);
  },
  hashSetImageHash: function(t) {
    return hC(t);
  },
  signaturesOf(t) {
    return Ql(t.tree);
  },
  signaturesOfDecoded: function(t) {
    return Jl(t.decoded.tree);
  }
};
var XQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignatureType: ot,
  SignaturePartType: qe,
  SignaturePartTypeLength: mp,
  isUnrecoveredNode: Xi,
  isUnrecoveredNestedLeaf: il,
  isUnrecoveredSignatureLeaf: bd,
  decodeSignatureTree: yp,
  InvalidSignatureLeafError: bC,
  recoverTopology: Pi,
  partEncoder: wt,
  encodeSigners: ql,
  encodeTree: Kl,
  deepestConfigOfSignature: D1,
  isUnrecoveredSignature: M1,
  isUnrecoveredChainedSignature: gd,
  isSignature: gC,
  isChainedSignature: L1,
  decodeSignature: hh,
  decodeSignatureBody: Sf,
  decodeChainedSignature: wC,
  setImageHashStruct: EC,
  recoverSignature: H1,
  encodeChain: mh,
  encodeSignature: ba,
  encodeSignatureBody: Kb,
  encodeSignatureTree: Wl,
  signaturesOf: Ql,
  signaturesOfDecoded: Jl,
  subdigestsOfDecoded: Of,
  trimSignature: bp,
  trimUnrecoveredTree: Zl,
  SignatureCoder: yh
});
function Kt(t) {
  return t.address !== void 0 && t.weight !== void 0;
}
function vs(t) {
  return t.subdigest !== void 0 && t.address === void 0;
}
function Xl(t) {
  return ur(t) ? JSON.stringify({
    left: Xl(t.left),
    right: Xl(t.right)
  }) : Cs(t) ? JSON.stringify({
    weight: BigInt(t.weight).toString(),
    threshold: BigInt(t.threshold).toString(),
    tree: Xl(t.tree)
  }) : Kt(t) ? JSON.stringify({
    address: t.address,
    weight: BigInt(t.weight).toString()
  }) : JSON.stringify(t);
}
function Yl(t) {
  const e = typeof t == "string" ? JSON.parse(t) : t;
  return e.left !== void 0 && e.right !== void 0 ? {
    left: Yl(e.left),
    right: Yl(e.right)
  } : e.weight !== void 0 && e.threshold !== void 0 && e.tree !== void 0 ? {
    weight: BigInt(e.weight),
    threshold: BigInt(e.threshold),
    tree: Yl(e.tree)
  } : e.address !== void 0 && e.weight !== void 0 ? {
    address: e.address,
    weight: BigInt(e.weight)
  } : e;
}
function Cs(t) {
  return t.tree !== void 0 && t.weight !== void 0 && t.threshold !== void 0;
}
function Ts(t) {
  return t.nodeHash !== void 0;
}
function $1(t) {
  return Kt(t) || vs(t) || Cs(t) || Ts(t);
}
function ur(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function YQ(t) {
  return ur(t) || $1(t);
}
function xC(t) {
  return xe(["uint96", "address"], [t.weight, t.address]);
}
function AC(t) {
  const e = J(t);
  if (e.length !== 32)
    throw new Error("Invalid encoded string length");
  const n = BigInt(G(e.slice(0, 12))), r = ue(G(e.slice(12)));
  return {
    weight: n,
    address: r
  };
}
function kC(t) {
  const e = J(t);
  return e.length !== 32 ? !1 : e.slice(0, 11).every((r) => r === 0);
}
function Mn(t) {
  if (Kt(t))
    return xC(t);
  if (vs(t))
    return Si(["string", "bytes32"], [`Sequence static digest:
`, t.subdigest]);
  if (Cs(t)) {
    const e = Mn(t.tree);
    return Si(["string", "bytes32", "uint256", "uint256"], [`Sequence nested config:
`, e, t.threshold, t.weight]);
  }
  return Ts(t) ? t.nodeHash : Si(["bytes32", "bytes32"], [Mn(t.left), Mn(t.right)]);
}
function eJ(t) {
  const e = [];
  let n = t;
  for (; !$1(n); )
    e.unshift(n.right), n = n.left;
  return e.unshift(n), e;
}
function tJ(t) {
  return t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && t.version !== void 0 && t.version === 2;
}
function _1(t) {
  return Si(["bytes32", "uint256"], [Si(["bytes32", "uint256"], [Mn(t.tree), t.threshold]), t.checkpoint]);
}
function vC(t) {
  return t.threshold !== void 0 && t.weight !== void 0 && t.members !== void 0;
}
function So(t) {
  return Kt(t) || vs(t) ? [t] : Cs(t) ? [{
    threshold: t.threshold,
    weight: t.weight,
    members: So(t.tree)
  }] : Ts(t) ? [] : [...So(t.left), ...So(t.right)];
}
function Wb(t) {
  return Ts(t) ? !0 : ur(t) ? Wb(t.left) || Wb(t.right) : !1;
}
function nJ(t) {
  return {
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    members: So(t.tree)
  };
}
const CC = (t, e) => t.map((n) => vC(n) ? {
  tree: e(n.members),
  threshold: n.threshold,
  weight: n.weight
} : n);
function G1(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  return CC(t, G1).reduce((n, r) => ({
    left: n,
    right: r
  }));
}
function z1(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  const e = CC(t, z1);
  for (let n = e.length; n > 1; n = n / 2)
    for (let r = 0; r < n / 2; r++) {
      const s = r * 2, a = s + 1;
      a >= n ? e[r] = e[s] : e[r] = {
        left: e[s],
        right: e[a]
      };
    }
  return e[0];
}
function V1(t) {
  return t.length > 8 ? z1(t) : G1(t);
}
function TC(t, e = V1) {
  return {
    version: 2,
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    tree: e(t.members)
  };
}
function gp(t, e) {
  return vs(t) ? t.subdigest === e : ur(t) ? gp(t.left, e) || gp(t.right, e) : !1;
}
function Qb(t) {
  const e = [t], n = /* @__PURE__ */ new Set();
  for (; e.length > 0; ) {
    const r = e.pop();
    Cs(r) ? e.push(r.tree) : ur(r) ? (e.push(r.left), e.push(r.right)) : Kt(r) && n.add({
      address: r.address,
      weight: Number(r.weight)
    });
  }
  return Array.from(n);
}
function wp(t) {
  return ur(t) ? wp(t.left) && wp(t.right) : !Ts(t);
}
const bh = {
  isWalletConfig: (t) => t.version === 2 && t.threshold !== void 0 && t.tree !== void 0,
  imageHashOf: (t) => _1(t),
  hasSubdigest: (t, e) => gp(t.tree, e),
  checkpointOf: (t) => BigInt(t.checkpoint),
  signersOf: (t) => Qb(t.tree),
  fromSimple: (t) => {
    var e;
    return TC(yt({}, t, {
      members: [...t.signers, ...((e = t.subdigests) != null ? e : []).map((n) => ({
        subdigest: n
      }))]
    }));
  },
  isComplete: (t) => wp(t.tree),
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Bt(St.mainModuleUpgradable.abi);
      return {
        entrypoint: t,
        transactions: [{
          to: t,
          data: s.encodeFunctionData(s.getFunction("updateImageHash"), [bh.imageHashOf(e)]),
          gasLimit: 0,
          delegateCall: !1,
          revertOnError: !0,
          value: 0
        }]
      };
    },
    decodeTransaction: function(t) {
      var e, n, r, s;
      const a = new Bt(St.mainModuleUpgradable.abi);
      if (t.transactions.length !== 1)
        throw new Error("Invalid transaction bundle, expected 1 transaction");
      const i = t.transactions[0].data;
      if (!i)
        throw new Error("Invalid transaction bundle, expected data");
      const o = a.decodeFunctionData(a.getFunction("updateImageHash"), i);
      if (!o)
        throw new Error("Invalid transaction bundle, expected valid data");
      if (t.transactions[0].to !== t.entrypoint)
        throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
      if (t.transactions[0].delegateCall)
        throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
      if (!t.transactions[0].revertOnError)
        throw new Error("Invalid transaction bundle, expected revertOnError");
      if (BigInt((e = (n = t.transactions[0]) == null ? void 0 : n.value) != null ? e : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      if (BigInt((r = (s = t.transactions[0]) == null ? void 0 : s.gasLimit) != null ? r : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      return {
        address: t.entrypoint,
        newImageHash: o[0],
        kind: void 0
      };
    }
  },
  toJSON: function(t) {
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      checkpoint: BigInt(t.checkpoint).toString(),
      tree: Xl(t.tree)
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t);
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      checkpoint: BigInt(e.checkpoint),
      tree: Yl(e.tree)
    };
  },
  editConfig: function(t, e) {
    var n, r;
    const s = So(t.tree);
    if (e.add)
      for (const a of e.add)
        s.find((i) => Kt(i) && i.address === a.address) || s.push({
          address: a.address,
          weight: a.weight
        });
    if (e.remove)
      for (const a of e.remove) {
        const i = s.findIndex((o) => Kt(o) && o.address === a);
        i >= 0 && s.splice(i, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      checkpoint: (r = e.checkpoint) != null ? r : t.checkpoint,
      tree: V1(s)
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = ql(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = Qb(t.tree);
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => a - i)) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = ql(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return ql(t, n, [], 0).encoded;
  }
};
var rJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSignerLeaf: Kt,
  isSubdigestLeaf: vs,
  topologyToJSON: Xl,
  topologyFromJSON: Yl,
  isNestedLeaf: Cs,
  isNodeLeaf: Ts,
  isLeaf: $1,
  isNode: ur,
  isTopology: YQ,
  encodeSignerLeaf: xC,
  decodeSignerLeaf: AC,
  isEncodedSignerLeaf: kC,
  hashNode: Mn,
  leftFace: eJ,
  isWalletConfig: tJ,
  imageHash: _1,
  isSimpleNestedMember: vC,
  topologyToMembers: So,
  hasUnknownNodes: Wb,
  toSimpleWalletConfig: nJ,
  legacyTopologyBuilder: G1,
  merkleTopologyBuilder: z1,
  optimized2SignersTopologyBuilder: V1,
  toWalletConfig: TC,
  hasSubdigest: gp,
  signersOf: Qb,
  isComplete: wp,
  ConfigCoder: bh
}), sJ = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const aJ = {
  config: bh,
  signature: yh
}, SC = 2, OC = {
  version: SC,
  factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
  guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
  mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
  mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3",
  proxyImplementationHook: "0x1f56dbAD5e8319F0DE9a323E24A31b5077dEB1a4"
};
var de = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: rJ,
  signature: XQ,
  context: sJ,
  chained: ZQ,
  coders: aJ,
  version: SC,
  DeployedWalletContext: OC
}), iJ = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function Jb(t, e) {
  const n = ke(xe(["bytes", "bytes32"], [t.walletCreationCode, hn(t.mainModule, 32)])), r = ke(xe(["bytes1", "address", "bytes32", "bytes32"], ["0xff", t.factory, e, n]));
  return ue(ze(r, 12));
}
async function oJ(t, e, n, r, s, a) {
  return (await Promise.all(BJ.map(async (o) => {
    try {
      const c = o.signature.SignatureCoder.decode(G(n)), u = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: G(e),
        chainId: r
      }, s), l = o.config.ConfigCoder.imageHashOf(u.config);
      if (Jb(a[o.version], l).toLowerCase() === t.toLowerCase())
        return !0;
      const m = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: G(e),
        chainId: r
      }, s), h = o.config.ConfigCoder.imageHashOf(m.config);
      return Jb(a[o.version], h).toLowerCase() === t.toLowerCase();
    } catch {
    }
    return !1;
  }))).some((o) => o);
}
function cJ(t) {
  const e = Object.keys(t).length;
  for (let n = 1; n <= e; n++) {
    const r = t[n];
    if (!r || r.version !== n)
      return !1;
  }
  return !0;
}
function lJ(t) {
  const e = Object.keys(t).length;
  return t[e];
}
const uJ = {
  1: pC,
  2: OC
};
var dJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addressOf: Jb,
  isValidCounterfactual: oJ,
  isValidVersionedContext: cJ,
  latestContext: lJ,
  defaultContexts: uJ
});
const gh = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function fJ(t, e, n, r) {
  return yt({}, t, {
    chainId: n,
    intent: {
      id: r,
      wallet: e
    }
  });
}
function pJ(t) {
  return ke(Ot.defaultAbiCoder().encode(["address", "uint256", "bytes32"], [t.intent.wallet, t.chainId, t.intent.id]));
}
function hJ(t) {
  const e = Ot.defaultAbiCoder().decode(["uint256", gh], t);
  if (e.length !== 2 || !e[0] || !e[1]) throw new Error("Invalid meta transaction data");
  return [e[0], e[1]];
}
function BC(t, e) {
  return Ot.defaultAbiCoder().encode(["uint256", gh], [t, Ou(e)]);
}
function IC(t, e) {
  return ke(BC(t, e));
}
function mJ(t, e, n, r) {
  return md({
    address: t,
    chainId: e,
    digest: IC(n, r)
  });
}
function yJ(t, e, n) {
  return md({
    address: t,
    chainId: e,
    digest: ke(Ot.defaultAbiCoder().encode(["string", gh], ["guest:", Ou(n)]))
  });
}
function PC(t, e) {
  return e.map((n) => j1(t, n));
}
function j1(t, e) {
  if (e.to && e.to !== ka)
    return {
      nonce: eu(e.nonce) ? void 0 : BigInt(e.nonce),
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: eu(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise
        // Keeping this as is for now so we don't have to change everything to async
        to: e.to,
        value: BigInt(e.value || 0),
        data: e.data || "0x"
      }
    };
  {
    const n = new Bt(St.mainModule.abi), r = n.encodeFunctionData(n.getFunction("createContract"), [e.data]);
    return {
      nonce: typeof e.nonce == "number" ? BigInt(e.nonce) : void 0,
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: eu(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        to: t,
        value: BigInt(e.value || 0),
        data: r
      }
    };
  }
}
function wh(t) {
  return t.delegateCall !== void 0 || t.revertOnError !== void 0;
}
function UC(t) {
  return t.every(wh);
}
function Ou(t) {
  return t.map((e) => {
    var n;
    return {
      delegateCall: e.delegateCall === !0,
      revertOnError: e.revertOnError === !0,
      gasLimit: eu(e.gasLimit) ? 0n : BigInt(e.gasLimit),
      target: (n = e.to) != null ? n : ka,
      value: eu(e.value) ? 0n : e.value,
      data: e.data || "0x"
    };
  });
}
function bJ(t) {
  return t.map((e) => ({
    delegateCall: e.delegateCall,
    revertOnError: e.revertOnError,
    gasLimit: e.gasLimit,
    to: e.target,
    value: e.value,
    data: e.data
  }));
}
function gJ(t, e) {
  const n = BigInt(t), r = BigInt(e), s = 2n ** 96n;
  if (r / s !== 0n)
    throw new Error("Space already encoded");
  return r + n * s;
}
function wJ(t) {
  const e = BigInt(t), n = 2n ** 96n;
  return [e / n, e % n];
}
function EJ(t, e) {
  return Array.isArray(e) ? UC(e) ? e : PC(t, e).map((r) => r.transaction) : wh(e) ? [e] : [j1(t, e).transaction];
}
function NC(t) {
  return t !== void 0 && t.entrypoint !== void 0 && t.chainId !== void 0 && t.transactions !== void 0 && t.nonce !== void 0 && t.intent !== void 0 && t.intent.id !== void 0 && t.intent.wallet !== void 0 && Array.isArray(t.transactions) && t.transactions.reduce((e, n) => e && wh(n), !0);
}
function RC(t) {
  return t !== void 0 && t.signature !== void 0 && t.signature !== "" && NC(t);
}
function xJ(t) {
  const e = new Bt(St.mainModule.abi);
  return e.encodeFunctionData(e.getFunction("execute"), RC(t) ? [
    // Signed transaction bundle has all 3 parameters
    Ou(t.transactions),
    t.nonce,
    t.signature
  ] : [
    // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
    Ou(t.transactions),
    0,
    new Uint8Array([])
  ]);
}
const FC = "0x61c2926c", DC = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`, Zb = (t, e) => {
  const n = [], r = new Bt(St.mainModule.abi);
  for (const s of e) {
    const a = J(s.data || "0x");
    if (s.to === t && G(a.slice(0, 4)) === FC) {
      const i = a.slice(4), o = Ot.defaultAbiCoder().decode([DC], i)[0];
      n.push(...Zb(s.to, o.map((c) => yt({}, c, {
        to: c.target
      }))));
    } else
      try {
        const i = r.decodeFunctionData("execute", a)[0], o = Zb(t, i.map((c) => yt({}, c.toObject(), {
          to: c.target
        })));
        n.push(...o);
      } catch {
        n.push(s);
      }
  }
  return n;
}, eu = (t) => t == null;
var AJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MetaTransactionsType: gh,
  intendTransactionBundle: fJ,
  intendedTransactionID: pJ,
  unpackMetaTransactionsData: hJ,
  packMetaTransactionsData: BC,
  digestOfTransactions: IC,
  subdigestOfTransactions: mJ,
  subdigestOfGuestModuleTransactions: yJ,
  toSequenceTransactions: PC,
  toSequenceTransaction: j1,
  isSequenceTransaction: wh,
  hasSequenceTransactions: UC,
  sequenceTxAbiEncode: Ou,
  fromTxAbiEncode: bJ,
  encodeNonce: gJ,
  decodeNonce: wJ,
  fromTransactionish: EJ,
  isTransactionBundle: NC,
  isSignedTransactionBundle: RC,
  encodeBundleExecData: xJ,
  selfExecuteSelector: FC,
  selfExecuteAbi: DC,
  unwind: Zb
});
const MC = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033", kJ = "0x6492649264926492649264926492649264926492649264926492649264926492";
async function LC(t, e, n, r) {
  try {
    return await t.call({
      data: Le([MC, Ot.defaultAbiCoder().encode(["address", "bytes32", "bytes"], [e, n, r])])
    }) === "0x01";
  } catch {
    return !1;
  }
}
var vJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE: MC,
  EIP_6492_SUFFIX: kJ,
  validateEIP6492Offchain: LC
});
class CJ {
  constructor(e) {
    this.provider = e, this.isDeployedCache = /* @__PURE__ */ new Set();
  }
  module(e) {
    return new Rr(e, [...St.mainModuleUpgradable.abi, ...St.mainModule.abi, ...St.erc1271.abi], this.provider);
  }
  async isDeployed(e) {
    if (this.isDeployedCache.has(e))
      return !0;
    const r = (await this.provider.getCode(e).then((s) => J(s))).length !== 0;
    return r && this.isDeployedCache.add(e), r;
  }
  async implementation(e) {
    const n = Ot.defaultAbiCoder().encode(["address"], [e]), r = await this.provider.getStorage(e, n).then((s) => J(s));
    if (r.length === 20)
      return ue(G(r));
    if (r.length === 32)
      return Ot.defaultAbiCoder().decode(["address"], r)[0];
  }
  async imageHash(e) {
    try {
      return await this.module(e).imageHash();
    } catch {
    }
  }
  async nonce(e, n = 0) {
    try {
      return await this.module(e).readNonce(n);
    } catch (r) {
      if (!await this.isDeployed(e))
        return 0;
      throw r;
    }
  }
  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(e, n, r) {
    return LC(this.provider, e, n, r);
  }
}
var TJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  OnChainReader: CJ
});
function SJ(t) {
  return t && t.address && t.digest && t.chainId !== void 0 && t.config;
}
var re = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: iJ,
  signature: $Q,
  context: dJ,
  signer: qQ,
  EIP1271: zQ,
  transaction: AJ,
  reader: TJ,
  EIP6492: vJ,
  isWalletSignRequestMetadata: SJ
});
const Xb = [{
  config: R1,
  signature: N1
}, {
  config: bh,
  signature: yh
}];
function HC(t) {
  const e = t - 1;
  if (e < 0 || e >= Xb.length)
    throw new Error(`No coder for version: ${t}`);
  return Xb[e];
}
function OJ(t) {
  return HC(t);
}
var _t = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALL_CODERS: Xb,
  coderFor: HC,
  genericCoderFor: OJ
});
const BJ = [Fa, de];
function IJ(t, e, n) {
  for (let r = 0; r < n.length; r++)
    if (re.context.addressOf(n[r], e) === t)
      return n[r].version;
  throw new Error("Could not find version for counterfactual address");
}
var PJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  counterfactualVersion: IJ
});
class UJ {
  constructor() {
    this.version = 2, this.configCoder = de.config.ConfigCoder, this.signatureCoder = de.signature.SignatureCoder;
  }
  buildTransaction(e, n, r) {
    if (!de.config.ConfigCoder.isWalletConfig(r)) {
      const c = de.config.toWalletConfig({
        threshold: r.threshold,
        members: r.signers,
        checkpoint: 0
      });
      return this.buildTransaction(e, n, c);
    }
    const s = n[2], a = new Bt(St.mainModule.abi), i = de.config.ConfigCoder.update.buildTransaction(e, r, s, "first");
    return {
      tx: {
        entrypoint: e,
        nonce: re.transaction.encodeNonce(Yb, 0),
        transactions: [{
          to: e,
          value: 0,
          gasLimit: 0,
          revertOnError: !0,
          delegateCall: !1,
          data: a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable])
        }, ...i.transactions]
      },
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: r
    };
  }
  decodeTransaction(e, n) {
    const r = e.entrypoint;
    if (e.transactions.length < 2)
      throw new Error("Invalid transaction bundle size");
    if (!e.nonce || re.transaction.encodeNonce(Yb, 0) !== BigInt(e.nonce))
      throw new Error("Invalid transaction bundle nonce");
    if (e.transactions[0].to !== r || e.transactions[1].to !== r || e.transactions[0].delegateCall || e.transactions[1].delegateCall || !e.transactions[0].revertOnError || !e.transactions[1].revertOnError || e.transactions[0].value && BigInt(e.transactions[0].value) !== 0n || e.transactions[1].value && BigInt(e.transactions[1].value) !== 0n || e.transactions[0].gasLimit && BigInt(e.transactions[0].gasLimit) !== 0n || e.transactions[1].gasLimit && BigInt(e.transactions[1].gasLimit) !== 0n)
      throw new Error("Invalid transaction bundle format");
    const s = n[2], a = new Bt(St.mainModule.abi), i = G(e.transactions[0].data || new Uint8Array()), o = G(a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable]));
    if (i !== o)
      throw new Error("Invalid new implementation on transaction");
    const c = de.config.ConfigCoder.update.decodeTransaction({
      entrypoint: r,
      transactions: [e.transactions[1]]
    });
    if (c.address !== r)
      throw new Error("Invalid transaction bundle address");
    return c;
  }
}
const Yb = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb", $C = new UJ();
var NJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE: Yb,
  v1v2: $C
});
function eg() {
  return eg = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, eg.apply(null, arguments);
}
function RJ(t) {
  for (const [e, n] of Object.entries(t))
    if (e !== String(n.version - 1))
      throw new Error(`Migration with key ${e} has version ${n.version}, expected version to be key + 1`);
}
class FJ {
  constructor(e, n, r) {
    this.tracker = e, this.migrations = n, this.contexts = r, RJ(n);
  }
  lastMigration() {
    let e;
    for (const n of Object.values(this.migrations))
      (e === void 0 || n.version > e.version) && (e = n);
    if (e === void 0)
      throw new Error("No migrations");
    return e;
  }
  async getAllMigratePresignedTransaction(e) {
    const {
      address: n,
      fromImageHash: r,
      fromVersion: s,
      chainId: a
    } = e;
    let i = r, o = s;
    const c = Object.values(this.contexts), u = [];
    for (let l = 1; l < c.length; l++) {
      const d = await this.tracker.getMigration(n, i, o, a);
      if (!d) return {
        signedMigrations: u,
        missing: !0,
        lastImageHash: i,
        lastVersion: o
      };
      u.push(d);
      const m = this.migrations[o];
      if (!m)
        throw new Error(`No migration found for version ${o}`);
      const h = m.decodeTransaction(d.tx, this.contexts);
      if (h.address !== n)
        throw new Error("Migration transaction address does not match expected address");
      i = h.newImageHash, o += 1;
    }
    return {
      signedMigrations: u,
      missing: !1,
      lastImageHash: i,
      lastVersion: o
    };
  }
  async signNextMigration(e, n, r, s) {
    const a = this.migrations[n];
    if (!a)
      return;
    const i = a.buildTransaction(e, this.contexts, s), o = await r.signTransactionBundle(i.tx);
    return eg({}, i, {
      tx: o
    });
  }
}
var u2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Migrator: FJ
});
const DJ = {
  1: $C
};
var d2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultMigrations: DJ
});
function Oo() {
  return Oo = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Oo.apply(null, arguments);
}
const q1 = "Webrpc", _C = "webrpc@v0.24.0;gen-typescript@v0.16.3;sequence-relayer@v0.4.1", MJ = "v1", LJ = "v0.4.1", HJ = "fdce30970483936652aaeabaf9339a302ac52d32";
function $J(t) {
  const e = t.get(q1);
  return e ? _J(e) : {
    webrpcGenVersion: "",
    codeGenName: "",
    codeGenVersion: "",
    schemaName: "",
    schemaVersion: ""
  };
}
function _J(t) {
  const e = t.split(";");
  if (e.length < 3)
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: ""
    };
  const [n, r] = e[0].split("@"), [s, a] = e[1].split("@"), [i, o] = e[2].split("@");
  return {
    webrpcGenVersion: r ?? "",
    codeGenName: s ?? "",
    codeGenVersion: a ?? "",
    schemaName: i ?? "",
    schemaVersion: o ?? ""
  };
}
let da = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.DROPPED = "DROPPED", t.QUEUED = "QUEUED", t.SENT = "SENT", t.SUCCEEDED = "SUCCEEDED", t.PARTIALLY_FAILED = "PARTIALLY_FAILED", t.FAILED = "FAILED", t;
}({}), GJ = /* @__PURE__ */ function(t) {
  return t.SEND = "SEND", t.RECEIVE = "RECEIVE", t.BRIDGE_DEPOSIT = "BRIDGE_DEPOSIT", t.BRIDGE_WITHDRAW = "BRIDGE_WITHDRAW", t.BURN = "BURN", t.UNKNOWN = "UNKNOWN", t;
}({}), zJ = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.ERC20_TOKEN = "ERC20_TOKEN", t.ERC1155_TOKEN = "ERC1155_TOKEN", t;
}({}), VJ = /* @__PURE__ */ function(t) {
  return t.DESC = "DESC", t.ASC = "ASC", t;
}({});
class GC {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Relayer/", this.ping = (r, s) => this.fetch(this.url("Ping"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getSequenceContext = (r, s) => this.fetch(this.url("GetSequenceContext"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      data: i.data
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getChainID = (r, s) => this.fetch(this.url("GetChainID"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      chainID: i.chainID
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.sendMetaTxn = (r, s, a) => this.fetch(this.url("SendMetaTxn"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      txnHash: o.txnHash
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNonce = (r, s, a) => this.fetch(this.url("GetMetaTxnNonce"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnReceipt = (r, s, a) => this.fetch(this.url("GetMetaTxnReceipt"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      receipt: o.receipt
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.simulate = (r, s, a) => this.fetch(this.url("Simulate"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      results: o.results
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateMetaTxnGasLimits = (r, s, a) => this.fetch(this.url("UpdateMetaTxnGasLimits"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      payload: o.payload
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.feeTokens = (r, s) => this.fetch(this.url("FeeTokens"), Be({}, r, s)).then((a) => Ie(a).then((i) => ({
      isFeeRequired: i.isFeeRequired,
      tokens: i.tokens
    })), (a) => {
      throw Se.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.feeOptions = (r, s, a) => this.fetch(this.url("FeeOptions"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      options: o.options,
      sponsored: o.sponsored,
      quote: o.quote
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNetworkFeeOptions = (r, s, a) => this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      options: o.options
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTransactions = (r, s, a) => this.fetch(this.url("GetMetaTransactions"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTransactionCost = (r, s, a) => this.fetch(this.url("GetTransactionCost"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      cost: o.cost
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.sentTransactions = (r, s, a) => this.fetch(this.url("SentTransactions"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.pendingTransactions = (r, s, a) => this.fetch(this.url("PendingTransactions"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTank = (r, s, a) => this.fetch(this.url("GetGasTank"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasTank = (r, s, a) => this.fetch(this.url("AddGasTank"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasTank = (r, s, a) => this.fetch(this.url("UpdateGasTank"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.nextGasTankBalanceAdjustmentNonce = (r, s, a) => this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustGasTankBalance = (r, s, a) => this.fetch(this.url("AdjustGasTankBalance"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      adjustment: o.adjustment
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTankBalanceAdjustment = (r, s, a) => this.fetch(this.url("GetGasTankBalanceAdjustment"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      adjustment: o.adjustment
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasTankBalanceAdjustments = (r, s, a) => this.fetch(this.url("ListGasTankBalanceAdjustments"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      adjustments: o.adjustments
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasSponsors = (r, s, a) => this.fetch(this.url("ListGasSponsors"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasSponsor = (r, s, a) => this.fetch(this.url("GetGasSponsor"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasSponsor = (r, s, a) => this.fetch(this.url("AddGasSponsor"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasSponsor = (r, s, a) => this.fetch(this.url("UpdateGasSponsor"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.removeGasSponsor = (r, s, a) => this.fetch(this.url("RemoveGasSponsor"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addressGasSponsors = (r, s, a) => this.fetch(this.url("AddressGasSponsors"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getProjectBalance = (r, s, a) => this.fetch(this.url("GetProjectBalance"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustProjectBalance = (r, s, a) => this.fetch(this.url("AdjustProjectBalance"), Be(r, s, a)).then((i) => Ie(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Se.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const Be = (t = {}, e = {}, n = null) => {
  const r = Oo({}, e, {
    "Content-Type": "application/json"
  });
  return r[q1] = _C, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, Ie = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), K1.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (h5[r] || be).new(n);
  }
  return n;
});
let be = class zC extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, zC.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, VC = class jC extends be {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, jC.prototype);
  }
}, Se = class qC extends be {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qC.prototype);
  }
}, KC = class WC extends be {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, WC.prototype);
  }
}, QC = class JC extends be {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, JC.prototype);
  }
}, ZC = class XC extends be {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, XC.prototype);
  }
}, K1 = class YC extends be {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, YC.prototype);
  }
}, e5 = class t5 extends be {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, t5.prototype);
  }
}, n5 = class r5 extends be {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, r5.prototype);
  }
}, s5 = class a5 extends be {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, a5.prototype);
  }
}, i5 = class o5 extends be {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, o5.prototype);
  }
}, c5 = class l5 extends be {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, l5.prototype);
  }
};
class Eh extends be {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Eh.prototype);
  }
}
class xh extends be {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, xh.prototype);
  }
}
class Ah extends be {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ah.prototype);
  }
}
class kh extends be {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, kh.prototype);
  }
}
class vh extends be {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, vh.prototype);
  }
}
class Ch extends be {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ch.prototype);
  }
}
class Th extends be {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Th.prototype);
  }
}
class Sh extends be {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Sh.prototype);
  }
}
class Oh extends be {
  constructor(e = "ProjectNotFound", n = 1008, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Oh.prototype);
  }
}
class Bh extends be {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Bh.prototype);
  }
}
class Ih extends be {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ih.prototype);
  }
}
class Ph extends be {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ph.prototype);
  }
}
class Uh extends be {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Uh.prototype);
  }
}
class Nh extends be {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Nh.prototype);
  }
}
class Rh extends be {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota request exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Rh.prototype);
  }
}
class Fh extends be {
  constructor(e = "QuotaRateLimit", n = 1201, r = "Quota rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Fh.prototype);
  }
}
class Dh extends be {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Dh.prototype);
  }
}
class Mh extends be {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Mh.prototype);
  }
}
class Lh extends be {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Lh.prototype);
  }
}
class Hh extends be {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Hh.prototype);
  }
}
let u5 = class d5 extends be {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, d5.prototype);
  }
};
class $h extends be {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $h.prototype);
  }
}
class _h extends be {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _h.prototype);
  }
}
let f5 = class p5 extends be {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, p5.prototype);
  }
};
class Gh extends be {
  constructor(e = "InsufficientFee", n = 3004, r = "Insufficient fee", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Gh.prototype);
  }
}
class zh extends be {
  constructor(e = "NotEnoughBalance", n = 3005, r = "Not enough balance", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, zh.prototype);
  }
}
let jJ = /* @__PURE__ */ function(t) {
  return t.WebrpcEndpoint = "WebrpcEndpoint", t.WebrpcRequestFailed = "WebrpcRequestFailed", t.WebrpcBadRoute = "WebrpcBadRoute", t.WebrpcBadMethod = "WebrpcBadMethod", t.WebrpcBadRequest = "WebrpcBadRequest", t.WebrpcBadResponse = "WebrpcBadResponse", t.WebrpcServerPanic = "WebrpcServerPanic", t.WebrpcInternalError = "WebrpcInternalError", t.WebrpcClientDisconnected = "WebrpcClientDisconnected", t.WebrpcStreamLost = "WebrpcStreamLost", t.WebrpcStreamFinished = "WebrpcStreamFinished", t.Unauthorized = "Unauthorized", t.PermissionDenied = "PermissionDenied", t.SessionExpired = "SessionExpired", t.MethodNotFound = "MethodNotFound", t.RequestConflict = "RequestConflict", t.Aborted = "Aborted", t.Geoblocked = "Geoblocked", t.RateLimited = "RateLimited", t.ProjectNotFound = "ProjectNotFound", t.AccessKeyNotFound = "AccessKeyNotFound", t.AccessKeyMismatch = "AccessKeyMismatch", t.InvalidOrigin = "InvalidOrigin", t.InvalidService = "InvalidService", t.UnauthorizedUser = "UnauthorizedUser", t.QuotaExceeded = "QuotaExceeded", t.QuotaRateLimit = "QuotaRateLimit", t.NoDefaultKey = "NoDefaultKey", t.MaxAccessKeys = "MaxAccessKeys", t.AtLeastOneKey = "AtLeastOneKey", t.Timeout = "Timeout", t.InvalidArgument = "InvalidArgument", t.Unavailable = "Unavailable", t.QueryFailed = "QueryFailed", t.NotFound = "NotFound", t.InsufficientFee = "InsufficientFee", t.NotEnoughBalance = "NotEnoughBalance", t;
}({}), qJ = /* @__PURE__ */ function(t) {
  return t[t.WebrpcEndpoint = 0] = "WebrpcEndpoint", t[t.WebrpcRequestFailed = -1] = "WebrpcRequestFailed", t[t.WebrpcBadRoute = -2] = "WebrpcBadRoute", t[t.WebrpcBadMethod = -3] = "WebrpcBadMethod", t[t.WebrpcBadRequest = -4] = "WebrpcBadRequest", t[t.WebrpcBadResponse = -5] = "WebrpcBadResponse", t[t.WebrpcServerPanic = -6] = "WebrpcServerPanic", t[t.WebrpcInternalError = -7] = "WebrpcInternalError", t[t.WebrpcClientDisconnected = -8] = "WebrpcClientDisconnected", t[t.WebrpcStreamLost = -9] = "WebrpcStreamLost", t[t.WebrpcStreamFinished = -10] = "WebrpcStreamFinished", t[t.Unauthorized = 1e3] = "Unauthorized", t[t.PermissionDenied = 1001] = "PermissionDenied", t[t.SessionExpired = 1002] = "SessionExpired", t[t.MethodNotFound = 1003] = "MethodNotFound", t[t.RequestConflict = 1004] = "RequestConflict", t[t.Aborted = 1005] = "Aborted", t[t.Geoblocked = 1006] = "Geoblocked", t[t.RateLimited = 1007] = "RateLimited", t[t.ProjectNotFound = 1008] = "ProjectNotFound", t[t.AccessKeyNotFound = 1101] = "AccessKeyNotFound", t[t.AccessKeyMismatch = 1102] = "AccessKeyMismatch", t[t.InvalidOrigin = 1103] = "InvalidOrigin", t[t.InvalidService = 1104] = "InvalidService", t[t.UnauthorizedUser = 1105] = "UnauthorizedUser", t[t.QuotaExceeded = 1200] = "QuotaExceeded", t[t.QuotaRateLimit = 1201] = "QuotaRateLimit", t[t.NoDefaultKey = 1300] = "NoDefaultKey", t[t.MaxAccessKeys = 1301] = "MaxAccessKeys", t[t.AtLeastOneKey = 1302] = "AtLeastOneKey", t[t.Timeout = 1900] = "Timeout", t[t.InvalidArgument = 2001] = "InvalidArgument", t[t.Unavailable = 2002] = "Unavailable", t[t.QueryFailed = 2003] = "QueryFailed", t[t.NotFound = 3e3] = "NotFound", t[t.InsufficientFee = 3004] = "InsufficientFee", t[t.NotEnoughBalance = 3005] = "NotEnoughBalance", t;
}({});
const h5 = {
  0: VC,
  [-1]: Se,
  [-2]: KC,
  [-3]: QC,
  [-4]: ZC,
  [-5]: K1,
  [-6]: e5,
  [-7]: n5,
  [-8]: s5,
  [-9]: i5,
  [-10]: c5,
  1e3: Eh,
  1001: xh,
  1002: Ah,
  1003: kh,
  1004: vh,
  1005: Ch,
  1006: Th,
  1007: Sh,
  1008: Oh,
  1101: Bh,
  1102: Ih,
  1103: Ph,
  1104: Uh,
  1105: Nh,
  1200: Rh,
  1201: Fh,
  1300: Dh,
  1301: Mh,
  1302: Lh,
  1900: Hh,
  2001: u5,
  2002: $h,
  2003: _h,
  3e3: f5,
  3004: Gh,
  3005: zh
};
var Ep = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WebrpcHeader: q1,
  WebrpcHeaderValue: _C,
  WebRPCVersion: MJ,
  WebRPCSchemaVersion: LJ,
  WebRPCSchemaHash: HJ,
  VersionFromHeader: $J,
  ETHTxnStatus: da,
  TransferType: GJ,
  FeeTokenType: zJ,
  SortOrder: VJ,
  Relayer: GC,
  WebrpcError: be,
  WebrpcEndpointError: VC,
  WebrpcRequestFailedError: Se,
  WebrpcBadRouteError: KC,
  WebrpcBadMethodError: QC,
  WebrpcBadRequestError: ZC,
  WebrpcBadResponseError: K1,
  WebrpcServerPanicError: e5,
  WebrpcInternalErrorError: n5,
  WebrpcClientDisconnectedError: s5,
  WebrpcStreamLostError: i5,
  WebrpcStreamFinishedError: c5,
  UnauthorizedError: Eh,
  PermissionDeniedError: xh,
  SessionExpiredError: Ah,
  MethodNotFoundError: kh,
  RequestConflictError: vh,
  AbortedError: Ch,
  GeoblockedError: Th,
  RateLimitedError: Sh,
  ProjectNotFoundError: Oh,
  AccessKeyNotFoundError: Bh,
  AccessKeyMismatchError: Ih,
  InvalidOriginError: Ph,
  InvalidServiceError: Uh,
  UnauthorizedUserError: Nh,
  QuotaExceededError: Rh,
  QuotaRateLimitError: Fh,
  NoDefaultKeyError: Dh,
  MaxAccessKeysError: Mh,
  AtLeastOneKeyError: Lh,
  TimeoutError: Hh,
  InvalidArgumentError: u5,
  UnavailableError: $h,
  QueryFailedError: _h,
  NotFoundError: f5,
  InsufficientFeeError: Gh,
  NotEnoughBalanceError: zh,
  errors: jJ,
  WebrpcErrorCodes: qJ,
  webrpcErrorByCode: h5
});
const KJ = [da.DROPPED, da.SUCCEEDED, da.PARTIALLY_FAILED, da.FAILED], WJ = [da.DROPPED, da.PARTIALLY_FAILED, da.FAILED];
class QJ {
  constructor(e) {
    if (this.options = e, this.service = void 0, this.provider = void 0, this._fetch = (n, r) => {
      const s = {}, {
        jwtAuth: a,
        projectAccessKey: i
      } = this.options;
      return a && a.length > 0 && (s.Authorization = `BEARER ${a}`), i && i.length > 0 && (s["X-Access-Key"] = i), r.headers = Oo({}, s, r.headers), fetch(n, r);
    }, this.service = new GC(e.url, this._fetch), ZJ(e.provider))
      this.provider = e.provider;
    else {
      const {
        jwtAuth: n,
        projectAccessKey: r
      } = this.options, s = Gk(e.provider.url, r, n);
      this.provider = new Ng(s, void 0, {
        staticNetwork: !0
      });
    }
  }
  async waitReceipt(e, n = 1e3, r = 5, s) {
    typeof e != "string" && (e = re.transaction.intendedTransactionID(e)), Gn.info(`[rpc-relayer/waitReceipt] waiting for ${e}`);
    let a = 0;
    for (; s === void 0 || !s(); ) {
      try {
        const {
          receipt: i
        } = await this.service.getMetaTxnReceipt({
          metaTxID: e
        });
        if (i && i.txnReceipt && i.txnReceipt !== "null" && KJ.includes(i.status))
          return {
            receipt: i
          };
      } catch (i) {
        if (a++, a === r)
          throw i;
      }
      (s === void 0 || !s()) && await new Promise((i) => setTimeout(i, n));
    }
    throw new Error(`Cancelled waiting for transaction receipt ${e}`);
  }
  async simulate(e, ...n) {
    const s = Ot.defaultAbiCoder().encode([re.transaction.MetaTransactionsType], [re.transaction.sequenceTxAbiEncode(n)]);
    return (await this.service.simulate({
      wallet: e,
      transactions: s
    })).results;
  }
  async getFeeOptions(e, ...n) {
    const r = await this.service.feeTokens();
    if (r.isFeeRequired) {
      const s = r.tokens.map((c) => c.symbol).join(", ");
      Gn.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${s}`);
      const a = await this.getNonce(e);
      if (!this.provider)
        throw Gn.warn("[rpc-relayer/getFeeOptions] provider not set, needed for stub signature"), new Error("provider is not set");
      const {
        options: i,
        quote: o
      } = await this.service.feeOptions({
        wallet: e,
        to: e,
        data: re.transaction.encodeBundleExecData({
          entrypoint: e,
          transactions: n,
          nonce: a
        })
      });
      return Gn.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(i, Dl)}`), {
        options: i,
        quote: {
          _tag: "FeeQuote",
          _quote: o
        }
      };
    } else
      return Gn.info("[rpc-relayer/getFeeOptions] relayer fees are not required"), {
        options: []
      };
  }
  async getFeeOptionsRaw(e, n, r) {
    const {
      options: s,
      quote: a
    } = await this.service.feeOptions({
      wallet: e,
      to: e,
      data: G(n),
      simulate: r == null ? void 0 : r.simulate
    }, Oo({}, r != null && r.projectAccessKey ? {
      "X-Access-Key": r.projectAccessKey
    } : void 0));
    return {
      options: s,
      quote: {
        _tag: "FeeQuote",
        _quote: a
      }
    };
  }
  async gasRefundOptions(e, ...n) {
    const {
      options: r
    } = await this.getFeeOptions(e, ...n);
    return r;
  }
  async getNonce(e, n) {
    Gn.info(`[rpc-relayer/getNonce] get nonce for wallet ${e} space: ${n}`);
    const r = n !== void 0 ? V0(BigInt(n)) : void 0, s = await this.service.getMetaTxnNonce({
      walletContractAddress: e,
      space: r
    }), a = BigInt(s.nonce), [i, o] = re.transaction.decodeNonce(a);
    return Gn.info(`[rpc-relayer/getNonce] got next nonce for wallet ${e} ${o} space: ${i}`), a;
  }
  async relay(e, n, r = !0, s) {
    var a = this;
    Gn.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(e, Dl)} with quote ${JSON.stringify(n, Dl)}`);
    let i;
    if (n !== void 0 && (typeof n._quote == "string" ? i = n._quote : Gn.warn("[rpc-relayer/relay] ignoring invalid fee quote")), !this.provider)
      throw Gn.warn("[rpc-relayer/relay] provider not set, failed relay"), new Error("provider is not set");
    const o = re.transaction.encodeBundleExecData(e), c = await this.service.sendMetaTxn({
      call: {
        walletAddress: e.intent.wallet,
        contract: e.entrypoint,
        input: o
      },
      quote: i
    }, Oo({}, s ? {
      "X-Access-Key": s
    } : void 0));
    if (Gn.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(c, Dl)}`), r)
      return this.wait(e.intent.id);
    {
      const u = {
        hash: e.intent.id,
        confirmations: 0,
        from: e.intent.wallet,
        wait: (d) => Promise.reject(new Error("impossible"))
      }, l = async function(m) {
        var h;
        if (!a.provider)
          throw new Error("cannot wait for receipt, relayer has no provider set");
        const b = await a.wait(e.intent.id), y = (h = b.receipt) == null ? void 0 : h.transactionHash;
        if (!y)
          throw new Error("cannot wait for receipt, unknown native transaction hash");
        return Object.assign(u, b), a.provider.waitForTransaction(y, m);
      };
      return u.wait = l, u;
    }
  }
  async wait(e, n, r = 1e3, s = 5) {
    var a = this;
    let i = !1;
    const {
      receipt: o
    } = await (n !== void 0 ? Promise.race([this.waitReceipt(e, r, s, () => i), new Promise((u, l) => setTimeout(() => {
      i = !0, l(`Timeout waiting for transaction receipt ${e}`);
    }, n))]) : this.waitReceipt(e, r, s));
    if (!o.txnReceipt || WJ.includes(o.status))
      throw new JJ(o);
    const c = JSON.parse(o.txnReceipt);
    return {
      blockHash: c.blockHash,
      blockNumber: Number(c.blockNumber),
      confirmations: 1,
      from: typeof e == "string" ? void 0 : e.intent.wallet,
      hash: c.transactionHash,
      raw: o.txnReceipt,
      receipt: c,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function(u) {
        return a.provider.waitForTransaction(c.transactionHash, u);
      }
    };
  }
  async getMetaTransactions(e, n) {
    return this.service.getMetaTransactions({
      projectId: e,
      page: n
    });
  }
  async getTransactionCost(e, n, r) {
    return this.service.getTransactionCost({
      projectId: e,
      from: n,
      to: r
    });
  }
  async listGasSponsors(e) {
    return this.service.listGasSponsors(e);
  }
  async addGasSponsor(e) {
    return this.service.addGasSponsor(e);
  }
  async updateGasSponsor(e) {
    return this.service.updateGasSponsor(e);
  }
  async removeGasSponsor(e) {
    return this.service.removeGasSponsor(e);
  }
}
class JJ {
  constructor(e) {
    this.receipt = e;
  }
}
function ZJ(t) {
  return t && typeof t == "object" && typeof t.getNetwork == "function" && typeof t.getBlockNumber == "function";
}
function XJ(t) {
  return typeof t == "object" && typeof t.simulate == "function" && typeof t.getFeeOptions == "function" && typeof t.gasRefundOptions == "function" && typeof t.getNonce == "function" && typeof t.relay == "function" && typeof t.wait == "function";
}
function YJ(t) {
  return t.getAddress !== void 0 && t.buildDeployTransaction !== void 0 && t.predecorateSignedTransactions !== void 0 && t.decorateTransactions !== void 0 && t.sign !== void 0 && t.notifyStatusChange !== void 0;
}
class eZ {
  constructor(e, n = !0) {
    this.signer = e, this.eoa = n;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(e) {
  }
  async predecorateSignedTransactions(e) {
    return [];
  }
  async decorateTransactions(e, n) {
    return e;
  }
  sign(e) {
    return this.signer.signMessage(e);
  }
  notifyStatusChange(e, n, r) {
  }
  suffix() {
    return new Uint8Array([2]);
  }
}
let qa = /* @__PURE__ */ function(t) {
  return t[t.INITIAL = 0] = "INITIAL", t[t.SIGNING = 1] = "SIGNING", t[t.SIGNED = 2] = "SIGNED", t[t.ERROR = 3] = "ERROR", t;
}({});
function tZ(t) {
  return t === void 0 || t.state === qa.INITIAL || t.state === qa.SIGNING;
}
class Vh {
  constructor(e, n = Vh.randomTag()) {
    this.tag = n, this.observers = [], this.signers = [], this.count = 0, this.setSigners(e);
  }
  static randomTag() {
    return `default-${G(Aa(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(e) {
    this.signers = e.map((n) => YJ(n) ? n : new eZ(n));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function(e) {
      return e.getAddress();
    }));
  }
  subscribe(e) {
    return this.observers.push(e), () => {
      this.observers = this.observers.filter((n) => n !== e);
    };
  }
  async notifyObservers(e, n, r) {
    await Promise.all([...this.signers.map(async function(s) {
      return s.notifyStatusChange(e, n, r);
    }), ...this.observers.map(async function(s) {
      return s(n, r);
    })]);
  }
  async buildDeployTransaction(e) {
    let n;
    for (const r of this.signers) {
      const s = await r.buildDeployTransaction(e);
      n === void 0 ? n = s : s != null && s.transactions && (n.transactions = s.transactions.concat(n.transactions));
    }
    return n;
  }
  async predecorateSignedTransactions(e) {
    const n = [];
    for (const r of this.signers)
      n.push(...await r.predecorateSignedTransactions(e ?? {}));
    return n;
  }
  async decorateTransactions(e, n) {
    for (const r of this.signers)
      e = await r.decorateTransactions(e, n ?? {});
    return e;
  }
  signMessage(e) {
    var n = this;
    const r = this.pullId();
    return new Promise(async function(s) {
      const {
        message: a,
        metadata: i,
        callback: o,
        candidates: c
      } = e, u = {
        ended: !1,
        message: a,
        signers: {}
      };
      let l = i ?? {};
      const d = (y) => {
        l = y, n.notifyObservers(r, u, l);
      }, m = () => {
        try {
          n.notifyObservers(r, u, l);
          const y = Object.entries(u.signers).filter(([g, w]) => tZ(w));
          if (o && o(u, d) || y.length === 0) {
            u.ended = !0, s(u), n.notifyObservers(r, u, l);
            return;
          }
        } catch (y) {
          console.error("Error while notifying observers", y);
        }
      };
      let h = n.signers;
      if (c) {
        const y = await Promise.all(n.signers.map(async function(g) {
          return g.getAddress();
        }));
        h = n.signers.filter((g, w) => c.includes(y[w]));
      }
      const b = await Promise.allSettled(h.map(async function(y) {
        const g = await y.getAddress();
        u.signers[g] = {
          state: qa.SIGNING,
          request: y.sign(a, i ?? {}).then((w) => {
            const v = y.suffix();
            return u.signers[g] = {
              state: qa.SIGNED,
              signature: w,
              suffix: v
            }, m(), w;
          }).catch((w) => {
            throw u.signers[g] = {
              state: qa.ERROR,
              error: w
            }, m(), w;
          })
        };
      }));
      for (let y = 0; y < b.length; y++) {
        const g = n.signers[y], w = b[y];
        if (w.status === "rejected") {
          const v = await g.getAddress();
          console.warn(`signer ${v} rejected the request: ${w.reason}`), u.signers[v] = {
            state: qa.ERROR,
            error: new Error(`signer ${v} rejected the request: ${w.reason}`)
          };
        }
      }
      m();
    });
  }
}
function Ms() {
  return Ms = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Ms.apply(null, arguments);
}
async function f2(t) {
  return Array.isArray(t) ? Promise.all(t.map((e) => dt(e))) : dt(t);
}
const p2 = (t) => {
  const e = /* @__PURE__ */ new Map();
  for (const n of Object.keys(t.signers)) {
    const r = t.signers[n];
    if (r.state === qa.SIGNED) {
      const s = J(r.suffix), a = xe(["bytes", "bytes"], [r.signature, s]);
      e.set(n, {
        signature: a,
        isDynamic: s.length !== 1 || s[0] !== 2
      });
    }
  }
  return e;
};
class Bo extends Hk {
  constructor(e) {
    var n;
    const r = BigInt(e.chainId);
    if (r === 0n && !e.coders.signature.supportsNoChainId)
      throw new Error(`Sequence version ${e.config.version} doesn't support chainId 0`);
    super((n = e.provider) != null ? n : null), this.context = void 0, this.config = void 0, this.address = void 0, this.chainId = void 0, this.relayer = void 0, this.coders = void 0, this.orchestrator = void 0, this._reader = void 0, this.context = e.context, this.config = e.config, this.orchestrator = e.orchestrator, this.coders = e.coders, this.address = e.address, this.chainId = r, this.relayer = e.relayer, this._reader = e.reader;
  }
  static newWallet(e) {
    const n = re.context.addressOf(e.context, e.coders.config.imageHashOf(e.config));
    return new Bo(Ms({}, e, {
      address: n
    }));
  }
  reader() {
    if (this._reader) return this._reader;
    if (!this.provider) throw new Error("Wallet status provider requires a provider");
    return new re.reader.OnChainReader(this.provider);
  }
  setConfig(e) {
    this.config = e;
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setAddress(e) {
    this.address = e;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(e) {
    const n = await this.orchestrator.decorateTransactions(e);
    if (await this.reader().isDeployed(this.address))
      return n;
    const r = [{
      to: n.entrypoint,
      data: re.transaction.encodeBundleExecData(n),
      revertOnError: !0
    }], s = await this.buildDeployTransaction();
    return s && r.unshift(...s.transactions), {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: n.intent,
      transactions: r
    };
  }
  async buildDeployTransaction(e) {
    if (e != null && e.ignoreDeployed && await this.reader().isDeployed(this.address))
      return;
    const n = this.coders.config.imageHashOf(this.config);
    if (re.context.addressOf(this.context, n) !== this.address)
      throw new Error(`First address of config ${n} doesn't match wallet address ${this.address}`);
    let r;
    switch (this.chainId) {
      case BigInt(k.SKALE_NEBULA):
        r = 10000000n;
        break;
      case BigInt(k.SOMNIA_TESTNET):
        r = 10000000n;
        break;
      case BigInt(k.SOMNIA):
        r = 10000000n;
        break;
    }
    const s = Bo.buildDeployTransaction(this.context, n, r);
    if (e != null && e.includeChildren) {
      const a = await this.orchestrator.buildDeployTransaction(e);
      a && (s.transactions = a.transactions.concat(s.transactions));
    }
    return s;
  }
  async deploy(e) {
    const n = await this.buildDeployTransaction(e);
    if (n !== void 0) {
      if (!this.relayer) throw new Error("Wallet deploy requires a relayer");
      return this.relayer.relay(Ms({}, n, {
        chainId: this.chainId,
        intent: {
          id: G(Aa(32)),
          wallet: this.address
        }
      }));
    }
  }
  static buildDeployTransaction(e, n, r = 100000n) {
    const s = new Bt(St.factory.abi);
    return {
      entrypoint: e.guestModule,
      transactions: [{
        to: e.factory,
        data: s.encodeFunctionData(s.getFunction("deploy"), [e.mainModule, n]),
        gasLimit: r,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(e) {
    if (this.coders.config.update.isKindUsed) {
      const n = await this.reader().implementation(this.address), r = n && n === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, e, this.context, r ? "later" : "first");
    }
    return this.coders.config.update.buildTransaction(this.address, e, this.context);
  }
  async getNonce(e = 0) {
    const n = await this.reader().nonce(this.address, e);
    if (n === void 0) throw new Error("Unable to determine nonce");
    return Number(n);
  }
  async signDigest(e, n) {
    const r = VE(this.address, this.chainId, e);
    if (this.coders.config.hasSubdigest(this.config, r))
      return this.coders.signature.encodeSigners(this.config, /* @__PURE__ */ new Map(), [r], this.chainId).encoded;
    const s = Ms({}, n, {
      // Keep other metadata fields
      digest: e,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    }), a = J(r), i = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map((c) => c.address),
      message: a,
      metadata: s,
      callback: (c, u) => {
        const l = p2(c), d = Ms({}, s, {
          parts: l
        });
        return u(d), this.coders.signature.hasEnoughSigningPower(this.config, l);
      }
    }), o = p2(i);
    return this.coders.signature.encodeSigners(this.config, o, [], this.chainId).encoded;
  }
  signMessage(e) {
    return this.signDigest(ke(e), {
      message: e
    });
  }
  // XXX This method is not implemented in the original code but required by the AbstractSigner interface
  signTypedData(e, n, r) {
    const s = zk({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(s);
  }
  signTransactionBundle(e) {
    if (e.entrypoint !== this.address)
      throw new Error(`Invalid entrypoint: ${e.entrypoint} !== ${this.address}`);
    return this.signTransactions(e.transactions, e.nonce);
  }
  async fetchNonceOrSpace(e) {
    let n;
    if (e && e.space !== void 0)
      n = BigInt(e.space);
    else {
      if (e === void 0)
        return this.randomNonce();
      if (e && e.serial === !0)
        n = 0;
      else
        return e;
    }
    const r = await this.reader().nonce(this.address, n);
    if (r === void 0) throw new Error("Unable to determine nonce");
    return re.transaction.encodeNonce(n, r);
  }
  // Generate nonce with random space
  randomNonce() {
    const e = BigInt(G(Aa(12)));
    return re.transaction.encodeNonce(e, 0);
  }
  async signTransactions(e, n, r) {
    const s = await f2(e), a = re.transaction.fromTransactionish(this.address, s);
    a.length === 0 && a.push({
      to: this.address,
      data: "0x",
      value: 0,
      gasLimit: 0,
      delegateCall: !1,
      revertOnError: !0
    });
    const i = await this.fetchNonceOrSpace(n), o = re.transaction.digestOfTransactions(i, a), c = Ms({
      digest: o,
      transactions: a
    }, r), u = await this.signDigest(o, c);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: VE(this.address, this.chainId, o),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions: a,
      entrypoint: this.address,
      nonce: i,
      signature: u
    };
  }
  async sendSignedTransaction(e, n) {
    if (!this.relayer) throw new Error("Wallet sendTransaction requires a relayer");
    return this.relayer.relay(e, n);
  }
  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(e, n) {
    let r;
    (n == null ? void 0 : n.nonce) !== void 0 ? r = n.nonce : n != null && n.serial ? r = {
      serial: !0
    } : r = this.randomNonce();
    const s = await this.signTransactions(e, r), a = await this.decorateTransactions(s);
    return this.sendSignedTransaction(a, n == null ? void 0 : n.quote);
  }
  async fillGasLimits(e) {
    const n = await f2(e), r = re.transaction.fromTransactionish(this.address, n), s = this.relayer;
    if (!s) throw new Error("Wallet fillGasLimits requires a relayer");
    const a = await s.simulate(this.address, ...r);
    return r.map((i, o) => {
      const c = i.gasLimit ? Number(i.gasLimit) : a[o].gasLimit;
      return Ms({}, i, a[o], {
        gasLimit: c
      });
    });
  }
  connect(e, n) {
    return new Bo({
      // Sequence version configurator
      coders: this.coders,
      context: this.context,
      config: this.config,
      chainId: this.chainId,
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this._reader,
      provider: e,
      relayer: n ?? this.relayer
    });
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
}
function wr() {
  return wr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, wr.apply(null, arguments);
}
function nZ(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case Ep.FeeTokenType.UNKNOWN:
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.to,
        value: V0(e),
        data: "0x"
      }];
    case Ep.FeeTokenType.ERC20_TOKEN:
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.token.contractAddress,
        value: 0,
        data: new Bt([{
          constant: !1,
          inputs: [{
            type: "address"
          }, {
            type: "uint256"
          }],
          name: "transfer",
          outputs: [],
          type: "function"
        }]).encodeFunctionData("transfer", [t.to, V0(e)])
      }];
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
class rZ {
  constructor(e, n, r) {
    this.account = e, this.chainId = n, this.options = r;
  }
  get provider() {
    return this.account.providerFor(this.chainId);
  }
  async getAddress() {
    return this.account.address;
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. The message is already being prefixed with the EIP-191 prefix.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @returns A Promise that resolves to the signature as a hexadecimal string
   *
   * @example
   * ```typescript
   * const signer = account.getSigner(chainId)
   *
   * const message = "Hello, Sequence!";
   * const signature = await signer.signMessage(message);
   * console.log(signature);
   * // => "0x123abc..." (hexadecimal signature)
   */
  signMessage(e) {
    var n, r;
    return this.account.signMessage(e, this.chainId, (n = (r = this.options) == null ? void 0 : r.cantValidateBehavior) != null ? n : "throw");
  }
  signTypedData(e, n, r) {
    var s, a;
    return this.account.signTypedData(e, n, r, this.chainId, (s = (a = this.options) == null ? void 0 : a.cantValidateBehavior) != null ? s : "throw");
  }
  async defaultSelectFee(e, n) {
    if (n.length === 0) return;
    const r = [{
      constant: !0,
      inputs: [{
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        type: "uint256"
      }],
      type: "function"
    }];
    for (const s of n)
      if (s.token.type === Ep.FeeTokenType.UNKNOWN) {
        if (await this.getBalance() >= BigInt(s.value))
          return s;
      } else if (s.token.contractAddress && s.token.type === Ep.FeeTokenType.ERC20_TOKEN && await new Rr(s.token.contractAddress, r, this.provider).balanceOf(this.account.address) >= BigInt(s.value))
        return s;
    throw new Error("No fee option available - not enough balance");
  }
  async sendTransaction(e, n) {
    var r, s, a, i, o;
    const c = await this.account.prepareTransactions({
      txs: e,
      chainId: this.chainId,
      stubSignatureOverrides: (r = (s = this.options) == null ? void 0 : s.stubSignatureOverrides) != null ? r : /* @__PURE__ */ new Map(),
      simulateForFeeOptions: n == null ? void 0 : n.simulateForFeeOptions
    }), l = await ((a = (i = this.options) == null ? void 0 : i.selectFee) != null ? a : this.defaultSelectFee.bind(this))(e, c.feeOptions), d = [...c.transactions, ...nZ(l)];
    return this.account.sendTransaction(d, this.chainId, c.feeQuote, void 0, void 0, ((o = this.options) == null ? void 0 : o.nonceSpace) !== void 0 ? {
      nonceSpace: this.options.nonceSpace
    } : void 0);
  }
  getBalance(e) {
    return this.provider.getBalance(this.account.address, e);
  }
  call(e, n) {
    return this.provider.call(wr({}, e, {
      blockTag: n
    }));
  }
  async resolveName(e) {
    const n = await this.provider.resolveName(e);
    if (!n) throw new Error(`Could not resolve name ${e}`);
    return n;
  }
  connect(e) {
    throw new Error("Method not implemented.");
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
  getTransactionCount(e) {
    throw new Error("Method not implemented.");
  }
  estimateGas(e) {
    throw new Error("Method not implemented.");
  }
  getChainId() {
    return Promise.resolve(Number(this.chainId));
  }
  getGasPrice() {
    throw new Error("Method not implemented.");
  }
  getFeeData() {
    throw new Error("Method not implemented.");
  }
  getNonce(e) {
    throw new Error("Method not implemented.");
  }
  populateCall(e) {
    throw new Error("Method not implemented.");
  }
  checkTransaction(e) {
    throw new Error("Method not implemented.");
  }
  async populateTransaction(e) {
    throw new Error("Method not implemented.");
  }
  _checkProvider(e) {
    throw new Error("Method not implemented.");
  }
}
class sZ {
  async isDeployed(e) {
    return !1;
  }
  async implementation(e) {
  }
  async imageHash(e) {
  }
  async nonce(e, n) {
    return 0n;
  }
  async isValidSignature(e, n, r) {
    throw new Error("Method not supported.");
  }
}
class jh {
  constructor(e) {
    this.address = void 0, this.networks = void 0, this.tracker = void 0, this.contexts = void 0, this.migrator = void 0, this.migrations = void 0, this.orchestrator = void 0, this.jwt = void 0, this.projectAccessKey = void 0, this.address = ue(e.address), this.contexts = e.contexts, this.tracker = e.tracker, this.networks = e.networks, this.orchestrator = e.orchestrator, this.jwt = e.jwt, this.projectAccessKey = e.projectAccessKey, this.migrations = e.migrations || d2.DefaultMigrations, this.migrator = new u2.Migrator(e.tracker, this.migrations, this.contexts);
  }
  getSigner(e, n) {
    return new rZ(this, e, n);
  }
  static async new(e) {
    var n;
    const s = new u2.Migrator(e.tracker, (n = e.migrations) != null ? n : d2.DefaultMigrations, e.contexts).lastMigration(), a = s.configCoder, i = a.fromSimple(e.config), o = a.imageHashOf(i), c = e.contexts[s.version], u = re.context.addressOf(c, o);
    return await e.tracker.saveCounterfactualWallet({
      config: i,
      context: Object.values(e.contexts)
    }), new jh({
      address: u,
      tracker: e.tracker,
      contexts: e.contexts,
      networks: e.networks,
      orchestrator: e.orchestrator,
      migrations: e.migrations,
      projectAccessKey: e.projectAccessKey
    });
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  get version() {
    return this.migrator.lastMigration().version;
  }
  get coders() {
    const e = this.migrator.lastMigration();
    return {
      signature: e.signatureCoder,
      config: e.configCoder
    };
  }
  network(e) {
    const n = BigInt(e), r = this.networks.find((s) => n === BigInt(s.chainId));
    if (!r) throw new Error(`Network not found for chainId ${e}`);
    return r;
  }
  providerFor(e) {
    const n = this.network(e);
    if (!n.provider && !n.rpcUrl)
      throw new Error(`Provider not found for chainId ${e}`);
    const r = new rr(n.name, n.chainId);
    return n.provider || new Ng(Gk(n.rpcUrl, this.projectAccessKey, this.jwt), r, {
      staticNetwork: r
    });
  }
  reader(e) {
    return BigInt(e) === 0n ? new sZ() : new re.reader.OnChainReader(this.providerFor(e));
  }
  relayer(e) {
    const n = this.network(e);
    if (!n.relayer) throw new Error(`Relayer not found for chainId ${e}`);
    return XJ(n.relayer) ? n.relayer : new QJ(wr({}, n.relayer, {
      projectAccessKey: this.projectAccessKey,
      jwtAuth: this.jwt
    }));
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setJwt(e) {
    this.jwt = e;
  }
  contextFor(e) {
    const n = this.contexts[e];
    if (!n) throw new Error(`Context not found for version ${e}`);
    return n;
  }
  walletForStatus(e, n) {
    const r = _t.coderFor(n.version);
    return this.walletFor(e, this.contextFor(n.version), n.config, r);
  }
  walletFor(e, n, r, s) {
    const a = BigInt(e) === 0n;
    return new Bo({
      config: r,
      context: n,
      chainId: e,
      coders: s,
      relayer: a ? void 0 : this.relayer(e),
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this.reader(e)
    });
  }
  // Get the status of the account on a given network
  // this does the following process:
  // 1. Get the current on-chain status of the wallet (version + imageHash)
  // 2. Get any pending migrations that have been signed by the wallet
  // 3. Get any pending configuration updates that have been signed by the wallet
  // 4. Fetch reverse lookups for both on-chain and pending configurations
  async status(e, n = !1) {
    var r = this;
    const s = this.reader(e).isDeployed(this.address), a = this.tracker.imageHashOfCounterfactualWallet({
      wallet: this.address
    }).then((x) => {
      if (!x) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
      return x;
    }), i = a.then((x) => PJ.counterfactualVersion(this.address, x.imageHash, Object.values(this.contexts))), o = async function() {
      if (!await s) return i;
      const N = await r.reader(e).implementation(r.address);
      if (!N) throw new Error(`Implementation not found for wallet ${r.address}`);
      const I = Object.values(r.contexts);
      for (let O = 0; O < I.length; O++)
        if (I[O].mainModule === N || I[O].mainModuleUpgradable === N)
          return I[O].version;
      throw new Error(`Version not found for implementation ${N}`);
    }(), c = async function() {
      const x = await r.reader(e).imageHash(r.address);
      if (x) return x;
      const N = await a;
      if (N) return N.imageHash;
      throw new Error(`On-chain imageHash not found for wallet ${r.address}`);
    }(), u = async function() {
      const x = await c, N = await r.tracker.configOfImageHash({
        imageHash: x
      });
      if (N) return N;
      throw new Error(`On-chain config not found for imageHash ${x}`);
    }(), l = await o, d = await c;
    let m = d, h = l, b = [];
    if (l !== this.version) {
      const x = await this.migrator.getAllMigratePresignedTransaction({
        address: this.address,
        fromImageHash: d,
        fromVersion: l,
        chainId: e
      });
      m = x.lastImageHash, h = x.lastVersion, b = x.signedMigrations;
    }
    const y = await this.tracker.loadPresignedConfiguration({
      wallet: this.address,
      fromImageHash: m,
      longestPath: n
    }), g = y && y.length > 0 ? y[y.length - 1].nextImageHash : m, w = await this.tracker.configOfImageHash({
      imageHash: g
    });
    if (!w)
      throw new Error(`Config not found for imageHash ${g}`);
    const v = await s, A = await a, B = _t.coderFor(h).config.checkpointOf(w);
    return {
      original: wr({}, A, {
        version: await i
      }),
      onChain: {
        imageHash: d,
        config: await u,
        version: l,
        deployed: v
      },
      fullyMigrated: h === this.version,
      signedMigrations: b,
      version: h,
      presignedConfigurations: y,
      imageHash: g,
      config: w,
      checkpoint: B,
      canOnchainValidate: l === this.version && v
    };
  }
  mustBeFullyMigrated(e) {
    if (!e.fullyMigrated)
      throw new Error(`Wallet ${this.address} is not fully migrated`);
  }
  async predecorateSignedTransactions(e, n) {
    const r = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), s = await this.predecorateTransactions([], e, n);
    return re.transaction.fromTransactionish(this.address, s).length > 0 && r.push(await this.signTransactions(s, n)), r;
  }
  async predecorateTransactions(e, n, r) {
    if (e = Array.isArray(e) ? e : [e], n.onChain.imageHash !== n.imageHash) {
      const i = await this.walletForStatus(r, n).buildUpdateConfigurationTransaction(n.config);
      e = [...e, ...i.transactions];
    }
    const {
      proxyImplementationHook: s
    } = this.contexts[n.config.version];
    if (s && (r === k.IMMUTABLE_ZKEVM || r === k.IMMUTABLE_ZKEVM_TESTNET)) {
      const a = this.providerFor(r);
      if (a) {
        const i = new Rr(this.address, St.walletProxyHook.abi, a);
        let o;
        try {
          o = await i.PROXY_getImplementation();
        } catch (c) {
          console.log("Error getting implementation address", c);
        }
        if (!o || o === ka) {
          console.log("Adding wallet proxy hook");
          const c = new Bt(St.moduleHooks.abi);
          e = [{
            to: this.address,
            data: c.encodeFunctionData(c.getFunction("addHook"), ["0x90611127", s]),
            gasLimit: 5e4,
            // Expected ~28k gas. Buffer added
            delegateCall: !1,
            revertOnError: !1,
            value: 0
          }, ...e];
        }
      }
    }
    return e;
  }
  async decorateTransactions(e, n, r) {
    var s, a;
    if (!Array.isArray(e))
      return this.decorateTransactions([e], n, r);
    r = (s = r) != null ? s : e[0].chainId;
    const i = await this.buildBootstrapTransactions(n, r), o = i.transactions.length > 0;
    if (!o && e.length === 1)
      return e[0];
    const {
      entrypoint: c
    } = o ? i : e[0], u = {
      entrypoint: c,
      chainId: r,
      // Intent of the first bundle is used
      intent: (a = e[0]) == null ? void 0 : a.intent,
      transactions: [...i.transactions, ...e.map((l) => ({
        to: l.entrypoint,
        data: re.transaction.encodeBundleExecData(l),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }))]
    };
    if (!n.onChain.deployed) {
      const l = re.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, r, u.transactions);
      u.intent === void 0 ? u.intent = {
        id: l,
        wallet: this.address
      } : u.intent.id = l;
    }
    return u;
  }
  async decorateSignature(e, n) {
    if (!n.presignedConfigurations || n.presignedConfigurations.length === 0)
      return e;
    const r = this.coders.signature, s = n.presignedConfigurations.map((i) => i.signature), a = r.chainSignatures(e, s);
    return r.trim(a);
  }
  async publishWitnessFor(e, n = 0) {
    const r = Mr(`This is a Sequence account woo! ${Date.now()}`), s = await this.status(n), a = this.coders.config.fromSimple({
      threshold: e.length,
      checkpoint: 0,
      signers: e.map((l) => ({
        address: l,
        weight: 1
      }))
    }), o = await this.walletFor(n, s.original.context, a, this.coders).signDigest(r), c = this.coders.signature.decode(o), u = this.coders.signature.signaturesOfDecoded(c);
    if (u.length === 0)
      throw new Error("No signatures found");
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: r,
      chainId: n,
      signatures: u
    });
  }
  async publishWitness() {
    const e = Mr(`This is a Sequence account woo! ${Date.now()}`), n = await this.signDigest(e, 0, !1), r = this.coders.signature.decode(n), s = this.coders.signature.signaturesOfDecoded(r);
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: e,
      chainId: 0,
      signatures: s
    });
  }
  async signDigest(e, n, r = !0, s = "ignore", a) {
    const i = BigInt(n) === 0n ? this.networks[0].chainId : n, o = await this.status(i);
    if (this.mustBeFullyMigrated(o), !o.canOnchainValidate && s === "throw")
      throw new Error("Wallet cannot validate onchain");
    const u = await this.walletForStatus(n, o).signDigest(e, a), l = r ? this.decorateSignature(u, o) : u;
    if (!o.canOnchainValidate)
      switch (s) {
        case "ignore":
          return l;
        case "eip6492":
          return this.buildEIP6492Signature(await l, o, n);
      }
    return l;
  }
  buildOnChainSignature(e) {
    const n = re.signature.subdigestOf({
      digest: G(e),
      chainId: 0,
      address: this.address
    }), r = G(n), s = this.coders.config.fromSimple({
      // Threshold *only* needs to be > 0, this is not a magic number
      // we only use 2 ** 15 because it may lead to lower gas costs in some chains
      threshold: 32768,
      checkpoint: 0,
      signers: [],
      subdigests: [r]
    }), a = new Bt(St.mainModule.abi), i = {
      entrypoint: this.address,
      transactions: [{
        to: this.address,
        data: a.encodeFunctionData(
          // *NEVER* use updateImageHash here, as it would effectively destroy the wallet
          // setExtraImageHash sets an additional imageHash, without changing the current one
          "setExtraImageHash",
          [
            this.coders.config.imageHashOf(s),
            // 2 ** 255 instead of max uint256, to have more zeros in the calldata
            "57896044618658097711785492504343953926634992332820282019728792003956564819968"
          ]
        ),
        // Conservative gas limit, used because the current relayer
        // has trouble estimating gas for this transaction
        gasLimit: 25e4
      }]
    };
    this.tracker.saveWalletConfig({
      config: s
    });
    const o = this.coders.signature.encodeSigners(s, /* @__PURE__ */ new Map(), [r], 0).encoded;
    return {
      bundle: i,
      signature: o
    };
  }
  async buildEIP6492Signature(e, n, r) {
    const s = await this.buildBootstrapTransactions(n, r);
    if (s.transactions.length === 0)
      throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
    const a = Ot.defaultAbiCoder().encode(["address", "bytes", "bytes"], [s.entrypoint, re.transaction.encodeBundleExecData(s), e]);
    return xe(["bytes", "bytes32"], [a, re.EIP6492.EIP_6492_SUFFIX]);
  }
  async editConfig(e) {
    const n = await this.status(0).then((s) => s.config), r = this.coders.config.editConfig(n, wr({}, e, {
      checkpoint: this.coders.config.checkpointOf(n) + 1n
    }));
    return this.updateConfig(r);
  }
  async updateConfig(e) {
    if (!this.coders.config.isWalletConfig(e))
      throw new Error(`Invalid config for wallet ${this.address}`);
    const n = this.coders.config.imageHashOf(e), r = this.coders.signature.hashSetImageHash(n), s = await this.signDigest(r, 0, !1);
    await this.tracker.savePresignedConfiguration({
      wallet: this.address,
      nextConfig: e,
      signature: s,
      referenceChainId: 1
    });
    const a = await this.tracker.configOfImageHash({
      imageHash: n,
      noCache: !0
    });
    if (!a || this.coders.config.imageHashOf(a) !== n)
      throw Error(`Reverse lookup failed for imageHash ${n}`);
  }
  /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */
  async buildBootstrapTransactions(e, n) {
    var r;
    const s = await this.orchestrator.buildDeployTransaction({
      chainId: n
    }), a = (r = s == null ? void 0 : s.transactions) != null ? r : [];
    if (!e.onChain.deployed) {
      let c;
      switch (BigInt(n)) {
        case BigInt(k.SKALE_NEBULA):
          c = 10000000n;
          break;
        case BigInt(k.SOMNIA_TESTNET):
          c = 10000000n;
          break;
        case BigInt(k.SOMNIA):
          c = 10000000n;
          break;
      }
      const u = Bo.buildDeployTransaction(e.original.context, e.original.imageHash, c);
      a.push(...u.transactions);
    }
    a.push(...e.signedMigrations.map((c) => ({
      to: c.tx.entrypoint,
      data: re.transaction.encodeBundleExecData(c.tx),
      value: 0,
      gasLimit: 0,
      revertOnError: !0,
      delegateCall: !1
    })));
    const i = e.signedMigrations.length > 0 ? e.signedMigrations[0].tx.intent.id : re.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, n, a), {
      guestModule: o
    } = this.contextFor(e.version);
    return {
      entrypoint: o,
      transactions: a,
      chainId: n,
      intent: {
        id: i,
        wallet: this.address
      }
    };
  }
  async bootstrapTransactions(e, n) {
    const r = n || await this.status(e);
    return this.buildBootstrapTransactions(r, e);
  }
  async doBootstrap(e, n, r) {
    const s = await this.bootstrapTransactions(e, r);
    return this.relayer(e).relay(wr({}, s, {
      chainId: e
    }), n);
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. If the message is already prefixed with the EIP-191
   * prefix, it will be hashed directly. Otherwise, it will be prefixed before hashing.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @param chainId - The chain ID to use for signing
   * @param cantValidateBehavior - Behavior when the wallet cannot validate on-chain
   * @returns A Promise that resolves to the signature as a hexadecimal string
   */
  signMessage(e, n, r = "ignore") {
    const s = G(e), a = G(en(FA));
    let i;
    return s.substring(2).startsWith(a.substring(2)) ? i = ke(e) : i = ck(e), this.signDigest(i, n, !0, r);
  }
  async signTransactions(e, n, r, s) {
    const a = r || await this.status(n);
    this.mustBeFullyMigrated(a);
    const i = this.walletForStatus(n, a), o = {
      address: this.address,
      digest: "",
      // Set in wallet.signTransactions
      chainId: n,
      config: {
        version: this.version
      },
      decorate: !0,
      cantValidateBehavior: "ignore"
    }, c = s != null && s.serial ? {
      serial: !0
    } : (s == null ? void 0 : s.nonceSpace) !== void 0 ? {
      space: s.nonceSpace
    } : void 0, u = await i.signTransactions(e, c, o);
    return wr({}, u, {
      signature: await this.decorateSignature(u.signature, a)
    });
  }
  async signMigrations(e, n) {
    const r = await this.status(e);
    if (r.fullyMigrated) return !1;
    const s = this.walletForStatus(e, r), a = n(s.config), i = await this.migrator.signNextMigration(this.address, r.version, s, a);
    if (!i) return !1;
    await this.tracker.saveWalletConfig({
      config: a
    });
    const o = _t.coderFor(a.version).config, c = o.imageHashOf(a), u = await this.tracker.configOfImageHash({
      imageHash: c,
      noCache: !0
    });
    if (!u || o.imageHashOf(u) !== c)
      throw Error(`Reverse lookup failed for imageHash ${c}`);
    return await this.tracker.saveMigration(this.address, i, this.contexts), !0;
  }
  async signAllMigrations(e) {
    var n = this;
    const r = [];
    return {
      signedMigrations: (await Promise.all(this.networks.map(async function(i) {
        try {
          return await n.signMigrations(i.chainId, e);
        } catch (o) {
          return console.warn(`Failed to sign migrations for chain ${i.chainId}`, o), r.push(i.chainId), null;
        }
      }))).filter((i) => i !== null),
      failedChains: r
    };
  }
  async isMigratedAllChains() {
    var e = this;
    const n = [];
    return {
      migratedAllChains: (await Promise.all(this.networks.map(async function(a) {
        try {
          return await e.status(a.chainId);
        } catch (i) {
          return n.push(a.chainId), console.warn(`Failed to get status for chain ${a.chainId}`, i), {
            fullyMigrated: !0
          };
        }
      }))).every((a) => a.fullyMigrated),
      failedChains: n
    };
  }
  async sendSignedTransactions(e, n, r, s, a, i) {
    if (!Array.isArray(e))
      return this.sendSignedTransactions([e], n, r, s, a, i);
    const o = s || await this.status(n);
    this.mustBeFullyMigrated(o);
    const c = await this.decorateTransactions(e, o, n);
    return a == null || a(c), this.relayer(n).relay(c, r, void 0, i);
  }
  async fillGasLimits(e, n, r) {
    return this.walletForStatus(n, r || await this.status(n)).fillGasLimits(e);
  }
  async gasRefundQuotes(e, n, r, s, a) {
    const i = s || await this.status(n), o = this.walletForStatus(n, i), c = await this.predecorateTransactions(e, i, n), u = re.transaction.fromTransactionish(this.address, c), l = o.coders.config.buildStubSignature(o.config, r), d = G(Aa(32)), m = {
      chainId: n,
      intent: {
        id: d,
        wallet: this.address
      },
      signature: l,
      transactions: u,
      entrypoint: this.address,
      nonce: 0
      // The relayer also ignored the nonce
    }, h = await this.decorateTransactions(m, i), b = re.transaction.encodeBundleExecData(h), y = await this.relayer(n).getFeeOptionsRaw(h.entrypoint, b, a);
    return wr({}, y, {
      decorated: h
    });
  }
  async prepareTransactions(e) {
    const n = await this.status(e.chainId), r = await this.fillGasLimits(e.txs, e.chainId, n), s = await this.gasRefundQuotes(r, e.chainId, e.stubSignatureOverrides, n, {
      simulate: e.simulateForFeeOptions,
      projectAccessKey: e.projectAccessKey
    }), a = re.transaction.unwind(this.address, s.decorated.transactions);
    return {
      transactions: r,
      flatDecorated: a,
      feeOptions: s.options,
      feeQuote: s.quote
    };
  }
  async sendTransaction(e, n, r, s = !1, a, i) {
    const o = await this.status(n), c = s ? e : await this.predecorateTransactions(e, o, n), l = re.transaction.fromTransactionish(this.address, c).length > 0 ? await this.signTransactions(c, n, void 0, i) : void 0, d = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), m = [];
    return l !== void 0 && l.transactions.length > 0 && m.push(l), m.push(...d.filter((h) => h.transactions.length > 0)), this.sendSignedTransactions(m, n, r, void 0, a, i == null ? void 0 : i.projectAccessKey);
  }
  async signTypedData(e, n, r, s, a = "ignore") {
    const i = zk({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(i, s, !0, a);
  }
  async getSigners() {
    var e = this;
    const n = (r) => r.length ? r[r.length - 1] : void 0;
    return (await Promise.all(this.networks.map(async function({
      chainId: r,
      name: s
    }) {
      try {
        var a;
        const i = await e.status(r);
        let o = (a = n(i.presignedConfigurations)) == null ? void 0 : a.nextImageHash;
        if (!o && i.onChain.version !== i.version) {
          const d = n(i.signedMigrations);
          if (d) {
            const {
              toVersion: m,
              toConfig: h
            } = d;
            o = _t.genericCoderFor(m).config.imageHashOf(h);
          }
        }
        o || (o = i.onChain.imageHash);
        const c = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!c)
          throw new Error(`unable to find config for image hash ${o}`);
        return _t.genericCoderFor(c.version).config.signersOf(c).map((d) => wr({}, d, {
          network: r
        }));
      } catch (i) {
        return console.warn(`unable to get signers on network ${r} ${s}`, i), [];
      }
    }))).flat();
  }
  async getAllSigners() {
    var e = this;
    const n = [];
    return await Promise.all(this.networks.map(async function(r) {
      const s = r.chainId, a = await e.status(s, !0), i = [a.onChain.imageHash, ...a.onChain.version !== a.version ? a.signedMigrations.map((o) => _t.coderFor(o.toVersion).config.imageHashOf(o.toConfig)) : [], ...a.presignedConfigurations.map((o) => o.nextImageHash)];
      return Promise.all(i.map(async function(o, c) {
        const u = c === i.length - 1, l = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!l) {
          console.warn(`AllSigners may be incomplete, config not found for imageHash ${o}`);
          return;
        }
        _t.genericCoderFor(l.version).config.signersOf(l).forEach((h) => {
          const b = n.find((y) => y.address === h.address && y.network === s);
          if (b && u && b.flaggedForRemoval) {
            b.flaggedForRemoval = !1;
            return;
          }
          b || n.push({
            address: h.address,
            weight: h.weight,
            network: s,
            flaggedForRemoval: !u
          });
        });
      }));
    })), n;
  }
}
function aZ(t, e) {
  const n = t.replace("ipfs://ipfs/", "").replace("ipfs://", "");
  return t.startsWith("ipfs://") ? `${e}${n}` : t;
}
function iZ(t) {
  return t.startsWith("ipfs://");
}
class m5 {
  constructor(e, n, r = 1e3) {
    this.provider = e, this.solver = n, this.window = r, this.pending = /* @__PURE__ */ new Map();
  }
  async runByEIP5719(e, n, r) {
    const s = `${e}-${n}-${r}`, a = Date.now();
    if (this.pending.has(s) && a - this.pending.get(s).timestamp < this.window)
      return this.pending.get(s).promise;
    const i = y5(e, this.provider, n, r, this.solver);
    return this.pending.set(s, {
      timestamp: a,
      promise: i
    }), i;
  }
}
function oZ(t, e) {
  const n = [{
    inputs: [{
      internalType: "bytes32",
      type: "bytes32"
    }],
    name: "getAlternativeSignature",
    outputs: [{
      internalType: "string",
      type: "string"
    }],
    stateMutability: "view",
    type: "function"
  }];
  return new Rr(t, n, e);
}
async function cZ(t) {
  try {
    return await t;
  } catch {
    return;
  }
}
async function y5(t, e, n, r, s, a = 0) {
  if (a > 10) throw new Error("EIP5719 - Too many tries");
  if (re.signer.canRecover(r)) {
    const c = re.signer.recoverSigner(n, r);
    if (c && c.toLowerCase() === t.toLowerCase()) return r;
  }
  try {
    if (await re.signer.isValidSignature(t, n, r, e))
      return r;
  } catch {
  }
  const i = await cZ(oZ(t, e).getAlternativeSignature(n));
  if (!i || i === "") throw new Error("EIP5719 - Invalid signature and no alternative signature");
  const o = G(await (s || new lZ()).resolve(i));
  if (!o || o === "") throw new Error("EIP5719 - Empty alternative signature");
  if (o === G(r))
    throw new Error("EIP5719 - Alternative signature is invalid or the same");
  return y5(t, e, n, o, s, a + 1);
}
class lZ {
  constructor(e = "https://cloudflare-ipfs.com/ipfs/") {
    var n = this;
    this.gateway = e, this.uri = (r) => iZ(r) ? aZ(r, this.gateway) : r, this.resolve = async function(r) {
      const s = n.uri(r), a = await fetch(s);
      if (!a.ok) throw new Error(`URISolverIPFS - Failed to fetch ${s}`);
      return await a.text();
    };
  }
}
const uZ = (t, e) => e.some((n) => t instanceof n);
let h2, m2;
function dZ() {
  return h2 || (h2 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function fZ() {
  return m2 || (m2 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const b5 = /* @__PURE__ */ new WeakMap(), tg = /* @__PURE__ */ new WeakMap(), g5 = /* @__PURE__ */ new WeakMap(), Mm = /* @__PURE__ */ new WeakMap(), W1 = /* @__PURE__ */ new WeakMap();
function pZ(t) {
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("success", a), t.removeEventListener("error", i);
    }, a = () => {
      n(ga(t.result)), s();
    }, i = () => {
      r(t.error), s();
    };
    t.addEventListener("success", a), t.addEventListener("error", i);
  });
  return e.then((n) => {
    n instanceof IDBCursor && b5.set(n, t);
  }).catch(() => {
  }), W1.set(e, t), e;
}
function hZ(t) {
  if (tg.has(t))
    return;
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("complete", a), t.removeEventListener("error", i), t.removeEventListener("abort", i);
    }, a = () => {
      n(), s();
    }, i = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), s();
    };
    t.addEventListener("complete", a), t.addEventListener("error", i), t.addEventListener("abort", i);
  });
  tg.set(t, e);
}
let ng = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return tg.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || g5.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return ga(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function mZ(t) {
  ng = t(ng);
}
function yZ(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(Lm(this), e, ...n);
    return g5.set(r, e.sort ? e.sort() : [e]), ga(r);
  } : fZ().includes(t) ? function(...e) {
    return t.apply(Lm(this), e), ga(b5.get(this));
  } : function(...e) {
    return ga(t.apply(Lm(this), e));
  };
}
function bZ(t) {
  return typeof t == "function" ? yZ(t) : (t instanceof IDBTransaction && hZ(t), uZ(t, dZ()) ? new Proxy(t, ng) : t);
}
function ga(t) {
  if (t instanceof IDBRequest)
    return pZ(t);
  if (Mm.has(t))
    return Mm.get(t);
  const e = bZ(t);
  return e !== t && (Mm.set(t, e), W1.set(e, t)), e;
}
const Lm = (t) => W1.get(t);
function gZ(t, e, { blocked: n, upgrade: r, blocking: s, terminated: a } = {}) {
  const i = indexedDB.open(t, e), o = ga(i);
  return r && i.addEventListener("upgradeneeded", (c) => {
    r(ga(i.result), c.oldVersion, c.newVersion, ga(i.transaction), c);
  }), n && i.addEventListener("blocked", (c) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    c.oldVersion,
    c.newVersion,
    c
  )), o.then((c) => {
    a && c.addEventListener("close", () => a()), s && c.addEventListener("versionchange", (u) => s(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
const wZ = ["get", "getKey", "getAll", "getAllKeys", "count"], EZ = ["put", "add", "delete", "clear"], Hm = /* @__PURE__ */ new Map();
function y2(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (Hm.get(e))
    return Hm.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, s = EZ.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(s || wZ.includes(n))
  )
    return;
  const a = async function(i, ...o) {
    const c = this.transaction(i, s ? "readwrite" : "readonly");
    let u = c.store;
    return r && (u = u.index(o.shift())), (await Promise.all([
      u[n](...o),
      s && c.done
    ]))[0];
  };
  return Hm.set(e, a), a;
}
mZ((t) => ({
  ...t,
  get: (e, n, r) => y2(e, n) || t.get(e, n, r),
  has: (e, n) => !!y2(e, n) || t.has(e, n)
}));
function _r() {
  return _r = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, _r.apply(null, arguments);
}
const xZ = ["function execute((bool delegateCall, bool revertOnError, uint256 gasLimit, address target, uint256 value, bytes data)[] calldata transactions, uint256 nonce, bytes calldata signature)"], Ui = {
  namespace: "Sequence-Sessions",
  owners: ["AZ6R2mG8zxW9q7--iZXGrBknjegHoPzmG5IG-nxvMaM"],
  arweaveUrl: "https://arweave.net",
  graphqlUrl: "https://arweave.net/graphql",
  eip5719Provider: void 0,
  rateLimitRetryDelayMs: 5 * 60 * 1e3
};
class AZ {
  constructor(e = Ui) {
    this.options = e, this.configs = /* @__PURE__ */ new Map(), this.eip5719 = void 0, e.eip5719Provider && (this.eip5719 = new m5(e.eip5719Provider));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = ue(e.wallet), s = await this.configOfImageHash({
      imageHash: e.fromImageHash
    });
    if (!s)
      throw new Error(`unable to find from config ${e.fromImageHash}`);
    if (!de.config.isWalletConfig(s))
      throw new Error(`from config ${e.fromImageHash} is not v2`);
    const a = BigInt(s.checkpoint), i = Object.entries(await Sl({
      Type: "config update",
      Wallet: r
    }, this.options)).flatMap(([l, d]) => {
      try {
        const {
          Signer: m,
          Subdigest: h,
          Digest: b,
          "To-Config": y
        } = d;
        let g;
        switch (d["Signature-Type"]) {
          case "eip-712":
          case "eth_sign":
          case "erc-1271":
            g = d["Signature-Type"];
            break;
          default:
            throw new Error(`unknown signature type ${d["Signature-Type"]}`);
        }
        let w;
        try {
          w = BigInt(d["To-Checkpoint"]);
        } catch {
          throw new Error(`to checkpoint is not a number: ${d["To-Checkpoint"]}`);
        }
        if (w <= a)
          return [];
        if (!oE(m))
          throw new Error(`signer is not an address: ${m}`);
        if (!Ue(h, 32))
          throw new Error(`subdigest is not a hash: ${h}`);
        if (!Ue(b, 32))
          throw new Error(`digest is not a hash: ${b}`);
        let v;
        try {
          v = BigInt(d["Chain-ID"]);
        } catch {
          throw new Error(`chain id is not a number: ${d["Chain-ID"]}`);
        }
        if (!Ue(y, 32))
          throw new Error(`to config is not a hash: ${y}`);
        return [{
          id: l,
          signatureType: g,
          signer: m,
          subdigest: h,
          digest: b,
          chainId: v,
          toImageHash: y,
          toCheckpoint: w
        }];
      } catch (m) {
        return console.warn(`invalid wallet ${r} config update ${l}:`, m), [];
      }
    }), o = /* @__PURE__ */ new Map();
    let c = [];
    for (const l of i) {
      let d = o.get(l.toImageHash);
      d || (d = /* @__PURE__ */ new Map(), o.set(l.toImageHash, d), c.push(l)), d.set(l.signer, l);
    }
    e.longestPath ? c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? -1 : 1) : c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? 1 : -1);
    const u = [];
    for (let l = s; c.length; ) {
      const d = de.config.imageHash(l);
      let m, h, b = [];
      for (const g of c) {
        h = o.get(g.toImageHash), b = Array.from(h.keys());
        const {
          weight: w
        } = de.signature.encodeSigners(l, new Map(b.map((v) => [v, {
          signature: "0x",
          isDynamic: !1
        }])), [], 0);
        if (w >= BigInt(l.threshold)) {
          m = g;
          break;
        }
      }
      if (!m) {
        console.warn(`unreachable configs with checkpoint > ${l.checkpoint} from config ${d}`);
        break;
      }
      const y = m.toImageHash;
      try {
        const g = await this.configOfImageHash({
          imageHash: y
        });
        if (!g)
          throw new Error(`unable to find config ${y}`);
        if (!de.config.isWalletConfig(g))
          throw new Error(`config ${y} is not v2`);
        const w = new Map((await Promise.all(b.map(async function(B) {
          const {
            id: x,
            subdigest: N,
            signatureType: I
          } = h.get(B);
          try {
            let O = await (await df(x, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).text();
            switch (I) {
              case "eip-712":
                O += "01";
                break;
              case "eth_sign":
                O += "02";
                break;
              case "erc-1271":
                O += "03";
                break;
            }
            if (n.eip5719)
              try {
                O = G(await n.eip5719.runByEIP5719(B, N, O));
              } catch {
                console.warn(`unable to run eip-5719 on config update ${x}`);
              }
            const C = re.signer.tryRecoverSigner(N, O);
            return [[B, {
              signature: O,
              isDynamic: C !== B
            }]];
          } catch (O) {
            return console.warn(`unable to fetch signer ${B} config update ${x}:`, O), [];
          }
        }))).flat()), {
          encoded: v,
          weight: A
        } = de.signature.encodeSigners(l, w, [], 0);
        if (A < BigInt(l.threshold))
          throw new Error(`insufficient signing power ${A.toString()} < ${l.threshold}`);
        u.push({
          wallet: r,
          signature: v,
          nextImageHash: y
        }), l = g, c = c.filter(({
          toCheckpoint: B
        }) => B > BigInt(l.checkpoint));
      } catch (g) {
        console.warn(`unable to reconstruct wallet ${r} update from config ${d} to config ${y}:`, g), c = c.filter(({
          toImageHash: w
        }) => w !== y);
      }
    }
    return u;
  }
  savePresignedConfiguration(e) {
    throw new Error("arweave backend does not support saving config updates");
  }
  saveWitnesses(e) {
    throw new Error("arweave backend does not support saving signatures");
  }
  async configOfImageHash(e) {
    var n = this;
    if (!e.noCache) {
      const s = this.configs.get(e.imageHash);
      if (s)
        try {
          return await s;
        } catch {
          const i = this.configs.get(e.imageHash);
          if (i)
            return i;
        }
    }
    const r = async function(s) {
      const a = Object.entries(await Sl({
        Type: "config",
        Config: s
      }, n.options)).flatMap(([i, o]) => {
        try {
          const c = Number(o.Version);
          if (!c)
            throw new Error(`invalid version: ${o.Version}`);
          return [{
            id: i,
            version: c
          }];
        } catch (c) {
          return console.warn(`config ${s} at ${i} invalid:`, c), [];
        }
      });
      switch (a.length) {
        case 0:
          n.configs.set(s, Promise.resolve(void 0));
          return;
        case 1:
          break;
        default:
          console.warn(`multiple configs ${s} at ${a.map(({
            id: i
          }) => i).join(", ")}`);
          break;
      }
      for (const {
        id: i,
        version: o
      } of a)
        try {
          const c = _r({}, await (await df(i, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).json(), {
            version: o
          });
          c.tree && (c.tree = fo(c.tree));
          const u = _t.coderFor(o).config.imageHashOf(c);
          if (u !== s)
            throw new Error(`image hash is ${u}, expected ${s}`);
          return n.configs.set(s, Promise.resolve(c)), c;
        } catch (c) {
          console.warn(`config at ${i} invalid:`, c);
        }
      n.configs.set(s, Promise.resolve(void 0));
    }(e.imageHash);
    return e.noCache || this.configs.set(e.imageHash, r), r;
  }
  saveWalletConfig(e) {
    throw new Error("arweave backend does not support saving configs");
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = ue(e.wallet), r = Object.entries(await Sl({
      Type: "wallet",
      Wallet: n
    }, this.options)).flatMap(([s, a]) => {
      try {
        const {
          "Deploy-Config": i
        } = a, o = Number(a["Deploy-Version"]);
        if (!o)
          throw new Error(`invalid version: ${a["Deploy-Version"]}`);
        if (!i)
          throw new Error("no deploy config");
        const c = re.context.defaultContexts[o];
        if (!c)
          throw new Error(`unknown version: ${o}`);
        if (re.context.addressOf(c, i) !== n)
          throw new Error(`incorrect v${o} deploy config: ${i}`);
        return [{
          id: s,
          imageHash: i,
          context: c
        }];
      } catch (i) {
        return console.warn(`wallet ${n} at ${s} invalid:`, i), [];
      }
    });
    switch (r.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple deploy configs for wallet ${n} at ${r.map(({
          id: s
        }) => s).join(", ")}, using first`);
        break;
    }
    return r[0];
  }
  saveCounterfactualWallet(e) {
    throw new Error("arweave backend does not support saving wallets");
  }
  async walletsOfSigner(e) {
    var n = this;
    const r = ue(e.signer), s = /* @__PURE__ */ new Map();
    for (const [a, i] of Object.entries(await Sl({
      Type: ["signature", "config update"],
      Signer: r,
      Witness: e.allSignatures ? void 0 : "true"
    }, this.options))) {
      const {
        Wallet: o,
        Subdigest: c,
        Digest: u,
        "Chain-ID": l
      } = i;
      try {
        if (s.has(o))
          continue;
        let d;
        switch (i["Signature-Type"]) {
          case "eip-712":
            d = "01";
            break;
          case "eth_sign":
            d = "02";
            break;
          case "erc-1271":
            d = "03";
            break;
          default:
            throw new Error(`unknown signature type ${i["Signature-Type"]}`);
        }
        if (c !== re.signature.subdigestOf({
          digest: u,
          chainId: l,
          address: o
        }))
          throw new Error("incorrect subdigest");
        const m = df(a, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then(async function(h) {
          const b = await h.text() + d;
          if (n.eip5719)
            try {
              return G(await n.eip5719.runByEIP5719(r, c, b));
            } catch {
              console.warn(`unable to run eip-5719 on signature ${a}`);
            }
          return b;
        });
        s.set(o, {
          digest: u,
          chainId: BigInt(l),
          signature: m
        });
      } catch (d) {
        console.warn(`signer ${r} signature ${a} of wallet ${o} invalid:`, d);
      }
    }
    return Promise.all([...s.entries()].map(async function([a, {
      digest: i,
      chainId: o,
      signature: c
    }]) {
      return {
        wallet: a,
        proof: {
          digest: i,
          chainId: o,
          signature: await c
        }
      };
    }));
  }
  async getMigration(e, n, r, s) {
    const a = ue(e), i = Object.entries(await Sl({
      Type: "migration",
      Migration: a,
      "Chain-ID": BigInt(s).toString(),
      "From-Version": `${r}`,
      "From-Config": n
    }, this.options)).flatMap(([A, B]) => {
      try {
        const {
          "To-Config": x,
          Executor: N
        } = B, I = Number(B["To-Version"]);
        if (!I)
          throw new Error(`invalid version: ${B["To-Version"]}`);
        if (!Ue(x, 32))
          throw new Error(`to config is not a hash: ${x}`);
        if (!oE(N))
          throw new Error(`executor is not an address: ${N}`);
        return {
          id: A,
          toVersion: I,
          toImageHash: x,
          executor: N
        };
      } catch (x) {
        return console.warn(`chain ${s} migration ${A} for v${r} wallet ${a} from config ${n} invalid:`, x), [];
      }
    });
    switch (i.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple chain ${s} migrations for v${r} wallet ${a} from config ${n} at ${i.map(({
          id: A
        }) => A).join(", ")}, using first`);
        break;
    }
    const {
      id: o,
      toVersion: c,
      toImageHash: u,
      executor: l
    } = i[0], [d, m] = await Promise.all([df(o, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then((A) => A.text()), this.configOfImageHash({
      imageHash: u
    })]);
    if (!m)
      throw new Error(`unable to find to config ${u} for migration`);
    const h = new Bt(xZ), [b, y, g] = h.decodeFunctionData("execute", d), w = re.transaction.fromTxAbiEncode(b), v = re.transaction.subdigestOfTransactions(a, s, y, w);
    return {
      tx: {
        entrypoint: l,
        transactions: w,
        nonce: y,
        chainId: s,
        intent: {
          id: v,
          wallet: a
        },
        signature: g
      },
      fromVersion: r,
      toVersion: Number(c),
      toConfig: m
    };
  }
  saveMigration(e, n, r) {
    throw new Error("arweave backend does not support saving migrations");
  }
}
async function Sl(t, e) {
  var n, r, s, a;
  const i = (n = e == null ? void 0 : e.namespace) != null ? n : Ui.namespace, o = e == null ? void 0 : e.owners, c = (r = e == null ? void 0 : e.graphqlUrl) != null ? r : Ui.graphqlUrl, u = (s = e == null ? void 0 : e.rateLimitRetryDelayMs) != null ? s : Ui.rateLimitRetryDelayMs, l = (a = e == null ? void 0 : e.pageSize) != null ? a : 100, d = e == null ? void 0 : e.maxResults, m = Object.entries(t).flatMap(([b, y]) => y === void 0 ? [] : [`{ name: "${i ? `${i}-${b}` : b}", values: [${typeof y == "string" ? `"${y}"` : y.map((g) => `"${g}"`).join(", ")}] }`]), h = [];
  for (let b = !0; b && (d === void 0 || h.length < d); ) {
    const y = `
      query {
        transactions(sort: HEIGHT_DESC, ${h.length ? `first: ${l}, after: "${h[h.length - 1].cursor}"` : `first: ${l}`}, tags: [${m.join(", ")}]${o === void 0 ? "" : `, owners: [${o.map((v) => `"${v}"`).join(", ")}]`}) {
          pageInfo {
            hasNextPage
          }
          edges {
            cursor
            node {
              id
              tags {
                name
                value
              }
            }
          }
        }
      }
    `;
    let g;
    for (; g = await fetch(c, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: y
      }),
      redirect: "follow"
    }), g.status === 429; )
      console.warn(`rate limited by ${c}, trying again in ${u / 1e3} seconds at ${new Date(Date.now() + u).toLocaleTimeString()}`), await new Promise((v) => setTimeout(v, u));
    const {
      data: {
        transactions: w
      }
    } = await g.json();
    h.push(...w.edges), b = w.pageInfo.hasNextPage;
  }
  return Object.fromEntries(h.map(({
    node: {
      id: b,
      tags: y
    }
  }) => [b, Object.fromEntries(y.map(({
    name: g,
    value: w
  }) => [i && g.startsWith(`${i}-`) ? g.slice(i.length + 1) : g, w]))]));
}
async function df(t, e = Ui.rateLimitRetryDelayMs, n = Ui.arweaveUrl) {
  for (; ; ) {
    const r = await fetch(`${n}/${t}`, {
      redirect: "follow"
    });
    if (r.status !== 429)
      return r;
    console.warn(`rate limited by ${n}, trying again in ${e / 1e3} seconds at ${new Date(Date.now() + e).toLocaleTimeString()}`), await new Promise((s) => setTimeout(s, e));
  }
}
function fo(t) {
  return typeof t == "string" ? {
    nodeHash: t
  } : typeof t == "object" && (t == null ? void 0 : t.node) !== void 0 ? {
    nodeHash: t.node
  } : t instanceof Array && t.length === 2 ? {
    left: fo(t[0]),
    right: fo(t[1])
  } : de.config.isNode(t) ? {
    left: fo(t.left),
    right: fo(t.right)
  } : de.config.isNestedLeaf(t) ? _r({}, t, {
    tree: fo(t.tree)
  }) : t;
}
var kZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaults: Ui,
  ArweaveReader: AZ
});
class vZ {
  constructor(e) {
    this.tracker = e;
  }
  async loadPresignedConfiguration(e) {
    return console.debug("? loadPresignedConfiguration"), Rt(e, "? "), Rt(await this.tracker.loadPresignedConfiguration(e), "! ");
  }
  savePresignedConfiguration(e) {
    return console.debug("? savePresignedConfiguration"), Rt(e, "? "), this.tracker.savePresignedConfiguration(e);
  }
  saveWitnesses(e) {
    return console.debug("? saveWitnesses"), Rt(e, "? "), this.tracker.saveWitnesses(e);
  }
  async configOfImageHash(e) {
    return console.debug("? configOfImageHash"), Rt(e, "? "), Rt(await this.tracker.configOfImageHash(e), "! ");
  }
  saveWalletConfig(e) {
    return console.debug("? saveWalletConfig"), Rt(e, "? "), this.tracker.saveWalletConfig(e);
  }
  async imageHashOfCounterfactualWallet(e) {
    return console.debug("? imageHashOfCounterfactualWallet"), Rt(e, "? "), Rt(await this.tracker.imageHashOfCounterfactualWallet(e), "! ");
  }
  saveCounterfactualWallet(e) {
    return console.debug("? saveCounterfactualWallet"), Rt(e, "? "), this.tracker.saveCounterfactualWallet(e);
  }
  async walletsOfSigner(e) {
    return console.debug("? walletsOfSigner"), Rt(e, "? "), Rt(await this.tracker.walletsOfSigner(e), "! ");
  }
  async getMigration(e, n, r, s) {
    return console.debug("? getMigration"), Rt({
      address: e,
      fromImageHash: n,
      fromVersion: r,
      chainId: s
    }, "? "), Rt(await this.tracker.getMigration(e, n, r, s), "! ");
  }
  saveMigration(e, n, r) {
    return console.debug("? saveMigration"), Rt({
      address: e,
      signed: n,
      contexts: r
    }, "? "), this.tracker.saveMigration(e, n, r);
  }
}
function Rt(t, e = "") {
  switch (t) {
    case void 0:
      console.debug(e + "undefined");
      break;
    default:
      JSON.stringify(t, Dl, 2).split(`
`).map((n) => e + n).forEach((n) => console.debug(n));
      break;
  }
  return t;
}
var CZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DebugConfigTracker: vZ
});
class w5 {
  constructor() {
    this.configs = {}, this.v2Nodes = {}, this.counterfactualWallets = {}, this.payloads = {}, this.signatures = {}, this.migrations = {}, this.loadConfig = (e) => Promise.resolve(this.configs[e]), this.saveConfig = (e, n) => (this.configs[e] = n, Promise.resolve()), this.loadV2Node = (e) => Promise.resolve(this.v2Nodes[e]), this.saveV2Node = (e, n) => (this.v2Nodes[e] = n, Promise.resolve()), this.loadCounterfactualWallet = (e) => Promise.resolve(this.counterfactualWallets[e]), this.saveCounterfactualWallet = (e, n, r) => (this.counterfactualWallets[e] = {
      imageHash: n,
      context: r
    }, Promise.resolve()), this.loadPayloadOfSubdigest = (e) => Promise.resolve(this.payloads[e]), this.savePayloadOfSubdigest = (e, n) => (this.payloads[e] = n, Promise.resolve()), this.loadSubdigestsOfSigner = (e) => Promise.resolve(Object.keys(this.signatures[e] || {})), this.loadSignatureOfSubdigest = (e, n) => {
      var r;
      return Promise.resolve((r = this.signatures[e]) == null ? void 0 : r[n]);
    }, this.saveSignatureOfSubdigest = (e, n, r) => (this.signatures[e] || (this.signatures[e] = {}), this.signatures[e][n] = r, Promise.resolve()), this.loadMigrationsSubdigest = (e, n, r) => {
      var s;
      return Promise.resolve(((s = this.migrations[e]) == null || (s = s[n]) == null ? void 0 : s[r]) || []);
    }, this.saveMigrationsSubdigest = (e, n, r, s, a) => (this.migrations[e] || (this.migrations[e] = {}), this.migrations[e][n] || (this.migrations[e][n] = {}), this.migrations[e][n][r] || (this.migrations[e][n][r] = []), this.migrations[e][n][r].push({
      subdigest: s,
      toImageHash: a
    }), Promise.resolve());
  }
}
function Io(t) {
  if (t === void 0) return;
  const e = {};
  for (const n of Object.keys(t)) {
    const r = t[n];
    r._isBigNumber === !0 && r._hex !== void 0 && typeof r._hex == "string" && r._hex.length !== "" ? e[n] = BigInt(r._hex) : Array.isArray(r) ? e[n] = r.map((s) => Io(s)) : typeof r == "object" && r !== null ? e[n] = Io(r) : e[n] = r;
  }
  return e;
}
class TZ {
  constructor(e) {
    var n = this;
    this.dbName = e, this._lazyDb = void 0, this.loadConfig = async function(r) {
      return (await n.getDb()).get("configs", r).then((a) => Io(a));
    }, this.saveConfig = async function(r, s) {
      await (await n.getDb()).put("configs", s, r);
    }, this.loadV2Node = async function(r) {
      return (await n.getDb()).get("v2Nodes", r).then((a) => Io(a));
    }, this.saveV2Node = async function(r, s) {
      await (await n.getDb()).put("v2Nodes", s, r);
    }, this.loadCounterfactualWallet = async function(r) {
      return (await n.getDb()).get("counterfactualWallets", r);
    }, this.saveCounterfactualWallet = async function(r, s, a) {
      await (await n.getDb()).put("counterfactualWallets", {
        imageHash: s,
        context: a
      }, r);
    }, this.loadPayloadOfSubdigest = async function(r) {
      return (await n.getDb()).get("payloads", r).then((a) => Io(a));
    }, this.savePayloadOfSubdigest = async function(r, s) {
      await (await n.getDb()).put("payloads", s, r);
    }, this.loadSubdigestsOfSigner = async function(r) {
      return (await (await n.getDb()).getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(r))).map((i) => i.split("-")[0]);
    }, this.loadSignatureOfSubdigest = async function(r, s) {
      const i = await (await n.getDb()).get("signatures", [s, r].join("-"));
      return i == null ? void 0 : i.signature;
    }, this.saveSignatureOfSubdigest = async function(r, s, a) {
      await (await n.getDb()).put("signatures", {
        signature: a,
        signer: r
      }, [s, r].join("-"));
    }, this.loadMigrationsSubdigest = async function(r, s, a) {
      return (await (await n.getDb()).getAllFromIndex("migrations", "jump", IDBKeyRange.only([r, s, a]))).map((c) => ({
        subdigest: c.subdigest,
        toImageHash: c.toImageHash
      }));
    }, this.saveMigrationsSubdigest = async function(r, s, a, i, o) {
      await (await n.getDb()).put("migrations", {
        wallet: r,
        fromVersion: s,
        toVersion: a,
        subdigest: i,
        toImageHash: o
      }, i);
    };
  }
  async getDb() {
    if (this._lazyDb) return this._lazyDb;
    const e = this.dbName;
    return this._lazyDb = await gZ(e, 1, {
      upgrade(n, r, s, a) {
        console.log(`upgrading ${e} from ${r} to ${s} - ${a}`), r === 0 && (n.createObjectStore("configs"), n.createObjectStore("v2Nodes"), n.createObjectStore("counterfactualWallets"), n.createObjectStore("payloads"), n.createObjectStore("signatures").createIndex("signer", "signer", {
          unique: !1
        }), n.createObjectStore("migrations").createIndex("jump", ["wallet", "fromVersion", "toVersion"]));
      }
    }), this._lazyDb;
  }
}
function E5(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function x5(t) {
  return t.weight !== void 0 && t.threshold !== void 0 && t.tree !== void 0;
}
function rg(t) {
  return t.version === 2 && t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && typeof t.tree == "string";
}
var SZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainNode: E5,
  isPlainNested: x5,
  isPlainV2Config: rg,
  MemoryTrackerStore: w5,
  recreateBigNumbers: Io,
  IndexedDBStore: TZ
});
class Q1 {
  constructor(e, n = new w5(), r = !1) {
    var s = this;
    this.provider = e, this.store = n, this.useEIP5719 = r, this.cachedEIP5719 = void 0, this.loadTopology = async function(a) {
      const i = await s.store.loadV2Node(a);
      if (!i) return {
        nodeHash: a
      };
      if (E5(i)) {
        const [o, c] = await Promise.all([s.loadTopology(i.left), s.loadTopology(i.right)]);
        return {
          left: o,
          right: c
        };
      }
      return x5(i) ? {
        weight: BigInt(i.weight),
        threshold: BigInt(i.threshold),
        tree: await s.loadTopology(i.tree)
      } : i;
    }, this.saveTopology = async function(a) {
      if (de.config.isNodeLeaf(a))
        return;
      const i = de.config.hashNode(a);
      if (de.config.isNode(a)) {
        const o = s.saveTopology(a.left), c = s.saveTopology(a.right), u = s.store.saveV2Node(i, {
          left: de.config.hashNode(a.left),
          right: de.config.hashNode(a.right)
        });
        await Promise.all([o, c, u]);
        return;
      }
      if (de.config.isNestedLeaf(a)) {
        const o = s.saveTopology(a.tree), c = s.store.saveV2Node(i, {
          weight: BigInt(a.weight).toString(),
          threshold: BigInt(a.threshold).toString(),
          tree: de.config.hashNode(a.tree)
        });
        await Promise.all([o, c]);
        return;
      }
      if (de.config.isSignerLeaf(a))
        return s.store.saveV2Node(i, {
          address: a.address,
          weight: a.weight
        });
      if (de.config.isSubdigestLeaf(a))
        return s.store.saveV2Node(i, {
          subdigest: a.subdigest
        });
      throw new Error(`Unknown topology type: ${a}`);
    }, this.saveWalletConfig = async function(a) {
      const {
        config: i
      } = a;
      if (Fa.config.ConfigCoder.isWalletConfig(i)) {
        const o = Fa.config.ConfigCoder.imageHashOf(i);
        return s.store.saveConfig(o, i);
      }
      if (de.config.ConfigCoder.isWalletConfig(i)) {
        const o = de.config.ConfigCoder.imageHashOf(i);
        if (de.config.isComplete(i.tree))
          return s.store.saveConfig(o, i);
      }
    }, this.configOfImageHashCache = {}, this.configOfImageHash = async function(a) {
      const {
        imageHash: i
      } = a;
      if (s.configOfImageHashCache[a.imageHash])
        return s.configOfImageHashCache[a.imageHash];
      const o = await s.store.loadConfig(i);
      if (o) {
        if (o.version === 1 || o.version === 2 && !rg(o))
          return s.configOfImageHashCache[a.imageHash] = o, o;
        if (rg(o)) {
          const c = {
            version: 2,
            threshold: BigInt(o.threshold),
            checkpoint: BigInt(o.checkpoint),
            tree: await s.loadTopology(o.tree)
          };
          return s.configOfImageHashCache[a.imageHash] = c, c;
        }
        throw new Error(`Unknown config type: ${o}`);
      }
    }, this.saveCounterfactualWallet = async function(a) {
      const {
        config: i,
        context: o
      } = a, c = _t.genericCoderFor(i.version).config.imageHashOf(i);
      await Promise.all([s.saveWalletConfig({
        config: i
      }), ...o.map((u) => {
        const l = re.context.addressOf(u, c);
        return s.store.saveCounterfactualWallet(l, c, u);
      })]);
    }, this.imageHashOfCounterfactualWallet = async function(a) {
      const {
        wallet: i
      } = a, o = await s.store.loadCounterfactualWallet(i);
      if (o)
        return {
          imageHash: o.imageHash,
          context: o.context
        };
    }, this.savePayload = async function(a) {
      const {
        payload: i
      } = a, o = re.signature.subdigestOf(i);
      await s.store.savePayloadOfSubdigest(o, i);
    }, this.payloadOfSubdigestCache = {}, this.payloadOfSubdigest = async function(a) {
      if (s.payloadOfSubdigestCache[a.subdigest])
        return s.payloadOfSubdigestCache[a.subdigest];
      const {
        subdigest: i
      } = a, o = await s.store.loadPayloadOfSubdigest(i);
      return o && (s.payloadOfSubdigestCache[i] = o), o;
    }, this.savePresignedConfiguration = async function(a) {
      const i = de.signature.SignatureCoder.decode(a.signature), o = _t.genericCoderFor(a.nextConfig.version).config.imageHashOf(a.nextConfig), c = de.chained.messageSetImageHash(o), u = ke(c), l = {
        message: c,
        address: a.wallet,
        chainId: 0,
        digest: u
      }, d = s.savePayload({
        payload: l
      }), m = s.saveWalletConfig({
        config: a.nextConfig
      }), h = await de.signature.SignatureCoder.recover(i, l, s.provider), b = de.signature.signaturesOf(h.config.tree);
      await Promise.all([d, m, s.saveWalletConfig({
        config: h.config
      }), ...b.map((y) => s.store.saveSignatureOfSubdigest(y.address, h.subdigest, y.signature))]);
    }, this.loadPresignedConfiguration = async function(a) {
      const {
        wallet: i,
        fromImageHash: o,
        longestPath: c
      } = a, u = await s.configOfImageHash({
        imageHash: o
      });
      if (!u || !de.config.ConfigCoder.isWalletConfig(u))
        return [];
      const l = de.config.signersOf(u.tree).map((A) => A.address), d = await Promise.all(l.map((A) => s.store.loadSubdigestsOfSigner(A))), m = [...new Set(d.flat())], b = (await Promise.all([...new Set(m)].map(async function(A) {
        return _r({}, await s.payloadOfSubdigest({
          subdigest: A
        }), {
          subdigest: A
        });
      }))).filter((A) => (A == null ? void 0 : A.message) && (A == null ? void 0 : A.address) && A.address === i).map((A) => ({
        payload: A,
        nextImageHash: de.chained.decodeMessageSetImageHash(A.message)
      })).filter((A) => A == null ? void 0 : A.nextImageHash);
      let y;
      const w = (await Promise.all(b.map(async function({
        nextImageHash: A,
        payload: B
      }) {
        const x = await s.configOfImageHash({
          imageHash: A
        });
        if (!x || !de.config.isWalletConfig(x)) return;
        const N = BigInt(x.checkpoint);
        return {
          nextConfig: x,
          nextCheckpoint: N,
          nextImageHash: A,
          payload: B
        };
      }))).filter((A) => A !== void 0).filter((A) => A.nextCheckpoint > BigInt(u.checkpoint)).sort((A, B) => (
        // If we are looking for the longest path, sort by ascending checkpoint
        // because we want to find the smalles jump, and we should start with the
        // closest one. If we are not looking for the longest path, sort by
        // descending checkpoint, because we want to find the largest jump.
        //
        // We don't have a guarantee that all "next configs" will be valid
        // so worst case scenario we will need to try all of them.
        // But we can try to optimize for the most common case.
        A.nextCheckpoint > B.nextCheckpoint ? c ? 1 : -1 : c ? -1 : 1
      ));
      for (const A of w) {
        const {
          nextConfig: B,
          nextCheckpoint: x,
          nextImageHash: N,
          payload: I
        } = A;
        if (y) {
          const U = y.checkpoint;
          if (c) {
            if (x >= U) continue;
          } else if (x <= U) continue;
        }
        const O = new Map((await Promise.all(l.map(async function(U) {
          const P = await s.store.loadSignatureOfSubdigest(U, I.subdigest);
          if (!P)
            return [U, void 0];
          const D = G(s.useEIP5719 ? await s.cachedEIP5719.runByEIP5719(U, I.subdigest, P) : P), $ = re.signer.tryRecoverSigner(I.subdigest, D) !== U;
          return [U, {
            isDynamic: $,
            signature: D
          }];
        }))).filter((U) => !!U[1]));
        if (O.size === 0) continue;
        const C = de.signature.SignatureCoder.encodeSigners(u, O, [], 0);
        C.weight < BigInt(u.threshold) || (y = {
          nextImageHash: N,
          checkpoint: BigInt(B.checkpoint),
          signature: C.encoded
        });
      }
      if (!y)
        return [];
      const v = await s.loadPresignedConfiguration({
        wallet: i,
        fromImageHash: y.nextImageHash,
        longestPath: c
      });
      return [{
        wallet: i,
        nextImageHash: y.nextImageHash,
        signature: y.signature
      }, ...v];
    }, this.saveWitnesses = async function(a) {
      const i = {
        digest: a.digest,
        address: a.wallet,
        chainId: a.chainId
      }, o = re.signature.subdigestOf(i);
      await Promise.all([s.savePayload({
        payload: i
      }), ...a.signatures.filter((c) => re.signer.canRecover(c)).map((c) => {
        const u = re.signer.recoverSigner(o, c);
        return s.store.saveSignatureOfSubdigest(u, o, c);
      })]);
    }, this.walletsOfSigner = async function(a) {
      const i = await s.store.loadSubdigestsOfSigner(a.signer), o = await Promise.all(i.map((u) => s.payloadOfSubdigest({
        subdigest: u
      }))).then((u) => u.filter((l) => l !== void 0)), c = [];
      for (const u of o) {
        const l = u.address;
        if (c.find((h) => h.wallet === l)) continue;
        const d = re.signature.subdigestOf(u), m = await s.store.loadSignatureOfSubdigest(a.signer, d);
        m && c.push({
          wallet: l,
          proof: {
            digest: u.digest,
            chainId: BigInt(u.chainId),
            signature: G(m)
          }
        });
      }
      return c;
    }, this.cachedEIP5719 = new m5(e);
  }
  async saveMigration(e, n, r) {
    const s = n.fromVersion;
    if (s !== 1) throw new Error("Migration not supported");
    if (!de.config.isWalletConfig(n.toConfig)) throw new Error("Invalid to config");
    const {
      newImageHash: a,
      address: i
    } = NJ.v1v2.decodeTransaction(n.tx, r);
    if (i !== e) throw new Error("Invalid migration transaction - address");
    if (de.config.ConfigCoder.imageHashOf(n.toConfig) != a) throw new Error("Invalid migration transaction - config");
    const o = re.transaction.packMetaTransactionsData(n.tx.nonce, n.tx.transactions), c = ke(o), u = {
      chainId: n.tx.chainId,
      message: o,
      address: e,
      digest: c
    }, l = re.signature.subdigestOf(u), d = this.savePayload({
      payload: u
    }), m = this.saveWalletConfig({
      config: n.toConfig
    }), h = Fa.signature.SignatureCoder.decode(n.tx.signature), b = await Fa.signature.SignatureCoder.recover(h, u, this.provider), y = Fa.signature.SignatureCoder.signaturesOf(b.config);
    await Promise.all([d, m, this.saveWalletConfig({
      config: b.config
    }), this.store.saveMigrationsSubdigest(e, s, s + 1, l, a), ...y.map((g) => this.store.saveSignatureOfSubdigest(g.address, b.subdigest, g.signature))]);
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const [i, o] = await Promise.all([this.configOfImageHash({
      imageHash: n
    }), this.store.loadMigrationsSubdigest(e, r, r + 1)]), c = _t.coderFor(r);
    return !i || !c.config.isWalletConfig(i) ? void 0 : (await Promise.all(o.map(async function(l) {
      const {
        subdigest: d,
        toImageHash: m
      } = l, h = await a.payloadOfSubdigest({
        subdigest: d
      });
      if (!h || !h.message || BigInt(s) !== BigInt(h.chainId)) return;
      const b = c.config.signersOf(i).map((A) => A.address), y = new Map((await Promise.all(b.map(async function(A) {
        const B = await a.store.loadSignatureOfSubdigest(A, d);
        if (!B)
          return [A, void 0];
        const x = G(a.useEIP5719 ? await a.cachedEIP5719.runByEIP5719(A, d, B) : B), N = re.signer.tryRecoverSigner(d, x) !== A;
        return [A, {
          isDynamic: N,
          signature: x
        }];
      }))).filter((A) => !!A[1])), g = c.signature.encodeSigners(i, y, [], s);
      if (!g || g.weight < BigInt(i.threshold)) return;
      const [w, v] = re.transaction.unpackMetaTransactionsData(h.message);
      return {
        tx: {
          entrypoint: e,
          transactions: re.transaction.fromTxAbiEncode(v),
          chainId: s,
          nonce: w,
          signature: g.encoded,
          intent: {
            id: d,
            wallet: e
          }
        },
        toConfig: await a.configOfImageHash({
          imageHash: m
        }),
        fromVersion: r,
        toVersion: r + 1
      };
    })).then((l) => l.filter((d) => d !== void 0)))[0];
  }
  updateProvider(e) {
    this.provider = e;
  }
}
var OZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LocalConfigTracker: Q1
});
const BZ = "Webrpc", IZ = "webrpc@v0.22.1;gen-typescript@v0.16.2;sessions@v0.0.1";
let $m = /* @__PURE__ */ function(t) {
  return t.EIP712 = "EIP712", t.EthSign = "EthSign", t.EIP1271 = "EIP1271", t;
}({});
class PZ {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Sessions/", this.ping = (r, s) => this.fetch(this.url("Ping"), An({}, r, s)).then((a) => kn(a).then((i) => ({})), (a) => {
      throw Ft.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.config = (r, s, a) => this.fetch(this.url("Config"), An(r, s, a)).then((i) => kn(i).then((o) => ({
      version: o.version,
      config: o.config
    })), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.wallets = (r, s, a) => this.fetch(this.url("Wallets"), An(r, s, a)).then((i) => kn(i).then((o) => ({
      wallets: o.wallets,
      cursor: o.cursor
    })), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.deployHash = (r, s, a) => this.fetch(this.url("DeployHash"), An(r, s, a)).then((i) => kn(i).then((o) => ({
      deployHash: o.deployHash,
      context: o.context
    })), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.configUpdates = (r, s, a) => this.fetch(this.url("ConfigUpdates"), An(r, s, a)).then((i) => kn(i).then((o) => ({
      updates: o.updates
    })), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.migrations = (r, s, a) => this.fetch(this.url("Migrations"), An(r, s, a)).then((i) => kn(i).then((o) => ({
      migrations: o.migrations
    })), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveConfig = (r, s, a) => this.fetch(this.url("SaveConfig"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveWallet = (r, s, a) => this.fetch(this.url("SaveWallet"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignature = (r, s, a) => this.fetch(this.url("SaveSignature"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures = (r, s, a) => this.fetch(this.url("SaveSignerSignatures"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures2 = (r, s, a) => this.fetch(this.url("SaveSignerSignatures2"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveMigration = (r, s, a) => this.fetch(this.url("SaveMigration"), An(r, s, a)).then((i) => kn(i).then((o) => ({})), (i) => {
      throw Ft.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const An = (t = {}, e = {}, n = null) => {
  const r = _r({}, e, {
    "Content-Type": "application/json"
  });
  return r[BZ] = IZ, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, kn = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), qh.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (UZ[r] || Ut).new(n);
  }
  return n;
});
class Ut extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, Ut.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}
class J1 extends Ut {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, J1.prototype);
  }
}
class Ft extends Ut {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ft.prototype);
  }
}
class Z1 extends Ut {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Z1.prototype);
  }
}
class X1 extends Ut {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, X1.prototype);
  }
}
class Y1 extends Ut {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Y1.prototype);
  }
}
class qh extends Ut {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qh.prototype);
  }
}
class ew extends Ut {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ew.prototype);
  }
}
class tw extends Ut {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, tw.prototype);
  }
}
class nw extends Ut {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, nw.prototype);
  }
}
class rw extends Ut {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, rw.prototype);
  }
}
class sw extends Ut {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, sw.prototype);
  }
}
class aw extends Ut {
  constructor(e = "InvalidArgument", n = 1, r = "invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, aw.prototype);
  }
}
class iw extends Ut {
  constructor(e = "NotFound", n = 2, r = "not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, iw.prototype);
  }
}
const UZ = {
  0: J1,
  [-1]: Ft,
  [-2]: Z1,
  [-3]: X1,
  [-4]: Y1,
  [-5]: qh,
  [-6]: ew,
  [-7]: tw,
  [-8]: nw,
  [-9]: rw,
  [-10]: sw,
  1: aw,
  2: iw
};
class NZ {
  constructor(e, n = !0) {
    this.onlyRecoverable = n, this.sessions = void 0, this.sessions = new PZ(e, fetch);
  }
  async loadPresignedConfiguration(e) {
    try {
      const {
        updates: n
      } = await this.sessions.configUpdates({
        wallet: e.wallet,
        fromImageHash: e.fromImageHash,
        allUpdates: e.longestPath
      });
      return n.map(({
        toImageHash: r,
        signature: s
      }) => ({
        wallet: e.wallet,
        nextImageHash: r,
        signature: s
      }));
    } catch (n) {
      if (_m(n))
        return [];
      throw n;
    }
  }
  async savePresignedConfiguration(e) {
    const n = e.nextConfig, r = _t.genericCoderFor(n.version).config.imageHashOf(n), s = de.signature.setImageHashStruct(r), a = ke(s);
    await this.sessions.saveSignature({
      wallet: e.wallet,
      digest: a,
      chainID: "0",
      signature: e.signature,
      toConfig: ff(n),
      referenceChainID: e.referenceChainId !== void 0 ? BigInt(e.referenceChainId).toString() : void 0
    });
  }
  async saveWitnesses(e) {
    let n = e.signatures;
    this.onlyRecoverable && (n = n.filter((r) => re.signer.canRecover(r))), await this.sessions.saveSignerSignatures({
      wallet: e.wallet,
      digest: e.digest,
      chainID: bo(e.chainId),
      signatures: n
    });
  }
  async configOfImageHash(e) {
    try {
      const {
        version: n,
        config: r
      } = await this.sessions.config(e);
      return RZ(n, r);
    } catch (n) {
      if (_m(n))
        return;
      throw n;
    }
  }
  async saveWalletConfig(e) {
    const n = ff(e.config);
    await this.sessions.saveConfig({
      version: e.config.version,
      config: n
    });
  }
  async imageHashOfCounterfactualWallet(e) {
    try {
      const {
        deployHash: n,
        context: r
      } = await this.sessions.deployHash(e);
      return {
        imageHash: n,
        context: r
      };
    } catch (n) {
      if (_m(n))
        return;
      throw n;
    }
  }
  async saveCounterfactualWallet(e) {
    const n = ff(e.config);
    await this.sessions.saveWallet({
      version: e.config.version,
      deployConfig: n
    });
  }
  async walletsOfSigner(e) {
    const {
      wallets: n
    } = await this.sessions.wallets(e);
    return Object.entries(n).map(([r, {
      digest: s,
      chainID: a,
      type: i,
      signature: o
    }]) => {
      switch (i) {
        case $m.EIP712:
          o += sr(re.signer.SigType.EIP712).slice(2);
          break;
        case $m.EthSign:
          o += sr(re.signer.SigType.ETH_SIGN).slice(2);
          break;
        case $m.EIP1271:
          o += sr(re.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet: r,
        proof: {
          digest: s,
          signature: o,
          chainId: BigInt(a)
        }
      };
    });
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const i = bo(s), {
      migrations: o
    } = await this.sessions.migrations({
      wallet: e,
      fromVersion: r,
      fromImageHash: n,
      chainID: i
    }), c = async function(d) {
      const m = o[d];
      if (m) {
        const h = Object.keys(m).map(Number).sort((b, y) => y - b);
        for (const b of h)
          for (const [y, g] of Object.entries(m[b]))
            try {
              const w = await a.configOfImageHash({
                imageHash: y
              });
              if (w)
                return {
                  fromVersion: r,
                  toVersion: b,
                  toConfig: w,
                  tx: {
                    entrypoint: g.executor,
                    transactions: g.transactions,
                    nonce: g.nonce,
                    signature: g.signature,
                    chainId: d,
                    intent: {
                      id: re.transaction.subdigestOfTransactions(e, d, g.nonce, g.transactions),
                      wallet: e
                    }
                  }
                };
            } catch (w) {
              console.error(w);
            }
      }
    }, u = await c(i);
    if (u)
      return u;
    for (const l in o)
      if (l !== i) {
        const d = await c(l);
        if (d)
          return d;
      }
  }
  async saveMigration(e, n, r) {
    await this.sessions.saveMigration({
      wallet: e,
      fromVersion: n.fromVersion,
      toVersion: n.toVersion,
      toConfig: ff(n.toConfig),
      executor: n.tx.entrypoint,
      transactions: n.tx.transactions.map(FZ),
      nonce: bo(n.tx.nonce),
      signature: n.tx.signature,
      chainID: bo(n.tx.chainId)
    });
  }
}
function ff(t) {
  switch (t.version) {
    case 1:
      if (Fa.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Ka(t.threshold),
          signers: t.signers.map(({
            weight: e,
            address: n
          }) => ({
            weight: Ka(e),
            address: n
          }))
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    case 2:
      if (de.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Ka(t.threshold),
          checkpoint: Ka(t.checkpoint),
          tree: Bf(t.tree)
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    default:
      throw new Error(`unknown version ${t.version}`);
  }
}
function Bf(t) {
  return de.config.isNode(t) ? {
    left: Bf(t.left),
    right: Bf(t.right)
  } : de.config.isSignerLeaf(t) ? {
    weight: Ka(t.weight),
    address: t.address
  } : de.config.isNestedLeaf(t) ? {
    weight: Ka(t.weight),
    threshold: Ka(t.threshold),
    tree: Bf(t.tree)
  } : de.config.isNodeLeaf(t) ? {
    node: t.nodeHash
  } : _r({}, t);
}
function RZ(t, e) {
  switch (t) {
    case 1:
      return _r({}, e, {
        version: t
      });
    case 2:
      return _r({}, e, {
        version: t,
        tree: If(e.tree)
      });
    default:
      throw new Error(`unknown version ${t}`);
  }
}
function If(t) {
  switch (typeof t) {
    case "object":
      const e = _r({}, t);
      return e.left !== void 0 && (e.left = If(e.left)), e.right !== void 0 && (e.right = If(e.right)), e.tree !== void 0 && (e.tree = If(e.tree)), e.node !== void 0 && (e.nodeHash = e.node, delete e.node), e;
    default:
      throw new Error(`v2 config tree ${t} is not an object`);
  }
}
function FZ(t) {
  return {
    to: t.to,
    value: t.value !== void 0 ? bo(t.value) : void 0,
    data: t.data !== void 0 ? G(t.data) : void 0,
    gasLimit: t.gasLimit !== void 0 ? bo(t.gasLimit) : void 0,
    delegateCall: t.delegateCall,
    revertOnError: t.revertOnError
  };
}
function Ka(t) {
  return Number(t);
}
function bo(t) {
  return BigInt(t).toString();
}
function _m(t) {
  return typeof t == "object" && t.status === 404;
}
var DZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  RemoteConfigTracker: NZ
});
function sg(t, e, n) {
  return new Promise((r) => {
    let s = 0;
    t.forEach((a) => a.then((i) => {
      n(i) ? r(i) : (s++, s === t.length && r(e));
    }).catch(() => {
      s++, s === t.length && r(e);
    }));
  });
}
async function $l(t, e) {
  return Promise.all(t.map((n) => n.catch(() => e)));
}
class MZ {
  constructor(e) {
    this.trackers = e;
  }
  async configOfImageHash(e) {
    const n = this.trackers.map(async function(o, c) {
      return {
        res: await o.configOfImageHash(e),
        i: c
      };
    }), r = await sg(n, void 0, (o) => (o == null ? void 0 : o.res) === void 0 ? !1 : _t.genericCoderFor(o.res.version).config.isComplete(o.res));
    if (r != null && r.res)
      return this.saveWalletConfig({
        config: r.res,
        skipTracker: r.i
      }), r.res;
    const s = new Q1(void 0), a = await $l(n, void 0);
    for (const o of a)
      o != null && o.res && await s.saveWalletConfig({
        config: o.res
      });
    const i = await s.configOfImageHash(e);
    return i && this.saveWalletConfig({
      config: i
    }), i;
  }
  async saveWalletConfig(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveWalletConfig(e);
    }));
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = await sg(this.trackers.map((r) => r.imageHashOfCounterfactualWallet(e)), void 0, (r) => !!r);
    return n && this.configOfImageHash({
      imageHash: n.imageHash
    }).then((r) => {
      r && this.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }), n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveCounterfactualWallet(e);
    }));
  }
  async walletsOfSigner(e) {
    const n = await $l(this.trackers.map((i) => i.walletsOfSigner(e)), []).then((i) => i.flat()), r = {};
    for (const i of n)
      r[i.wallet] = i.proof;
    const s = Object.keys(r).map((i) => ({
      wallet: i,
      proof: r[i]
    })), a = /* @__PURE__ */ new Map();
    return s.forEach(({
      wallet: i,
      proof: {
        digest: o,
        chainId: c,
        signature: u
      }
    }) => {
      const l = `${i}-${o}-${c}`;
      let d = a.get(l);
      d || (d = {
        wallet: i,
        digest: o,
        chainId: c,
        signatures: []
      }, a.set(l, d)), d.signatures.push(u);
    }), a.forEach((i) => this.saveWitnesses(i)), s;
  }
  async saveWitnesses(e) {
    await Promise.all(this.trackers.map((n) => n.saveWitnesses(e)));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = await $l(this.trackers.map((c) => c.loadPresignedConfiguration(e)), []), a = (await $l(r.map(async function(c) {
      const u = c[c.length - 1], l = await n.configOfImageHash({
        imageHash: u.nextImageHash
      });
      if (l)
        return {
          checkpoint: _t.genericCoderFor(l.version).config.checkpointOf(l),
          result: c
        };
    }), void 0)).reduce((c, u) => u && (!c || u.checkpoint > c.checkpoint) ? u : c);
    if (!a) return [];
    const i = /* @__PURE__ */ new Map(), o = (c) => (i.has(c) || i.set(c, this.configOfImageHash({
      imageHash: c
    })), i.get(c));
    return a.result.forEach(async function(c) {
      const u = await o(c.nextImageHash);
      u && n.savePresignedConfiguration({
        wallet: e.wallet,
        nextConfig: u,
        signature: c.signature
      });
    }), a.result;
  }
  async savePresignedConfiguration(e) {
    await Promise.all(this.trackers.map((n) => n.savePresignedConfiguration(e)));
  }
  async getMigration(e, n, r, s) {
    return (await Promise.all(this.trackers.map((i) => i.getMigration(e, n, r, s)))).find((i) => !!i);
  }
  async saveMigration(e, n, r) {
    await Promise.all(this.trackers.map((s) => s.saveMigration(e, n, r)));
  }
}
class LZ {
  constructor(e, n, r) {
    this.tracker = e, this.cache = n, this.contexts = r;
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = [this.tracker.loadPresignedConfiguration(e), this.cache.loadPresignedConfiguration(e)];
    let s;
    const [a, i] = await Promise.all(r);
    if (a.length > 0 && i.length > 0 && a[a.length - 1].nextImageHash === i[i.length - 1].nextImageHash)
      s = e.longestPath === !0 ? a.length > i.length ? a : i : a.length < i.length ? a : i;
    else {
      var o, c;
      s = (o = (c = (await Promise.all(r.map(async function(l) {
        const d = await l, m = d[d.length - 1];
        if (!m) return;
        const h = await n.configOfImageHash({
          imageHash: m.nextImageHash
        });
        if (h)
          return {
            checkpoint: _t.genericCoderFor(h.version).config.checkpointOf(h),
            result: d
          };
      }))).reduce((l, d) => d && (!l || d.checkpoint > l.checkpoint) ? d : l)) == null ? void 0 : c.result) != null ? o : [];
    }
    return s || [];
  }
  async savePresignedConfiguration(e) {
    await Promise.all([this.tracker.savePresignedConfiguration(e), this.cache.savePresignedConfiguration(e)]);
  }
  async configOfImageHash(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.configOfImageHash(e);
      if (r) return r;
    }
    const n = await this.tracker.configOfImageHash(e);
    return n && await this.cache.saveWalletConfig({
      config: n
    }), n;
  }
  async saveWalletConfig(e) {
    await Promise.all([this.tracker.saveWalletConfig(e), this.cache.saveWalletConfig(e)]);
  }
  async imageHashOfCounterfactualWallet(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.imageHashOfCounterfactualWallet(e);
      if (r) return r;
    }
    const n = await this.tracker.imageHashOfCounterfactualWallet(e);
    if (n) {
      const r = await this.configOfImageHash({
        imageHash: n.imageHash
      });
      r && await this.cache.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }
    return n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all([this.tracker.saveCounterfactualWallet(e), this.cache.saveCounterfactualWallet(e)]);
  }
  async walletsOfSigner(e) {
    if (e.noCache)
      return this.tracker.walletsOfSigner(e);
    const n = await Promise.all([this.tracker.walletsOfSigner(e), this.cache.walletsOfSigner(e)]), r = /* @__PURE__ */ new Map();
    for (const s of n)
      for (const a of s)
        r.set(a.wallet, a);
    return Array.from(r.values());
  }
  async saveWitnesses(e) {
    await Promise.all([this.tracker.saveWitnesses(e), this.cache.saveWitnesses(e)]);
  }
  async getMigration(e, n, r, s) {
    const a = await this.cache.getMigration(e, n, r, s);
    if (a) return a;
    const i = await this.tracker.getMigration(e, n, r, s);
    return i && await this.cache.saveMigration(e, i, this.contexts), i;
  }
  async saveMigration(e, n, r) {
    await Promise.all([this.tracker.saveMigration(e, n, r), this.cache.saveMigration(e, n, r)]);
  }
}
class b2 {
  constructor() {
    this.cache = void 0, this.cache = /* @__PURE__ */ new Map();
  }
  do(e, n, r, ...s) {
    e = `${e}:${Mr(JSON.stringify(s, HZ))}`;
    let a = this.cache.get(e);
    if (a && a.expiration && /* @__PURE__ */ new Date() >= a.expiration && (a = void 0, this.cache.delete(e)), !a) {
      const i = {
        promise: r(...s)
      };
      n !== void 0 && (i.promise = i.promise.then((o) => (i.expiration = new Date(Date.now() + n), o))), a = i, this.cache.set(e, a);
    }
    return a.promise;
  }
}
function HZ(t, e) {
  return typeof e == "object" && e !== null && !Array.isArray(e) ? Object.fromEntries(Object.entries(e).sort()) : typeof e == "bigint" ? e.toString() : e;
}
function $Z(t) {
  return t instanceof A5;
}
class A5 {
  constructor(e, n = 50, r = !1) {
    this.tracker = e, this.window = n, this.verbose = r, this.cache = new b2();
  }
  invalidateCache() {
    this.cache = new b2();
  }
  configOfImageHash(e) {
    return this.cache.do("configOfImageHash", this.window, (n) => this.tracker.configOfImageHash(n), e);
  }
  getMigration(e, n, r, s) {
    return this.cache.do("getMigration", this.window, (...a) => this.tracker.getMigration(...a), e, n, r, s);
  }
  saveMigration(e, n, r) {
    return this.cache.do("saveMigration", void 0, (...s) => this.tracker.saveMigration(...s), e, n, r);
  }
  loadPresignedConfiguration(e) {
    return this.cache.do("loadPresignedConfiguration", this.window, (n) => this.tracker.loadPresignedConfiguration(n), e);
  }
  savePresignedConfiguration(e) {
    return this.cache.do("savePresignedConfiguration", void 0, (n) => this.tracker.savePresignedConfiguration(n), e);
  }
  saveWitnesses(e) {
    return this.cache.do("saveWitnesses", void 0, (n) => this.tracker.saveWitnesses(n), e);
  }
  saveWalletConfig(e) {
    return this.cache.do("saveWalletConfig", void 0, (n) => this.tracker.saveWalletConfig(n), e);
  }
  imageHashOfCounterfactualWallet(e) {
    return this.cache.do("imageHashOfCounterfactualWallet", void 0, (n) => this.tracker.imageHashOfCounterfactualWallet(n), e);
  }
  saveCounterfactualWallet(e) {
    return this.cache.do("saveCounterfactualWallet", void 0, (n) => this.tracker.saveCounterfactualWallet(n), e);
  }
  walletsOfSigner(e) {
    return this.cache.do("walletsOfSigner", this.window, (n) => this.tracker.walletsOfSigner(n), e);
  }
  updateProvider(e) {
    this.tracker instanceof Q1 && this.tracker.updateProvider(e);
  }
}
var _Z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arweave: kZ,
  debug: CZ,
  local: OZ,
  remote: DZ,
  stores: SZ,
  raceUntil: sg,
  allSafe: $l,
  MultipleTracker: MZ,
  CachedTracker: LZ,
  isDedupedTracker: $Z,
  DedupedTracker: A5
});
const Pf = new _Z.remote.RemoteConfigTracker(
  "https://sessions.sequence.app"
);
function k5(t) {
  return nI.map((e) => {
    try {
      const n = aC(t.relayerConfig, e.chainId);
      if (n) {
        const r = {
          provider: new Ng(e.rpcUrl),
          url: n,
          projectAccessKey: t.sequenceProjectAccessKey
        };
        return {
          ...e,
          relayer: r
        };
      }
    } catch {
    }
    return e;
  });
}
async function GZ(t, e, n, r) {
  const s = await jh.new({
    config: {
      threshold: t,
      // By default a random checkpoint is generated every second
      checkpoint: Math.floor(Date.now() / 1e3),
      signers: e
    },
    tracker: Pf,
    contexts: re.context.defaultContexts,
    orchestrator: new Vh([]),
    networks: k5({ relayerConfig: n, sequenceProjectAccessKey: r })
  }), a = await Pf.imageHashOfCounterfactualWallet({
    wallet: s.address
  });
  if (!a)
    throw new Error("Failed to fetch imageHash from the tracker");
  if (!await Pf.configOfImageHash({
    imageHash: a.imageHash
  }))
    throw new Error("Failed to fetch config from the tracker");
  return s;
}
function v5(t) {
  return t.map(zZ);
}
function zZ(t) {
  return {
    to: t.to,
    value: t.value ? BigInt(t.value) : void 0,
    data: t.data,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    delegateCall: t.delegateCall || !1,
    revertOnError: t.revertOnError || !1
  };
}
function VZ(t) {
  const e = [];
  if (t.signatures)
    for (const { signer: n, signature: r } of t.signatures) {
      const s = ag(r);
      s.length === 66 && (s[64] === 0 || s[64] === 1) && (s[64] = s[64] + 27), e.push(new KZ(n, K5(s)));
    }
  return console.log("[trails-sdk] signers", e), new jh({
    address: t.address,
    tracker: Pf,
    contexts: re.context.defaultContexts,
    orchestrator: new Vh(e),
    networks: k5({
      relayerConfig: t.relayerConfig,
      sequenceProjectAccessKey: t.sequenceProjectAccessKey
    })
  });
}
function jZ(t) {
  return re.transaction.digestOfTransactions(
    re.transaction.encodeNonce(t.space, t.nonce),
    v5(t.transactions)
  );
}
function qZ(t) {
  const e = jZ(t);
  return re.signature.subdigestOf({
    digest: e,
    chainId: t.chainId,
    address: t.wallet
  });
}
async function C5(t, e, n) {
  const r = t.address;
  return (await GZ(
    1,
    [{ address: r, weight: 1 }],
    e,
    n
  )).address;
}
async function T5(t, e) {
  const n = await (e == null ? void 0 : e.getCode({
    address: t
  }));
  return n !== void 0 && n !== "0x";
}
async function g2(t, e) {
  for (; !await T5(t, e); )
    console.log("[trails-sdk] waiting for wallet deployment"), await new Promise((r) => setTimeout(r, 500));
}
async function S5(t, e, n, r, s, a, i) {
  var U, P;
  const o = s.id;
  if (!((U = e == null ? void 0 : e.account) != null && U.address) || !t)
    throw new Error("Privy signer or sequence wallet address not available");
  const c = r.map((D) => ({
    to: D.to,
    data: D.data,
    value: D.value || "0",
    revertOnError: !0
  })), u = {
    wallet: t,
    space: Math.floor(Date.now()).toString(),
    nonce: "0",
    chainId: o.toString(),
    transactions: c
  }, l = qZ(u), d = ag(l), h = `${await e.signMessage({
    account: e.account,
    message: { raw: d }
  })}02`, b = VZ({
    address: t,
    signatures: [
      {
        signer: (P = e.account) == null ? void 0 : P.address,
        signature: h
      }
    ],
    relayerConfig: a,
    sequenceProjectAccessKey: i
  }), y = v5(c), g = await b.status(o), w = b.walletForStatus(o, g);
  if (console.log("[trails-sdk] sequence wallet", w), !await T5(
    w.address,
    n
  )) {
    console.log("[trails-sdk] deploying sequence wallet");
    const D = await w.buildDeployTransaction();
    if (!w.relayer) throw new Error("Wallet deploy requires a relayer");
    console.log("[trails-sdk] deploy Tx", D), console.log("[trails-sdk] deployTx entrypoint:", D.entrypoint), console.log("[trails-sdk] deployTx transactions:", D.transactions), console.log("[trails-sdk] getting fee options 0");
    const $ = await w.relayer.getFeeOptions(
      w.address,
      ...D.transactions
    ), K = $ == null ? void 0 : $.quote;
    if (console.log("[trails-sdk] feeOptions", $), ($ == null ? void 0 : $.options.length) === 0) {
      console.log("[trails-sdk] Deployment is whitelisted - no fees required");
      const F = new Uint8Array(32);
      crypto.getRandomValues(F), w.relayer.relay(
        {
          entrypoint: D.entrypoint,
          transactions: D.transactions,
          chainId: w.chainId,
          intent: {
            id: Ea(F),
            wallet: w.address
          }
        },
        K
      ), console.log("[trails-sdk] Deployment relayed"), await g2(
        w.address,
        n
      ), console.log("[trails-sdk] sequence wallet deployed");
    } else {
      const F = $ == null ? void 0 : $.options[0];
      if (!F)
        throw new Error("fee option not found");
      if (console.log("[trails-sdk] option", F), F) {
        console.log("[trails-sdk] Using native token for deployment fee");
        const M = w2(F);
        console.log("[trails-sdk] Fee transactions:", M);
        const V = [...D.transactions];
        console.log(
          "[trails-sdk] All transactions (deployment + fees):",
          V
        );
        const z = await b.predecorateTransactions(
          V,
          g,
          o
        ), X = await b.signTransactions(
          z,
          o
        );
        console.log(
          "[trails-sdk] signed transactions with fees:",
          X.transactions
        ), console.log(
          "[trails-sdk] signed entrypoint with fees:",
          X.entrypoint
        );
        const Y = new Uint8Array(32);
        crypto.getRandomValues(Y), w.relayer.relay(
          {
            entrypoint: D.entrypoint,
            transactions: D.transactions,
            chainId: w.chainId,
            intent: {
              id: Ea(Y),
              wallet: w.address
            }
          },
          K
        ), console.log("[trails-sdk] relayed deployment"), await g2(
          w.address,
          n
        ), console.log("[trails-sdk] sequence wallet deployed");
      } else
        throw new Error(
          "ERC20 fee payment for deployment is not supported yet. Please use native token or a relayer with free wallet deployments."
        );
    }
  }
  console.log("[trails-sdk] getting fee options 1");
  const A = await w.relayer.getFeeOptions(
    w.address,
    ...y
  ), B = A == null ? void 0 : A.options.find(
    (D) => D.token.symbol === "USDC"
  ), x = A == null ? void 0 : A.quote, N = w2(B);
  console.log("[trails-sdk] Fee transactions:", N);
  const I = await w.signTransactions(
    [...N, ...y],
    re.transaction.encodeNonce(u.space, u.nonce)
  ), C = await b.relayer(o).relay(I, x);
  return (C == null ? void 0 : C.hash) || null;
}
class KZ {
  constructor(e, n) {
    R(this, "signatureBytes");
    R(this, "savedSuffix");
    this.address = e, this.signature = n;
    const r = ag(this.signature);
    this.savedSuffix = r.slice(-1), this.signatureBytes = r.slice(0, -1);
  }
  async buildDeployTransaction() {
  }
  async predecorateSignedTransactions() {
    return [];
  }
  async decorateTransactions(e) {
    return e;
  }
  async sign() {
    return this.signatureBytes;
  }
  notifyStatusChange() {
  }
  suffix() {
    return this.savedSuffix;
  }
  async getAddress() {
    return this.address;
  }
}
async function WZ(t, e, n, r) {
  return await t.feeOptions(
    e,
    BigInt(n),
    r
  );
}
function w2(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case "UNKNOWN":
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.to,
          value: e.toString(),
          data: "0x"
        }
      ];
    case "ERC20_TOKEN": {
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      const [n] = ej([
        {
          inputs: [{ type: "address" }, { type: "uint256" }],
          name: "transfer",
          outputs: [{ type: "bool" }],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]);
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.token.contractAddress,
          value: "0",
          data: s3(n, [
            t.to,
            e
          ])
        }
      ];
    }
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
const QZ = new cg({
  defaultOptions: {
    queries: {
      staleTime: 6e4,
      // 1 minute
      gcTime: 3e5,
      // 5 minutes
      retry: 2,
      retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
      refetchOnWindowFocus: !1,
      refetchOnReconnect: !0
    }
  }
}), JZ = { page: 1, pageSize: 10, more: !1 };
function go(t) {
  return !("contractAddress" in t);
}
function ZZ(t, e) {
  const n = t.balanceUsd ?? 0, r = e.balanceUsd ?? 0;
  if (n !== r)
    return r - n;
  if (go(t) && !go(e)) return -1;
  if (!go(t) && go(e)) return 1;
  try {
    const s = BigInt(t.balance), a = BigInt(e.balance);
    if (s > a) return -1;
    if (s < a) return 1;
  } catch {
    return 0;
  }
  return 0;
}
function MY(t, e, n) {
  var b;
  const r = dd(), s = rd(), a = e ?? r, i = n ?? s, {
    data: o,
    isLoading: c,
    error: u
  } = yn({
    queryKey: ["tokenBalances", "summary", t],
    queryFn: async () => {
      if (!t)
        return console.warn("[trails-sdk] No account address or indexer client"), {
          balances: [],
          nativeBalances: [],
          page: JZ
        };
      try {
        const y = await I5({
          account: t,
          indexerGatewayClient: a
        });
        return {
          page: y.page,
          balances: y.balances.flatMap((g) => g.results),
          nativeBalances: y.nativeBalances.flatMap((g) => g.results)
        };
      } catch (y) {
        throw console.error("[trails-sdk] Failed to fetch token balances:", y), y;
      }
    },
    enabled: !!t && !!a,
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5,
    // 5 minutes cache time
    retry: (y, g) => g && "status" in g && g.status === 404 ? !1 : y < 3,
    retryDelay: (y) => Math.min(1e3 * 2 ** y, 3e4),
    // Exponential backoff
    refetchOnWindowFocus: !1,
    // Prevent refetch on window focus
    refetchOnReconnect: !0,
    // Refetch on reconnect
    refetchInterval: 3e5,
    // Background refetch every 5 minutes
    refetchIntervalInBackground: !0
  }), { tokenPrices: l, isLoadingTokenPrices: d } = cQ(
    ((o == null ? void 0 : o.balances) ?? []).map((y) => {
      var g, w;
      return {
        tokenId: (g = y.contractInfo) == null ? void 0 : g.symbol,
        contractAddress: y.contractAddress,
        chainId: (w = y.contractInfo) == null ? void 0 : w.chainId
      };
    }).concat(
      ((o == null ? void 0 : o.nativeBalances) ?? []).map((y) => ({
        tokenId: y.symbol,
        contractAddress: Me,
        chainId: y.chainId
      }))
    ) ?? [],
    i
  ), { data: m = [], isLoading: h } = yn({
    queryKey: [
      "tokenBalances",
      "sorted",
      t,
      (b = o == null ? void 0 : o.page) == null ? void 0 : b.page,
      l == null ? void 0 : l.length
    ],
    queryFn: () => !o || !l ? [] : [
      ...o.nativeBalances,
      ...o.balances
    ].filter((w) => {
      try {
        return BigInt(w.balance) > 0n;
      } catch {
        return !1;
      }
    }).map((w) => {
      const v = go(w), A = l.find(
        (B) => {
          var x;
          return B.token.contractAddress === (v ? Me : w.contractAddress) && B.token.chainId === (v ? w.chainId : (x = w.contractInfo) == null ? void 0 : x.chainId);
        }
      );
      if (A != null && A.price) {
        const B = { ...w, price: A.price };
        return B.balanceUsd = ow(
          w,
          A.price
        ), B.balanceUsdFormatted = B5(
          w,
          A.price
        ), B;
      }
      return w;
    }).sort(ZZ),
    enabled: !c && !d && !!o && !!l,
    staleTime: 3e4,
    // 30 seconds for sorted tokens
    gcTime: 12e4,
    // 2 minutes cache time
    refetchOnWindowFocus: !1
  });
  return {
    tokenBalancesData: o,
    isLoadingBalances: c,
    isLoadingPrices: d,
    isLoadingSortedTokens: h || c || d,
    balanceError: u,
    sortedTokens: m
  };
}
function XZ(t, e = 18) {
  try {
    const n = zm(BigInt(t), e);
    return YZ(n);
  } catch (n) {
    return console.error("[trails-sdk] Error formatting balance:", n), t;
  }
}
function ow(t, e) {
  var a;
  const n = go(t), r = XZ(
    t.balance,
    n ? 18 : (a = t.contractInfo) == null ? void 0 : a.decimals
  ), s = Number(e.value) ?? 0;
  return Number(r) * s;
}
function YZ(t) {
  try {
    return Number(t).toLocaleString(void 0, {
      maximumFractionDigits: 5,
      minimumFractionDigits: 2
    });
  } catch (e) {
    console.error("[trails-sdk] Error formatting value:", e);
  }
  return t.toString();
}
function O5(t = 0) {
  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2,
    minimumFractionDigits: 2
  }).format(Number(t));
}
function B5(t, e) {
  const n = ow(t, e);
  return O5(n);
}
async function eX({
  account: t,
  indexerGatewayClient: e
}) {
  if (!t || !e)
    throw new Error("Account address and indexer client are required");
  try {
    return await e.getTokenBalancesSummary({
      filter: {
        accountAddresses: [t],
        contractStatus: CT.VERIFIED,
        contractTypes: ["ERC20"],
        omitNativeBalances: !1
      }
    });
  } catch (n) {
    throw console.error("[trails-sdk] Failed to fetch token balances summary:", n), n;
  }
}
async function I5({
  account: t,
  indexerGatewayClient: e
}) {
  return QZ.fetchQuery({
    queryKey: ["tokenBalances", "summary", t],
    queryFn: () => eX({ account: t, indexerGatewayClient: e }),
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5
    // 5 minutes
  });
}
async function tX({
  account: t,
  indexerGatewayClient: e
}) {
  const n = await I5({
    account: t,
    indexerGatewayClient: e
  }), r = /* @__PURE__ */ new Map();
  for (const a of n.balances)
    a.results.forEach((i) => {
      var o, c, u;
      r.set(
        `${i.contractAddress}-${(o = i.contractInfo) == null ? void 0 : o.chainId}-${(c = i.contractInfo) == null ? void 0 : c.symbol}`,
        {
          ...i,
          contractAddress: i.contractAddress ?? Me,
          tokenId: (u = i.contractInfo) == null ? void 0 : u.symbol
        }
      );
    });
  for (const a of n.nativeBalances)
    a.results.forEach((i) => {
      r.set(`${i.contractAddress}-${i.chainId}-${i.symbol}`, {
        ...i,
        contractAddress: i.contractAddress ?? Me,
        tokenId: i.symbol
      });
    });
  return Array.from(r.values());
}
async function cw({
  account: t,
  indexerGatewayClient: e,
  apiClient: n
}) {
  const r = await tX({
    account: t,
    indexerGatewayClient: e
  }), s = await S1(n, r);
  return {
    balances: r.map((i) => {
      const o = s.find((c) => {
        const u = c.token.chainId === i.chainId;
        let l = c.token.contractAddress === i.contractAddress;
        return i.contractAddress || (l = c.token.contractAddress === Me || !c.token.contractAddress), u && l;
      });
      return {
        ...i,
        price: o == null ? void 0 : o.price,
        balanceUsd: o != null && o.price ? ow(i, o == null ? void 0 : o.price) : void 0,
        balanceUsdFormatted: o != null && o.price ? B5(i, o == null ? void 0 : o.price) : void 0
      };
    })
  };
}
function nX({
  account: t,
  token: e,
  chainId: n,
  indexerGatewayClient: r,
  apiClient: s
}) {
  const { data: a, isLoading: i } = yn({
    queryKey: ["tokenBalances", "balances", t],
    queryFn: async () => {
      if (!t || !r || !s || !e || !n)
        return null;
      const { balances: o } = await cw({
        account: t,
        indexerGatewayClient: r,
        apiClient: s
      });
      return o.find(
        (u) => {
          var l;
          return u.chainId === n && (((l = u.contractAddress) == null ? void 0 : l.toLowerCase()) === e.toLowerCase() || !u.contractAddress && e === Me);
        }
      );
    }
  });
  return {
    tokenBalance: a,
    isLoadingTokenBalance: i
  };
}
async function rX({
  account: t,
  token: e,
  amount: n,
  chainId: r,
  indexerGatewayClient: s,
  apiClient: a
}) {
  var u;
  const { balances: i } = await cw({
    account: t,
    indexerGatewayClient: s,
    apiClient: a
  }), o = i.find(
    (l) => {
      var d;
      return l.chainId === r && (((d = l.contractAddress) == null ? void 0 : d.toLowerCase()) === e.toLowerCase() || !l.contractAddress && e === Me);
    }
  );
  if (!o)
    return !1;
  const c = ((u = o == null ? void 0 : o.contractInfo) == null ? void 0 : u.decimals) ?? 18;
  return o != null && o.balance ? BigInt(o.balance) >= Vm(n, c) : !1;
}
function LY(t, e, n, r) {
  const s = dd(), a = rd(), {
    data: i,
    isLoading: o
  } = yn({
    queryKey: ["tokenBalances", "sufficient", t, e, n, r],
    queryFn: () => t ? rX({
      account: t,
      token: e,
      amount: n,
      chainId: r,
      indexerGatewayClient: s,
      apiClient: a
    }) : null,
    enabled: !!t && !!e && !!n && !!r,
    staleTime: 45e3,
    // 45 seconds
    gcTime: 18e4,
    // 3 minutes cache time
    retry: (c, u) => u && "status" in u && u.status === 404 ? !1 : c < 2,
    retryDelay: (c) => Math.min(1e3 * 2 ** c, 3e4),
    refetchOnWindowFocus: !1
  });
  return {
    hasSufficientBalanceToken: i || !1,
    isLoadingHasSufficientBalanceToken: o
  };
}
async function sX({
  account: t,
  targetAmountUsd: e,
  indexerGatewayClient: n,
  apiClient: r
}) {
  return await P5({
    account: t,
    indexerGatewayClient: n,
    apiClient: r
  }) >= Number(e);
}
function HY(t, e) {
  const n = dd(), r = rd(), {
    data: s,
    isLoading: a,
    error: i
  } = yn({
    queryKey: ["tokenBalances", "sufficientUsd", t, e],
    queryFn: () => t && e ? sX({
      account: t,
      targetAmountUsd: e,
      indexerGatewayClient: n,
      apiClient: r
    }) : !1,
    enabled: !!t && !!e,
    staleTime: 45e3,
    // 45 seconds
    gcTime: 18e4,
    // 3 minutes cache time
    retry: (o, c) => c && "status" in c && c.status === 404 ? !1 : o < 2,
    retryDelay: (o) => Math.min(1e3 * 2 ** o, 3e4),
    refetchOnWindowFocus: !1
  });
  return {
    hasSufficientBalanceUsd: s || !1,
    isLoadingHasSufficientBalanceUsd: a || !e || !t,
    hasSufficientBalanceUsdError: i
  };
}
async function P5({
  account: t,
  indexerGatewayClient: e,
  apiClient: n
}) {
  const { balances: r } = await cw({
    account: t,
    indexerGatewayClient: e,
    apiClient: n
  });
  return r.reduce((s, a) => s + (a.balanceUsd ?? 0), 0);
}
function $Y(t) {
  const e = dd(), n = rd(), { data: r, isLoading: s } = yn({
    queryKey: ["tokenBalances", "totalUsd", t],
    queryFn: () => t ? P5({
      account: t,
      indexerGatewayClient: e,
      apiClient: n
    }) : null,
    enabled: !!t,
    staleTime: 6e4,
    // 1 minute
    gcTime: 3e5,
    // 5 minutes cache time
    retry: (a, i) => i && "status" in i && i.status === 404 ? !1 : a < 2,
    retryDelay: (a) => Math.min(1e3 * 2 ** a, 3e4),
    refetchOnWindowFocus: !1,
    refetchOnReconnect: !0,
    refetchInterval: 3e5,
    // Background refetch every 5 minutes
    refetchIntervalInBackground: !0
  });
  return {
    totalBalanceUsd: r || 0,
    isLoadingTotalBalanceUsd: s,
    totalBalanceUsdFormatted: O5(r || 0)
  };
}
const U5 = "trails-sdk:token-image-cache", aX = 7 * 24 * 60 * 60 * 1e3;
function N5() {
  if (typeof window > "u") return {};
  try {
    const t = localStorage.getItem(U5);
    if (!t) return {};
    const e = JSON.parse(t), n = Date.now(), r = Object.entries(e).filter(([s, a]) => n - a.timestamp < aX);
    return Object.fromEntries(r);
  } catch {
    return {};
  }
}
function E2(t, e, n) {
  if (!(typeof window > "u"))
    try {
      const r = N5();
      r[t] = {
        imageUrl: e,
        timestamp: Date.now(),
        found: n
      }, localStorage.setItem(U5, JSON.stringify(r));
    } catch (r) {
      console.warn("[trails-sdk] Failed to cache token image:", r);
    }
}
const iX = new cg({
  defaultOptions: {
    queries: {
      staleTime: 24 * 60 * 60 * 1e3,
      // 24 hours
      gcTime: 7 * 24 * 60 * 60 * 1e3,
      // 7 days
      retry: 2,
      retryDelay: (t) => Math.min(1e3 * 2 ** t, 3e4),
      refetchOnWindowFocus: !1,
      refetchOnReconnect: !1
    }
  }
}), x2 = [
  "ETH",
  "WETH",
  "AVAX",
  "WAVAX",
  "xDAI",
  "POL",
  "USDC",
  "USDT",
  "DAI",
  "MATIC",
  "ARB",
  "OP",
  "BAT",
  "WBTC",
  "cbBTC",
  "XAI"
];
function oX(t) {
  return t.sort((e, n) => {
    const r = x2.indexOf(e.symbol), s = x2.indexOf(n.symbol);
    if (r !== -1 && s !== -1)
      return r - s;
    if (r !== -1) return -1;
    if (s !== -1) return 1;
    const a = !!e.imageUrl, i = !!n.imageUrl;
    return a && !i ? -1 : !a && i ? 1 : e.symbol.localeCompare(n.symbol);
  });
}
async function cX(t, e) {
  const n = `${t}:${e}`, r = F5(t, e), a = N5()[n];
  if (a)
    return a.found ? a.imageUrl : "";
  try {
    return await iX.fetchQuery({
      queryKey: ["tokenImage", t, e],
      queryFn: async () => {
        const c = (await fetch(r, {
          method: "HEAD",
          // Only fetch headers to check if image exists
          cache: "no-cache"
          // Don't cache the fetch request itself
        })).ok, u = c ? r : "";
        return E2(n, u, c), u;
      },
      staleTime: 864e5,
      // 24 hours
      gcTime: 6048e5
      // 7 days
    });
  } catch (i) {
    return console.error("[trails-sdk] Error fetching token image:", i), E2(n, "", !1), "";
  }
}
async function lw() {
  const t = await jV();
  for (const n of t)
    n.imageUrl || (n.imageUrl = F5(n.chainId, n.contractAddress)), cX(n.chainId, n.contractAddress).then((r) => {
      n.imageUrl = r;
    }).catch((r) => {
      console.error("[trails-sdk] Error getting token image url:", r);
    });
  const e = t.filter(
    (n, r, s) => r === s.findIndex(
      (a) => a.chainId === n.chainId && a.contractAddress === n.contractAddress
    )
  );
  return oX(e);
}
function R5() {
  const { data: t = [], isLoading: e } = yn({
    queryKey: ["supportedTokens"],
    queryFn: lw,
    staleTime: 36e5,
    // 1 hour - tokens rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return {
    supportedTokens: t || [],
    isLoadingTokens: e
  };
}
async function lX() {
  return (await lw()).map((e) => e.symbol);
}
function _Y() {
  const { data: t = [] } = yn({
    queryKey: ["sourceTokenList"],
    queryFn: lX,
    staleTime: 36e5,
    // 1 hour - token list rarely changes
    gcTime: 864e5,
    // 24 hours cache time
    refetchOnWindowFocus: !1,
    refetchOnReconnect: !1
  });
  return t;
}
const uX = {
  ETH: "Ethereum",
  WETH: "Wrapped ETH",
  USDC: "USDC",
  USDT: "Tether",
  DAI: "Dai Stablecoin",
  OP: "Optimism",
  ARB: "Arbitrum",
  POL: "POL",
  MATIC: "Matic Token",
  BAT: "Basic Attention Token"
}, dX = {
  USDC: "USDC",
  ETH: "ETH",
  POL: "POL"
}, fX = {
  [lr.id]: "Optimistic",
  [cr.id]: "Arbitrum",
  [ar.id]: "Polygon"
};
function GY(t, e, n) {
  let r = uX[e] || t || e;
  if (n)
    try {
      const s = ws(n);
      if (s && dX[e]) {
        n !== Ln.id && (r = `${s == null ? void 0 : s.name} ${e}`);
        const a = fX[n];
        a && (r = `${a} ${e}`);
      }
    } catch (s) {
      console.error("[trails-sdk] Error getting chain info:", s);
    }
  return r;
}
async function pX(t, e) {
  const n = ws(t);
  if (e === (n == null ? void 0 : n.nativeCurrency.symbol))
    return Me;
  const s = (await lw()).find(
    (a) => a.symbol === e && a.chainId === t
  );
  if (s != null && s.contractAddress)
    return s.contractAddress;
  throw new Error(
    `Unsupported token symbol: ${e} for chainId: ${t}`
  );
}
function zY({
  chainId: t,
  tokenSymbol: e
}) {
  const { data: n } = yn({
    queryKey: ["tokenAddress", t, e],
    queryFn: () => t && e ? pX(t, e) : null,
    enabled: !!t && !!e,
    staleTime: 36e5,
    // 1 hour - token addresses rarely change
    gcTime: 864e5,
    // 24 hours - keep in cache for a full day
    refetchOnWindowFocus: !1,
    // Don't refetch when window regains focus
    refetchOnReconnect: !1
    // Don't refetch on network reconnect
  });
  return n || null;
}
function F5(t, e) {
  return `https://assets.sequence.info/images/tokens/large/${t}/${e}.webp`;
}
function VY() {
  const { supportedTokens: t, isLoadingTokens: e } = R5();
  return {
    tokens: t,
    isLoadingTokens: e
  };
}
function jY({
  address: t,
  chainId: e
}) {
  var d, m;
  if (!((t == null ? void 0 : t.startsWith("0x")) ?? !1) || !e)
    return {
      tokenInfo: null,
      isLoading: !1,
      error: null
    };
  const r = {
    address: t,
    abi: Ju,
    chainId: e
  }, s = Z5({
    contracts: [
      { ...r, functionName: "name" },
      { ...r, functionName: "symbol" },
      { ...r, functionName: "decimals" }
    ]
  }), a = (s == null ? void 0 : s.error) ?? ((m = (d = s == null ? void 0 : s.data) == null ? void 0 : d.find((h) => h.error)) == null ? void 0 : m.error) ?? null, [i, o, c] = s.data ?? [], u = ws(e);
  return {
    tokenInfo: Wu(() => !(o != null && o.result) || !(i != null && i.result) || (c == null ? void 0 : c.result) == null ? null : {
      id: o.result,
      name: i.result,
      symbol: o.result,
      decimals: c.result,
      chainId: e,
      contractAddress: t,
      chainName: (u == null ? void 0 : u.name) ?? "",
      imageUrl: ""
    }, [
      t,
      e,
      u == null ? void 0 : u.name,
      i == null ? void 0 : i.result,
      o == null ? void 0 : o.result,
      c == null ? void 0 : c.result
    ]),
    isLoading: s.isLoading,
    error: a
  };
}
async function hX(t, e, n) {
  return Promise.race([
    t.request(...e),
    new Promise(
      (r, s) => setTimeout(() => s(new Error("Request timed out")), n)
    )
  ]);
}
function mX(t, e) {
  return (t == null ? void 0 : t.toString()) === (e == null ? void 0 : e.toString());
}
function yX(t, e) {
  return (t == null ? void 0 : t.toLowerCase()) === (e == null ? void 0 : e.toLowerCase());
}
function bX(t, e, n, r) {
  return Qx(t, n) && Qx(e, r);
}
function A2() {
  return uQ("testnet") === "true";
}
function gX() {
  return "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
}
function wX(t, e, n, r, s, a, i, o, c, u) {
  const l = u || (a === Me ? "0x" : k1({
    recipient: c,
    amount: BigInt(i)
  }));
  return {
    userAddress: t,
    originChainId: e,
    originTokenAddress: n,
    originTokenAmount: n === a ? i : r,
    // max amount
    destinationChainId: s,
    destinationToAddress: u || a === Me ? c : a,
    destinationTokenAddress: a,
    destinationTokenAmount: i,
    destinationTokenSymbol: o,
    destinationCallData: l,
    destinationCallValue: a === Me ? i : "0"
  };
}
async function EX(t) {
  const {
    account: e,
    originTokenAddress: n,
    originChainId: r,
    originTokenAmount: s,
    // account balance
    destinationChainId: a,
    recipient: i,
    destinationTokenAddress: o,
    destinationTokenAmount: c,
    destinationTokenSymbol: u,
    fee: l,
    client: d,
    dryMode: m = !1,
    apiClient: h,
    originRelayer: b,
    destinationRelayer: y,
    destinationCalldata: g,
    onTransactionStateChange: w,
    sourceTokenPriceUsd: v,
    destinationTokenPriceUsd: A,
    sourceTokenDecimals: B,
    destinationTokenDecimals: x,
    paymasterUrl: N,
    gasless: I = !1,
    relayerConfig: O,
    sequenceProjectAccessKey: C
  } = t;
  if (!d)
    throw new Error("Wallet client not provided");
  const U = ws(r);
  if (!U)
    throw new Error(`Chain ${r} not found`);
  const P = mX(r, a), D = yX(
    n,
    o
  );
  console.log("[trails-sdk] isToSameChain", P), console.log("[trails-sdk] isToSameToken", D);
  const $ = wa({
    chain: U,
    transport: ct()
  }), K = e.address, F = [];
  return F.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending",
    label: P && D ? "Execute" : P && !D ? "Swap" : "Transfer"
  }), P || (F.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending",
    label: D ? "Bridge" : "Swap & Bridge"
  }), F.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: a,
    state: "pending",
    label: "Execute"
  })), P && !D ? await kX({
    originTokenAddress: n,
    destinationTokenAmount: c,
    destinationTokenAddress: o,
    destinationCalldata: g,
    recipient: i,
    originChainId: r,
    walletClient: d,
    publicClient: $,
    account: e
  }) : D && P ? await AX({
    originTokenAddress: n,
    destinationTokenAmount: c,
    destinationCalldata: g,
    recipient: i,
    originChainId: r,
    walletClient: d,
    publicClient: $,
    onTransactionStateChange: w,
    dryMode: m,
    account: e,
    chain: U
  }) : await xX({
    mainSignerAddress: K,
    originChainId: r,
    originTokenAddress: n,
    originTokenAmount: s,
    destinationChainId: a,
    destinationTokenAddress: o,
    destinationTokenAmount: c,
    destinationTokenSymbol: u,
    recipient: i,
    destinationCalldata: g,
    apiClient: h,
    sourceTokenPriceUsd: v,
    destinationTokenPriceUsd: A,
    sourceTokenDecimals: B,
    destinationTokenDecimals: x,
    gasless: I,
    paymasterUrl: N,
    originRelayer: b,
    destinationRelayer: y,
    sequenceProjectAccessKey: C,
    relayerConfig: O,
    walletClient: d,
    publicClient: $,
    chain: U,
    account: e,
    fee: l,
    dryMode: m,
    onTransactionStateChange: w,
    transactionStates: F
  });
}
async function xX({
  mainSignerAddress: t,
  originChainId: e,
  originTokenAddress: n,
  originTokenAmount: r,
  destinationChainId: s,
  destinationTokenAddress: a,
  destinationTokenAmount: i,
  destinationTokenSymbol: o,
  recipient: c,
  destinationCalldata: u,
  apiClient: l,
  sourceTokenPriceUsd: d,
  destinationTokenPriceUsd: m,
  sourceTokenDecimals: h,
  destinationTokenDecimals: b,
  gasless: y,
  paymasterUrl: g,
  originRelayer: w,
  destinationRelayer: v,
  sequenceProjectAccessKey: A,
  relayerConfig: B,
  walletClient: x,
  publicClient: N,
  chain: I,
  account: O,
  fee: C,
  dryMode: U,
  onTransactionStateChange: P,
  transactionStates: D
}) {
  var le, Z, ce, te;
  const $ = A2();
  if (bX(
    n,
    a,
    e,
    s
  ) && $)
    return {
      intentAddress: "",
      originSendAmount: i,
      send: async (fe) => {
        const he = $ ? Cm(I) : I, Ae = $ ? Cm(s) : ws(s);
        if (!he || !Ae)
          throw new Error("Invalid chain");
        console.log("[trails-sdk] originChain", he), console.log("[trails-sdk] destinationChain", Ae);
        const $e = wa({
          chain: he,
          transport: ct()
        }), { txHash: tt, attestation: Nt } = await lK({
          walletClient: x,
          originChain: he,
          destinationChain: Ae,
          amount: BigInt(i)
        });
        if (!Nt)
          throw new Error("Failed to retrieve attestation");
        fe && fe(), console.log("[trails-sdk] waiting for tx", tt);
        const _e = await $e.waitForTransactionReceipt({
          hash: tt
        });
        console.log("[trails-sdk] tx receipt", _e), D[0] = Pa(
          _e,
          he.id,
          "Transfer"
        ), D[1] = Pa(
          _e,
          he.id,
          "Bridge"
        ), P(D);
        const wn = cK(Ae.id);
        console.log("[trails-sdk] tokenMessenger", wn);
        const ol = [
          await bK({
            tokenMessenger: wn,
            attestation: Nt
          })
        ];
        console.log("[trails-sdk] calls", ol);
        const wd = A1(), hw = Tu(wd), mw = Qu({
          account: hw,
          chain: Ae,
          transport: ct()
        }), yw = wa({
          chain: Ae,
          transport: ct()
        });
        console.log("[trails-sdk] delegatorClient", mw);
        const bw = await C5(
          hw,
          B,
          A
        );
        console.log("[trails-sdk] sequenceWalletAddress", bw);
        const M5 = await S5(
          bw,
          mw,
          yw,
          ol,
          Ae,
          B,
          A
        ), gw = await yw.waitForTransactionReceipt({
          hash: M5
        });
        return console.log("[trails-sdk] destinationReceipt", gw), D[2] = Pa(
          gw,
          Ae.id,
          "Receive"
        ), P(D), {
          originUserTxReceipt: _e,
          originMetaTxnReceipt: null,
          destinationMetaTxnReceipt: null
        };
      }
    };
  const F = wX(
    t,
    e,
    n,
    r,
    s,
    a,
    i,
    o,
    c,
    u
  );
  console.log("[trails-sdk] Creating intent with args:", F);
  const M = await Bq(l, F);
  if (console.log("[trails-sdk] Got intent:", M), !M)
    throw new Error("Invalid intent");
  if (!((le = M.preconditions) != null && le.length) || !((Z = M.calls) != null && Z.length))
    throw new Error("Invalid intent");
  const V = wb(t, M.calls);
  console.log(
    "[trails-sdk] Calculated intent address:",
    V.toString()
  ), await Pq(
    l,
    t,
    M.calls,
    M.preconditions
  ), console.log("[trails-sdk] Committed intent config");
  const z = Oq(
    M.preconditions,
    e
  );
  if (!z)
    throw new Error("No precondition found for origin chain");
  const X = (te = (ce = z == null ? void 0 : z.data) == null ? void 0 : ce.min) == null ? void 0 : te.toString(), Y = X;
  if (!await uw({
    account: O,
    tokenAddress: n,
    depositAmount: Y,
    publicClient: N
  }))
    throw new Error("Account does not have enough balance for deposit");
  return {
    intentAddress: V,
    originSendAmount: Y,
    send: async (ie) => {
      console.log("[trails-sdk] sending origin transaction");
      const fe = D5({
        originTokenAddress: n,
        destinationTokenAmount: i,
        destinationTokenDecimals: b,
        sourceTokenDecimals: h,
        sourceTokenPriceUsd: d ?? null,
        destinationTokenPriceUsd: m ?? null,
        depositAmount: Y
      });
      console.log("[trails-sdk] needsNativeFee", fe), console.log("[trails-sdk] sourceTokenPriceUsd", d), console.log(
        "[trails-sdk] destinationTokenPriceUsd",
        m
      ), console.log("[trails-sdk] sourceTokenDecimals", h), console.log(
        "[trails-sdk] destinationTokenDecimals",
        b
      );
      let he = null, Ae = null, $e = null;
      const tt = A2(), Nt = gX(), _e = tt ? Cm(I) : I;
      if (console.log("[trails-sdk] testnet", tt), he = await TX({
        originTokenAddress: tt ? Nt : n,
        gasless: y,
        paymasterUrl: g,
        chain: _e,
        account: O,
        relayerConfig: B,
        sequenceProjectAccessKey: A,
        originRelayer: w,
        firstPreconditionMin: X,
        intentAddress: V,
        onOriginSend: ie,
        publicClient: N,
        walletClient: x,
        destinationTokenDecimals: b,
        sourceTokenDecimals: h,
        fee: C,
        dryMode: U,
        sourceTokenPriceUsd: d ?? null,
        destinationTokenPriceUsd: m ?? null,
        destinationTokenAmount: i
      }), !he)
        throw new Error("Failed to send origin transaction");
      return D[0] = Pa(
        he,
        e,
        "Transfer"
      ), P(D), M.metaTxns[0] && M.preconditions[0] && (Ae = await k2({
        metaTx: M.metaTxns[0],
        relayer: w,
        precondition: M.preconditions[0]
      }), Ae && (D[1] = Pa(
        Ae,
        e,
        "Swap & Bridge"
      ), P(D))), M.metaTxns[1] && M.preconditions[1] && ($e = await k2({
        metaTx: M.metaTxns[1],
        relayer: v,
        precondition: M.preconditions[1]
      }), $e && (D[2] = Pa(
        $e,
        s,
        "Execute"
      ), P(D))), {
        originUserTxReceipt: he,
        originMetaTxnReceipt: Ae,
        destinationMetaTxnReceipt: $e
      };
    }
  };
}
async function AX({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationCalldata: n,
  recipient: r,
  originChainId: s,
  walletClient: a,
  publicClient: i,
  onTransactionStateChange: o,
  dryMode: c,
  account: u,
  chain: l
}) {
  if (console.log("[trails-sdk] isToSameToken && isToSameChain"), !await uw({
    account: u,
    tokenAddress: t,
    depositAmount: e,
    publicClient: i
  }))
    throw new Error("Account does not have enough balance for deposit");
  return {
    originSendAmount: e,
    send: async (m) => {
      const h = {
        to: n || t === Me ? r : t,
        data: n || (t === Me ? "0x" : k1({
          recipient: r,
          amount: BigInt(e)
        })),
        value: t === Me ? BigInt(e) : "0",
        chainId: s,
        chain: l
      };
      console.log("[trails-sdk] origin call params", h);
      let b = null;
      const y = null, g = null;
      if (await ks({
        walletClient: a,
        desiredChainId: s
      }), !c) {
        o([
          {
            transactionHash: "",
            explorerUrl: "",
            chainId: s,
            state: "pending",
            label: "Execute"
          }
        ]), console.log("[trails-sdk] origin call params", h);
        const w = await Eb(
          u,
          a,
          h
        );
        console.log("[trails-sdk] origin tx", w), m && m();
        const v = await i.waitForTransactionReceipt({
          hash: w
        });
        console.log("[trails-sdk] receipt", v), b = v, o([
          Pa(
            b,
            s,
            "Swap"
          )
        ]);
      }
      return {
        originUserTxReceipt: b,
        originMetaTxnReceipt: y,
        destinationMetaTxnReceipt: g
      };
    }
  };
}
async function kX({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationTokenAddress: n,
  destinationCalldata: r,
  recipient: s,
  originChainId: a,
  walletClient: i,
  publicClient: o,
  account: c
}) {
  var h, b, y, g, w, v, A, B, x, N;
  const u = [];
  r && u.push({
    to: s,
    value: n === Me ? e : "0",
    data: r
  });
  const l = await HV({
    wallet: i,
    chainId: a,
    amount: e,
    currency: t,
    toCurrency: n,
    txs: u
  });
  console.log("[trails-sdk] relaysdk quote", l);
  let d = "0";
  try {
    if (d = (w = (g = (y = (b = (h = l.steps) == null ? void 0 : h[0]) == null ? void 0 : b.items) == null ? void 0 : y[0]) == null ? void 0 : g.data) == null ? void 0 : w.value, t !== Me) {
      const I = Gm({
        abi: Ju,
        data: (N = (x = (B = (A = (v = l.steps) == null ? void 0 : v[0]) == null ? void 0 : A.items) == null ? void 0 : B[0]) == null ? void 0 : x.data) == null ? void 0 : N.data
      });
      I.functionName === "approve" && (d = I.args[1].toString()), I.functionName === "transfer" && (d = I.args[1].toString());
    }
  } catch (I) {
    console.error("[trails-sdk] Error decoding function data:", I);
  }
  if (!await uw({
    account: c,
    tokenAddress: t,
    depositAmount: d,
    publicClient: o
  }))
    throw new Error("Account does not have enough balance for deposit");
  return {
    originSendAmount: d,
    send: async (I) => {
      await ks({
        walletClient: i,
        desiredChainId: a
      });
      const O = await _V(l, i);
      console.log("[trails-sdk] relaysdk result", O);
      const C = GV(O);
      return I && I(), {
        originUserTxReceipt: await o.waitForTransactionReceipt({
          hash: C
        }),
        originMetaTxnReceipt: null,
        destinationMetaTxnReceipt: null
      };
    }
  };
}
async function vX({
  paymasterUrl: t,
  depositTokenAddress: e,
  depositTokenAmount: n,
  depositRecipient: r,
  onOriginSend: s,
  walletClient: a,
  chain: i,
  account: o,
  relayerConfig: c,
  sequenceProjectAccessKey: u,
  originRelayer: l
}) {
  let d = null;
  const m = i.id;
  console.log("[trails-sdk] originChainId", m);
  const h = wa({
    chain: i,
    transport: ct()
  }), b = aI[i.id];
  console.log("[trails-sdk] intentEntrypoint", b);
  let y = [];
  if (t) {
    console.log("[trails-sdk] doing gasless with paymaster");
    const g = await nQ({
      publicClient: h
    });
    b ? y = await Jx({
      publicClient: h,
      walletClient: a,
      account: o,
      intentEntrypoint: b,
      depositTokenAddress: e,
      depositTokenAmount: BigInt(n),
      depositRecipient: r,
      chain: i
    }) : y = await rQ({
      walletClient: a,
      chain: i,
      tokenAddress: e,
      amount: BigInt(n),
      recipient: r,
      delegatorSmartAccount: g
    }), console.log("[trails-sdk] calls", y);
    const w = await sQ({
      walletClient: a,
      publicClient: h,
      chain: i,
      paymasterUrl: t,
      delegatorSmartAccount: g,
      calls: y
    });
    s && s();
    const v = await h.waitForTransactionReceipt({
      hash: w
    });
    console.log("[trails-sdk] receipt", v), d = v;
  } else {
    console.log("[trails-sdk] doing gasless with sequence wallet");
    const g = A1(), w = Tu(g), v = Qu({
      account: w,
      chain: i,
      transport: ct()
    });
    console.log("[trails-sdk] attempting to switch chain"), await ks({
      walletClient: a,
      desiredChainId: m
    }), console.log("[trails-sdk] creating sequence wallet");
    const A = await C5(
      w,
      c,
      u
    );
    if (console.log("[trails-sdk] sequenceWalletAddress", A), b)
      y = await Jx({
        publicClient: h,
        walletClient: a,
        account: o,
        intentEntrypoint: b,
        depositTokenAddress: e,
        depositTokenAmount: BigInt(n),
        depositRecipient: r,
        chain: i
      });
    else {
      const { signature: I, deadline: O } = await C1({
        publicClient: h,
        walletClient: a,
        signer: o.address,
        spender: A,
        tokenAddress: e,
        amount: BigInt(n),
        chain: i
      });
      y = kK(
        o.address,
        A,
        BigInt(n),
        O,
        I,
        r,
        e
      );
    }
    console.log("[trails-sdk] calls", y);
    const B = await WZ(
      l,
      A,
      m,
      y.map((I) => ({
        to: I.to,
        value: BigInt(I.value),
        data: I.data,
        gasLimit: BigInt(0),
        delegateCall: !1,
        onlyFallback: !1,
        behaviorOnError: "revert"
      }))
    );
    console.log("[trails-sdk] feeOptions", B);
    const x = await S5(
      A,
      v,
      h,
      y,
      i,
      c,
      u
    );
    console.log("[trails-sdk] sequenceTxHash", x), s && s();
    const N = await h.waitForTransactionReceipt({
      hash: x
    });
    console.log("[trails-sdk] receipt", N), d = N;
  }
  return d;
}
async function CX({
  originTokenAddress: t,
  firstPreconditionMin: e,
  onOriginSend: n,
  publicClient: r,
  walletClient: s,
  originChainId: a,
  chain: i,
  account: o,
  fee: c,
  dryMode: u,
  sourceTokenPriceUsd: l,
  destinationTokenPriceUsd: d,
  destinationTokenAmount: m,
  destinationTokenDecimals: h,
  sourceTokenDecimals: b,
  intentAddress: y
}) {
  var N, I;
  let g = null;
  const w = await D5({
    originTokenAddress: t,
    destinationTokenAmount: m,
    destinationTokenDecimals: h,
    sourceTokenDecimals: b,
    sourceTokenPriceUsd: l ?? null,
    destinationTokenPriceUsd: d ?? null,
    depositAmount: e
  });
  let v = Vm("0.00005", 18).toString();
  a === 137 && (v = Vm("1.5", 18).toString()), console.log("[trails-sdk] needsNativeFee", w);
  const A = {
    to: t === Me ? y : t,
    data: t === Me ? "0x" : k1({
      recipient: y,
      amount: BigInt(e) + BigInt(c)
    }),
    value: t === Me ? BigInt(e) + BigInt(c) : "0",
    chain: i
  };
  await ks({
    walletClient: s,
    desiredChainId: a
  });
  let B = !1;
  if (w)
    try {
      const O = await hX(
        s,
        [
          {
            method: "wallet_getCapabilities",
            params: [o.address]
          }
        ],
        1e4
      );
      console.log("[trails-sdk] capabilities", O);
      const C = `0x${a.toString(16)}`, U = O[C];
      B = ((N = U == null ? void 0 : U.atomic) == null ? void 0 : N.status) === "supported";
    } catch (O) {
      console.error("[trails-sdk] Error getting capabilities", O);
    }
  if (u && console.log("[trails-sdk] dry mode, skipping send calls"), console.log(B ? "[trails-sdk] using sendCalls" : "[trails-sdk] using sendTransaction"), B) {
    if (!u) {
      const O = [];
      w && O.push({
        to: y,
        data: "0x00",
        value: `0x${BigInt(v).toString(16)}`
      }), O.push({
        to: A.to,
        data: A.data,
        value: A.value ? `0x${BigInt(A.value).toString(16)}` : "0x0"
      });
      const C = await s.request({
        method: "wallet_sendCalls",
        params: [
          {
            version: "2.0.0",
            chainId: `0x${a.toString(16)}`,
            atomicRequired: !0,
            calls: O
          }
        ]
      });
      console.log("[trails-sdk] sendCalls result", C);
      const U = C.requestId || C.id;
      let P;
      for (; !P; ) {
        const $ = await s.request({
          method: "wallet_getCallsStatus",
          params: [U]
        });
        console.log("[trails-sdk] getCallsStatus result", $);
        const K = (I = $ == null ? void 0 : $.receipts) == null ? void 0 : I[0];
        if ($.status === 200 && (K != null && K.transactionHash)) {
          P = K.transactionHash;
          break;
        } else if ($.status === 500)
          throw new Error(`Transaction failed: ${$.error}`);
        await new Promise((F) => setTimeout(F, 2e3));
      }
      n && n();
      const D = await r.waitForTransactionReceipt({
        hash: P
      });
      console.log("[trails-sdk] receipt", D), g = D;
    }
  } else if (!u) {
    if (w) {
      const U = await Eb(o, s, {
        to: y,
        data: "0x00",
        value: v,
        chain: i
      });
      console.log("[trails-sdk] origin tx", U);
      const P = await r.waitForTransactionReceipt({
        hash: U
      });
      console.log("[trails-sdk] nativeFeeReceipt", P);
    }
    const O = await Eb(
      o,
      s,
      A
    );
    console.log("[trails-sdk] origin tx", O), n && n();
    const C = await r.waitForTransactionReceipt({
      hash: O
    });
    console.log("[trails-sdk] receipt", C), g = C;
  }
  return g;
}
async function TX({
  originTokenAddress: t,
  gasless: e,
  paymasterUrl: n,
  chain: r,
  account: s,
  relayerConfig: a,
  sequenceProjectAccessKey: i,
  originRelayer: o,
  firstPreconditionMin: c,
  intentAddress: u,
  onOriginSend: l,
  publicClient: d,
  walletClient: m,
  destinationTokenDecimals: h,
  sourceTokenDecimals: b,
  fee: y,
  dryMode: g,
  sourceTokenPriceUsd: w,
  destinationTokenPriceUsd: v,
  destinationTokenAmount: A
}) {
  let B = null;
  const x = r.id, N = SX(t, e, n);
  if (console.log("[trails-sdk] doGasless", N, n), N)
    try {
      B = await vX({
        paymasterUrl: n,
        depositTokenAddress: t,
        depositTokenAmount: c,
        depositRecipient: u,
        onOriginSend: l,
        walletClient: m,
        chain: r,
        account: s,
        relayerConfig: a,
        sequenceProjectAccessKey: i,
        originRelayer: o
      });
    } catch (I) {
      console.log("[trails-sdk] gassless attempt failed", I);
    }
  return B || (B = await CX({
    originTokenAddress: t,
    firstPreconditionMin: c,
    intentAddress: u,
    onOriginSend: l,
    publicClient: d,
    walletClient: m,
    originChainId: x,
    chain: r,
    account: s,
    fee: y,
    dryMode: g,
    sourceTokenPriceUsd: w,
    destinationTokenPriceUsd: v,
    destinationTokenAmount: A,
    destinationTokenDecimals: h,
    sourceTokenDecimals: b
  })), B;
}
function SX(t, e, n) {
  return !!(t !== Me && (e || n));
}
function Pa(t, e, n) {
  let r = "", s = "pending";
  return "transactionHash" in t ? (r = t.transactionHash, s = t.status === "success" ? "confirmed" : "failed") : "txnHash" in t && (r = t.txnHash, s = t.status === "SUCCEEDED" ? "confirmed" : "failed"), {
    transactionHash: r,
    explorerUrl: wK({ txHash: r, chainId: e }),
    chainId: e,
    state: s,
    label: n
  };
}
async function k2({
  metaTx: t,
  relayer: e,
  precondition: n
}) {
  var a;
  let r = null;
  console.log("[trails-sdk] metaTx", t);
  const s = await BK(e, t, [n]);
  for (console.log("[trails-sdk] opHash", s); ; ) {
    console.log(
      "[trails-sdk] polling status",
      t.id,
      BigInt(t.chainId)
    );
    const i = await OK(
      e,
      t.id,
      Number(t.chainId)
    );
    if (console.log("[trails-sdk] status", i), i != null && i.transactionHash) {
      r = (a = i.data) == null ? void 0 : a.receipt;
      break;
    }
    await new Promise((o) => setTimeout(o, 1e3));
  }
  return r;
}
async function uw({
  account: t,
  tokenAddress: e,
  depositAmount: n,
  publicClient: r
}) {
  try {
    let s;
    e === Me ? s = await r.getBalance({ address: t.address }) : s = await r.readContract({
      address: e,
      abi: Ju,
      functionName: "balanceOf",
      args: [t.address]
    });
    const a = BigInt(n);
    return console.log("[trails-sdk] balance", s), console.log("[trails-sdk] requiredAmount", a), s >= a;
  } catch (s) {
    return console.error("[trails-sdk] Error checking account balance:", s), !1;
  }
}
function D5({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationTokenDecimals: n,
  sourceTokenDecimals: r,
  sourceTokenPriceUsd: s,
  destinationTokenPriceUsd: a,
  depositAmount: i
}) {
  let o = !1;
  if (t !== Me && s && a && i && n !== void 0 && r !== void 0) {
    const c = Number(
      zm(BigInt(e), n)
    ), u = Number(
      zm(BigInt(i), n)
    );
    console.log("[trails-sdk] destinationAmount", c), console.log("[trails-sdk] depositAmountFormatted", u);
    const l = c * a, d = u * s, m = d - l;
    console.log(
      "[trails-sdk] destinationAmountUsd",
      l,
      "[trails-sdk] depositAmountUsd",
      d,
      "[trails-sdk] diff",
      m
    ), m >= 0 && m <= 0.02 && (o = !0);
  }
  return o;
}
function qY({
  walletClient: t,
  fromTokenAddress: e,
  fromChainId: n,
  toTokenAddress: r,
  toChainId: s,
  toAmount: a,
  toRecipient: i
} = {}) {
  var w;
  const o = rd(), { getRelayer: c } = TQ({
    env: "dev",
    useV3Relayers: iI
  }), u = dd(), { supportedTokens: l } = R5(), { tokenBalance: d } = nX({
    account: (w = t == null ? void 0 : t.account) == null ? void 0 : w.address,
    token: e,
    chainId: n,
    indexerGatewayClient: u,
    apiClient: o
  }), m = r && s ? {
    tokenId: r,
    chainId: s,
    contractAddress: r
  } : null, { tokenPrice: h } = lQ(
    m,
    o
  ), { data: b, isLoading: y, error: g } = yn({
    queryKey: [
      "quote",
      e,
      n,
      r,
      s,
      a == null ? void 0 : a.toString(),
      i
    ],
    queryFn: async () => {
      var X, Y;
      if (!t || !o || !e || !r || !a || !i || !n || !s)
        return null;
      const v = (d == null ? void 0 : d.balance) ?? "0", A = "", B = c(s), x = c(n);
      console.log("originRelayer", x), console.log("destinationRelayer", B);
      const N = ((X = d == null ? void 0 : d.price) == null ? void 0 : X.value) ?? 0, I = ((Y = h == null ? void 0 : h.price) == null ? void 0 : Y.value) ?? 0, O = l == null ? void 0 : l.find(
        (Q) => Q.contractAddress === e && Q.chainId === n
      ), C = l == null ? void 0 : l.find(
        (Q) => Q.contractAddress === r && Q.chainId === s
      ), U = (O == null ? void 0 : O.decimals) ?? 18, P = (C == null ? void 0 : C.decimals) ?? 18, D = (C == null ? void 0 : C.symbol) ?? "", $ = {
        account: t.account,
        originTokenAddress: e,
        originChainId: n,
        originTokenAmount: v,
        destinationChainId: s,
        recipient: i,
        destinationTokenAddress: r,
        destinationTokenAmount: a.toString(),
        destinationTokenSymbol: D,
        sequenceProjectAccessKey: A,
        client: t,
        apiClient: o,
        originRelayer: x,
        destinationRelayer: B,
        sourceTokenPriceUsd: N,
        destinationTokenPriceUsd: I,
        sourceTokenDecimals: U,
        destinationTokenDecimals: P,
        fee: "0",
        dryMode: !1,
        onTransactionStateChange: () => {
        },
        relayerConfig: {}
      };
      console.log("[trails-sdk] options", $);
      const { intentAddress: K, originSendAmount: F, send: M } = await EX($);
      return console.log("[trails-sdk] Intent address:", K == null ? void 0 : K.toString()), {
        quote: {
          fromAmount: F
        },
        swap: async () => {
          const { originUserTxReceipt: Q, destinationMetaTxnReceipt: le } = await M();
          return {
            originTransaction: {
              transactionHash: Q == null ? void 0 : Q.transactionHash,
              receipt: Q
            },
            destinationTransaction: {
              transactionHash: le == null ? void 0 : le.txnHash,
              receipt: le
            }
          };
        }
      };
    }
  });
  return {
    quote: (b == null ? void 0 : b.quote) || null,
    swap: (b == null ? void 0 : b.swap) || null,
    isLoadingQuote: y,
    quoteError: g
  };
}
export {
  jY as $,
  dd as A,
  Pq as B,
  EX as C,
  qY as D,
  P5 as E,
  rX as F,
  sX as G,
  $Y as H,
  LY as I,
  HY as J,
  MY as K,
  lw as L,
  R5 as M,
  VY as N,
  Tq as O,
  PY as P,
  UY as Q,
  yu as R,
  Kc as S,
  qX as T,
  nP as U,
  Pe as V,
  eY as W,
  He as X,
  Jc as Y,
  DY as Z,
  Ln as _,
  $t as a,
  zY as a0,
  cQ as a1,
  YZ as a2,
  XZ as a3,
  iI as a4,
  O5 as a5,
  CQ as a6,
  _Y as a7,
  GY as a8,
  LX as a9,
  L3 as aA,
  rn as aB,
  iY as aC,
  NY as aa,
  lQ as ab,
  cg as ac,
  $2 as ad,
  MX as ae,
  DX as af,
  bu as ag,
  Xg as ah,
  zc as ai,
  rY as aj,
  J8 as ak,
  H as al,
  ev as am,
  el as an,
  n1 as ao,
  nY as ap,
  tY as aq,
  ma as ar,
  _n as as,
  Xf as at,
  lD as au,
  hD as av,
  FY as aw,
  tD as ax,
  Z8 as ay,
  XK as az,
  sT as b,
  rd as c,
  TQ as d,
  yn as e,
  Vc as f,
  hT as g,
  nu as h,
  k1 as i,
  RY as j,
  ws as k,
  Iq as l,
  wb as m,
  nt as n,
  ks as o,
  vQ as p,
  Sq as q,
  jX as r,
  Km as s,
  VX as t,
  Z2 as u,
  Bq as v,
  oI as w,
  ZV as x,
  CY as y,
  XV as z
};
