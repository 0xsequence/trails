var K3 = Object.defineProperty;
var Rg = (t) => {
  throw TypeError(t);
};
var q3 = (t, e, n) => e in t ? K3(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var F = (t, e, n) => q3(t, typeof e != "symbol" ? e + "" : e, n), oh = (t, e, n) => e.has(t) || Rg("Cannot " + n);
var m = (t, e, n) => (oh(t, e, "read from private field"), n ? n.call(t) : e.get(t)), B = (t, e, n) => e.has(t) ? Rg("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), E = (t, e, n, r) => (oh(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n), z = (t, e, n) => (oh(t, e, "access private method"), n);
var Ic = (t, e, n, r) => ({
  set _(s) {
    E(t, e, s, n);
  },
  get _() {
    return m(t, e, r);
  }
});
import { isAddressEqual as W3, encodeFunctionData as Xs, createWalletClient as Df, http as Zt, createPublicClient as uu, keccak256 as Uc, encodeAbiParameters as Fg, concat as du, pad as pi, toHex as Ys, custom as Zc, encodeDeployData as Q3, decodeAbiParameters as J3, decodeFunctionData as rm, parseGwei as Z3, zeroAddress as Ye, hexToBigInt as us, fallback as Mg, hexToBytes as Sb, bytesToHex as X3, parseUnits as Dg, erc20Abi as Y3, formatUnits as sm } from "viem";
import { Payload as HE, Config as eC } from "@0xsequence/wallet-primitives";
import * as ut from "react";
import { createContext as tC, useState as Lf, useContext as nC, useMemo as Hf, useEffect as Ob } from "react";
import { Relayer as am } from "@0xsequence/wallet-core";
import { jsx as $E } from "react/jsx-runtime";
import { SequenceAPIClient as rC } from "@0xsequence/anypay-api";
const sC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get claimAppFees() {
    return Zq;
  },
  get execute() {
    return jq;
  },
  get getAppFees() {
    return Jq;
  },
  get getPrice() {
    return Wq;
  },
  get getQuote() {
    return qq;
  },
  get getSolverCapacity() {
    return Qq;
  }
}, Symbol.toStringTag, { value: "Module" }));
var JJ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function aC(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function ZJ(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var $f = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, hi = typeof window > "u" || "Deno" in globalThis;
function nc() {
}
function XJ(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function im(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function _E(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function Qi(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Kn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function YJ(t, e) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: s,
    predicate: a,
    queryKey: i,
    stale: o
  } = t;
  if (i) {
    if (r) {
      if (e.queryHash !== iC(i, e.options))
        return !1;
    } else if (!Bb(e.queryKey, i))
      return !1;
  }
  if (n !== "all") {
    const c = e.isActive();
    if (n === "active" && !c || n === "inactive" && c)
      return !1;
  }
  return !(typeof o == "boolean" && e.isStale() !== o || s && s !== e.state.fetchStatus || a && !a(e));
}
function eZ(t, e) {
  const { exact: n, status: r, predicate: s, mutationKey: a } = t;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (n) {
      if (om(e.options.mutationKey) !== om(a))
        return !1;
    } else if (!Bb(e.options.mutationKey, a))
      return !1;
  }
  return !(r && e.state.status !== r || s && !s(e));
}
function iC(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || om)(t);
}
function om(t) {
  return JSON.stringify(
    t,
    (e, n) => lm(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n
  );
}
function Bb(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((n) => Bb(t[n], e[n])) : !1;
}
function Vd(t, e) {
  if (t === e)
    return t;
  const n = Lg(t) && Lg(e);
  if (n || lm(t) && lm(e)) {
    const r = n ? t : Object.keys(t), s = r.length, a = n ? e : Object.keys(e), i = a.length, o = n ? [] : {}, c = new Set(r);
    let u = 0;
    for (let l = 0; l < i; l++) {
      const d = n ? l : a[l];
      (!n && c.has(d) || n) && t[d] === void 0 && e[d] === void 0 ? (o[d] = void 0, u++) : (o[d] = Vd(t[d], e[d]), o[d] === t[d] && t[d] !== void 0 && u++);
    }
    return s === i && u === s ? t : o;
  }
  return e;
}
function cm(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const n in t)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Lg(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function lm(t) {
  if (!Hg(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const n = e.prototype;
  return !(!Hg(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Hg(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function oC(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function um(t, e, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(t, e);
  if (n.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Vd(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${n.queryHash}]: ${r}`
        ), r;
      }
    return Vd(t, e);
  }
  return e;
}
function tZ(t, e, n = 0) {
  const r = [...t, e];
  return n && r.length > n ? r.slice(1) : r;
}
function nZ(t, e, n = 0) {
  const r = [e, ...t];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var dm = Symbol();
function cC(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === dm && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === dm ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function lC(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var Oa, Es, ao, PE, uC = (PE = class extends $f {
  constructor() {
    super();
    B(this, Oa);
    B(this, Es);
    B(this, ao);
    E(this, ao, (e) => {
      if (!hi && window.addEventListener) {
        const n = () => e();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    m(this, Es) || this.setEventListener(m(this, ao));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = m(this, Es)) == null || e.call(this), E(this, Es, void 0));
  }
  setEventListener(e) {
    var n;
    E(this, ao, e), (n = m(this, Es)) == null || n.call(this), E(this, Es, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    m(this, Oa) !== e && (E(this, Oa, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((n) => {
      n(e);
    });
  }
  isFocused() {
    var e;
    return typeof m(this, Oa) == "boolean" ? m(this, Oa) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, Oa = new WeakMap(), Es = new WeakMap(), ao = new WeakMap(), PE), GE = new uC(), io, xs, oo, IE, dC = (IE = class extends $f {
  constructor() {
    super();
    B(this, io, !0);
    B(this, xs);
    B(this, oo);
    E(this, oo, (e) => {
      if (!hi && window.addEventListener) {
        const n = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    m(this, xs) || this.setEventListener(m(this, oo));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = m(this, xs)) == null || e.call(this), E(this, xs, void 0));
  }
  setEventListener(e) {
    var n;
    E(this, oo, e), (n = m(this, xs)) == null || n.call(this), E(this, xs, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    m(this, io) !== e && (E(this, io, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return m(this, io);
  }
}, io = new WeakMap(), xs = new WeakMap(), oo = new WeakMap(), IE), zE = new dC();
function fm() {
  let t, e;
  const n = new Promise((s, a) => {
    t = s, e = a;
  });
  n.status = "pending", n.catch(() => {
  });
  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject;
  }
  return n.resolve = (s) => {
    r({
      status: "fulfilled",
      value: s
    }), t(s);
  }, n.reject = (s) => {
    r({
      status: "rejected",
      reason: s
    }), e(s);
  }, n;
}
function fC(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function VE(t) {
  return (t ?? "online") === "online" ? zE.isOnline() : !0;
}
var jE = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function ch(t) {
  return t instanceof jE;
}
function KE(t) {
  let e = !1, n = 0, r = !1, s;
  const a = fm(), i = (b) => {
    var g;
    r || (f(new jE(b)), (g = t.abort) == null || g.call(t));
  }, o = () => {
    e = !0;
  }, c = () => {
    e = !1;
  }, u = () => GE.isFocused() && (t.networkMode === "always" || zE.isOnline()) && t.canRun(), l = () => VE(t.networkMode) && t.canRun(), d = (b) => {
    var g;
    r || (r = !0, (g = t.onSuccess) == null || g.call(t, b), s == null || s(), a.resolve(b));
  }, f = (b) => {
    var g;
    r || (r = !0, (g = t.onError) == null || g.call(t, b), s == null || s(), a.reject(b));
  }, h = () => new Promise((b) => {
    var g;
    s = (w) => {
      (r || u()) && b(w);
    }, (g = t.onPause) == null || g.call(t);
  }).then(() => {
    var b;
    s = void 0, r || (b = t.onContinue) == null || b.call(t);
  }), y = () => {
    if (r)
      return;
    let b;
    const g = n === 0 ? t.initialPromise : void 0;
    try {
      b = g ?? t.fn();
    } catch (w) {
      b = Promise.reject(w);
    }
    Promise.resolve(b).then(d).catch((w) => {
      var O;
      if (r)
        return;
      const v = t.retry ?? (hi ? 0 : 3), A = t.retryDelay ?? fC, P = typeof A == "function" ? A(n, w) : A, x = v === !0 || typeof v == "number" && n < v || typeof v == "function" && v(n, w);
      if (e || !x) {
        f(w);
        return;
      }
      n++, (O = t.onFail) == null || O.call(t, n, w), oC(P).then(() => u() ? void 0 : h()).then(() => {
        e ? f(w) : y();
      });
    });
  };
  return {
    promise: a,
    cancel: i,
    continue: () => (s == null || s(), a),
    cancelRetry: o,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? y() : h().then(y), a)
  };
}
var pC = (t) => setTimeout(t, 0);
function hC() {
  let t = [], e = 0, n = (o) => {
    o();
  }, r = (o) => {
    o();
  }, s = pC;
  const a = (o) => {
    e ? t.push(o) : s(() => {
      n(o);
    });
  }, i = () => {
    const o = t;
    t = [], o.length && s(() => {
      r(() => {
        o.forEach((c) => {
          n(c);
        });
      });
    });
  };
  return {
    batch: (o) => {
      let c;
      e++;
      try {
        c = o();
      } finally {
        e--, e || i();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (o) => (...c) => {
      a(() => {
        o(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (o) => {
      n = o;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (o) => {
      r = o;
    },
    setScheduler: (o) => {
      s = o;
    }
  };
}
var mi = hC(), Ba, UE, qE = (UE = class {
  constructor() {
    B(this, Ba);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), im(this.gcTime) && E(this, Ba, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (hi ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    m(this, Ba) && (clearTimeout(m(this, Ba)), E(this, Ba, void 0));
  }
}, Ba = new WeakMap(), UE), co, Pa, vn, Ia, gt, Kl, Ua, $n, Mr, NE, rZ = (NE = class extends qE {
  constructor(e) {
    super();
    B(this, $n);
    B(this, co);
    B(this, Pa);
    B(this, vn);
    B(this, Ia);
    B(this, gt);
    B(this, Kl);
    B(this, Ua);
    E(this, Ua, !1), E(this, Kl, e.defaultOptions), this.setOptions(e.options), this.observers = [], E(this, Ia, e.client), E(this, vn, m(this, Ia).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, E(this, co, mC(this.options)), this.state = e.state ?? m(this, co), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = m(this, gt)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...m(this, Kl), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && m(this, vn).remove(this);
  }
  setData(e, n) {
    const r = um(this.state.data, e, this.options);
    return z(this, $n, Mr).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(e, n) {
    z(this, $n, Mr).call(this, { type: "setState", state: e, setStateOptions: n });
  }
  cancel(e) {
    var r, s;
    const n = (r = m(this, gt)) == null ? void 0 : r.promise;
    return (s = m(this, gt)) == null || s.cancel(e), n ? n.then(nc).catch(nc) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(m(this, co));
  }
  isActive() {
    return this.observers.some(
      (e) => Kn(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === dm || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Qi(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !_E(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = m(this, gt)) == null || n.continue();
  }
  onOnline() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = m(this, gt)) == null || n.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), m(this, vn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((n) => n !== e), this.observers.length || (m(this, gt) && (m(this, Ua) ? m(this, gt).cancel({ revert: !0 }) : m(this, gt).cancelRetry()), this.scheduleGc()), m(this, vn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || z(this, $n, Mr).call(this, { type: "invalidate" });
  }
  fetch(e, n) {
    var u, l, d;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (m(this, gt))
        return m(this, gt).continueRetry(), m(this, gt).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const f = this.observers.find((h) => h.options.queryFn);
      f && this.setOptions(f.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), s = (f) => {
      Object.defineProperty(f, "signal", {
        enumerable: !0,
        get: () => (E(this, Ua, !0), r.signal)
      });
    }, a = () => {
      const f = cC(this.options, n), y = (() => {
        const b = {
          client: m(this, Ia),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(b), b;
      })();
      return E(this, Ua, !1), this.options.persister ? this.options.persister(
        f,
        y,
        this
      ) : f(y);
    }, o = (() => {
      const f = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        client: m(this, Ia),
        state: this.state,
        fetchFn: a
      };
      return s(f), f;
    })();
    (u = this.options.behavior) == null || u.onFetch(o, this), E(this, Pa, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((l = o.fetchOptions) == null ? void 0 : l.meta)) && z(this, $n, Mr).call(this, { type: "fetch", meta: (d = o.fetchOptions) == null ? void 0 : d.meta });
    const c = (f) => {
      var h, y, b, g;
      ch(f) && f.silent || z(this, $n, Mr).call(this, {
        type: "error",
        error: f
      }), ch(f) || ((y = (h = m(this, vn).config).onError) == null || y.call(
        h,
        f,
        this
      ), (g = (b = m(this, vn).config).onSettled) == null || g.call(
        b,
        this.state.data,
        f,
        this
      )), this.scheduleGc();
    };
    return E(this, gt, KE({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: o.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (f) => {
        var h, y, b, g;
        if (f === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(f);
        } catch (w) {
          c(w);
          return;
        }
        (y = (h = m(this, vn).config).onSuccess) == null || y.call(h, f, this), (g = (b = m(this, vn).config).onSettled) == null || g.call(
          b,
          f,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: c,
      onFail: (f, h) => {
        z(this, $n, Mr).call(this, { type: "failed", failureCount: f, error: h });
      },
      onPause: () => {
        z(this, $n, Mr).call(this, { type: "pause" });
      },
      onContinue: () => {
        z(this, $n, Mr).call(this, { type: "continue" });
      },
      retry: o.options.retry,
      retryDelay: o.options.retryDelay,
      networkMode: o.options.networkMode,
      canRun: () => !0
    })), m(this, gt).start();
  }
}, co = new WeakMap(), Pa = new WeakMap(), vn = new WeakMap(), Ia = new WeakMap(), gt = new WeakMap(), Kl = new WeakMap(), Ua = new WeakMap(), $n = new WeakSet(), Mr = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...WE(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return E(this, Pa, void 0), {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const s = e.error;
        return ch(s) && s.revert && m(this, Pa) ? { ...m(this, Pa), fetchStatus: "idle" } : {
          ...r,
          error: s,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = n(this.state), mi.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), m(this, vn).notify({ query: this, type: "updated", action: e });
  });
}, NE);
function WE(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: VE(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function mC(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var dr, Ft, Na, fr, ys, RE, sZ = (RE = class extends qE {
  constructor(e) {
    super();
    B(this, fr);
    B(this, dr);
    B(this, Ft);
    B(this, Na);
    this.mutationId = e.mutationId, E(this, Ft, e.mutationCache), E(this, dr, []), this.state = e.state || bC(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    m(this, dr).includes(e) || (m(this, dr).push(e), this.clearGcTimeout(), m(this, Ft).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    E(this, dr, m(this, dr).filter((n) => n !== e)), this.scheduleGc(), m(this, Ft).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    m(this, dr).length || (this.state.status === "pending" ? this.scheduleGc() : m(this, Ft).remove(this));
  }
  continue() {
    var e;
    return ((e = m(this, Na)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var a, i, o, c, u, l, d, f, h, y, b, g, w, v, A, P, x, O, I, T;
    const n = () => {
      z(this, fr, ys).call(this, { type: "continue" });
    };
    E(this, Na, KE({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (C, N) => {
        z(this, fr, ys).call(this, { type: "failed", failureCount: C, error: N });
      },
      onPause: () => {
        z(this, fr, ys).call(this, { type: "pause" });
      },
      onContinue: n,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => m(this, Ft).canRun(this)
    }));
    const r = this.state.status === "pending", s = !m(this, Na).canStart();
    try {
      if (r)
        n();
      else {
        z(this, fr, ys).call(this, { type: "pending", variables: e, isPaused: s }), await ((i = (a = m(this, Ft).config).onMutate) == null ? void 0 : i.call(
          a,
          e,
          this
        ));
        const N = await ((c = (o = this.options).onMutate) == null ? void 0 : c.call(o, e));
        N !== this.state.context && z(this, fr, ys).call(this, {
          type: "pending",
          context: N,
          variables: e,
          isPaused: s
        });
      }
      const C = await m(this, Na).start();
      return await ((l = (u = m(this, Ft).config).onSuccess) == null ? void 0 : l.call(
        u,
        C,
        e,
        this.state.context,
        this
      )), await ((f = (d = this.options).onSuccess) == null ? void 0 : f.call(d, C, e, this.state.context)), await ((y = (h = m(this, Ft).config).onSettled) == null ? void 0 : y.call(
        h,
        C,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((g = (b = this.options).onSettled) == null ? void 0 : g.call(b, C, null, e, this.state.context)), z(this, fr, ys).call(this, { type: "success", data: C }), C;
    } catch (C) {
      try {
        throw await ((v = (w = m(this, Ft).config).onError) == null ? void 0 : v.call(
          w,
          C,
          e,
          this.state.context,
          this
        )), await ((P = (A = this.options).onError) == null ? void 0 : P.call(
          A,
          C,
          e,
          this.state.context
        )), await ((O = (x = m(this, Ft).config).onSettled) == null ? void 0 : O.call(
          x,
          void 0,
          C,
          this.state.variables,
          this.state.context,
          this
        )), await ((T = (I = this.options).onSettled) == null ? void 0 : T.call(
          I,
          void 0,
          C,
          e,
          this.state.context
        )), C;
      } finally {
        z(this, fr, ys).call(this, { type: "error", error: C });
      }
    } finally {
      m(this, Ft).runNext(this);
    }
  }
}, dr = new WeakMap(), Ft = new WeakMap(), Na = new WeakMap(), fr = new WeakSet(), ys = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: e.error,
          failureCount: r.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), mi.batch(() => {
    m(this, dr).forEach((r) => {
      r.onMutationUpdate(e);
    }), m(this, Ft).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, RE);
function bC() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Kt, Ae, ql, Mt, Ra, lo, As, vs, Wl, uo, fo, Fa, Ma, ks, po, Ne, Xc, pm, hm, mm, bm, ym, gm, wm, QE, FE, Pb = (FE = class extends $f {
  constructor(e, n) {
    super();
    B(this, Ne);
    B(this, Kt);
    B(this, Ae);
    B(this, ql);
    B(this, Mt);
    B(this, Ra);
    B(this, lo);
    B(this, As);
    B(this, vs);
    B(this, Wl);
    B(this, uo);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    B(this, fo);
    B(this, Fa);
    B(this, Ma);
    B(this, ks);
    B(this, po, /* @__PURE__ */ new Set());
    this.options = n, E(this, Kt, e), E(this, vs, null), E(this, As, fm()), this.options.experimental_prefetchInRender || m(this, As).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (m(this, Ae).addObserver(this), $g(m(this, Ae), this.options) ? z(this, Ne, Xc).call(this) : this.updateResult(), z(this, Ne, bm).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Em(
      m(this, Ae),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Em(
      m(this, Ae),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), z(this, Ne, ym).call(this), z(this, Ne, gm).call(this), m(this, Ae).removeObserver(this);
  }
  setOptions(e) {
    const n = this.options, r = m(this, Ae);
    if (this.options = m(this, Kt).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Kn(this.options.enabled, m(this, Ae)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    z(this, Ne, wm).call(this), m(this, Ae).setOptions(this.options), n._defaulted && !cm(this.options, n) && m(this, Kt).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: m(this, Ae),
      observer: this
    });
    const s = this.hasListeners();
    s && _g(
      m(this, Ae),
      r,
      this.options,
      n
    ) && z(this, Ne, Xc).call(this), this.updateResult(), s && (m(this, Ae) !== r || Kn(this.options.enabled, m(this, Ae)) !== Kn(n.enabled, m(this, Ae)) || Qi(this.options.staleTime, m(this, Ae)) !== Qi(n.staleTime, m(this, Ae))) && z(this, Ne, pm).call(this);
    const a = z(this, Ne, hm).call(this);
    s && (m(this, Ae) !== r || Kn(this.options.enabled, m(this, Ae)) !== Kn(n.enabled, m(this, Ae)) || a !== m(this, ks)) && z(this, Ne, mm).call(this, a);
  }
  getOptimisticResult(e) {
    const n = m(this, Kt).getQueryCache().build(m(this, Kt), e), r = this.createResult(n, e);
    return gC(this, r) && (E(this, Mt, r), E(this, lo, this.options), E(this, Ra, m(this, Ae).state)), r;
  }
  getCurrentResult() {
    return m(this, Mt);
  }
  trackResult(e, n) {
    return new Proxy(e, {
      get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
    });
  }
  trackProp(e) {
    m(this, po).add(e);
  }
  getCurrentQuery() {
    return m(this, Ae);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const n = m(this, Kt).defaultQueryOptions(e), r = m(this, Kt).getQueryCache().build(m(this, Kt), n);
    return r.fetch().then(() => this.createResult(r, n));
  }
  fetch(e) {
    return z(this, Ne, Xc).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), m(this, Mt)));
  }
  createResult(e, n) {
    var C;
    const r = m(this, Ae), s = this.options, a = m(this, Mt), i = m(this, Ra), o = m(this, lo), u = e !== r ? e.state : m(this, ql), { state: l } = e;
    let d = { ...l }, f = !1, h;
    if (n._optimisticResults) {
      const N = this.hasListeners(), U = !N && $g(e, n), L = N && _g(e, r, n, s);
      (U || L) && (d = {
        ...d,
        ...WE(l.data, e.options)
      }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle");
    }
    let { error: y, errorUpdatedAt: b, status: g } = d;
    h = d.data;
    let w = !1;
    if (n.placeholderData !== void 0 && h === void 0 && g === "pending") {
      let N;
      a != null && a.isPlaceholderData && n.placeholderData === (o == null ? void 0 : o.placeholderData) ? (N = a.data, w = !0) : N = typeof n.placeholderData == "function" ? n.placeholderData(
        (C = m(this, fo)) == null ? void 0 : C.state.data,
        m(this, fo)
      ) : n.placeholderData, N !== void 0 && (g = "success", h = um(
        a == null ? void 0 : a.data,
        N,
        n
      ), f = !0);
    }
    if (n.select && h !== void 0 && !w)
      if (a && h === (i == null ? void 0 : i.data) && n.select === m(this, Wl))
        h = m(this, uo);
      else
        try {
          E(this, Wl, n.select), h = n.select(h), h = um(a == null ? void 0 : a.data, h, n), E(this, uo, h), E(this, vs, null);
        } catch (N) {
          E(this, vs, N);
        }
    m(this, vs) && (y = m(this, vs), h = m(this, uo), b = Date.now(), g = "error");
    const v = d.fetchStatus === "fetching", A = g === "pending", P = g === "error", x = A && v, O = h !== void 0, T = {
      status: g,
      fetchStatus: d.fetchStatus,
      isPending: A,
      isSuccess: g === "success",
      isError: P,
      isInitialLoading: x,
      isLoading: x,
      data: h,
      dataUpdatedAt: d.dataUpdatedAt,
      error: y,
      errorUpdatedAt: b,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount,
      isFetching: v,
      isRefetching: v && !A,
      isLoadingError: P && !O,
      isPaused: d.fetchStatus === "paused",
      isPlaceholderData: f,
      isRefetchError: P && O,
      isStale: Ib(e, n),
      refetch: this.refetch,
      promise: m(this, As)
    };
    if (this.options.experimental_prefetchInRender) {
      const N = ($) => {
        T.status === "error" ? $.reject(T.error) : T.data !== void 0 && $.resolve(T.data);
      }, U = () => {
        const $ = E(this, As, T.promise = fm());
        N($);
      }, L = m(this, As);
      switch (L.status) {
        case "pending":
          e.queryHash === r.queryHash && N(L);
          break;
        case "fulfilled":
          (T.status === "error" || T.data !== L.value) && U();
          break;
        case "rejected":
          (T.status !== "error" || T.error !== L.reason) && U();
          break;
      }
    }
    return T;
  }
  updateResult() {
    const e = m(this, Mt), n = this.createResult(m(this, Ae), this.options);
    if (E(this, Ra, m(this, Ae).state), E(this, lo, this.options), m(this, Ra).data !== void 0 && E(this, fo, m(this, Ae)), cm(n, e))
      return;
    E(this, Mt, n);
    const r = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: s } = this.options, a = typeof s == "function" ? s() : s;
      if (a === "all" || !a && !m(this, po).size)
        return !0;
      const i = new Set(
        a ?? m(this, po)
      );
      return this.options.throwOnError && i.add("error"), Object.keys(m(this, Mt)).some((o) => {
        const c = o;
        return m(this, Mt)[c] !== e[c] && i.has(c);
      });
    };
    z(this, Ne, QE).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && z(this, Ne, bm).call(this);
  }
}, Kt = new WeakMap(), Ae = new WeakMap(), ql = new WeakMap(), Mt = new WeakMap(), Ra = new WeakMap(), lo = new WeakMap(), As = new WeakMap(), vs = new WeakMap(), Wl = new WeakMap(), uo = new WeakMap(), fo = new WeakMap(), Fa = new WeakMap(), Ma = new WeakMap(), ks = new WeakMap(), po = new WeakMap(), Ne = new WeakSet(), Xc = function(e) {
  z(this, Ne, wm).call(this);
  let n = m(this, Ae).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (n = n.catch(nc)), n;
}, pm = function() {
  z(this, Ne, ym).call(this);
  const e = Qi(
    this.options.staleTime,
    m(this, Ae)
  );
  if (hi || m(this, Mt).isStale || !im(e))
    return;
  const r = _E(m(this, Mt).dataUpdatedAt, e) + 1;
  E(this, Fa, setTimeout(() => {
    m(this, Mt).isStale || this.updateResult();
  }, r));
}, hm = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(m(this, Ae)) : this.options.refetchInterval) ?? !1;
}, mm = function(e) {
  z(this, Ne, gm).call(this), E(this, ks, e), !(hi || Kn(this.options.enabled, m(this, Ae)) === !1 || !im(m(this, ks)) || m(this, ks) === 0) && E(this, Ma, setInterval(() => {
    (this.options.refetchIntervalInBackground || GE.isFocused()) && z(this, Ne, Xc).call(this);
  }, m(this, ks)));
}, bm = function() {
  z(this, Ne, pm).call(this), z(this, Ne, mm).call(this, z(this, Ne, hm).call(this));
}, ym = function() {
  m(this, Fa) && (clearTimeout(m(this, Fa)), E(this, Fa, void 0));
}, gm = function() {
  m(this, Ma) && (clearInterval(m(this, Ma)), E(this, Ma, void 0));
}, wm = function() {
  const e = m(this, Kt).getQueryCache().build(m(this, Kt), this.options);
  if (e === m(this, Ae))
    return;
  const n = m(this, Ae);
  E(this, Ae, e), E(this, ql, e.state), this.hasListeners() && (n == null || n.removeObserver(this), e.addObserver(this));
}, QE = function(e) {
  mi.batch(() => {
    e.listeners && this.listeners.forEach((n) => {
      n(m(this, Mt));
    }), m(this, Kt).getQueryCache().notify({
      query: m(this, Ae),
      type: "observerResultsUpdated"
    });
  });
}, FE);
function yC(t, e) {
  return Kn(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function $g(t, e) {
  return yC(t, e) || t.state.data !== void 0 && Em(t, e, e.refetchOnMount);
}
function Em(t, e, n) {
  if (Kn(e.enabled, t) !== !1 && Qi(e.staleTime, t) !== "static") {
    const r = typeof n == "function" ? n(t) : n;
    return r === "always" || r !== !1 && Ib(t, e);
  }
  return !1;
}
function _g(t, e, n, r) {
  return (t !== e || Kn(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && Ib(t, n);
}
function Ib(t, e) {
  return Kn(e.enabled, t) !== !1 && t.isStaleByTime(Qi(e.staleTime, t));
}
function gC(t, e) {
  return !cm(t.getCurrentResult(), e);
}
function Gg(t, e) {
  const n = new Set(e);
  return t.filter((r) => !n.has(r));
}
function wC(t, e, n) {
  const r = t.slice(0);
  return r[e] = n, r;
}
var Da, kn, ho, mo, Cn, Cs, Ql, Jl, Zl, mt, xm, Am, vm, km, Cm, ME, EC = (ME = class extends $f {
  constructor(e, n, r) {
    super();
    B(this, mt);
    B(this, Da);
    B(this, kn);
    B(this, ho);
    B(this, mo);
    B(this, Cn);
    B(this, Cs);
    B(this, Ql);
    B(this, Jl);
    B(this, Zl, []);
    E(this, Da, e), E(this, mo, r), E(this, ho, []), E(this, Cn, []), E(this, kn, []), this.setQueries(n);
  }
  onSubscribe() {
    this.listeners.size === 1 && m(this, Cn).forEach((e) => {
      e.subscribe((n) => {
        z(this, mt, km).call(this, e, n);
      });
    });
  }
  onUnsubscribe() {
    this.listeners.size || this.destroy();
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), m(this, Cn).forEach((e) => {
      e.destroy();
    });
  }
  setQueries(e, n) {
    if (E(this, ho, e), E(this, mo, n), process.env.NODE_ENV !== "production") {
      const r = e.map(
        (s) => m(this, Da).defaultQueryOptions(s).queryHash
      );
      new Set(r).size !== r.length && console.warn(
        "[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior."
      );
    }
    mi.batch(() => {
      const r = m(this, Cn), s = z(this, mt, vm).call(this, m(this, ho));
      E(this, Zl, s), s.forEach(
        (c) => c.observer.setOptions(c.defaultedQueryOptions)
      );
      const a = s.map((c) => c.observer), i = a.map(
        (c) => c.getCurrentResult()
      ), o = a.some(
        (c, u) => c !== r[u]
      );
      r.length === a.length && !o || (E(this, Cn, a), E(this, kn, i), this.hasListeners() && (Gg(r, a).forEach((c) => {
        c.destroy();
      }), Gg(a, r).forEach((c) => {
        c.subscribe((u) => {
          z(this, mt, km).call(this, c, u);
        });
      }), z(this, mt, Cm).call(this)));
    });
  }
  getCurrentResult() {
    return m(this, kn);
  }
  getQueries() {
    return m(this, Cn).map((e) => e.getCurrentQuery());
  }
  getObservers() {
    return m(this, Cn);
  }
  getOptimisticResult(e, n) {
    const r = z(this, mt, vm).call(this, e), s = r.map(
      (a) => a.observer.getOptimisticResult(a.defaultedQueryOptions)
    );
    return [
      s,
      (a) => z(this, mt, Am).call(this, a ?? s, n),
      () => z(this, mt, xm).call(this, s, r)
    ];
  }
}, Da = new WeakMap(), kn = new WeakMap(), ho = new WeakMap(), mo = new WeakMap(), Cn = new WeakMap(), Cs = new WeakMap(), Ql = new WeakMap(), Jl = new WeakMap(), Zl = new WeakMap(), mt = new WeakSet(), xm = function(e, n) {
  return n.map((r, s) => {
    const a = e[s];
    return r.defaultedQueryOptions.notifyOnChangeProps ? a : r.observer.trackResult(a, (i) => {
      n.forEach((o) => {
        o.observer.trackProp(i);
      });
    });
  });
}, Am = function(e, n) {
  return n ? ((!m(this, Cs) || m(this, kn) !== m(this, Jl) || n !== m(this, Ql)) && (E(this, Ql, n), E(this, Jl, m(this, kn)), E(this, Cs, Vd(
    m(this, Cs),
    n(e)
  ))), m(this, Cs)) : e;
}, vm = function(e) {
  const n = new Map(
    m(this, Cn).map((s) => [s.options.queryHash, s])
  ), r = [];
  return e.forEach((s) => {
    const a = m(this, Da).defaultQueryOptions(s), i = n.get(a.queryHash);
    i ? r.push({
      defaultedQueryOptions: a,
      observer: i
    }) : r.push({
      defaultedQueryOptions: a,
      observer: new Pb(m(this, Da), a)
    });
  }), r;
}, km = function(e, n) {
  const r = m(this, Cn).indexOf(e);
  r !== -1 && (E(this, kn, wC(m(this, kn), r, n)), z(this, mt, Cm).call(this));
}, Cm = function() {
  var e;
  if (this.hasListeners()) {
    const n = m(this, Cs), r = z(this, mt, xm).call(this, m(this, kn), m(this, Zl)), s = z(this, mt, Am).call(this, r, (e = m(this, mo)) == null ? void 0 : e.combine);
    n !== s && mi.batch(() => {
      this.listeners.forEach((a) => {
        a(m(this, kn));
      });
    });
  }
}, ME), JE = ut.createContext(
  void 0
), ZE = (t) => {
  const e = ut.useContext(JE);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, aZ = ({
  client: t,
  children: e
}) => (ut.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ $E(JE.Provider, { value: t, children: e })), XE = ut.createContext(!1), YE = () => ut.useContext(XE);
XE.Provider;
function xC() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var AC = ut.createContext(xC()), ex = () => ut.useContext(AC), tx = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, nx = (t) => {
  ut.useEffect(() => {
    t.clearReset();
  }, [t]);
}, rx = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: n,
  query: r,
  suspense: s
}) => t.isError && !e.isReset() && !t.isFetching && r && (s && t.data === void 0 || lC(n, [t.error, r])), sx = (t) => {
  if (t.suspense) {
    const e = (r) => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime;
    t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3));
  }
}, ax = (t, e) => t.isLoading && t.isFetching && !e, Tm = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, jd = (t, e, n) => e.fetchOptimistic(t).catch(() => {
  n.clearReset();
});
function vC({
  queries: t,
  ...e
}, n) {
  const r = ZE(), s = YE(), a = ex(), i = ut.useMemo(
    () => t.map((b) => {
      const g = r.defaultQueryOptions(
        b
      );
      return g._optimisticResults = s ? "isRestoring" : "optimistic", g;
    }),
    [t, r, s]
  );
  i.forEach((b) => {
    sx(b), tx(b, a);
  }), nx(a);
  const [o] = ut.useState(
    () => new EC(
      r,
      i,
      e
    )
  ), [c, u, l] = o.getOptimisticResult(
    i,
    e.combine
  ), d = !s && e.subscribed !== !1;
  ut.useSyncExternalStore(
    ut.useCallback(
      (b) => d ? o.subscribe(mi.batchCalls(b)) : nc,
      [o, d]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), ut.useEffect(() => {
    o.setQueries(
      i,
      e
    );
  }, [i, e, o]);
  const h = c.some(
    (b, g) => Tm(i[g], b)
  ) ? c.flatMap((b, g) => {
    const w = i[g];
    if (w) {
      const v = new Pb(r, w);
      if (Tm(w, b))
        return jd(w, v, a);
      ax(b, s) && jd(w, v, a);
    }
    return [];
  }) : [];
  if (h.length > 0)
    throw Promise.all(h);
  const y = c.find(
    (b, g) => {
      const w = i[g];
      return w && rx({
        result: b,
        errorResetBoundary: a,
        throwOnError: w.throwOnError,
        query: r.getQueryCache().get(w.queryHash),
        suspense: w.suspense
      });
    }
  );
  if (y != null && y.error)
    throw y.error;
  return u(l());
}
function kC(t, e, n) {
  var d, f, h, y, b;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = YE(), s = ex(), a = ZE(), i = a.defaultQueryOptions(t);
  (f = (d = a.getDefaultOptions().queries) == null ? void 0 : d._experimental_beforeQuery) == null || f.call(
    d,
    i
  ), process.env.NODE_ENV !== "production" && (i.queryFn || console.error(
    `[${i.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), i._optimisticResults = r ? "isRestoring" : "optimistic", sx(i), tx(i, s), nx(s);
  const o = !a.getQueryCache().get(i.queryHash), [c] = ut.useState(
    () => new e(
      a,
      i
    )
  ), u = c.getOptimisticResult(i), l = !r && t.subscribed !== !1;
  if (ut.useSyncExternalStore(
    ut.useCallback(
      (g) => {
        const w = l ? c.subscribe(mi.batchCalls(g)) : nc;
        return c.updateResult(), w;
      },
      [c, l]
    ),
    () => c.getCurrentResult(),
    () => c.getCurrentResult()
  ), ut.useEffect(() => {
    c.setOptions(i);
  }, [i, c]), Tm(i, u))
    throw jd(i, c, s);
  if (rx({
    result: u,
    errorResetBoundary: s,
    throwOnError: i.throwOnError,
    query: a.getQueryCache().get(i.queryHash),
    suspense: i.suspense
  }))
    throw u.error;
  if ((y = (h = a.getDefaultOptions().queries) == null ? void 0 : h._experimental_afterQuery) == null || y.call(
    h,
    i,
    u
  ), i.experimental_prefetchInRender && !hi && ax(u, r)) {
    const g = o ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      jd(i, c, s)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (b = a.getQueryCache().get(i.queryHash)) == null ? void 0 : b.promise
    );
    g == null || g.catch(nc).finally(() => {
      c.updateResult();
    });
  }
  return i.notifyOnChangeProps ? u : c.trackResult(u);
}
function Sm(t, e) {
  return kC(t, Pb);
}
const CC = "1.0.8";
let pn = class Om extends Error {
  constructor(e, n = {}) {
    var i;
    const r = n.cause instanceof Om ? n.cause.details : (i = n.cause) != null && i.message ? n.cause.message : n.details, s = n.cause instanceof Om && n.cause.docsPath || n.docsPath, a = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...s ? [`Docs: https://abitype.dev${s}`] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: abitype@${CC}`
    ].join(`
`);
    super(a), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.shortMessage = e;
  }
};
function as(t, e) {
  const n = t.exec(e);
  return n == null ? void 0 : n.groups;
}
const ix = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, ox = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, cx = /^\(.+?\).*?$/, zg = /^tuple(?<array>(\[(\d*)\])*)$/;
function Bm(t) {
  let e = t.type;
  if (zg.test(t.type) && "components" in t) {
    e = "(";
    const n = t.components.length;
    for (let s = 0; s < n; s++) {
      const a = t.components[s];
      e += Bm(a), s < n - 1 && (e += ", ");
    }
    const r = as(zg, t.type);
    return e += `)${(r == null ? void 0 : r.array) ?? ""}`, Bm({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function Nc(t) {
  let e = "";
  const n = t.length;
  for (let r = 0; r < n; r++) {
    const s = t[r];
    e += Bm(s), r !== n - 1 && (e += ", ");
  }
  return e;
}
function Kd(t) {
  var e;
  return t.type === "function" ? `function ${t.name}(${Nc(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${(e = t.outputs) != null && e.length ? ` returns (${Nc(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${Nc(t.inputs)})` : t.type === "error" ? `error ${t.name}(${Nc(t.inputs)})` : t.type === "constructor" ? `constructor(${Nc(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? `fallback() external${t.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
const lx = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function TC(t) {
  return lx.test(t);
}
function SC(t) {
  return as(lx, t);
}
const ux = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function OC(t) {
  return ux.test(t);
}
function BC(t) {
  return as(ux, t);
}
const dx = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function PC(t) {
  return dx.test(t);
}
function IC(t) {
  return as(dx, t);
}
const fx = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function px(t) {
  return fx.test(t);
}
function UC(t) {
  return as(fx, t);
}
const hx = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function NC(t) {
  return hx.test(t);
}
function RC(t) {
  return as(hx, t);
}
const mx = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function FC(t) {
  return mx.test(t);
}
function MC(t) {
  return as(mx, t);
}
const DC = /^receive\(\) external payable$/;
function LC(t) {
  return DC.test(t);
}
const HC = /* @__PURE__ */ new Set(["indexed"]), Pm = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class $C extends pn {
  constructor({ signature: e }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,
      docsPath: "/api/human#parseabiitem-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiItemError"
    });
  }
}
class _C extends pn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class GC extends pn {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class zC extends pn {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class VC extends pn {
  constructor({ param: e, name: n }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class jC extends pn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class KC extends pn {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class qC extends pn {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class gc extends pn {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class WC extends pn {
  constructor({ signature: e }) {
    super("Unknown signature.", {
      details: e
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class QC extends pn {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class JC extends pn {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class ZC extends pn {
  constructor({ current: e, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function XC(t, e, n) {
  let r = "";
  if (n)
    for (const s of Object.entries(n)) {
      if (!s)
        continue;
      let a = "";
      for (const i of s[1])
        a += `[${i.type}${i.name ? `:${i.name}` : ""}]`;
      r += `(${s[0]}{${a}})`;
    }
  return e ? `${e}:${t}${r}` : t;
}
const lh = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function bx(t, e = {}) {
  if (PC(t))
    return YC(t, e);
  if (OC(t))
    return e5(t, e);
  if (TC(t))
    return t5(t, e);
  if (NC(t))
    return n5(t, e);
  if (FC(t))
    return r5(t);
  if (LC(t))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new WC({ signature: t });
}
function YC(t, e = {}) {
  const n = IC(t);
  if (!n)
    throw new gc({ signature: t, type: "function" });
  const r = Wn(n.parameters), s = [], a = r.length;
  for (let o = 0; o < a; o++)
    s.push(bi(r[o], {
      modifiers: Pm,
      structs: e,
      type: "function"
    }));
  const i = [];
  if (n.returns) {
    const o = Wn(n.returns), c = o.length;
    for (let u = 0; u < c; u++)
      i.push(bi(o[u], {
        modifiers: Pm,
        structs: e,
        type: "function"
      }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s,
    outputs: i
  };
}
function e5(t, e = {}) {
  const n = BC(t);
  if (!n)
    throw new gc({ signature: t, type: "event" });
  const r = Wn(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(bi(r[i], {
      modifiers: HC,
      structs: e,
      type: "event"
    }));
  return { name: n.name, type: "event", inputs: s };
}
function t5(t, e = {}) {
  const n = SC(t);
  if (!n)
    throw new gc({ signature: t, type: "error" });
  const r = Wn(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(bi(r[i], { structs: e, type: "error" }));
  return { name: n.name, type: "error", inputs: s };
}
function n5(t, e = {}) {
  const n = RC(t);
  if (!n)
    throw new gc({ signature: t, type: "constructor" });
  const r = Wn(n.parameters), s = [], a = r.length;
  for (let i = 0; i < a; i++)
    s.push(bi(r[i], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: s
  };
}
function r5(t) {
  const e = MC(t);
  if (!e)
    throw new gc({ signature: t, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable"
  };
}
const s5 = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, a5 = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, i5 = /^u?int$/;
function bi(t, e) {
  var d, f;
  const n = XC(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs);
  if (lh.has(n))
    return lh.get(n);
  const r = cx.test(t), s = as(r ? a5 : s5, t);
  if (!s)
    throw new zC({ param: t });
  if (s.name && c5(s.name))
    throw new VC({ param: t, name: s.name });
  const a = s.name ? { name: s.name } : {}, i = s.modifier === "indexed" ? { indexed: !0 } : {}, o = (e == null ? void 0 : e.structs) ?? {};
  let c, u = {};
  if (r) {
    c = "tuple";
    const h = Wn(s.type), y = [], b = h.length;
    for (let g = 0; g < b; g++)
      y.push(bi(h[g], { structs: o }));
    u = { components: y };
  } else if (s.type in o)
    c = "tuple", u = { components: o[s.type] };
  else if (i5.test(s.type))
    c = `${s.type}256`;
  else if (c = s.type, (e == null ? void 0 : e.type) !== "struct" && !yx(c))
    throw new GC({ type: c });
  if (s.modifier) {
    if (!((f = (d = e == null ? void 0 : e.modifiers) == null ? void 0 : d.has) != null && f.call(d, s.modifier)))
      throw new jC({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
    if (Pm.has(s.modifier) && !l5(c, !!s.array))
      throw new KC({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: s.modifier
      });
  }
  const l = {
    type: `${c}${s.array ?? ""}`,
    ...a,
    ...i,
    ...u
  };
  return lh.set(n, l), l;
}
function Wn(t, e = [], n = "", r = 0) {
  const s = t.trim().length;
  for (let a = 0; a < s; a++) {
    const i = t[a], o = t.slice(a + 1);
    switch (i) {
      case ",":
        return r === 0 ? Wn(o, [...e, n.trim()]) : Wn(o, e, `${n}${i}`, r);
      case "(":
        return Wn(o, e, `${n}${i}`, r + 1);
      case ")":
        return Wn(o, e, `${n}${i}`, r - 1);
      default:
        return Wn(o, e, `${n}${i}`, r);
    }
  }
  if (n === "")
    return e;
  if (r !== 0)
    throw new ZC({ current: n, depth: r });
  return e.push(n.trim()), e;
}
function yx(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || ix.test(t) || ox.test(t);
}
const o5 = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function c5(t) {
  return t === "address" || t === "bool" || t === "function" || t === "string" || t === "tuple" || ix.test(t) || ox.test(t) || o5.test(t);
}
function l5(t, e) {
  return e || t === "bytes" || t === "string" || t === "tuple";
}
function u5(t) {
  const e = {}, n = t.length;
  for (let i = 0; i < n; i++) {
    const o = t[i];
    if (!px(o))
      continue;
    const c = UC(o);
    if (!c)
      throw new gc({ signature: o, type: "struct" });
    const u = c.properties.split(";"), l = [], d = u.length;
    for (let f = 0; f < d; f++) {
      const y = u[f].trim();
      if (!y)
        continue;
      const b = bi(y, {
        type: "struct"
      });
      l.push(b);
    }
    if (!l.length)
      throw new QC({ signature: o });
    e[c.name] = l;
  }
  const r = {}, s = Object.entries(e), a = s.length;
  for (let i = 0; i < a; i++) {
    const [o, c] = s[i];
    r[o] = gx(c, e);
  }
  return r;
}
const d5 = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function gx(t, e, n = /* @__PURE__ */ new Set()) {
  const r = [], s = t.length;
  for (let a = 0; a < s; a++) {
    const i = t[a];
    if (cx.test(i.type))
      r.push(i);
    else {
      const c = as(d5, i.type);
      if (!(c != null && c.type))
        throw new qC({ abiParameter: i });
      const { array: u, type: l } = c;
      if (l in e) {
        if (n.has(l))
          throw new JC({ type: l });
        r.push({
          ...i,
          type: `tuple${u ?? ""}`,
          components: gx(e[l] ?? [], e, /* @__PURE__ */ new Set([...n, l]))
        });
      } else if (yx(l))
        r.push(i);
      else
        throw new _C({ type: l });
    }
  }
  return r;
}
function _f(t) {
  const e = u5(t), n = [], r = t.length;
  for (let s = 0; s < r; s++) {
    const a = t[s];
    px(a) || n.push(bx(a, e));
  }
  return n;
}
function Vg(t) {
  let e;
  if (e = bx(t), !e)
    throw new $C({ signature: t });
  return e;
}
function f5(t) {
  for (const e of t)
    if (typeof e != "string")
      return !1;
  return !0;
}
function p5(t) {
  return f5(t) ? _f(t) : t;
}
const h5 = "0.1.1";
function m5() {
  return h5;
}
let Ke = class Im extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof Im) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof Im && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${m5()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return wx(this, e);
  }
};
function wx(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? wx(t.cause, e) : e ? null : t;
}
const Ii = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Ub(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ol(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Xn(t, ...e) {
  if (!Ub(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function b5(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  Ol(t.outputLen), Ol(t.blockLen);
}
function rc(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ex(t, e) {
  Xn(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
function y5(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function sc(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function uh(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function sr(t, e) {
  return t << 32 - e | t >>> e;
}
const g5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function w5(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function E5(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = w5(t[e]);
  return t;
}
const jg = g5 ? (t) => t : E5, xx = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", x5 = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Bl(t) {
  if (Xn(t), xx)
    return t.toHex();
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += x5[t[n]];
  return e;
}
const Nr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Kg(t) {
  if (t >= Nr._0 && t <= Nr._9)
    return t - Nr._0;
  if (t >= Nr.A && t <= Nr.F)
    return t - (Nr.A - 10);
  if (t >= Nr.a && t <= Nr.f)
    return t - (Nr.a - 10);
}
function Nb(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (xx)
    return Uint8Array.fromHex(t);
  const e = t.length, n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, a = 0; s < n; s++, a += 2) {
    const i = Kg(t.charCodeAt(a)), o = Kg(t.charCodeAt(a + 1));
    if (i === void 0 || o === void 0) {
      const c = t[a] + t[a + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + a);
    }
    r[s] = i * 16 + o;
  }
  return r;
}
function A5(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function Gf(t) {
  return typeof t == "string" && (t = A5(t)), Xn(t), t;
}
function ya(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    Xn(s), e += s.length;
  }
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
let Rb = class {
};
function Ax(t) {
  const e = (r) => t().update(Gf(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function v5(t = 32) {
  if (Ii && typeof Ii.getRandomValues == "function")
    return Ii.getRandomValues(new Uint8Array(t));
  if (Ii && typeof Ii.randomBytes == "function")
    return Uint8Array.from(Ii.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
function k5(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
function C5(t, e, n) {
  return t & e ^ ~t & n;
}
function T5(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
class S5 extends Rb {
  constructor(e, n, r, s) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = uh(this.buffer);
  }
  update(e) {
    rc(this), e = Gf(e), Xn(e);
    const { view: n, buffer: r, blockLen: s } = this, a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = uh(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    rc(this), Ex(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, sc(this.buffer.subarray(i)), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    k5(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = uh(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.destroyed = i, e.finished = a, e.length = s, e.pos = o, s % n && e.buffer.set(r), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const ds = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Nu = /* @__PURE__ */ BigInt(2 ** 32 - 1), qg = /* @__PURE__ */ BigInt(32);
function O5(t, e = !1) {
  return e ? { h: Number(t & Nu), l: Number(t >> qg & Nu) } : { h: Number(t >> qg & Nu) | 0, l: Number(t & Nu) | 0 };
}
function B5(t, e = !1) {
  const n = t.length;
  let r = new Uint32Array(n), s = new Uint32Array(n);
  for (let a = 0; a < n; a++) {
    const { h: i, l: o } = O5(t[a], e);
    [r[a], s[a]] = [i, o];
  }
  return [r, s];
}
const P5 = (t, e, n) => t << n | e >>> 32 - n, I5 = (t, e, n) => e << n | t >>> 32 - n, U5 = (t, e, n) => e << n - 32 | t >>> 64 - n, N5 = (t, e, n) => t << n - 32 | e >>> 64 - n, R5 = BigInt(0), Rc = BigInt(1), F5 = BigInt(2), M5 = BigInt(7), D5 = BigInt(256), L5 = BigInt(113), vx = [], kx = [], Cx = [];
for (let t = 0, e = Rc, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], vx.push(2 * (5 * r + n)), kx.push((t + 1) * (t + 2) / 2 % 64);
  let s = R5;
  for (let a = 0; a < 7; a++)
    e = (e << Rc ^ (e >> M5) * L5) % D5, e & F5 && (s ^= Rc << (Rc << /* @__PURE__ */ BigInt(a)) - Rc);
  Cx.push(s);
}
const Tx = B5(Cx, !0), H5 = Tx[0], $5 = Tx[1], Wg = (t, e, n) => n > 32 ? U5(t, e, n) : P5(t, e, n), Qg = (t, e, n) => n > 32 ? N5(t, e, n) : I5(t, e, n);
function _5(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = Wg(u, l, 1) ^ n[o], f = Qg(u, l, 1) ^ n[o + 1];
      for (let h = 0; h < 50; h += 10)
        t[i + h] ^= d, t[i + h + 1] ^= f;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = kx[i], c = Wg(s, a, o), u = Qg(s, a, o), l = vx[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= H5[r], t[1] ^= $5[r];
  }
  sc(n);
}
let G5 = class Sx extends Rb {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, Ol(r), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = y5(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    jg(this.state32), _5(this.state32, this.rounds), jg(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    rc(this), e = Gf(e), Xn(e);
    const { blockLen: n, state: r } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    rc(this, !1), Xn(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Ol(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Ex(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, sc(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new Sx(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
};
const z5 = (t, e, n) => Ax(() => new G5(e, t, n)), Ox = z5(1, 136, 256 / 8), V5 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), fs = /* @__PURE__ */ new Uint32Array(64);
let j5 = class extends S5 {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = ds[0] | 0, this.B = ds[1] | 0, this.C = ds[2] | 0, this.D = ds[3] | 0, this.E = ds[4] | 0, this.F = ds[5] | 0, this.G = ds[6] | 0, this.H = ds[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      fs[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = fs[d - 15], h = fs[d - 2], y = sr(f, 7) ^ sr(f, 18) ^ f >>> 3, b = sr(h, 17) ^ sr(h, 19) ^ h >>> 10;
      fs[d] = b + fs[d - 7] + y + fs[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = sr(o, 6) ^ sr(o, 11) ^ sr(o, 25), h = l + f + C5(o, c, u) + V5[d] + fs[d] | 0, b = (sr(r, 2) ^ sr(r, 13) ^ sr(r, 22)) + T5(r, s, a) | 0;
      l = u, u = c, c = o, o = i + h | 0, i = a, a = s, s = r, r = h + b | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    sc(fs);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), sc(this.buffer);
  }
};
const Bx = /* @__PURE__ */ Ax(() => new j5()), K5 = Bx;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fb = /* @__PURE__ */ BigInt(0), Um = /* @__PURE__ */ BigInt(1);
function qd(t, e) {
  if (typeof e != "boolean")
    throw new Error(t + " boolean expected, got " + e);
}
function Ru(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Px(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Fb : BigInt("0x" + t);
}
function zf(t) {
  return Px(Bl(t));
}
function Ix(t) {
  return Xn(t), Px(Bl(Uint8Array.from(t).reverse()));
}
function Mb(t, e) {
  return Nb(t.toString(16).padStart(e * 2, "0"));
}
function Ux(t, e) {
  return Mb(t, e).reverse();
}
function An(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = Nb(e);
    } catch (a) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + a);
    }
  else if (Ub(e))
    r = Uint8Array.from(e);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(t + " of length " + n + " expected, got " + s);
  return r;
}
const dh = (t) => typeof t == "bigint" && Fb <= t;
function q5(t, e, n) {
  return dh(t) && dh(e) && dh(n) && e <= t && t < n;
}
function W5(t, e, n, r) {
  if (!q5(e, n, r))
    throw new Error("expected valid " + t + ": " + n + " <= n < " + r + ", got " + e);
}
function Q5(t) {
  let e;
  for (e = 0; t > Fb; t >>= Um, e += 1)
    ;
  return e;
}
const Vf = (t) => (Um << BigInt(t)) - Um;
function J5(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  const r = (h) => new Uint8Array(h), s = (h) => Uint8Array.of(h);
  let a = r(t), i = r(t), o = 0;
  const c = () => {
    a.fill(1), i.fill(0), o = 0;
  }, u = (...h) => n(i, a, ...h), l = (h = r(0)) => {
    i = u(s(0), h), a = u(), h.length !== 0 && (i = u(s(1), h), a = u());
  }, d = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let h = 0;
    const y = [];
    for (; h < e; ) {
      a = u();
      const b = a.slice();
      y.push(b), h += a.length;
    }
    return ya(...y);
  };
  return (h, y) => {
    c(), l(h);
    let b;
    for (; !(b = y(d())); )
      l();
    return c(), b;
  };
}
function Db(t, e, n = {}) {
  if (!t || typeof t != "object")
    throw new Error("expected valid options object");
  function r(s, a, i) {
    const o = t[s];
    if (i && o === void 0)
      return;
    const c = typeof o;
    if (c !== a || o === null)
      throw new Error(`param "${s}" is invalid: expected ${a}, got ${c}`);
  }
  Object.entries(e).forEach(([s, a]) => r(s, a, !1)), Object.entries(n).forEach(([s, a]) => r(s, a, !0));
}
function Jg(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const s = e.get(n);
    if (s !== void 0)
      return s;
    const a = t(n, ...r);
    return e.set(n, a), a;
  };
}
const Z5 = "#__bigint";
function Nx(t, e, n) {
  return JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() + Z5 : s, n);
}
function X5(t, e) {
  if (e1(t) > e)
    throw new fT({
      givenSize: e1(t),
      maxSize: e
    });
}
const Rr = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Zg(t) {
  if (t >= Rr.zero && t <= Rr.nine)
    return t - Rr.zero;
  if (t >= Rr.A && t <= Rr.F)
    return t - (Rr.A - 10);
  if (t >= Rr.a && t <= Rr.f)
    return t - (Rr.a - 10);
}
function Rx(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  if (t.length > r)
    throw new pT({
      size: t.length,
      targetSize: r,
      type: "Bytes"
    });
  const s = new Uint8Array(r);
  for (let a = 0; a < r; a++) {
    const i = n === "right";
    s[i ? a : r - a - 1] = t[i ? a : t.length - a - 1];
  }
  return s;
}
function Lb(t, e) {
  if (Nn(t) > e)
    throw new aT({
      givenSize: Nn(t),
      maxSize: e
    });
}
function Y5(t, e) {
  if (typeof e == "number" && e > 0 && e > Nn(t) - 1)
    throw new Lx({
      offset: e,
      position: "start",
      size: Nn(t)
    });
}
function eT(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && Nn(t) !== n - e)
    throw new Lx({
      offset: n,
      position: "end",
      size: Nn(t)
    });
}
function Fx(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new iT({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
const tT = /* @__PURE__ */ new TextEncoder(), nT = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function rT(t, e = {}) {
  const { strict: n = !1 } = e;
  if (!t)
    throw new Xg(t);
  if (typeof t != "string")
    throw new Xg(t);
  if (n && !/^0x[0-9a-fA-F]*$/.test(t))
    throw new Yg(t);
  if (!t.startsWith("0x"))
    throw new Yg(t);
}
function rs(...t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
function Mx(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Lb(n, e.size), yi(n, e.size)) : n;
}
function Hb(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += nT[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (Lb(r, e.size), gi(r, e.size)) : r;
}
function wc(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new Dx({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? yi(c, r) : c;
}
function $b(t, e = {}) {
  return Hb(tT.encode(t), e);
}
function yi(t, e) {
  return Fx(t, { dir: "left", size: e });
}
function gi(t, e) {
  return Fx(t, { dir: "right", size: e });
}
function jf(t, e, n, r = {}) {
  const { strict: s } = r;
  Y5(t, e);
  const a = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return s && eT(a, e, n), a;
}
function Nn(t) {
  return Math.ceil((t.length - 2) / 2);
}
function sT(t, e = {}) {
  const { strict: n = !1 } = e;
  try {
    return rT(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
let Dx = class extends Ke {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
class Xg extends Ke {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? Nx(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexTypeError"
    });
  }
}
class Yg extends Ke {
  constructor(e) {
    super(`Value \`${e}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexValueError"
    });
  }
}
let aT = class extends Ke {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeOverflowError"
    });
  }
}, Lx = class extends Ke {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${r}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}, iT = class extends Ke {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};
const oT = /* @__PURE__ */ new TextEncoder();
function cT(t) {
  if (!(t instanceof Uint8Array)) {
    if (!t)
      throw new Fu(t);
    if (typeof t != "object")
      throw new Fu(t);
    if (!("BYTES_PER_ELEMENT" in t))
      throw new Fu(t);
    if (t.BYTES_PER_ELEMENT !== 1 || t.constructor.name !== "Uint8Array")
      throw new Fu(t);
  }
}
function _b(...t) {
  let e = 0;
  for (const r of t)
    e += r.length;
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const a = t[r];
    n.set(a, s), s += a.length;
  }
  return n;
}
function wi(t) {
  return t instanceof Uint8Array ? t : typeof t == "string" ? ga(t) : lT(t);
}
function lT(t) {
  return t instanceof Uint8Array ? t : new Uint8Array(t);
}
function ga(t, e = {}) {
  const { size: n } = e;
  let r = t;
  n && (Lb(t, n), r = gi(t, n));
  let s = r.slice(2);
  s.length % 2 && (s = `0${s}`);
  const a = s.length / 2, i = new Uint8Array(a);
  for (let o = 0, c = 0; o < a; o++) {
    const u = Zg(s.charCodeAt(c++)), l = Zg(s.charCodeAt(c++));
    if (u === void 0 || l === void 0)
      throw new Ke(`Invalid byte sequence ("${s[c - 2]}${s[c - 1]}" in "${s}").`);
    i[o] = u * 16 + l;
  }
  return i;
}
function uT(t, e = {}) {
  const { size: n } = e, r = oT.encode(t);
  return typeof n == "number" ? (X5(r, n), dT(r, n)) : r;
}
function Hx(t, e) {
  return Rx(t, { dir: "left", size: e });
}
function dT(t, e) {
  return Rx(t, { dir: "right", size: e });
}
function e1(t) {
  return t.length;
}
function js(t, e = {}) {
  return Hb(t, e);
}
function t1(t) {
  try {
    return cT(t), !0;
  } catch {
    return !1;
  }
}
class Fu extends Ke {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? Nx(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
}
let fT = class extends Ke {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeOverflowError"
    });
  }
}, pT = class extends Ke {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};
function ea(t, e = {}) {
  const { as: n = typeof t == "string" ? "Hex" : "Bytes" } = e, r = Ox(wi(t));
  return n === "Bytes" ? r : Hb(r);
}
let hT = class extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
};
const mT = {
  checksum: /* @__PURE__ */ new hT(8192)
}, fh = mT.checksum, bT = /^0x[a-fA-F0-9]{40}$/;
function fu(t, e = {}) {
  const { strict: n = !0 } = e;
  if (!bT.test(t))
    throw new n1({
      address: t,
      cause: new yT()
    });
  if (n) {
    if (t.toLowerCase() === t)
      return;
    if ($x(t) !== t)
      throw new n1({
        address: t,
        cause: new gT()
      });
  }
}
function $x(t) {
  if (fh.has(t))
    return fh.get(t);
  fu(t, { strict: !1 });
  const e = t.substring(2).toLowerCase(), n = ea(uT(e), { as: "Bytes" }), r = e.split("");
  for (let a = 0; a < 40; a += 2)
    n[a >> 1] >> 4 >= 8 && r[a] && (r[a] = r[a].toUpperCase()), (n[a >> 1] & 15) >= 8 && r[a + 1] && (r[a + 1] = r[a + 1].toUpperCase());
  const s = `0x${r.join("")}`;
  return fh.set(t, s), s;
}
function si(t, e = {}) {
  const { checksum: n = !1 } = e;
  return fu(t), n ? $x(t) : t;
}
function Nm(t, e = {}) {
  const { strict: n = !0 } = e ?? {};
  try {
    return fu(t, { strict: n }), !0;
  } catch {
    return !1;
  }
}
let n1 = class extends Ke {
  constructor({ address: e, cause: n }) {
    super(`Address "${e}" is invalid.`, {
      cause: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidAddressError"
    });
  }
};
class yT extends Ke {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidInputError"
    });
  }
}
class gT extends Ke {
  constructor() {
    super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidChecksumError"
    });
  }
}
function Rm(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", "error", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new Ke("Unable to normalize signature.");
  return s;
}
function Fm(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return Nm(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => Fm(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => Fm(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function _x(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return _x(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? Nm(n[r], {
      strict: !1
    }) : i.includes("address") && i.includes("bytes") ? Nm(n[r], {
      strict: !1
    }) : !1)
      return i;
  }
}
function wT(t, e = {}) {
  const { prepare: n = !0 } = e, r = (Array.isArray(t), Vg(t));
  return {
    ...r,
    ...n ? { hash: $i(r) } : {}
  };
}
function ET(t, e, n) {
  const { args: r = [], prepare: s = !0 } = n ?? {}, a = sT(e, { strict: !1 }), i = t.filter((u) => a ? u.type === "function" || u.type === "error" ? Gx(u) === jf(e, 0, 4) : u.type === "event" ? $i(u) === e : !1 : "name" in u && u.name === e);
  if (i.length === 0)
    throw new Mm({ name: e });
  if (i.length === 1)
    return {
      ...i[0],
      ...s ? { hash: $i(i[0]) } : {}
    };
  let o;
  for (const u of i) {
    if (!("inputs" in u))
      continue;
    if (!r || r.length === 0) {
      if (!u.inputs || u.inputs.length === 0)
        return {
          ...u,
          ...s ? { hash: $i(u) } : {}
        };
      continue;
    }
    if (!u.inputs || u.inputs.length === 0 || u.inputs.length !== r.length)
      continue;
    if (r.every((d, f) => {
      const h = "inputs" in u && u.inputs[f];
      return h ? Fm(d, h) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const d = _x(u.inputs, o.inputs, r);
        if (d)
          throw new AT({
            abiItem: u,
            type: d[0]
          }, {
            abiItem: o,
            type: d[1]
          });
      }
      o = u;
    }
  }
  const c = (() => {
    if (o)
      return o;
    const [u, ...l] = i;
    return { ...u, overloads: l };
  })();
  if (!c)
    throw new Mm({ name: e });
  return {
    ...c,
    ...s ? { hash: $i(c) } : {}
  };
}
function Gx(t) {
  return jf($i(t), 0, 4);
}
function xT(t) {
  const e = typeof t == "string" ? t : Kd(t);
  return Rm(e);
}
function $i(t) {
  return typeof t != "string" && "hash" in t && t.hash ? t.hash : ea($b(xT(t)));
}
class AT extends Ke {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${e.type}\` in \`${Rm(Kd(e.abiItem))}\`, and`,
        `\`${n.type}\` in \`${Rm(Kd(n.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.AmbiguityError"
    });
  }
}
let Mm = class extends Ke {
  constructor({ name: e, data: n, type: r = "item" }) {
    const s = e ? ` with name "${e}"` : n ? ` with data "${n}"` : "";
    super(`ABI ${r}${s} not found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.NotFoundError"
    });
  }
};
const vT = /^(.*)\[([0-9]*)\]$/, kT = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, zx = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function CT({ checksumAddress: t, parameters: e, values: n }) {
  const r = [];
  for (let s = 0; s < e.length; s++)
    r.push(Gb({
      checksumAddress: t,
      parameter: e[s],
      value: n[s]
    }));
  return r;
}
function Gb({ checksumAddress: t = !1, parameter: e, value: n }) {
  const r = e, s = NT(r.type);
  if (s) {
    const [a, i] = s;
    return ST(n, {
      checksumAddress: t,
      length: a,
      parameter: {
        ...r,
        type: i
      }
    });
  }
  if (r.type === "tuple")
    return UT(n, {
      checksumAddress: t,
      parameter: r
    });
  if (r.type === "address")
    return TT(n, {
      checksum: t
    });
  if (r.type === "bool")
    return BT(n);
  if (r.type.startsWith("uint") || r.type.startsWith("int")) {
    const a = r.type.startsWith("int"), [, , i = "256"] = zx.exec(r.type) ?? [];
    return PT(n, {
      signed: a,
      size: Number(i)
    });
  }
  if (r.type.startsWith("bytes"))
    return OT(n, { type: r.type });
  if (r.type === "string")
    return IT(n);
  throw new Kx(r.type);
}
function zb(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += Nn(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(wc(e + s, { size: 32 })), r.push(o), s += Nn(o)) : n.push(o);
  }
  return rs(...n, ...r);
}
function TT(t, e) {
  const { checksum: n = !1 } = e;
  return fu(t, { strict: n }), {
    dynamic: !1,
    encoded: yi(t.toLowerCase())
  };
}
function ST(t, e) {
  const { checksumAddress: n, length: r, parameter: s } = e, a = r === null;
  if (!Array.isArray(t))
    throw new FT(t);
  if (!a && t.length !== r)
    throw new RT({
      expectedLength: r,
      givenLength: t.length,
      type: `${s.type}[${r}]`
    });
  let i = !1;
  const o = [];
  for (let c = 0; c < t.length; c++) {
    const u = Gb({
      checksumAddress: n,
      parameter: s,
      value: t[c]
    });
    u.dynamic && (i = !0), o.push(u);
  }
  if (a || i) {
    const c = zb(o);
    if (a) {
      const u = wc(o.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: o.length > 0 ? rs(u, c) : u
      };
    }
    if (i)
      return { dynamic: !0, encoded: c };
  }
  return {
    dynamic: !1,
    encoded: rs(...o.map(({ encoded: c }) => c))
  };
}
function OT(t, { type: e }) {
  const [, n] = e.split("bytes"), r = Nn(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = gi(s, Math.ceil((t.length - 2) / 2 / 32) * 32)), {
      dynamic: !0,
      encoded: rs(yi(wc(r, { size: 32 })), s)
    };
  }
  if (r !== Number.parseInt(n))
    throw new Vx({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: gi(t) };
}
function BT(t) {
  if (typeof t != "boolean")
    throw new Ke(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: yi(Mx(t)) };
}
function PT(t, { signed: e, size: n }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new Dx({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: wc(t, {
      size: 32,
      signed: e
    })
  };
}
function IT(t) {
  const e = $b(t), n = Math.ceil(Nn(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(gi(jf(e, s * 32, (s + 1) * 32)));
  return {
    dynamic: !0,
    encoded: rs(gi(wc(Nn(e), { size: 32 })), ...r)
  };
}
function UT(t, e) {
  const { checksumAddress: n, parameter: r } = e;
  let s = !1;
  const a = [];
  for (let i = 0; i < r.components.length; i++) {
    const o = r.components[i], c = Array.isArray(t) ? i : o.name, u = Gb({
      checksumAddress: n,
      parameter: o,
      value: t[c]
    });
    a.push(u), u.dynamic && (s = !0);
  }
  return {
    dynamic: s,
    encoded: s ? zb(a) : rs(...a.map(({ encoded: i }) => i))
  };
}
function NT(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function Vb(t, e, n) {
  const { checksumAddress: r = !1 } = {};
  if (t.length !== e.length)
    throw new jx({
      expectedLength: t.length,
      givenLength: e.length
    });
  const s = CT({
    checksumAddress: r,
    parameters: t,
    values: e
  }), a = zb(s);
  return a.length === 0 ? "0x" : a;
}
function Dm(t, e) {
  if (t.length !== e.length)
    throw new jx({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r], a = e[r];
    n.push(Dm.encode(s, a));
  }
  return rs(...n);
}
(function(t) {
  function e(n, r, s = !1) {
    if (n === "address") {
      const c = r;
      return fu(c), yi(c.toLowerCase(), s ? 32 : 0);
    }
    if (n === "string")
      return $b(r);
    if (n === "bytes")
      return r;
    if (n === "bool")
      return yi(Mx(r), s ? 32 : 1);
    const a = n.match(zx);
    if (a) {
      const [c, u, l = "256"] = a, d = Number.parseInt(l) / 8;
      return wc(r, {
        size: s ? 32 : d,
        signed: u === "int"
      });
    }
    const i = n.match(kT);
    if (i) {
      const [c, u] = i;
      if (Number.parseInt(u) !== (r.length - 2) / 2)
        throw new Vx({
          expectedSize: Number.parseInt(u),
          value: r
        });
      return gi(r, s ? 32 : 0);
    }
    const o = n.match(vT);
    if (o && Array.isArray(r)) {
      const [c, u] = o, l = [];
      for (let d = 0; d < r.length; d++)
        l.push(e(u, r[d], !0));
      return l.length === 0 ? "0x" : rs(...l);
    }
    throw new Kx(n);
  }
  t.encode = e;
})(Dm || (Dm = {}));
class RT extends Ke {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(`Array length mismatch for type \`${r}\`. Expected: \`${e}\`. Given: \`${n}\`.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}
let Vx = class extends Ke {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${Nn(n)}) does not match expected size (bytes${e}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
class jx extends Ke {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}
let FT = class extends Ke {
  constructor(e) {
    super(`Value \`${e}\` is not a valid array.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidArrayError"
    });
  }
};
class Kx extends Ke {
  constructor(e) {
    super(`Type \`${e}\` is not a valid ABI Type.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}
function qx(t, ...e) {
  const { overloads: n } = t, r = n ? DT([t, ...n], t.name, {
    args: e[0]
  }) : t, s = LT(r), a = e.length > 0 ? Vb(r.inputs, e[0]) : void 0;
  return a ? rs(s, a) : s;
}
function MT(t, e = {}) {
  return wT(t, e);
}
function DT(t, e, n) {
  const r = ET(t, e, n);
  if (r.type !== "function")
    throw new Mm({ name: e, type: "function" });
  return r;
}
function LT(t) {
  return Gx(t);
}
let Wx = class extends Rb {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, b5(e);
    const r = Gf(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), sc(a);
  }
  update(e) {
    return rc(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    rc(this), Xn(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Qx = (t, e, n) => new Wx(t, e).update(n).digest();
Qx.create = (t, e) => new Wx(t, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Xt = BigInt(0), Vt = BigInt(1), wa = /* @__PURE__ */ BigInt(2), HT = /* @__PURE__ */ BigInt(3), Jx = /* @__PURE__ */ BigInt(4), Zx = /* @__PURE__ */ BigInt(5), Xx = /* @__PURE__ */ BigInt(8);
function In(t, e) {
  const n = t % e;
  return n >= Xt ? n : e + n;
}
function bn(t, e, n) {
  let r = t;
  for (; e-- > Xt; )
    r *= r, r %= n;
  return r;
}
function r1(t, e) {
  if (t === Xt)
    throw new Error("invert: expected non-zero number");
  if (e <= Xt)
    throw new Error("invert: expected positive modulus, got " + e);
  let n = In(t, e), r = e, s = Xt, a = Vt;
  for (; n !== Xt; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== Vt)
    throw new Error("invert: does not exist");
  return In(s, e);
}
function Yx(t, e) {
  const n = (t.ORDER + Vt) / Jx, r = t.pow(e, n);
  if (!t.eql(t.sqr(r), e))
    throw new Error("Cannot find square root");
  return r;
}
function $T(t, e) {
  const n = (t.ORDER - Zx) / Xx, r = t.mul(e, wa), s = t.pow(r, n), a = t.mul(e, s), i = t.mul(t.mul(a, wa), s), o = t.mul(a, t.sub(i, t.ONE));
  if (!t.eql(t.sqr(o), e))
    throw new Error("Cannot find square root");
  return o;
}
function _T(t) {
  if (t < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let e = t - Vt, n = 0;
  for (; e % wa === Xt; )
    e /= wa, n++;
  let r = wa;
  const s = Kf(t);
  for (; s1(s, r) === 1; )
    if (r++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n === 1)
    return Yx;
  let a = s.pow(r, e);
  const i = (e + Vt) / wa;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (s1(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = n, d = c.mul(c.ONE, a), f = c.pow(u, e), h = c.pow(u, i);
    for (; !c.eql(f, c.ONE); ) {
      if (c.is0(f))
        return c.ZERO;
      let y = 1, b = c.sqr(f);
      for (; !c.eql(b, c.ONE); )
        if (y++, b = c.sqr(b), y === l)
          throw new Error("Cannot find square root");
      const g = Vt << BigInt(l - y - 1), w = c.pow(d, g);
      l = y, d = c.sqr(w), f = c.mul(f, d), h = c.mul(h, w);
    }
    return h;
  };
}
function GT(t) {
  return t % Jx === HT ? Yx : t % Xx === Zx ? $T : _T(t);
}
const zT = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function VT(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n = zT.reduce((r, s) => (r[s] = "function", r), e);
  return Db(t, n), t;
}
function jT(t, e, n) {
  if (n < Xt)
    throw new Error("invalid exponent, negatives unsupported");
  if (n === Xt)
    return t.ONE;
  if (n === Vt)
    return e;
  let r = t.ONE, s = e;
  for (; n > Xt; )
    n & Vt && (r = t.mul(r, s)), s = t.sqr(s), n >>= Vt;
  return r;
}
function e2(t, e, n = !1) {
  const r = new Array(e.length).fill(n ? t.ZERO : void 0), s = e.reduce((i, o, c) => t.is0(o) ? i : (r[c] = i, t.mul(i, o)), t.ONE), a = t.inv(s);
  return e.reduceRight((i, o, c) => t.is0(o) ? i : (r[c] = t.mul(i, r[c]), t.mul(i, o)), a), r;
}
function s1(t, e) {
  const n = (t.ORDER - Vt) / wa, r = t.pow(e, n), s = t.eql(r, t.ONE), a = t.eql(r, t.ZERO), i = t.eql(r, t.neg(t.ONE));
  if (!s && !a && !i)
    throw new Error("invalid Legendre symbol result");
  return s ? 1 : a ? 0 : -1;
}
function KT(t, e) {
  e !== void 0 && Ol(e);
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function Kf(t, e, n = !1, r = {}) {
  if (t <= Xt)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  let s, a;
  if (typeof e == "object" && e != null) {
    if (r.sqrt || n)
      throw new Error("cannot specify opts in two arguments");
    const l = e;
    l.BITS && (s = l.BITS), l.sqrt && (a = l.sqrt), typeof l.isLE == "boolean" && (n = l.isLE);
  } else
    typeof e == "number" && (s = e), r.sqrt && (a = r.sqrt);
  const { nBitLength: i, nByteLength: o } = KT(t, s);
  if (o > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let c;
  const u = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: o,
    MASK: Vf(i),
    ZERO: Xt,
    ONE: Vt,
    create: (l) => In(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof l);
      return Xt <= l && l < t;
    },
    is0: (l) => l === Xt,
    // is valid and invertible
    isValidNot0: (l) => !u.is0(l) && u.isValid(l),
    isOdd: (l) => (l & Vt) === Vt,
    neg: (l) => In(-l, t),
    eql: (l, d) => l === d,
    sqr: (l) => In(l * l, t),
    add: (l, d) => In(l + d, t),
    sub: (l, d) => In(l - d, t),
    mul: (l, d) => In(l * d, t),
    pow: (l, d) => jT(u, l, d),
    div: (l, d) => In(l * r1(d, t), t),
    // Same as above, but doesn't normalize
    sqrN: (l) => l * l,
    addN: (l, d) => l + d,
    subN: (l, d) => l - d,
    mulN: (l, d) => l * d,
    inv: (l) => r1(l, t),
    sqrt: a || ((l) => (c || (c = GT(t)), c(u, l))),
    toBytes: (l) => n ? Ux(l, o) : Mb(l, o),
    fromBytes: (l) => {
      if (l.length !== o)
        throw new Error("Field.fromBytes: expected " + o + " bytes, got " + l.length);
      return n ? Ix(l) : zf(l);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (l) => e2(u, l),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (l, d, f) => f ? d : l
  });
  return Object.freeze(u);
}
function t2(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function n2(t) {
  const e = t2(t);
  return e + Math.ceil(e / 2);
}
function qT(t, e, n = !1) {
  const r = t.length, s = t2(e), a = n2(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error("expected " + a + "-1024 bytes of input, got " + r);
  const i = n ? Ix(t) : zf(t), o = In(i, e - Vt) + Vt;
  return n ? Ux(o, s) : Mb(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ac = BigInt(0), Ea = BigInt(1);
function ll(t, e) {
  const n = e.negate();
  return t ? n : e;
}
function WT(t, e, n) {
  const r = (i) => i.pz, s = e2(t.Fp, n.map(r));
  return n.map((i, o) => i.toAffine(s[o])).map(t.fromAffine);
}
function r2(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function ph(t, e) {
  r2(t, e);
  const n = Math.ceil(e / t) + 1, r = 2 ** (t - 1), s = 2 ** t, a = Vf(t), i = BigInt(t);
  return { windows: n, windowSize: r, mask: a, maxNumber: s, shiftBy: i };
}
function a1(t, e, n) {
  const { windowSize: r, mask: s, maxNumber: a, shiftBy: i } = n;
  let o = Number(t & s), c = t >> i;
  o > r && (o -= a, c += Ea);
  const u = e * r, l = u + Math.abs(o) - 1, d = o === 0, f = o < 0, h = e % 2 !== 0;
  return { nextN: c, offset: l, isZero: d, isNeg: f, isNegF: h, offsetF: u };
}
function QT(t, e) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((n, r) => {
    if (!(n instanceof e))
      throw new Error("invalid point at index " + r);
  });
}
function JT(t, e) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((n, r) => {
    if (!e.isValid(n))
      throw new Error("invalid scalar at index " + r);
  });
}
const hh = /* @__PURE__ */ new WeakMap(), s2 = /* @__PURE__ */ new WeakMap();
function mh(t) {
  return s2.get(t) || 1;
}
function i1(t) {
  if (t !== ac)
    throw new Error("invalid wNAF");
}
function ZT(t, e) {
  return {
    constTimeNegate: ll,
    hasPrecomputes(n) {
      return mh(n) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(n, r, s = t.ZERO) {
      let a = n;
      for (; r > ac; )
        r & Ea && (s = s.add(a)), a = a.double(), r >>= Ea;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(n, r) {
      const { windows: s, windowSize: a } = ph(r, e), i = [];
      let o = n, c = o;
      for (let u = 0; u < s; u++) {
        c = o, i.push(c);
        for (let l = 1; l < a; l++)
          c = c.add(o), i.push(c);
        o = c.double();
      }
      return i;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(n, r, s) {
      let a = t.ZERO, i = t.BASE;
      const o = ph(n, e);
      for (let c = 0; c < o.windows; c++) {
        const { nextN: u, offset: l, isZero: d, isNeg: f, isNegF: h, offsetF: y } = a1(s, c, o);
        s = u, d ? i = i.add(ll(h, r[y])) : a = a.add(ll(f, r[l]));
      }
      return i1(s), { p: a, f: i };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(n, r, s, a = t.ZERO) {
      const i = ph(n, e);
      for (let o = 0; o < i.windows && s !== ac; o++) {
        const { nextN: c, offset: u, isZero: l, isNeg: d } = a1(s, o, i);
        if (s = c, !l) {
          const f = r[u];
          a = a.add(d ? f.negate() : f);
        }
      }
      return i1(s), a;
    },
    getPrecomputes(n, r, s) {
      let a = hh.get(r);
      return a || (a = this.precomputeWindow(r, n), n !== 1 && (typeof s == "function" && (a = s(a)), hh.set(r, a))), a;
    },
    wNAFCached(n, r, s) {
      const a = mh(n);
      return this.wNAF(a, this.getPrecomputes(a, n, s), r);
    },
    wNAFCachedUnsafe(n, r, s, a) {
      const i = mh(n);
      return i === 1 ? this.unsafeLadder(n, r, a) : this.wNAFUnsafe(i, this.getPrecomputes(i, n, s), r, a);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(n, r) {
      r2(r, e), s2.set(n, r), hh.delete(n);
    }
  };
}
function XT(t, e, n, r) {
  let s = e, a = t.ZERO, i = t.ZERO;
  for (; n > ac || r > ac; )
    n & Ea && (a = a.add(s)), r & Ea && (i = i.add(s)), s = s.double(), n >>= Ea, r >>= Ea;
  return { p1: a, p2: i };
}
function YT(t, e, n, r) {
  QT(n, t), JT(r, e);
  const s = n.length, a = r.length;
  if (s !== a)
    throw new Error("arrays of points and scalars must have equal length");
  const i = t.ZERO, o = Q5(BigInt(s));
  let c = 1;
  o > 12 ? c = o - 3 : o > 4 ? c = o - 2 : o > 0 && (c = 2);
  const u = Vf(c), l = new Array(Number(u) + 1).fill(i), d = Math.floor((e.BITS - 1) / c) * c;
  let f = i;
  for (let h = d; h >= 0; h -= c) {
    l.fill(i);
    for (let b = 0; b < a; b++) {
      const g = r[b], w = Number(g >> BigInt(h) & u);
      l[w] = l[w].add(n[b]);
    }
    let y = i;
    for (let b = l.length - 1, g = i; b > 0; b--)
      g = g.add(l[b]), y = y.add(g);
    if (f = f.add(y), h !== 0)
      for (let b = 0; b < c; b++)
        f = f.double();
  }
  return f;
}
function o1(t, e) {
  if (e) {
    if (e.ORDER !== t)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return VT(e), e;
  } else
    return Kf(t);
}
function eS(t, e, n = {}) {
  if (!e || typeof e != "object")
    throw new Error(`expected valid ${t} CURVE object`);
  for (const o of ["p", "n", "h"]) {
    const c = e[o];
    if (!(typeof c == "bigint" && c > ac))
      throw new Error(`CURVE.${o} must be positive bigint`);
  }
  const r = o1(e.p, n.Fp), s = o1(e.n, n.Fn), i = ["Gx", "Gy", "a", "b"];
  for (const o of i)
    if (!r.isValid(e[o]))
      throw new Error(`CURVE.${o} must be valid field element of CURVE.Fp`);
  return { Fp: r, Fn: s };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function c1(t) {
  t.lowS !== void 0 && qd("lowS", t.lowS), t.prehash !== void 0 && qd("prehash", t.prehash);
}
class tS extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Hr = {
  // asn.1 DER encoding utils
  Err: tS,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (t, e) => {
      const { Err: n } = Hr;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = e.length / 2, s = Ru(r);
      if (s.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const a = r > 127 ? Ru(s.length / 2 | 128) : "";
      return Ru(t) + a + s + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(t, e) {
      const { Err: n } = Hr;
      let r = 0;
      if (t < 0 || t > 256)
        throw new n("tlv.encode: wrong tag");
      if (e.length < 2 || e[r++] !== t)
        throw new n("tlv.decode: wrong tlv");
      const s = e[r++], a = !!(s & 128);
      let i = 0;
      if (!a)
        i = s;
      else {
        const c = s & 127;
        if (!c)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const u = e.subarray(r, r + c);
        if (u.length !== c)
          throw new n("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          i = i << 8 | l;
        if (r += c, i < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const o = e.subarray(r, r + i);
      if (o.length !== i)
        throw new n("tlv.decode: wrong value length");
      return { v: o, l: e.subarray(r + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(t) {
      const { Err: e } = Hr;
      if (t < ul)
        throw new e("integer: negative integers are not allowed");
      let n = Ru(t);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return n;
    },
    decode(t) {
      const { Err: e } = Hr;
      if (t[0] & 128)
        throw new e("invalid signature integer: negative");
      if (t[0] === 0 && !(t[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return zf(t);
    }
  },
  toSig(t) {
    const { Err: e, _int: n, _tlv: r } = Hr, s = An("signature", t), { v: a, l: i } = r.decode(48, s);
    if (i.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: o, l: c } = r.decode(2, a), { v: u, l } = r.decode(2, c);
    if (l.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: n.decode(o), s: n.decode(u) };
  },
  hexFromSig(t) {
    const { _tlv: e, _int: n } = Hr, r = e.encode(2, n.encode(t.r)), s = e.encode(2, n.encode(t.s)), a = r + s;
    return e.encode(48, a);
  }
}, ul = BigInt(0), dl = BigInt(1), nS = BigInt(2), Mu = BigInt(3), rS = BigInt(4);
function sS(t, e, n) {
  function r(s) {
    const a = t.sqr(s), i = t.mul(a, s);
    return t.add(t.add(i, t.mul(s, e)), n);
  }
  return r;
}
function a2(t, e, n) {
  const { BYTES: r } = t;
  function s(a) {
    let i;
    if (typeof a == "bigint")
      i = a;
    else {
      let o = An("private key", a);
      if (e) {
        if (!e.includes(o.length * 2))
          throw new Error("invalid private key");
        const c = new Uint8Array(r);
        c.set(o, c.length - o.length), o = c;
      }
      try {
        i = t.fromBytes(o);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof a}`);
      }
    }
    if (n && (i = t.create(i)), !t.isValidNot0(i))
      throw new Error("invalid private key: out of range [1..N-1]");
    return i;
  }
  return s;
}
function aS(t, e = {}) {
  const { Fp: n, Fn: r } = eS("weierstrass", t, e), { h: s, n: a } = t;
  Db(e, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: i } = e;
  if (i && (!n.is0(t.a) || typeof i.beta != "bigint" || typeof i.splitScalar != "function"))
    throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function o() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function c(T, C, N) {
    const { x: U, y: L } = C.toAffine(), $ = n.toBytes(U);
    if (qd("isCompressed", N), N) {
      o();
      const _ = !n.isOdd(L);
      return ya(i2(_), $);
    } else
      return ya(Uint8Array.of(4), $, n.toBytes(L));
  }
  function u(T) {
    Xn(T);
    const C = n.BYTES, N = C + 1, U = 2 * C + 1, L = T.length, $ = T[0], _ = T.subarray(1);
    if (L === N && ($ === 2 || $ === 3)) {
      const R = n.fromBytes(_);
      if (!n.isValid(R))
        throw new Error("bad point: is not on curve, wrong x");
      const M = f(R);
      let j;
      try {
        j = n.sqrt(M);
      } catch (Y) {
        const X = Y instanceof Error ? ": " + Y.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + X);
      }
      o();
      const G = n.isOdd(j);
      return ($ & 1) === 1 !== G && (j = n.neg(j)), { x: R, y: j };
    } else if (L === U && $ === 4) {
      const R = n.fromBytes(_.subarray(C * 0, C * 1)), M = n.fromBytes(_.subarray(C * 1, C * 2));
      if (!h(R, M))
        throw new Error("bad point: is not on curve");
      return { x: R, y: M };
    } else
      throw new Error(`bad point: got length ${L}, expected compressed=${N} or uncompressed=${U}`);
  }
  const l = e.toBytes || c, d = e.fromBytes || u, f = sS(n, t.a, t.b);
  function h(T, C) {
    const N = n.sqr(C), U = f(T);
    return n.eql(N, U);
  }
  if (!h(t.Gx, t.Gy))
    throw new Error("bad curve params: generator point");
  const y = n.mul(n.pow(t.a, Mu), rS), b = n.mul(n.sqr(t.b), BigInt(27));
  if (n.is0(n.add(y, b)))
    throw new Error("bad curve params: a or b");
  function g(T, C, N = !1) {
    if (!n.isValid(C) || N && n.is0(C))
      throw new Error(`bad point coordinate ${T}`);
    return C;
  }
  function w(T) {
    if (!(T instanceof x))
      throw new Error("ProjectivePoint expected");
  }
  const v = Jg((T, C) => {
    const { px: N, py: U, pz: L } = T;
    if (n.eql(L, n.ONE))
      return { x: N, y: U };
    const $ = T.is0();
    C == null && (C = $ ? n.ONE : n.inv(L));
    const _ = n.mul(N, C), R = n.mul(U, C), M = n.mul(L, C);
    if ($)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(M, n.ONE))
      throw new Error("invZ was invalid");
    return { x: _, y: R };
  }), A = Jg((T) => {
    if (T.is0()) {
      if (e.allowInfinityPoint && !n.is0(T.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: C, y: N } = T.toAffine();
    if (!n.isValid(C) || !n.isValid(N))
      throw new Error("bad point: x or y not field elements");
    if (!h(C, N))
      throw new Error("bad point: equation left != right");
    if (!T.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function P(T, C, N, U, L) {
    return N = new x(n.mul(N.px, T), N.py, N.pz), C = ll(U, C), N = ll(L, N), C.add(N);
  }
  class x {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(C, N, U) {
      this.px = g("x", C), this.py = g("y", N, !0), this.pz = g("z", U), Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(C) {
      const { x: N, y: U } = C || {};
      if (!C || !n.isValid(N) || !n.isValid(U))
        throw new Error("invalid affine point");
      if (C instanceof x)
        throw new Error("projective point not allowed");
      return n.is0(N) && n.is0(U) ? x.ZERO : new x(N, U, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(C) {
      return WT(x, "pz", C);
    }
    static fromBytes(C) {
      return Xn(C), x.fromHex(C);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(C) {
      const N = x.fromAffine(d(An("pointHex", C)));
      return N.assertValidity(), N;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(C) {
      const N = a2(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
      return x.BASE.multiply(N(C));
    }
    /** Multiscalar Multiplication */
    static msm(C, N) {
      return YT(x, r, C, N);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(C = 8, N = !0) {
      return I.setWindowSize(this, C), N || this.multiply(Mu), this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(C) {
      this.precompute(C);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      A(this);
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(C);
    }
    /** Compare one point to another. */
    equals(C) {
      w(C);
      const { px: N, py: U, pz: L } = this, { px: $, py: _, pz: R } = C, M = n.eql(n.mul(N, R), n.mul($, L)), j = n.eql(n.mul(U, R), n.mul(_, L));
      return M && j;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new x(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: C, b: N } = t, U = n.mul(N, Mu), { px: L, py: $, pz: _ } = this;
      let R = n.ZERO, M = n.ZERO, j = n.ZERO, G = n.mul(L, L), Z = n.mul($, $), Y = n.mul(_, _), X = n.mul(L, $);
      return X = n.add(X, X), j = n.mul(L, _), j = n.add(j, j), R = n.mul(C, j), M = n.mul(U, Y), M = n.add(R, M), R = n.sub(Z, M), M = n.add(Z, M), M = n.mul(R, M), R = n.mul(X, R), j = n.mul(U, j), Y = n.mul(C, Y), X = n.sub(G, Y), X = n.mul(C, X), X = n.add(X, j), j = n.add(G, G), G = n.add(j, G), G = n.add(G, Y), G = n.mul(G, X), M = n.add(M, G), Y = n.mul($, _), Y = n.add(Y, Y), G = n.mul(Y, X), R = n.sub(R, G), j = n.mul(Y, Z), j = n.add(j, j), j = n.add(j, j), new x(R, M, j);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(C) {
      w(C);
      const { px: N, py: U, pz: L } = this, { px: $, py: _, pz: R } = C;
      let M = n.ZERO, j = n.ZERO, G = n.ZERO;
      const Z = t.a, Y = n.mul(t.b, Mu);
      let X = n.mul(N, $), le = n.mul(U, _), J = n.mul(L, R), ce = n.add(N, U), te = n.add($, _);
      ce = n.mul(ce, te), te = n.add(X, le), ce = n.sub(ce, te), te = n.add(N, L);
      let ae = n.add($, R);
      return te = n.mul(te, ae), ae = n.add(X, J), te = n.sub(te, ae), ae = n.add(U, L), M = n.add(_, R), ae = n.mul(ae, M), M = n.add(le, J), ae = n.sub(ae, M), G = n.mul(Z, te), M = n.mul(Y, J), G = n.add(M, G), M = n.sub(le, G), G = n.add(le, G), j = n.mul(M, G), le = n.add(X, X), le = n.add(le, X), J = n.mul(Z, J), te = n.mul(Y, te), le = n.add(le, J), J = n.sub(X, J), J = n.mul(Z, J), te = n.add(te, J), X = n.mul(le, te), j = n.add(j, X), X = n.mul(ae, te), M = n.mul(ce, M), M = n.sub(M, X), X = n.mul(ce, le), G = n.mul(ae, G), G = n.add(G, X), new x(M, j, G);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(x.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(C) {
      const { endo: N } = e;
      if (!r.isValidNot0(C))
        throw new Error("invalid scalar: out of range");
      let U, L;
      const $ = (_) => I.wNAFCached(this, _, x.normalizeZ);
      if (N) {
        const { k1neg: _, k1: R, k2neg: M, k2: j } = N.splitScalar(C), { p: G, f: Z } = $(R), { p: Y, f: X } = $(j);
        L = Z.add(X), U = P(N.beta, G, Y, _, M);
      } else {
        const { p: _, f: R } = $(C);
        U = _, L = R;
      }
      return x.normalizeZ([U, L])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(C) {
      const { endo: N } = e, U = this;
      if (!r.isValid(C))
        throw new Error("invalid scalar: out of range");
      if (C === ul || U.is0())
        return x.ZERO;
      if (C === dl)
        return U;
      if (I.hasPrecomputes(this))
        return this.multiply(C);
      if (N) {
        const { k1neg: L, k1: $, k2neg: _, k2: R } = N.splitScalar(C), { p1: M, p2: j } = XT(x, U, $, R);
        return P(N.beta, M, j, L, _);
      } else
        return I.wNAFCachedUnsafe(U, C);
    }
    multiplyAndAddUnsafe(C, N, U) {
      const L = this.multiplyUnsafe(N).add(C.multiplyUnsafe(U));
      return L.is0() ? void 0 : L;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(C) {
      return v(this, C);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: C } = e;
      return s === dl ? !0 : C ? C(x, this) : I.wNAFCachedUnsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: C } = e;
      return s === dl ? this : C ? C(x, this) : this.multiplyUnsafe(s);
    }
    toBytes(C = !0) {
      return qd("isCompressed", C), this.assertValidity(), l(x, this, C);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(C = !0) {
      return this.toBytes(C);
    }
    toHex(C = !0) {
      return Bl(this.toBytes(C));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  x.BASE = new x(t.Gx, t.Gy, n.ONE), x.ZERO = new x(n.ZERO, n.ONE, n.ZERO), x.Fp = n, x.Fn = r;
  const O = r.BITS, I = ZT(x, e.endo ? Math.ceil(O / 2) : O);
  return x;
}
function i2(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function iS(t, e, n = {}) {
  Db(e, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const r = e.randomBytes || v5, s = e.hmac || ((U, ...L) => Qx(e.hash, U, ya(...L))), { Fp: a, Fn: i } = t, { ORDER: o, BITS: c } = i;
  function u(U) {
    const L = o >> dl;
    return U > L;
  }
  function l(U) {
    return u(U) ? i.neg(U) : U;
  }
  function d(U, L) {
    if (!i.isValidNot0(L))
      throw new Error(`invalid signature ${U}: out of range 1..CURVE.n`);
  }
  class f {
    constructor(L, $, _) {
      d("r", L), d("s", $), this.r = L, this.s = $, _ != null && (this.recovery = _), Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(L) {
      const $ = i.BYTES, _ = An("compactSignature", L, $ * 2);
      return new f(i.fromBytes(_.subarray(0, $)), i.fromBytes(_.subarray($, $ * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(L) {
      const { r: $, s: _ } = Hr.toSig(An("DER", L));
      return new f($, _);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(L) {
      return new f(this.r, this.s, L);
    }
    // ProjPointType<bigint>
    recoverPublicKey(L) {
      const $ = a.ORDER, { r: _, s: R, recovery: M } = this;
      if (M == null || ![0, 1, 2, 3].includes(M))
        throw new Error("recovery id invalid");
      if (o * nS < $ && M > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const G = M === 2 || M === 3 ? _ + o : _;
      if (!a.isValid(G))
        throw new Error("recovery id 2 or 3 invalid");
      const Z = a.toBytes(G), Y = t.fromHex(ya(i2((M & 1) === 0), Z)), X = i.inv(G), le = A(An("msgHash", L)), J = i.create(-le * X), ce = i.create(R * X), te = t.BASE.multiplyUnsafe(J).add(Y.multiplyUnsafe(ce));
      if (te.is0())
        throw new Error("point at infinify");
      return te.assertValidity(), te;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return u(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new f(this.r, i.neg(this.s), this.recovery) : this;
    }
    toBytes(L) {
      if (L === "compact")
        return ya(i.toBytes(this.r), i.toBytes(this.s));
      if (L === "der")
        return Nb(Hr.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Bl(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Bl(this.toBytes("compact"));
    }
  }
  const h = a2(i, n.allowedPrivateKeyLengths, n.wrapPrivateKey), y = {
    isValidPrivateKey(U) {
      try {
        return h(U), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: h,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const U = o;
      return qT(r(n2(U)), U);
    },
    precompute(U = 8, L = t.BASE) {
      return L.precompute(U, !1);
    }
  };
  function b(U, L = !0) {
    return t.fromPrivateKey(U).toBytes(L);
  }
  function g(U) {
    if (typeof U == "bigint")
      return !1;
    if (U instanceof t)
      return !0;
    const $ = An("key", U).length, _ = a.BYTES, R = _ + 1, M = 2 * _ + 1;
    if (!(n.allowedPrivateKeyLengths || i.BYTES === R))
      return $ === R || $ === M;
  }
  function w(U, L, $ = !0) {
    if (g(U) === !0)
      throw new Error("first arg must be private key");
    if (g(L) === !1)
      throw new Error("second arg must be public key");
    return t.fromHex(L).multiply(h(U)).toBytes($);
  }
  const v = e.bits2int || function(U) {
    if (U.length > 8192)
      throw new Error("input is too large");
    const L = zf(U), $ = U.length * 8 - c;
    return $ > 0 ? L >> BigInt($) : L;
  }, A = e.bits2int_modN || function(U) {
    return i.create(v(U));
  }, P = Vf(c);
  function x(U) {
    return W5("num < 2^" + c, U, ul, P), i.toBytes(U);
  }
  function O(U, L, $ = I) {
    if (["recovered", "canonical"].some((ce) => ce in $))
      throw new Error("sign() legacy options not supported");
    const { hash: _ } = e;
    let { lowS: R, prehash: M, extraEntropy: j } = $;
    R == null && (R = !0), U = An("msgHash", U), c1($), M && (U = An("prehashed msgHash", _(U)));
    const G = A(U), Z = h(L), Y = [x(Z), x(G)];
    if (j != null && j !== !1) {
      const ce = j === !0 ? r(a.BYTES) : j;
      Y.push(An("extraEntropy", ce));
    }
    const X = ya(...Y), le = G;
    function J(ce) {
      const te = v(ce);
      if (!i.isValidNot0(te))
        return;
      const ae = i.inv(te), he = t.BASE.multiply(te).toAffine(), Oe = i.create(he.x);
      if (Oe === ul)
        return;
      const De = i.create(ae * i.create(le + Oe * Z));
      if (De === ul)
        return;
      let ze = (he.x === Oe ? 0 : 2) | Number(he.y & dl), at = De;
      return R && u(De) && (at = l(De), ze ^= 1), new f(Oe, at, ze);
    }
    return { seed: X, k2sig: J };
  }
  const I = { lowS: e.lowS, prehash: !1 }, T = { lowS: e.lowS, prehash: !1 };
  function C(U, L, $ = I) {
    const { seed: _, k2sig: R } = O(U, L, $);
    return J5(e.hash.outputLen, i.BYTES, s)(_, R);
  }
  t.BASE.precompute(8);
  function N(U, L, $, _ = T) {
    const R = U;
    L = An("msgHash", L), $ = An("publicKey", $), c1(_);
    const { lowS: M, prehash: j, format: G } = _;
    if ("strict" in _)
      throw new Error("options.strict was renamed to lowS");
    if (G !== void 0 && !["compact", "der", "js"].includes(G))
      throw new Error('format must be "compact", "der" or "js"');
    const Z = typeof R == "string" || Ub(R), Y = !Z && !G && typeof R == "object" && R !== null && typeof R.r == "bigint" && typeof R.s == "bigint";
    if (!Z && !Y)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let X, le;
    try {
      if (Y)
        if (G === void 0 || G === "js")
          X = new f(R.r, R.s);
        else
          throw new Error("invalid format");
      if (Z) {
        try {
          G !== "compact" && (X = f.fromDER(R));
        } catch (at) {
          if (!(at instanceof Hr.Err))
            throw at;
        }
        !X && G !== "der" && (X = f.fromCompact(R));
      }
      le = t.fromHex($);
    } catch {
      return !1;
    }
    if (!X || M && X.hasHighS())
      return !1;
    j && (L = e.hash(L));
    const { r: J, s: ce } = X, te = A(L), ae = i.inv(ce), he = i.create(te * ae), Oe = i.create(J * ae), De = t.BASE.multiplyUnsafe(he).add(le.multiplyUnsafe(Oe));
    return De.is0() ? !1 : i.create(De.x) === J;
  }
  return Object.freeze({
    getPublicKey: b,
    getSharedSecret: w,
    sign: C,
    verify: N,
    utils: y,
    Point: t,
    Signature: f
  });
}
function oS(t) {
  const e = {
    a: t.a,
    b: t.b,
    p: t.Fp.ORDER,
    n: t.n,
    h: t.h,
    Gx: t.Gx,
    Gy: t.Gy
  }, n = t.Fp, r = Kf(e.n, t.nBitLength), s = {
    Fp: n,
    Fn: r,
    allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
    allowInfinityPoint: t.allowInfinityPoint,
    endo: t.endo,
    wrapPrivateKey: t.wrapPrivateKey,
    isTorsionFree: t.isTorsionFree,
    clearCofactor: t.clearCofactor,
    fromBytes: t.fromBytes,
    toBytes: t.toBytes
  };
  return { CURVE: e, curveOpts: s };
}
function cS(t) {
  const { CURVE: e, curveOpts: n } = oS(t), r = {
    hash: t.hash,
    hmac: t.hmac,
    randomBytes: t.randomBytes,
    lowS: t.lowS,
    bits2int: t.bits2int,
    bits2int_modN: t.bits2int_modN
  };
  return { CURVE: e, curveOpts: n, ecdsaOpts: r };
}
function lS(t, e) {
  return Object.assign({}, e, {
    ProjectivePoint: e.Point,
    CURVE: t
  });
}
function uS(t) {
  const { CURVE: e, curveOpts: n, ecdsaOpts: r } = cS(t), s = aS(e, n), a = iS(s, r, n);
  return lS(t, a);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function dS(t, e) {
  const n = (r) => uS({ ...t, hash: r });
  return { ...n(e), create: n };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Wd = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const fS = BigInt(1), Lm = BigInt(2), l1 = (t, e) => (t + e / Lm) / e;
function pS(t) {
  const e = Wd.p, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = bn(l, n, e) * l % e, f = bn(d, n, e) * l % e, h = bn(f, Lm, e) * u % e, y = bn(h, s, e) * h % e, b = bn(y, a, e) * y % e, g = bn(b, o, e) * b % e, w = bn(g, c, e) * g % e, v = bn(w, o, e) * b % e, A = bn(v, n, e) * l % e, P = bn(A, i, e) * y % e, x = bn(P, r, e) * u % e, O = bn(x, Lm, e);
  if (!Hm.eql(Hm.sqr(O), t))
    throw new Error("Cannot find square root");
  return O;
}
const Hm = Kf(Wd.p, void 0, void 0, { sqrt: pS }), pu = dS({
  ...Wd,
  Fp: Hm,
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = Wd.n, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -fS * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = l1(a * t, e), c = l1(-r * t, e);
      let u = In(t - o * n - c * s, e), l = In(-o * r - c * a, e);
      const d = u > i, f = l > i;
      if (d && (u = e - u), f && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: f, k2: l };
    }
  }
}, Bx), hS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1: pu
}, Symbol.toStringTag, { value: "Module" }));
function mS(t) {
  const e = ga(si(t.from)), n = Hx(t1(t.salt) ? t.salt : ga(t.salt), 32), r = "bytecodeHash" in t ? t1(t.bytecodeHash) ? t.bytecodeHash : ga(t.bytecodeHash) : ea(t.bytecode, { as: "Bytes" });
  return si(jf(ea(_b(ga("0xff"), e, n, r), { as: "Hex" }), 12));
}
const bS = {
  indexerGatewayUrl: "https://indexer.sequence.app",
  metadataUrl: "https://metadata.sequence.app",
  apiUrl: "https://api.sequence.app",
  indexerUrl: "https://indexer.sequence.app",
  imageProxyUrl: "https://imgproxy.sequence.xyz/"
}, o2 = tC(null), EZ = (t) => {
  const [e, n] = Lf(t.config.jwt), r = {
    ...t.config,
    env: {
      ...bS,
      ...t.config.env
    },
    jwt: e,
    setJWT: n
  };
  return $E(o2.Provider, { value: r, children: t.children });
}, c2 = () => {
  const t = nC(o2);
  if (!t)
    throw new Error("useConfig must be used within a SequenceHooksProvider");
  return t;
};
function Qd() {
  return Qd = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Qd.apply(null, arguments);
}
let yS = /* @__PURE__ */ function(t) {
  return t.VERIFIED = "VERIFIED", t.UNVERIFIED = "UNVERIFIED", t.ALL = "ALL", t;
}({});
const gS = "Webrpc", wS = "webrpc@v0.21.1;gen-typescript@v0.15.1;sequence-indexer@v0.4.0";
class ES {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/IndexerGateway/", this.getNativeTokenBalance = (r, s, a) => this.fetch(this.url("GetNativeTokenBalance"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalances = (r, s, a) => this.fetch(this.url("GetTokenBalances"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesSummary = (r, s, a) => this.fetch(this.url("GetTokenBalancesSummary"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesDetails = (r, s, a) => this.fetch(this.url("GetTokenBalancesDetails"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      page: o.page,
      nativeBalances: o.nativeBalances,
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTokenBalancesByContract = (r, s, a) => this.fetch(this.url("GetTokenBalancesByContract"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getBalanceUpdates = (r, s, a) => this.fetch(this.url("GetBalanceUpdates"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      page: o.page,
      balances: o.balances
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getChains = (r, s, a) => this.fetch(this.url("GetChains"), ar(r, s, a)).then((i) => ir(i).then((o) => ({
      chains: o.chains
    })), (i) => {
      throw Mn.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.ping = (r, s) => this.fetch(this.url("Ping"), ar({}, r, s)).then((a) => ir(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Mn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), ar({}, r, s)).then((a) => ir(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw Mn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), ar({}, r, s)).then((a) => ir(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Mn.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const ar = (t = {}, e = {}, n = null) => {
  const r = Qd({}, e, {
    "Content-Type": "application/json"
  });
  return r[gS] = wS, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, ir = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), m2.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (YS[r] || we).new(n);
  }
  return n;
});
let we = class l2 extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, l2.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, xS = class u2 extends we {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, u2.prototype);
  }
}, Mn = class d2 extends we {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, d2.prototype);
  }
}, AS = class f2 extends we {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, f2.prototype);
  }
}, vS = class p2 extends we {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, p2.prototype);
  }
}, kS = class h2 extends we {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, h2.prototype);
  }
}, m2 = class b2 extends we {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, b2.prototype);
  }
}, CS = class y2 extends we {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, y2.prototype);
  }
}, TS = class g2 extends we {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, g2.prototype);
  }
}, SS = class w2 extends we {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, w2.prototype);
  }
}, OS = class E2 extends we {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, E2.prototype);
  }
}, BS = class x2 extends we {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, x2.prototype);
  }
}, PS = class A2 extends we {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, A2.prototype);
  }
}, IS = class v2 extends we {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, v2.prototype);
  }
}, US = class k2 extends we {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, k2.prototype);
  }
}, NS = class C2 extends we {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, C2.prototype);
  }
}, RS = class T2 extends we {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, T2.prototype);
  }
}, FS = class S2 extends we {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, S2.prototype);
  }
}, MS = class O2 extends we {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, O2.prototype);
  }
}, DS = class B2 extends we {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, B2.prototype);
  }
}, LS = class P2 extends we {
  constructor(e = "ProjectNotFound", n = 1100, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, P2.prototype);
  }
}, HS = class I2 extends we {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, I2.prototype);
  }
}, $S = class U2 extends we {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, U2.prototype);
  }
}, _S = class N2 extends we {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, N2.prototype);
  }
}, GS = class R2 extends we {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, R2.prototype);
  }
}, zS = class F2 extends we {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, F2.prototype);
  }
}, VS = class M2 extends we {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, M2.prototype);
  }
};
class jb extends we {
  constructor(e = "RateLimit", n = 1201, r = "Rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, jb.prototype);
  }
}
let jS = class D2 extends we {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, D2.prototype);
  }
}, KS = class L2 extends we {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, L2.prototype);
  }
}, qS = class H2 extends we {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, H2.prototype);
  }
}, WS = class $2 extends we {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $2.prototype);
  }
}, QS = class _2 extends we {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _2.prototype);
  }
}, JS = class G2 extends we {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, G2.prototype);
  }
}, ZS = class z2 extends we {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, z2.prototype);
  }
};
class Kb extends we {
  constructor(e = "ResourceExhausted", n = 2004, r = "Resource exhausted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Kb.prototype);
  }
}
let XS = class V2 extends we {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, V2.prototype);
  }
};
class qb extends we {
  constructor(e = "MetadataCallFailed", n = 3003, r = "Metadata service call failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qb.prototype);
  }
}
const YS = {
  0: xS,
  [-1]: Mn,
  [-2]: AS,
  [-3]: vS,
  [-4]: kS,
  [-5]: m2,
  [-6]: CS,
  [-7]: TS,
  [-8]: SS,
  [-9]: OS,
  [-10]: BS,
  1e3: PS,
  1001: IS,
  1002: US,
  1003: NS,
  1004: RS,
  1005: FS,
  1006: MS,
  1007: DS,
  1100: LS,
  1101: HS,
  1102: $S,
  1103: _S,
  1104: GS,
  1105: zS,
  1200: VS,
  1201: jb,
  1300: jS,
  1301: KS,
  1302: qS,
  1900: WS,
  2001: QS,
  2002: JS,
  2003: ZS,
  2004: Kb,
  3e3: XS,
  3003: qb
};
class e7 extends ES {
  constructor(e, n, r) {
    super(e.endsWith("/") ? e.slice(0, -1) : e, fetch), this.projectAccessKey = n, this.jwtAuth = r, this._fetch = (s, a) => {
      const i = {}, o = this.jwtAuth, c = this.projectAccessKey;
      return o && o.length > 0 && (i.Authorization = `BEARER ${o}`), c && c.length > 0 && (i["X-Access-Key"] = c), a.headers = Qd({}, a.headers, i), fetch(s, a);
    }, this.fetch = this._fetch;
  }
}
let se = /* @__PURE__ */ function(t) {
  return t.MAINNET = "mainnet", t.TESTNET = "testnet", t;
}({}), k = /* @__PURE__ */ function(t) {
  return t[t.MAINNET = 1] = "MAINNET", t[t.ROPSTEN = 3] = "ROPSTEN", t[t.RINKEBY = 4] = "RINKEBY", t[t.GOERLI = 5] = "GOERLI", t[t.KOVAN = 42] = "KOVAN", t[t.SEPOLIA = 11155111] = "SEPOLIA", t[t.POLYGON = 137] = "POLYGON", t[t.POLYGON_MUMBAI = 80001] = "POLYGON_MUMBAI", t[t.POLYGON_ZKEVM = 1101] = "POLYGON_ZKEVM", t[t.POLYGON_AMOY = 80002] = "POLYGON_AMOY", t[t.BSC = 56] = "BSC", t[t.BSC_TESTNET = 97] = "BSC_TESTNET", t[t.OPTIMISM = 10] = "OPTIMISM", t[t.OPTIMISM_KOVAN = 69] = "OPTIMISM_KOVAN", t[t.OPTIMISM_GOERLI = 420] = "OPTIMISM_GOERLI", t[t.OPTIMISM_SEPOLIA = 11155420] = "OPTIMISM_SEPOLIA", t[t.ARBITRUM = 42161] = "ARBITRUM", t[t.ARBITRUM_GOERLI = 421613] = "ARBITRUM_GOERLI", t[t.ARBITRUM_SEPOLIA = 421614] = "ARBITRUM_SEPOLIA", t[t.ARBITRUM_NOVA = 42170] = "ARBITRUM_NOVA", t[t.AVALANCHE = 43114] = "AVALANCHE", t[t.AVALANCHE_TESTNET = 43113] = "AVALANCHE_TESTNET", t[t.GNOSIS = 100] = "GNOSIS", t[t.BASE = 8453] = "BASE", t[t.BASE_GOERLI = 84531] = "BASE_GOERLI", t[t.BASE_SEPOLIA = 84532] = "BASE_SEPOLIA", t[t.HOMEVERSE_TESTNET = 40875] = "HOMEVERSE_TESTNET", t[t.HOMEVERSE = 19011] = "HOMEVERSE", t[t.XAI = 660279] = "XAI", t[t.XAI_SEPOLIA = 37714555429] = "XAI_SEPOLIA", t[t.TELOS = 40] = "TELOS", t[t.TELOS_TESTNET = 41] = "TELOS_TESTNET", t[t.B3 = 8333] = "B3", t[t.B3_SEPOLIA = 1993] = "B3_SEPOLIA", t[t.APECHAIN = 33139] = "APECHAIN", t[t.APECHAIN_TESTNET = 33111] = "APECHAIN_TESTNET", t[t.BLAST = 81457] = "BLAST", t[t.BLAST_SEPOLIA = 168587773] = "BLAST_SEPOLIA", t[t.BORNE_TESTNET = 94984] = "BORNE_TESTNET", t[t.SKALE_NEBULA = 1482601649] = "SKALE_NEBULA", t[t.SKALE_NEBULA_TESTNET = 37084624] = "SKALE_NEBULA_TESTNET", t[t.SONEIUM_MINATO = 1946] = "SONEIUM_MINATO", t[t.SONEIUM = 1868] = "SONEIUM", t[t.TOY_TESTNET = 21e6] = "TOY_TESTNET", t[t.IMMUTABLE_ZKEVM = 13371] = "IMMUTABLE_ZKEVM", t[t.IMMUTABLE_ZKEVM_TESTNET = 13473] = "IMMUTABLE_ZKEVM_TESTNET", t[t.ROOT_NETWORK = 7668] = "ROOT_NETWORK", t[t.ROOT_NETWORK_PORCINI = 7672] = "ROOT_NETWORK_PORCINI", t[t.HARDHAT = 31337] = "HARDHAT", t[t.HARDHAT_2 = 31338] = "HARDHAT_2", t[t.LAOS = 6283] = "LAOS", t[t.LAOS_SIGMA_TESTNET = 62850] = "LAOS_SIGMA_TESTNET", t[t.ETHERLINK = 42793] = "ETHERLINK", t[t.ETHERLINK_TESTNET = 128123] = "ETHERLINK_TESTNET", t[t.MOONBEAM = 1284] = "MOONBEAM", t[t.MOONBASE_ALPHA = 1287] = "MOONBASE_ALPHA", t[t.MONAD_TESTNET = 10143] = "MONAD_TESTNET", t[t.SOMNIA_TESTNET = 50312] = "SOMNIA_TESTNET", t[t.INCENTIV_TESTNET = 11690] = "INCENTIV_TESTNET", t;
}({});
const $m = {
  [k.MAINNET]: {
    chainId: k.MAINNET,
    type: se.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [k.ROPSTEN]: {
    chainId: k.ROPSTEN,
    type: se.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROPSTEN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.RINKEBY]: {
    chainId: k.RINKEBY,
    type: se.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.RINKEBY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.GOERLI]: {
    chainId: k.GOERLI,
    type: se.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: !0
  },
  [k.KOVAN]: {
    chainId: k.KOVAN,
    type: se.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.SEPOLIA]: {
    chainId: k.SEPOLIA,
    type: se.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.POLYGON]: {
    chainId: k.POLYGON,
    type: se.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "POL",
      name: "POL",
      decimals: 18
    }
  },
  [k.POLYGON_MUMBAI]: {
    chainId: k.POLYGON_MUMBAI,
    type: se.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_MUMBAI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: !0
  },
  [k.POLYGON_AMOY]: {
    chainId: k.POLYGON_AMOY,
    type: se.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_AMOY}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aPOL",
      name: "Amoy POL",
      decimals: 18
    }
  },
  [k.POLYGON_ZKEVM]: {
    chainId: k.POLYGON_ZKEVM,
    type: se.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BSC]: {
    chainId: k.BSC,
    type: se.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [k.BSC_TESTNET]: {
    chainId: k.BSC_TESTNET,
    type: se.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BSC_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [k.OPTIMISM]: {
    chainId: k.OPTIMISM,
    type: se.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.OPTIMISM_KOVAN]: {
    chainId: k.OPTIMISM_KOVAN,
    type: se.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_KOVAN}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.OPTIMISM_GOERLI]: {
    chainId: k.OPTIMISM_GOERLI,
    type: se.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.OPTIMISM_SEPOLIA]: {
    chainId: k.OPTIMISM_SEPOLIA,
    type: se.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.OPTIMISM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM]: {
    chainId: k.ARBITRUM,
    type: se.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM_GOERLI]: {
    chainId: k.ARBITRUM_GOERLI,
    type: se.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.ARBITRUM_SEPOLIA]: {
    chainId: k.ARBITRUM_SEPOLIA,
    type: se.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.ARBITRUM_NOVA]: {
    chainId: k.ARBITRUM_NOVA,
    type: se.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.AVALANCHE]: {
    chainId: k.AVALANCHE,
    type: se.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [k.AVALANCHE_TESTNET]: {
    chainId: k.AVALANCHE_TESTNET,
    type: se.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.AVALANCHE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [k.GNOSIS]: {
    chainId: k.GNOSIS,
    type: se.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [k.BASE]: {
    chainId: k.BASE,
    type: se.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BASE_GOERLI]: {
    chainId: k.BASE_GOERLI,
    type: se.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE_GOERLI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: !0
  },
  [k.BASE_SEPOLIA]: {
    chainId: k.BASE_SEPOLIA,
    type: se.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BASE_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [k.HOMEVERSE]: {
    chainId: k.HOMEVERSE,
    type: se.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [k.HOMEVERSE_TESTNET]: {
    chainId: k.HOMEVERSE_TESTNET,
    type: se.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.HOMEVERSE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [k.XAI]: {
    chainId: k.XAI,
    type: se.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [k.XAI_SEPOLIA]: {
    chainId: k.XAI_SEPOLIA,
    type: se.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.XAI_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [k.B3]: {
    chainId: k.B3,
    type: se.MAINNET,
    name: "b3",
    title: "B3",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.B3}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "B3 Explorer",
      rootUrl: "https://explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.B3_SEPOLIA]: {
    chainId: k.B3_SEPOLIA,
    type: se.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.B3_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.APECHAIN]: {
    chainId: k.APECHAIN,
    type: se.MAINNET,
    name: "apechain",
    title: "APE Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.APECHAIN}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://apechain.calderaexplorer.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [k.APECHAIN_TESTNET]: {
    chainId: k.APECHAIN_TESTNET,
    type: se.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.APECHAIN_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [k.BLAST]: {
    chainId: k.BLAST,
    type: se.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.BLAST_SEPOLIA]: {
    chainId: k.BLAST_SEPOLIA,
    type: se.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BLAST_SEPOLIA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.TELOS]: {
    chainId: k.TELOS,
    type: se.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [k.TELOS_TESTNET]: {
    chainId: k.TELOS_TESTNET,
    type: se.TESTNET,
    name: "telos-testnet",
    title: "Telos Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TELOS_TESTNET}.webp`,
    blockExplorer: {
      name: "Telos Testnet Explorer",
      rootUrl: "https://explorer-test.telos.net/network"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [k.BORNE_TESTNET]: {
    chainId: k.BORNE_TESTNET,
    type: se.TESTNET,
    name: "borne-testnet",
    title: "Borne Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.BORNE_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Borne Testnet Explorer",
      rootUrl: "https://subnets-test.avax.network/bornegfdn"
    },
    nativeToken: {
      symbol: "BORNE",
      name: "BORNE",
      decimals: 18
    }
  },
  [k.SKALE_NEBULA]: {
    chainId: k.SKALE_NEBULA,
    type: se.MAINNET,
    name: "skale-nebula",
    title: "SKALE Nebula Gaming Hub",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SKALE_NEBULA}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Explorer",
      rootUrl: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [k.SKALE_NEBULA_TESTNET]: {
    chainId: k.SKALE_NEBULA_TESTNET,
    type: se.TESTNET,
    name: "skale-nebula-testnet",
    title: "SKALE Nebula Gaming Hub Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SKALE_NEBULA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Testnet Explorer",
      rootUrl: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [k.SONEIUM]: {
    chainId: k.SONEIUM,
    type: se.MAINNET,
    name: "soneium",
    title: "Soneium",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SONEIUM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Soneium Explorer",
      rootUrl: "https://soneium.blockscout.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.SONEIUM_MINATO]: {
    chainId: k.SONEIUM_MINATO,
    type: se.TESTNET,
    name: "soneium-minato",
    title: "Soneium Minato (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SONEIUM_MINATO}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Soneium Minato Explorer",
      rootUrl: "https://explorer-testnet.soneium.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.TOY_TESTNET]: {
    chainId: k.TOY_TESTNET,
    type: se.TESTNET,
    name: "toy-testnet",
    title: "TOY (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.TOY_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "TOY Testnet Explorer",
      rootUrl: "https://toy-chain-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "TOY",
      name: "TOY",
      decimals: 18
    }
  },
  [k.IMMUTABLE_ZKEVM]: {
    chainId: k.IMMUTABLE_ZKEVM,
    type: se.MAINNET,
    name: "immutable-zkevm",
    title: "Immutable zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.IMMUTABLE_ZKEVM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Immutable zkEVM Explorer",
      rootUrl: "https://explorer.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [k.IMMUTABLE_ZKEVM_TESTNET]: {
    chainId: k.IMMUTABLE_ZKEVM_TESTNET,
    type: se.TESTNET,
    name: "immutable-zkevm-testnet",
    title: "Immutable zkEVM Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.IMMUTABLE_ZKEVM_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Immutable zkEVM Testnet Explorer",
      rootUrl: "https://explorer.testnet.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [k.ROOT_NETWORK]: {
    chainId: k.ROOT_NETWORK,
    type: se.MAINNET,
    name: "rootnet",
    title: "The Root Network",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROOT_NETWORK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "The Root Network Explorer",
      rootUrl: "https://rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [k.ROOT_NETWORK_PORCINI]: {
    chainId: k.ROOT_NETWORK_PORCINI,
    type: se.TESTNET,
    name: "rootnet-porcini",
    title: "The Root Network Porcini Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ROOT_NETWORK_PORCINI}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "The Root Network Porcini Testnet Explorer",
      rootUrl: "https://porcini.rootscan.io/"
    },
    nativeToken: {
      symbol: "XRP",
      name: "XRP",
      decimals: 18
    }
  },
  [k.HARDHAT]: {
    chainId: k.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.HARDHAT_2]: {
    chainId: k.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [k.LAOS]: {
    chainId: k.LAOS,
    type: se.MAINNET,
    name: "laos",
    title: "LAOS",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.LAOS}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "LAOS Explorer",
      rootUrl: "https://blockscout.laos.laosfoundation.io/"
    },
    nativeToken: {
      symbol: "LAOS",
      name: "LAOS",
      decimals: 18
    }
  },
  [k.LAOS_SIGMA_TESTNET]: {
    chainId: k.LAOS_SIGMA_TESTNET,
    type: se.TESTNET,
    name: "laos-sigma-testnet",
    title: "LAOS Sigma Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.LAOS_SIGMA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "LAOS Sigma Testnet Explorer",
      rootUrl: "https://sigma.explorer.laosnetwork.io/"
    },
    nativeToken: {
      symbol: "SIGMA",
      name: "SIGMA",
      decimals: 18
    }
  },
  [k.MOONBEAM]: {
    chainId: k.MOONBEAM,
    type: se.MAINNET,
    name: "moonbeam",
    title: "Moonbeam",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MOONBEAM}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Moonscan",
      rootUrl: "https://moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [k.MOONBASE_ALPHA]: {
    chainId: k.MOONBASE_ALPHA,
    type: se.TESTNET,
    name: "moonbase-alpha",
    title: "Moonbase Alpha",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MOONBASE_ALPHA}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Moonscan (Moonbase Alpha)",
      rootUrl: "https://moonbase.moonscan.io/"
    },
    nativeToken: {
      symbol: "GLMR",
      name: "GLMR",
      decimals: 18
    }
  },
  [k.ETHERLINK]: {
    chainId: k.ETHERLINK,
    type: se.MAINNET,
    name: "etherlink",
    title: "Etherlink",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ETHERLINK}.webp`,
    testnet: !1,
    blockExplorer: {
      name: "Etherlink Explorer",
      rootUrl: "https://explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [k.ETHERLINK_TESTNET]: {
    chainId: k.ETHERLINK_TESTNET,
    type: se.TESTNET,
    name: "etherlink-testnet",
    title: "Etherlink Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.ETHERLINK_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Etherlink Testnet Explorer",
      rootUrl: "https://testnet.explorer.etherlink.com/"
    },
    nativeToken: {
      symbol: "XTZ",
      name: "Tez",
      decimals: 18
    }
  },
  [k.MONAD_TESTNET]: {
    chainId: k.MONAD_TESTNET,
    type: se.TESTNET,
    name: "monad-testnet",
    title: "Monad Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.MONAD_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Monad Testnet Explorer",
      rootUrl: "https://testnet.monadexplorer.com/"
    },
    nativeToken: {
      symbol: "MON",
      name: "MON",
      decimals: 18
    }
  },
  [k.SOMNIA_TESTNET]: {
    chainId: k.SOMNIA_TESTNET,
    type: se.TESTNET,
    name: "somnia-testnet",
    title: "Somnia Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.SOMNIA_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Somnia Testnet Explorer",
      rootUrl: "https://shannon-explorer.somnia.network/"
    },
    nativeToken: {
      symbol: "STT",
      name: "STT",
      decimals: 18
    }
  },
  [k.INCENTIV_TESTNET]: {
    chainId: k.INCENTIV_TESTNET,
    type: se.TESTNET,
    name: "incentiv-testnet",
    title: "Incentiv Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${k.INCENTIV_TESTNET}.webp`,
    testnet: !0,
    blockExplorer: {
      name: "Incentiv Testnet Explorer",
      rootUrl: "https://explorer.testnet.incentiv.net/"
    },
    nativeToken: {
      symbol: "CENT",
      name: "CENT",
      decimals: 18
    }
  }
}, t7 = "6.14.4";
function n7(t, e, n) {
  const r = e.split("|").map((a) => a.trim());
  for (let a = 0; a < r.length; a++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof t === e)
          return;
    }
  const s = new Error(`invalid value for type ${e}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${n}`, s.value = t, s;
}
async function ot(t) {
  const e = Object.keys(t);
  return (await Promise.all(e.map((r) => Promise.resolve(t[r])))).reduce((r, s, a) => (r[e[a]] = s, r), {});
}
function oe(t, e, n) {
  for (let r in e) {
    let s = e[r];
    const a = n ? n[r] : null;
    a && n7(s, a, r), Object.defineProperty(t, r, { enumerable: !0, value: s, writable: !1 });
  }
}
function _i(t, e) {
  if (t == null)
    return "null";
  if (e == null && (e = /* @__PURE__ */ new Set()), typeof t == "object") {
    if (e.has(t))
      return "[Circular]";
    e.add(t);
  }
  if (Array.isArray(t))
    return "[ " + t.map((n) => _i(n, e)).join(", ") + " ]";
  if (t instanceof Uint8Array) {
    const n = "0123456789abcdef";
    let r = "0x";
    for (let s = 0; s < t.length; s++)
      r += n[t[s] >> 4], r += n[t[s] & 15];
    return r;
  }
  if (typeof t == "object" && typeof t.toJSON == "function")
    return _i(t.toJSON(), e);
  switch (typeof t) {
    case "boolean":
    case "number":
    case "symbol":
      return t.toString();
    case "bigint":
      return BigInt(t).toString();
    case "string":
      return JSON.stringify(t);
    case "object": {
      const n = Object.keys(t);
      return n.sort(), "{ " + n.map((r) => `${_i(r, e)}: ${_i(t[r], e)}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function dt(t, e) {
  return t && t.code === e;
}
function Wb(t) {
  return dt(t, "CALL_EXCEPTION");
}
function $e(t, e, n) {
  let r = t;
  {
    const a = [];
    if (n) {
      if ("message" in n || "code" in n || "name" in n)
        throw new Error(`value will overwrite populated values: ${_i(n)}`);
      for (const i in n) {
        if (i === "shortMessage")
          continue;
        const o = n[i];
        a.push(i + "=" + _i(o));
      }
    }
    a.push(`code=${e}`), a.push(`version=${t7}`), a.length && (t += " (" + a.join(", ") + ")");
  }
  let s;
  switch (e) {
    case "INVALID_ARGUMENT":
      s = new TypeError(t);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(t);
      break;
    default:
      s = new Error(t);
  }
  return oe(s, { code: e }), n && Object.assign(s, n), s.shortMessage == null && oe(s, { shortMessage: r }), s;
}
function K(t, e, n, r) {
  if (!t)
    throw $e(e, n, r);
}
function S(t, e, n, r) {
  K(t, e, "INVALID_ARGUMENT", { argument: n, value: r });
}
function j2(t, e, n) {
  n == null && (n = ""), n && (n = ": " + n), K(t >= e, "missing argument" + n, "MISSING_ARGUMENT", {
    count: t,
    expectedCount: e
  }), K(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
    count: t,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    t.push(e);
  } catch {
  }
  return t;
}, []);
function qf(t, e, n) {
  if (n == null && (n = ""), t !== e) {
    let r = n, s = "new";
    n && (r += ".", s += " " + n), K(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function K2(t, e, n) {
  if (t instanceof Uint8Array)
    return n ? new Uint8Array(t) : t;
  if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r = new Uint8Array((t.length - 2) / 2);
    let s = 2;
    for (let a = 0; a < r.length; a++)
      r[a] = parseInt(t.substring(s, s + 2), 16), s += 2;
    return r;
  }
  S(!1, "invalid BytesLike value", e || "value", t);
}
function Q(t, e) {
  return K2(t, e, !1);
}
function $t(t, e) {
  return K2(t, e, !0);
}
function Ue(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === !0 && t.length % 2 !== 0);
}
function Ei(t) {
  return Ue(t, !0) || t instanceof Uint8Array;
}
const u1 = "0123456789abcdef";
function V(t) {
  const e = Q(t);
  let n = "0x";
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    n += u1[(s & 240) >> 4] + u1[s & 15];
  }
  return n;
}
function Le(t) {
  return "0x" + t.map((e) => V(e).substring(2)).join("");
}
function ai(t) {
  return Ue(t, !0) ? (t.length - 2) / 2 : Q(t).length;
}
function _e(t, e, n) {
  const r = Q(t);
  return n != null && n > r.length && K(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: r,
    length: r.length,
    offset: n
  }), V(r.slice(e ?? 0, n ?? r.length));
}
function q2(t, e, n) {
  const r = Q(t);
  K(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: e,
    offset: e + 1
  });
  const s = new Uint8Array(e);
  return s.fill(0), n ? s.set(r, e - r.length) : s.set(r, 0), V(s);
}
function fn(t, e) {
  return q2(t, e, !0);
}
function W2(t, e) {
  return q2(t, e, !1);
}
const Wf = BigInt(0), Qn = BigInt(1), Gi = 9007199254740991;
function r7(t, e) {
  const n = Qf(t, "value"), r = BigInt(ge(e, "width"));
  if (K(n >> r === Wf, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: t
  }), n >> r - Qn) {
    const s = (Qn << r) - Qn;
    return -((~n & s) + Qn);
  }
  return n;
}
function Qb(t, e) {
  let n = ne(t, "value");
  const r = BigInt(ge(e, "width")), s = Qn << r - Qn;
  if (n < Wf) {
    n = -n, K(n <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
    const a = (Qn << r) - Qn;
    return (~n & a) + Qn;
  } else
    K(n < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
  return n;
}
function Yc(t, e) {
  const n = Qf(t, "value"), r = BigInt(ge(e, "bits"));
  return n & (Qn << r) - Qn;
}
function ne(t, e) {
  switch (typeof t) {
    case "bigint":
      return t;
    case "number":
      return S(Number.isInteger(t), "underflow", e || "value", t), S(t >= -Gi && t <= Gi, "overflow", e || "value", t), BigInt(t);
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t);
      } catch (n) {
        S(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t);
      }
  }
  S(!1, "invalid BigNumberish value", e || "value", t);
}
function Qf(t, e) {
  const n = ne(t, e);
  return K(n >= Wf, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: t
  }), n;
}
const d1 = "0123456789abcdef";
function Jb(t) {
  if (t instanceof Uint8Array) {
    let e = "0x0";
    for (const n of t)
      e += d1[n >> 4], e += d1[n & 15];
    return BigInt(e);
  }
  return ne(t);
}
function ge(t, e) {
  switch (typeof t) {
    case "bigint":
      return S(t >= -Gi && t <= Gi, "overflow", e || "value", t), Number(t);
    case "number":
      return S(Number.isInteger(t), "underflow", e || "value", t), S(t >= -Gi && t <= Gi, "overflow", e || "value", t), t;
    case "string":
      try {
        if (t === "")
          throw new Error("empty string");
        return ge(BigInt(t), e);
      } catch (n) {
        S(!1, `invalid numeric string: ${n.message}`, e || "value", t);
      }
  }
  S(!1, "invalid numeric value", e || "value", t);
}
function s7(t) {
  return ge(Jb(t));
}
function Zn(t, e) {
  let r = Qf(t, "value").toString(16);
  if (e == null)
    r.length % 2 && (r = "0" + r);
  else {
    const s = ge(e, "width");
    for (K(s * 2 >= r.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: t
    }); r.length < s * 2; )
      r = "0" + r;
  }
  return "0x" + r;
}
function Xe(t) {
  const e = Qf(t, "value");
  if (e === Wf)
    return new Uint8Array([]);
  let n = e.toString(16);
  n.length % 2 && (n = "0" + n);
  const r = new Uint8Array(n.length / 2);
  for (let s = 0; s < r.length; s++) {
    const a = s * 2;
    r[s] = parseInt(n.substring(a, a + 2), 16);
  }
  return r;
}
function qn(t) {
  let e = V(Ei(t) ? t : Xe(t)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const f1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const p1 = BigInt(58);
function a7(t) {
  const e = Q(t);
  let n = Jb(e), r = "";
  for (; n; )
    r = f1[Number(n % p1)] + r, n /= p1;
  for (let s = 0; s < e.length && !e[s]; s++)
    r = f1[0] + r;
  return r;
}
function i7(t) {
  t = atob(t);
  const e = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    e[n] = t.charCodeAt(n);
  return Q(e);
}
function o7(t) {
  const e = Q(t);
  let n = "";
  for (let r = 0; r < e.length; r++)
    n += String.fromCharCode(e[r]);
  return btoa(n);
}
var bo;
class Q2 {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, n, r) {
    /**
     *  The event filter.
     */
    F(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    F(this, "emitter");
    B(this, bo);
    E(this, bo, n), oe(this, { emitter: e, filter: r });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    m(this, bo) != null && await this.emitter.off(this.filter, m(this, bo));
  }
}
bo = new WeakMap();
function c7(t, e, n, r, s) {
  S(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
}
function J2(t, e, n, r, s) {
  if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
    let a = 0;
    for (let i = e + 1; i < n.length && n[i] >> 6 === 2; i++)
      a++;
    return a;
  }
  return t === "OVERRUN" ? n.length - e - 1 : 0;
}
function l7(t, e, n, r, s) {
  return t === "OVERLONG" ? (S(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), r.push(s), 0) : (r.push(65533), J2(t, e, n));
}
const u7 = Object.freeze({
  error: c7,
  ignore: J2,
  replace: l7
});
function d7(t, e) {
  e == null && (e = u7.error);
  const n = Q(t, "bytes"), r = [];
  let s = 0;
  for (; s < n.length; ) {
    const a = n[s++];
    if (!(a >> 7)) {
      r.push(a);
      continue;
    }
    let i = null, o = null;
    if ((a & 224) === 192)
      i = 1, o = 127;
    else if ((a & 240) === 224)
      i = 2, o = 2047;
    else if ((a & 248) === 240)
      i = 3, o = 65535;
    else {
      (a & 192) === 128 ? s += e("UNEXPECTED_CONTINUE", s - 1, n, r) : s += e("BAD_PREFIX", s - 1, n, r);
      continue;
    }
    if (s - 1 + i >= n.length) {
      s += e("OVERRUN", s - 1, n, r);
      continue;
    }
    let c = a & (1 << 8 - i - 1) - 1;
    for (let u = 0; u < i; u++) {
      let l = n[s];
      if ((l & 192) != 128) {
        s += e("MISSING_CONTINUE", s, n, r), c = null;
        break;
      }
      c = c << 6 | l & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += e("OUT_OF_RANGE", s - 1 - i, n, r, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += e("UTF16_SURROGATE", s - 1 - i, n, r, c);
        continue;
      }
      if (c <= o) {
        s += e("OVERLONG", s - 1 - i, n, r, c);
        continue;
      }
      r.push(c);
    }
  }
  return r;
}
function Yt(t, e) {
  S(typeof t == "string", "invalid string value", "str", t);
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t.charCodeAt(r);
    if (s < 128)
      n.push(s);
    else if (s < 2048)
      n.push(s >> 6 | 192), n.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      r++;
      const a = t.charCodeAt(r);
      S(r < t.length && (a & 64512) === 56320, "invalid surrogate pair", "str", t);
      const i = 65536 + ((s & 1023) << 10) + (a & 1023);
      n.push(i >> 18 | 240), n.push(i >> 12 & 63 | 128), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
    } else
      n.push(s >> 12 | 224), n.push(s >> 6 & 63 | 128), n.push(s & 63 | 128);
  }
  return new Uint8Array(n);
}
function f7(t) {
  return t.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function Jd(t, e) {
  return f7(d7(t, e));
}
function Z2(t) {
  async function e(n, r) {
    K(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
    const s = n.url.split(":")[0].toLowerCase();
    K(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), K(s === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let a = null;
    const i = new AbortController(), o = setTimeout(() => {
      a = $e("request timeout", "TIMEOUT"), i.abort();
    }, n.timeout);
    r && r.addListener(() => {
      a = $e("request cancelled", "CANCELLED"), i.abort();
    });
    const c = Object.assign({}, t, {
      method: n.method,
      headers: new Headers(Array.from(n)),
      body: n.body || void 0,
      signal: i.signal
    });
    let u;
    try {
      u = await fetch(n.url, c);
    } catch (h) {
      throw clearTimeout(o), a || h;
    }
    clearTimeout(o);
    const l = {};
    u.headers.forEach((h, y) => {
      l[y.toLowerCase()] = h;
    });
    const d = await u.arrayBuffer(), f = d == null ? null : new Uint8Array(d);
    return {
      statusCode: u.status,
      statusMessage: u.statusText,
      headers: l,
      body: f
    };
  }
  return e;
}
const p7 = 12, h7 = 250;
let h1 = Z2();
const m7 = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), b7 = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let bh = !1;
async function X2(t, e) {
  try {
    const n = t.match(m7);
    if (!n)
      throw new Error("invalid data");
    return new Ks(200, "OK", {
      "content-type": n[1] || "text/plain"
    }, n[2] ? i7(n[3]) : g7(n[3]));
  } catch {
    return new Ks(599, "BAD REQUEST (invalid data: URI)", {}, null, new Cr(t));
  }
}
function Y2(t) {
  async function e(n, r) {
    try {
      const s = n.match(b7);
      if (!s)
        throw new Error("invalid link");
      return new Cr(`${t}${s[2]}`);
    } catch {
      return new Ks(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Cr(n));
    }
  }
  return e;
}
const Du = {
  data: X2,
  ipfs: Y2("https://gateway.ipfs.io/ipfs/")
}, e6 = /* @__PURE__ */ new WeakMap();
var La, Ts;
class y7 {
  constructor(e) {
    B(this, La);
    B(this, Ts);
    E(this, La, []), E(this, Ts, !1), e6.set(e, () => {
      if (!m(this, Ts)) {
        E(this, Ts, !0);
        for (const n of m(this, La))
          setTimeout(() => {
            n();
          }, 0);
        E(this, La, []);
      }
    });
  }
  addListener(e) {
    K(!m(this, Ts), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), m(this, La).push(e);
  }
  get cancelled() {
    return m(this, Ts);
  }
  checkSignal() {
    K(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
La = new WeakMap(), Ts = new WeakMap();
function Lu(t) {
  if (t == null)
    throw new Error("missing signal; should not happen");
  return t.checkSignal(), t;
}
var yo, go, _n, Gr, wo, Eo, tt, cn, zr, Ha, $a, _a, pr, Gn, Ss, Ga, el;
const Pf = class Pf {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    B(this, Ga);
    B(this, yo);
    B(this, go);
    B(this, _n);
    B(this, Gr);
    B(this, wo);
    B(this, Eo);
    B(this, tt);
    B(this, cn);
    B(this, zr);
    // Hooks
    B(this, Ha);
    B(this, $a);
    B(this, _a);
    B(this, pr);
    B(this, Gn);
    B(this, Ss);
    E(this, Eo, String(e)), E(this, yo, !1), E(this, go, !0), E(this, _n, {}), E(this, Gr, ""), E(this, wo, 3e5), E(this, Gn, {
      slotInterval: h7,
      maxAttempts: p7
    }), E(this, Ss, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return m(this, Eo);
  }
  set url(e) {
    E(this, Eo, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return m(this, tt) == null ? null : new Uint8Array(m(this, tt));
  }
  set body(e) {
    if (e == null)
      E(this, tt, void 0), E(this, cn, void 0);
    else if (typeof e == "string")
      E(this, tt, Yt(e)), E(this, cn, "text/plain");
    else if (e instanceof Uint8Array)
      E(this, tt, e), E(this, cn, "application/octet-stream");
    else if (typeof e == "object")
      E(this, tt, Yt(JSON.stringify(e))), E(this, cn, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return m(this, tt) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return m(this, Gr) ? m(this, Gr) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), E(this, Gr, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, m(this, _n));
    return m(this, zr) && (e.authorization = `Basic ${o7(Yt(m(this, zr)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && m(this, cn) && (e["content-type"] = m(this, cn)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, n) {
    m(this, _n)[String(e).toLowerCase()] = String(n);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    E(this, _n, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return m(this, zr) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, n) {
    S(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), E(this, zr, `${e}:${n}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return m(this, go);
  }
  set allowGzip(e) {
    E(this, go, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!m(this, yo);
  }
  set allowInsecureAuthentication(e) {
    E(this, yo, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return m(this, wo);
  }
  set timeout(e) {
    S(e >= 0, "timeout must be non-zero", "timeout", e), E(this, wo, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return m(this, Ha) || null;
  }
  set preflightFunc(e) {
    E(this, Ha, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return m(this, $a) || null;
  }
  set processFunc(e) {
    E(this, $a, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return m(this, _a) || null;
  }
  set retryFunc(e) {
    E(this, _a, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return m(this, Ss) || h1;
  }
  set getUrlFunc(e) {
    E(this, Ss, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${m(this, tt) ? V(m(this, tt)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (m(this, Gn).slotInterval = e.slotInterval), e.maxAttempts != null && (m(this, Gn).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return K(m(this, pr) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), E(this, pr, new y7(this)), z(this, Ga, el).call(this, 0, m1() + this.timeout, 0, this, new Ks(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    K(m(this, pr) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = e6.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const n = this.url.split(":")[0].toLowerCase(), r = e.split(":")[0].toLowerCase();
    K(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const s = new Pf(e);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, E(s, _n, Object.assign({}, m(this, _n))), m(this, tt) && E(s, tt, new Uint8Array(m(this, tt))), E(s, cn, m(this, cn)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new Pf(this.url);
    return E(e, Gr, m(this, Gr)), m(this, tt) && E(e, tt, m(this, tt)), E(e, cn, m(this, cn)), E(e, _n, Object.assign({}, m(this, _n))), E(e, zr, m(this, zr)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), E(e, Ha, m(this, Ha)), E(e, $a, m(this, $a)), E(e, _a, m(this, _a)), E(e, Gn, Object.assign({}, m(this, Gn))), E(e, Ss, m(this, Ss)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    bh = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return Du[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, n) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (bh)
      throw new Error("gateways locked");
    Du[e] = n;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (bh)
      throw new Error("gateways locked");
    h1 = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return Z2(e);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return X2;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return Y2(e);
  }
};
yo = new WeakMap(), go = new WeakMap(), _n = new WeakMap(), Gr = new WeakMap(), wo = new WeakMap(), Eo = new WeakMap(), tt = new WeakMap(), cn = new WeakMap(), zr = new WeakMap(), Ha = new WeakMap(), $a = new WeakMap(), _a = new WeakMap(), pr = new WeakMap(), Gn = new WeakMap(), Ss = new WeakMap(), Ga = new WeakSet(), el = async function(e, n, r, s, a) {
  var l, d, f;
  if (e >= m(this, Gn).maxAttempts)
    return a.makeServerError("exceeded maximum retry limit");
  K(m1() <= n, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), r > 0 && await w7(r);
  let i = this.clone();
  const o = (i.url.split(":")[0] || "").toLowerCase();
  if (o in Du) {
    const h = await Du[o](i.url, Lu(m(s, pr)));
    if (h instanceof Ks) {
      let y = h;
      if (this.processFunc) {
        Lu(m(s, pr));
        try {
          y = await this.processFunc(i, y);
        } catch (b) {
          (b.throttle == null || typeof b.stall != "number") && y.makeServerError("error in post-processing function", b).assertOk();
        }
      }
      return y;
    }
    i = h;
  }
  this.preflightFunc && (i = await this.preflightFunc(i));
  const c = await this.getUrlFunc(i, Lu(m(s, pr)));
  let u = new Ks(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const h = u.headers.location || "";
      return z(l = i.redirect(h), Ga, el).call(l, e + 1, n, 0, s, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(i, u, e))) {
    const h = u.headers["retry-after"];
    let y = m(this, Gn).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
    return typeof h == "string" && h.match(/^[1-9][0-9]*$/) && (y = parseInt(h)), z(d = i.clone(), Ga, el).call(d, e + 1, n, y, s, u);
  }
  if (this.processFunc) {
    Lu(m(s, pr));
    try {
      u = await this.processFunc(i, u);
    } catch (h) {
      (h.throttle == null || typeof h.stall != "number") && u.makeServerError("error in post-processing function", h).assertOk();
      let y = m(this, Gn).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return h.stall >= 0 && (y = h.stall), z(f = i.clone(), Ga, el).call(f, e + 1, n, y, s, u);
    }
  }
  return u;
};
let Cr = Pf;
var Xl, Yl, eu, ln, xo, za;
const Bg = class Bg {
  constructor(e, n, r, s, a) {
    B(this, Xl);
    B(this, Yl);
    B(this, eu);
    B(this, ln);
    B(this, xo);
    B(this, za);
    E(this, Xl, e), E(this, Yl, n), E(this, eu, Object.keys(r).reduce((i, o) => (i[o.toLowerCase()] = String(r[o]), i), {})), E(this, ln, s == null ? null : new Uint8Array(s)), E(this, xo, a || null), E(this, za, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${m(this, ln) ? V(m(this, ln)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return m(this, Xl);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return m(this, Yl);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, m(this, eu));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return m(this, ln) == null ? null : new Uint8Array(m(this, ln));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return m(this, ln) == null ? "" : Jd(m(this, ln));
    } catch {
      K(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      K(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, n = Object.keys(e);
    let r = 0;
    return {
      next: () => {
        if (r < n.length) {
          const s = n[r++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, n) {
    let r;
    e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const s = new Bg(599, r, this.headers, this.body, m(this, xo) || void 0);
    return E(s, za, { message: e, error: n }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, n) {
    n == null ? n = -1 : S(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
    const r = new Error(e || "throttling requests");
    throw oe(r, { stall: n, throttle: !0 }), r;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return m(this, ln) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return m(this, xo);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return m(this, za).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: n } = m(this, za);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let r = null;
    this.request && (r = this.request.url);
    let s = null;
    try {
      m(this, ln) && (s = Jd(m(this, ln)));
    } catch {
    }
    K(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: n,
      info: {
        requestUrl: r,
        responseBody: s,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
Xl = new WeakMap(), Yl = new WeakMap(), eu = new WeakMap(), ln = new WeakMap(), xo = new WeakMap(), za = new WeakMap();
let Ks = Bg;
function m1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function g7(t) {
  return Yt(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))));
}
function w7(t) {
  return new Promise((e) => setTimeout(e, t));
}
function E7(t) {
  let e = t.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function b1(t, e, n) {
  let r = 0;
  for (let s = 0; s < n; s++)
    r = r * 256 + t[e + s];
  return r;
}
function y1(t, e, n, r) {
  const s = [];
  for (; n < e + 1 + r; ) {
    const a = t6(t, n);
    s.push(a.result), n += a.consumed, K(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: r,
      offset: e
    });
  }
  return { consumed: 1 + r, result: s };
}
function t6(t, e) {
  K(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: t,
    length: 0,
    offset: 1
  });
  const n = (r) => {
    K(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: t.length,
      offset: r
    });
  };
  if (t[e] >= 248) {
    const r = t[e] - 247;
    n(e + 1 + r);
    const s = b1(t, e + 1, r);
    return n(e + 1 + r + s), y1(t, e, e + 1 + r, r + s);
  } else if (t[e] >= 192) {
    const r = t[e] - 192;
    return n(e + 1 + r), y1(t, e, e + 1, r);
  } else if (t[e] >= 184) {
    const r = t[e] - 183;
    n(e + 1 + r);
    const s = b1(t, e + 1, r);
    n(e + 1 + r + s);
    const a = V(t.slice(e + 1 + r, e + 1 + r + s));
    return { consumed: 1 + r + s, result: a };
  } else if (t[e] >= 128) {
    const r = t[e] - 128;
    n(e + 1 + r);
    const s = V(t.slice(e + 1, e + 1 + r));
    return { consumed: 1 + r, result: s };
  }
  return { consumed: 1, result: E7(t[e]) };
}
function hu(t) {
  const e = Q(t, "data"), n = t6(e, 0);
  return S(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result;
}
function g1(t) {
  const e = [];
  for (; t; )
    e.unshift(t & 255), t >>= 8;
  return e;
}
function n6(t) {
  if (Array.isArray(t)) {
    let r = [];
    if (t.forEach(function(a) {
      r = r.concat(n6(a));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const s = g1(r.length);
    return s.unshift(247 + s.length), s.concat(r);
  }
  const e = Array.prototype.slice.call(Q(t, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const n = g1(e.length);
  return n.unshift(183 + n.length), n.concat(e);
}
const w1 = "0123456789abcdef";
function ta(t) {
  let e = "0x";
  for (const n of n6(t))
    e += w1[n >> 4], e += w1[n & 15];
  return e;
}
const _t = 32, _m = new Uint8Array(_t), x7 = ["then"], Hu = {}, r6 = /* @__PURE__ */ new WeakMap();
function da(t) {
  return r6.get(t);
}
function E1(t, e) {
  r6.set(t, e);
}
function Fc(t, e) {
  const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
  throw n.error = e, n;
}
function Gm(t, e, n) {
  return t.indexOf(null) >= 0 ? e.map((r, s) => r instanceof ic ? Gm(da(r), r, n) : r) : t.reduce((r, s, a) => {
    let i = e.getValue(s);
    return s in r || (n && i instanceof ic && (i = Gm(da(i), i, n)), r[s] = i), r;
  }, {});
}
var Ao;
const Ki = class Ki extends Array {
  /**
   *  @private
   */
  constructor(...n) {
    const r = n[0];
    let s = n[1], a = (n[2] || []).slice(), i = !0;
    r !== Hu && (s = n, a = [], i = !1);
    super(s.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    B(this, Ao);
    s.forEach((u, l) => {
      this[l] = u;
    });
    const o = a.reduce((u, l) => (typeof l == "string" && u.set(l, (u.get(l) || 0) + 1), u), /* @__PURE__ */ new Map());
    if (E1(this, Object.freeze(s.map((u, l) => {
      const d = a[l];
      return d != null && o.get(d) === 1 ? d : null;
    }))), E(this, Ao, []), m(this, Ao) == null && m(this, Ao), !i)
      return;
    Object.freeze(this);
    const c = new Proxy(this, {
      get: (u, l, d) => {
        if (typeof l == "string") {
          if (l.match(/^[0-9]+$/)) {
            const h = ge(l, "%index");
            if (h < 0 || h >= this.length)
              throw new RangeError("out of result range");
            const y = u[h];
            return y instanceof Error && Fc(`index ${h}`, y), y;
          }
          if (x7.indexOf(l) >= 0)
            return Reflect.get(u, l, d);
          const f = u[l];
          if (f instanceof Function)
            return function(...h) {
              return f.apply(this === d ? u : this, h);
            };
          if (!(l in u))
            return u.getValue.apply(this === d ? u : this, [l]);
        }
        return Reflect.get(u, l, d);
      }
    });
    return E1(c, da(this)), c;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(n) {
    const r = [];
    return this.forEach((s, a) => {
      s instanceof Error && Fc(`index ${a}`, s), n && s instanceof Ki && (s = s.toArray(n)), r.push(s);
    }), r;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(n) {
    const r = da(this);
    return r.reduce((s, a, i) => (K(a != null, `value at index ${i} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), Gm(r, this, n)), {});
  }
  /**
   *  @_ignore
   */
  slice(n, r) {
    n == null && (n = 0), n < 0 && (n += this.length, n < 0 && (n = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
    const s = da(this), a = [], i = [];
    for (let o = n; o < r; o++)
      a.push(this[o]), i.push(s[o]);
    return new Ki(Hu, a, i);
  }
  /**
   *  @_ignore
   */
  filter(n, r) {
    const s = da(this), a = [], i = [];
    for (let o = 0; o < this.length; o++) {
      const c = this[o];
      c instanceof Error && Fc(`index ${o}`, c), n.call(r, c, o, this) && (a.push(c), i.push(s[o]));
    }
    return new Ki(Hu, a, i);
  }
  /**
   *  @_ignore
   */
  map(n, r) {
    const s = [];
    for (let a = 0; a < this.length; a++) {
      const i = this[a];
      i instanceof Error && Fc(`index ${a}`, i), s.push(n.call(r, i, a, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(n) {
    const r = da(this).indexOf(n);
    if (r === -1)
      return;
    const s = this[r];
    return s instanceof Error && Fc(`property ${JSON.stringify(n)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(n, r) {
    return new Ki(Hu, n, r);
  }
};
Ao = new WeakMap();
let ic = Ki;
function x1(t) {
  let e = Xe(t);
  return K(e.length <= _t, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: _t, offset: e.length }), e.length !== _t && (e = $t(Le([_m.slice(e.length % _t), e]))), e;
}
class is {
  constructor(e, n, r, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    F(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    F(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    F(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    F(this, "dynamic");
    oe(this, { name: e, type: n, localName: r, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, n) {
    S(!1, e, this.localName, n);
  }
}
var Vr, Va, vo, kd;
class zm {
  constructor() {
    B(this, vo);
    // An array of WordSize lengthed objects to concatenation
    B(this, Vr);
    B(this, Va);
    E(this, Vr, []), E(this, Va, 0);
  }
  get data() {
    return Le(m(this, Vr));
  }
  get length() {
    return m(this, Va);
  }
  appendWriter(e) {
    return z(this, vo, kd).call(this, $t(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let n = $t(e);
    const r = n.length % _t;
    return r && (n = $t(Le([n, _m.slice(r)]))), z(this, vo, kd).call(this, n);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return z(this, vo, kd).call(this, x1(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = m(this, Vr).length;
    return m(this, Vr).push(_m), E(this, Va, m(this, Va) + _t), (n) => {
      m(this, Vr)[e] = x1(n);
    };
  }
}
Vr = new WeakMap(), Va = new WeakMap(), vo = new WeakSet(), kd = function(e) {
  return m(this, Vr).push(e), E(this, Va, m(this, Va) + e.length), e.length;
};
var qt, un, ja, Ka, Os, Si, jm, s6;
const Pg = class Pg {
  constructor(e, n, r) {
    B(this, Si);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    F(this, "allowLoose");
    B(this, qt);
    B(this, un);
    B(this, ja);
    B(this, Ka);
    B(this, Os);
    oe(this, { allowLoose: !!n }), E(this, qt, $t(e)), E(this, ja, 0), E(this, Ka, null), E(this, Os, r ?? 1024), E(this, un, 0);
  }
  get data() {
    return V(m(this, qt));
  }
  get dataLength() {
    return m(this, qt).length;
  }
  get consumed() {
    return m(this, un);
  }
  get bytes() {
    return new Uint8Array(m(this, qt));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const n = new Pg(m(this, qt).slice(m(this, un) + e), this.allowLoose, m(this, Os));
    return E(n, Ka, this), n;
  }
  // Read bytes
  readBytes(e, n) {
    let r = z(this, Si, s6).call(this, 0, e, !!n);
    return z(this, Si, jm).call(this, e), E(this, un, m(this, un) + r.length), r.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return Jb(this.readBytes(_t));
  }
  readIndex() {
    return s7(this.readBytes(_t));
  }
};
qt = new WeakMap(), un = new WeakMap(), ja = new WeakMap(), Ka = new WeakMap(), Os = new WeakMap(), Si = new WeakSet(), jm = function(e) {
  var n;
  if (m(this, Ka))
    return z(n = m(this, Ka), Si, jm).call(n, e);
  E(this, ja, m(this, ja) + e), K(m(this, Os) < 1 || m(this, ja) <= m(this, Os) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${m(this, Os)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: $t(m(this, qt)),
    offset: m(this, un),
    length: e,
    info: {
      bytesRead: m(this, ja),
      dataLength: this.dataLength
    }
  });
}, s6 = function(e, n, r) {
  let s = Math.ceil(n / _t) * _t;
  return m(this, un) + s > m(this, qt).length && (this.allowLoose && r && m(this, un) + n <= m(this, qt).length ? s = n : K(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: $t(m(this, qt)),
    length: m(this, qt).length,
    offset: m(this, un) + s
  })), m(this, qt).slice(m(this, un), m(this, un) + s);
};
let Vm = Pg;
function Zd(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`Wrong positive integer: ${t}`);
}
function Zb(t, ...e) {
  if (!(t instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
}
function A7(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Zd(t.outputLen), Zd(t.blockLen);
}
function oc(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function a6(t, e) {
  Zb(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const yh = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const i6 = (t) => t instanceof Uint8Array, v7 = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), gh = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), or = (t, e) => t << 32 - e | t >>> e, k7 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!k7)
  throw new Error("Non little-endian hardware is not supported");
function C7(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Jf(t) {
  if (typeof t == "string" && (t = C7(t)), !i6(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
function T7(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!i6(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
class Xb {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Yb(t) {
  const e = (r) => t().update(Jf(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
function S7(t = 32) {
  if (yh && typeof yh.getRandomValues == "function")
    return yh.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
class o6 extends Xb {
  constructor(e, n) {
    super(), this.finished = !1, this.destroyed = !1, A7(e);
    const r = Jf(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, a = new Uint8Array(s);
    a.set(r.length > s ? e.create().update(r).digest() : r);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = e.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(e) {
    return oc(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    oc(this), Zb(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: a, blockLen: i, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = a, e.blockLen = i, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const c6 = (t, e, n) => new o6(t, e).update(n).digest();
c6.create = (t, e) => new o6(t, e);
function O7(t, e, n, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, n, r);
  const s = BigInt(32), a = BigInt(4294967295), i = Number(n >> s & a), o = Number(n & a), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, i, r), t.setUint32(e + u, o, r);
}
class l6 extends Xb {
  constructor(e, n, r, s) {
    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = gh(this.buffer);
  }
  update(e) {
    oc(this);
    const { view: n, buffer: r, blockLen: s } = this;
    e = Jf(e);
    const a = e.length;
    for (let i = 0; i < a; ) {
      const o = Math.min(s - this.pos, a - i);
      if (o === s) {
        const c = gh(e);
        for (; s <= a - i; i += s)
          this.process(c, i);
        continue;
      }
      r.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    oc(this), a6(e, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: s, isLE: a } = this;
    let { pos: i } = this;
    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > s - i && (this.process(r, 0), i = 0);
    for (let d = i; d < s; d++)
      n[d] = 0;
    O7(r, s - 8, BigInt(this.length * 8), a), this.process(r, 0);
    const o = gh(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      o.setUint32(4 * d, l[d], a);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: a, destroyed: i, pos: o } = this;
    return e.length = s, e.pos = o, e.finished = a, e.destroyed = i, s % n && e.buffer.set(r), e;
  }
}
const B7 = (t, e, n) => t & e ^ ~t & n, P7 = (t, e, n) => t & e ^ t & n ^ e & n, I7 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ps = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), hs = /* @__PURE__ */ new Uint32Array(64);
class U7 extends l6 {
  constructor() {
    super(64, 32, 8, !1), this.A = ps[0] | 0, this.B = ps[1] | 0, this.C = ps[2] | 0, this.D = ps[3] | 0, this.E = ps[4] | 0, this.F = ps[5] | 0, this.G = ps[6] | 0, this.H = ps[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: a, F: i, G: o, H: c } = this;
    return [e, n, r, s, a, i, o, c];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = a | 0, this.F = i | 0, this.G = o | 0, this.H = c | 0;
  }
  process(e, n) {
    for (let d = 0; d < 16; d++, n += 4)
      hs[d] = e.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = hs[d - 15], h = hs[d - 2], y = or(f, 7) ^ or(f, 18) ^ f >>> 3, b = or(h, 17) ^ or(h, 19) ^ h >>> 10;
      hs[d] = b + hs[d - 7] + y + hs[d - 16] | 0;
    }
    let { A: r, B: s, C: a, D: i, E: o, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = or(o, 6) ^ or(o, 11) ^ or(o, 25), h = l + f + B7(o, c, u) + I7[d] + hs[d] | 0, b = (or(r, 2) ^ or(r, 13) ^ or(r, 22)) + P7(r, s, a) | 0;
      l = u, u = c, c = o, o = i + h | 0, i = a, a = s, s = r, r = h + b | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, a, i, o, c, u, l);
  }
  roundClean() {
    hs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const u6 = /* @__PURE__ */ Yb(() => new U7()), $u = /* @__PURE__ */ BigInt(2 ** 32 - 1), Km = /* @__PURE__ */ BigInt(32);
function d6(t, e = !1) {
  return e ? { h: Number(t & $u), l: Number(t >> Km & $u) } : { h: Number(t >> Km & $u) | 0, l: Number(t & $u) | 0 };
}
function f6(t, e = !1) {
  let n = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: a, l: i } = d6(t[s], e);
    [n[s], r[s]] = [a, i];
  }
  return [n, r];
}
const N7 = (t, e) => BigInt(t >>> 0) << Km | BigInt(e >>> 0), R7 = (t, e, n) => t >>> n, F7 = (t, e, n) => t << 32 - n | e >>> n, M7 = (t, e, n) => t >>> n | e << 32 - n, D7 = (t, e, n) => t << 32 - n | e >>> n, L7 = (t, e, n) => t << 64 - n | e >>> n - 32, H7 = (t, e, n) => t >>> n - 32 | e << 64 - n, $7 = (t, e) => e, _7 = (t, e) => t, p6 = (t, e, n) => t << n | e >>> 32 - n, h6 = (t, e, n) => e << n | t >>> 32 - n, m6 = (t, e, n) => e << n - 32 | t >>> 64 - n, b6 = (t, e, n) => t << n - 32 | e >>> 64 - n;
function G7(t, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const z7 = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), V7 = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, j7 = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), K7 = (t, e, n, r, s) => e + n + r + s + (t / 2 ** 32 | 0) | 0, q7 = (t, e, n, r, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), W7 = (t, e, n, r, s, a) => e + n + r + s + a + (t / 2 ** 32 | 0) | 0, pe = {
  fromBig: d6,
  split: f6,
  toBig: N7,
  shrSH: R7,
  shrSL: F7,
  rotrSH: M7,
  rotrSL: D7,
  rotrBH: L7,
  rotrBL: H7,
  rotr32H: $7,
  rotr32L: _7,
  rotlSH: p6,
  rotlSL: h6,
  rotlBH: m6,
  rotlBL: b6,
  add: G7,
  add3L: z7,
  add3H: V7,
  add4L: j7,
  add4H: K7,
  add5H: W7,
  add5L: q7
}, [Q7, J7] = pe.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), ms = /* @__PURE__ */ new Uint32Array(80), bs = /* @__PURE__ */ new Uint32Array(80);
class Z7 extends l6 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: a, Cl: i, Dh: o, Dl: c, Eh: u, El: l, Fh: d, Fl: f, Gh: h, Gl: y, Hh: b, Hl: g } = this;
    return [e, n, r, s, a, i, o, c, u, l, d, f, h, y, b, g];
  }
  // prettier-ignore
  set(e, n, r, s, a, i, o, c, u, l, d, f, h, y, b, g) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = f | 0, this.Gh = h | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = g | 0;
  }
  process(e, n) {
    for (let A = 0; A < 16; A++, n += 4)
      ms[A] = e.getUint32(n), bs[A] = e.getUint32(n += 4);
    for (let A = 16; A < 80; A++) {
      const P = ms[A - 15] | 0, x = bs[A - 15] | 0, O = pe.rotrSH(P, x, 1) ^ pe.rotrSH(P, x, 8) ^ pe.shrSH(P, x, 7), I = pe.rotrSL(P, x, 1) ^ pe.rotrSL(P, x, 8) ^ pe.shrSL(P, x, 7), T = ms[A - 2] | 0, C = bs[A - 2] | 0, N = pe.rotrSH(T, C, 19) ^ pe.rotrBH(T, C, 61) ^ pe.shrSH(T, C, 6), U = pe.rotrSL(T, C, 19) ^ pe.rotrBL(T, C, 61) ^ pe.shrSL(T, C, 6), L = pe.add4L(I, U, bs[A - 7], bs[A - 16]), $ = pe.add4H(L, O, N, ms[A - 7], ms[A - 16]);
      ms[A] = $ | 0, bs[A] = L | 0;
    }
    let { Ah: r, Al: s, Bh: a, Bl: i, Ch: o, Cl: c, Dh: u, Dl: l, Eh: d, El: f, Fh: h, Fl: y, Gh: b, Gl: g, Hh: w, Hl: v } = this;
    for (let A = 0; A < 80; A++) {
      const P = pe.rotrSH(d, f, 14) ^ pe.rotrSH(d, f, 18) ^ pe.rotrBH(d, f, 41), x = pe.rotrSL(d, f, 14) ^ pe.rotrSL(d, f, 18) ^ pe.rotrBL(d, f, 41), O = d & h ^ ~d & b, I = f & y ^ ~f & g, T = pe.add5L(v, x, I, J7[A], bs[A]), C = pe.add5H(T, w, P, O, Q7[A], ms[A]), N = T | 0, U = pe.rotrSH(r, s, 28) ^ pe.rotrBH(r, s, 34) ^ pe.rotrBH(r, s, 39), L = pe.rotrSL(r, s, 28) ^ pe.rotrBL(r, s, 34) ^ pe.rotrBL(r, s, 39), $ = r & a ^ r & o ^ a & o, _ = s & i ^ s & c ^ i & c;
      w = b | 0, v = g | 0, b = h | 0, g = y | 0, h = d | 0, y = f | 0, { h: d, l: f } = pe.add(u | 0, l | 0, C | 0, N | 0), u = o | 0, l = c | 0, o = a | 0, c = i | 0, a = r | 0, i = s | 0;
      const R = pe.add3L(N, L, _);
      r = pe.add3H(R, C, U, $), s = R | 0;
    }
    ({ h: r, l: s } = pe.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: a, l: i } = pe.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: o, l: c } = pe.add(this.Ch | 0, this.Cl | 0, o | 0, c | 0), { h: u, l } = pe.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: f } = pe.add(this.Eh | 0, this.El | 0, d | 0, f | 0), { h, l: y } = pe.add(this.Fh | 0, this.Fl | 0, h | 0, y | 0), { h: b, l: g } = pe.add(this.Gh | 0, this.Gl | 0, b | 0, g | 0), { h: w, l: v } = pe.add(this.Hh | 0, this.Hl | 0, w | 0, v | 0), this.set(r, s, a, i, o, c, u, l, d, f, h, y, b, g, w, v);
  }
  roundClean() {
    ms.fill(0), bs.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const X7 = /* @__PURE__ */ Yb(() => new Z7());
function Y7() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const A1 = Y7(), v1 = A1.crypto || A1.msCrypto;
function eO(t) {
  switch (t) {
    case "sha256":
      return u6.create();
    case "sha512":
      return X7.create();
  }
  S(!1, "invalid hashing algorithm name", "algorithm", t);
}
function tO(t) {
  K(v1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  }), S(Number.isInteger(t) && t > 0 && t <= 1024, "invalid length", "length", t);
  const e = new Uint8Array(t);
  return v1.getRandomValues(e), e;
}
const [y6, g6, w6] = [[], [], []], nO = /* @__PURE__ */ BigInt(0), Mc = /* @__PURE__ */ BigInt(1), rO = /* @__PURE__ */ BigInt(2), sO = /* @__PURE__ */ BigInt(7), aO = /* @__PURE__ */ BigInt(256), iO = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = Mc, n = 1, r = 0; t < 24; t++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], y6.push(2 * (5 * r + n)), g6.push((t + 1) * (t + 2) / 2 % 64);
  let s = nO;
  for (let a = 0; a < 7; a++)
    e = (e << Mc ^ (e >> sO) * iO) % aO, e & rO && (s ^= Mc << (Mc << /* @__PURE__ */ BigInt(a)) - Mc);
  w6.push(s);
}
const [oO, cO] = /* @__PURE__ */ f6(w6, !0), k1 = (t, e, n) => n > 32 ? m6(t, e, n) : p6(t, e, n), C1 = (t, e, n) => n > 32 ? b6(t, e, n) : h6(t, e, n);
function lO(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const o = (i + 8) % 10, c = (i + 2) % 10, u = n[c], l = n[c + 1], d = k1(u, l, 1) ^ n[o], f = C1(u, l, 1) ^ n[o + 1];
      for (let h = 0; h < 50; h += 10)
        t[i + h] ^= d, t[i + h + 1] ^= f;
    }
    let s = t[2], a = t[3];
    for (let i = 0; i < 24; i++) {
      const o = g6[i], c = k1(s, a, o), u = C1(s, a, o), l = y6[i];
      s = t[l], a = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let o = 0; o < 10; o++)
        n[o] = t[i + o];
      for (let o = 0; o < 10; o++)
        t[i + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t[0] ^= oO[r], t[1] ^= cO[r];
  }
  n.fill(0);
}
class ey extends Xb {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, r, s = !1, a = 24) {
    if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Zd(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = v7(this.state);
  }
  keccak() {
    lO(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    oc(this);
    const { blockLen: n, state: r } = this;
    e = Jf(e);
    const s = e.length;
    for (let a = 0; a < s; ) {
      const i = Math.min(n - this.pos, s - a);
      for (let o = 0; o < i; o++)
        r[this.pos++] ^= e[a++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    oc(this, !1), Zb(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, a - s);
      e.set(n.subarray(this.posOut, this.posOut + i), s), this.posOut += i, s += i;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Zd(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (a6(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: a, enableXOF: i } = this;
    return e || (e = new ey(n, r, s, i, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = s, e.enableXOF = i, e.destroyed = this.destroyed, e;
  }
}
const uO = (t, e, n) => Yb(() => new ey(e, t, n)), dO = /* @__PURE__ */ uO(1, 136, 256 / 8);
let E6 = !1;
const x6 = function(t) {
  return dO(t);
};
let A6 = x6;
function xe(t) {
  const e = Q(t, "data");
  return V(A6(e));
}
xe._ = x6;
xe.lock = function() {
  E6 = !0;
};
xe.register = function(t) {
  if (E6)
    throw new TypeError("keccak256 is locked");
  A6 = t;
};
Object.freeze(xe);
let v6 = !1;
const k6 = function(t) {
  return new Uint8Array(tO(t));
};
let C6 = k6;
function na(t) {
  return C6(t);
}
na._ = k6;
na.lock = function() {
  v6 = !0;
};
na.register = function(t) {
  if (v6)
    throw new Error("randomBytes is locked");
  C6 = t;
};
Object.freeze(na);
const T6 = function(t) {
  return eO("sha256").update(t).digest();
};
let S6 = T6, O6 = !1;
function Ec(t) {
  const e = Q(t, "data");
  return V(S6(e));
}
Ec._ = T6;
Ec.lock = function() {
  O6 = !0;
};
Ec.register = function(t) {
  if (O6)
    throw new Error("sha256 is locked");
  S6 = t;
};
Object.freeze(Ec);
Object.freeze(Ec);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const B6 = BigInt(0), Zf = BigInt(1), fO = BigInt(2), Xf = (t) => t instanceof Uint8Array, pO = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function cc(t) {
  if (!Xf(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += pO[t[n]];
  return e;
}
function P6(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function ty(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function lc(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(e / 2);
  for (let r = 0; r < n.length; r++) {
    const s = r * 2, a = t.slice(s, s + 2), i = Number.parseInt(a, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    n[r] = i;
  }
  return n;
}
function ii(t) {
  return ty(cc(t));
}
function ny(t) {
  if (!Xf(t))
    throw new Error("Uint8Array expected");
  return ty(cc(Uint8Array.from(t).reverse()));
}
function uc(t, e) {
  return lc(t.toString(16).padStart(e * 2, "0"));
}
function ry(t, e) {
  return uc(t, e).reverse();
}
function hO(t) {
  return lc(P6(t));
}
function Hn(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = lc(e);
    } catch (a) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${a}`);
    }
  else if (Xf(e))
    r = Uint8Array.from(e);
  else
    throw new Error(`${t} must be hex string or Uint8Array`);
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(`${t} expected ${n} bytes, got ${s}`);
  return r;
}
function Pl(...t) {
  const e = new Uint8Array(t.reduce((r, s) => r + s.length, 0));
  let n = 0;
  return t.forEach((r) => {
    if (!Xf(r))
      throw new Error("Uint8Array expected");
    e.set(r, n), n += r.length;
  }), e;
}
function mO(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function bO(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function yO(t) {
  let e;
  for (e = 0; t > B6; t >>= Zf, e += 1)
    ;
  return e;
}
function gO(t, e) {
  return t >> BigInt(e) & Zf;
}
const wO = (t, e, n) => t | (n ? Zf : B6) << BigInt(e), sy = (t) => (fO << BigInt(t - 1)) - Zf, wh = (t) => new Uint8Array(t), T1 = (t) => Uint8Array.from(t);
function I6(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = wh(t), s = wh(t), a = 0;
  const i = () => {
    r.fill(1), s.fill(0), a = 0;
  }, o = (...d) => n(s, r, ...d), c = (d = wh()) => {
    s = o(T1([0]), d), r = o(), d.length !== 0 && (s = o(T1([1]), d), r = o());
  }, u = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const f = [];
    for (; d < e; ) {
      r = o();
      const h = r.slice();
      f.push(h), d += r.length;
    }
    return Pl(...f);
  };
  return (d, f) => {
    i(), c(d);
    let h;
    for (; !(h = f(u())); )
      c();
    return i(), h;
  };
}
const EO = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  stringOrUint8Array: (t) => typeof t == "string" || t instanceof Uint8Array,
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function mu(t, e, n = {}) {
  const r = (s, a, i) => {
    const o = EO[a];
    if (typeof o != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const c = t[s];
    if (!(i && c === void 0) && !o(c, t))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${a}`);
  };
  for (const [s, a] of Object.entries(e))
    r(s, a, !1);
  for (const [s, a] of Object.entries(n))
    r(s, a, !0);
  return t;
}
const xO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: gO,
  bitLen: yO,
  bitMask: sy,
  bitSet: wO,
  bytesToHex: cc,
  bytesToNumberBE: ii,
  bytesToNumberLE: ny,
  concatBytes: Pl,
  createHmacDrbg: I6,
  ensureBytes: Hn,
  equalBytes: mO,
  hexToBytes: lc,
  hexToNumber: ty,
  numberToBytesBE: uc,
  numberToBytesLE: ry,
  numberToHexUnpadded: P6,
  numberToVarBytesBE: hO,
  utf8ToBytes: bO,
  validateObject: mu
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const st = BigInt(0), Qe = BigInt(1), fa = BigInt(2), AO = BigInt(3), qm = BigInt(4), S1 = BigInt(5), O1 = BigInt(8);
BigInt(9);
BigInt(16);
function Qt(t, e) {
  const n = t % e;
  return n >= st ? n : e + n;
}
function vO(t, e, n) {
  if (n <= st || e < st)
    throw new Error("Expected power/modulo > 0");
  if (n === Qe)
    return st;
  let r = Qe;
  for (; e > st; )
    e & Qe && (r = r * t % n), t = t * t % n, e >>= Qe;
  return r;
}
function yn(t, e, n) {
  let r = t;
  for (; e-- > st; )
    r *= r, r %= n;
  return r;
}
function Wm(t, e) {
  if (t === st || e <= st)
    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
  let n = Qt(t, e), r = e, s = st, a = Qe;
  for (; n !== st; ) {
    const o = r / n, c = r % n, u = s - a * o;
    r = n, n = c, s = a, a = u;
  }
  if (r !== Qe)
    throw new Error("invert: does not exist");
  return Qt(s, e);
}
function kO(t) {
  const e = (t - Qe) / fa;
  let n, r, s;
  for (n = t - Qe, r = 0; n % fa === st; n /= fa, r++)
    ;
  for (s = fa; s < t && vO(s, e, t) !== t - Qe; s++)
    ;
  if (r === 1) {
    const i = (t + Qe) / qm;
    return function(c, u) {
      const l = c.pow(u, i);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (n + Qe) / fa;
  return function(o, c) {
    if (o.pow(c, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let u = r, l = o.pow(o.mul(o.ONE, s), n), d = o.pow(c, a), f = o.pow(c, n);
    for (; !o.eql(f, o.ONE); ) {
      if (o.eql(f, o.ZERO))
        return o.ZERO;
      let h = 1;
      for (let b = o.sqr(f); h < u && !o.eql(b, o.ONE); h++)
        b = o.sqr(b);
      const y = o.pow(l, Qe << BigInt(u - h - 1));
      l = o.sqr(y), d = o.mul(d, y), f = o.mul(f, l), u = h;
    }
    return d;
  };
}
function CO(t) {
  if (t % qm === AO) {
    const e = (t + Qe) / qm;
    return function(r, s) {
      const a = r.pow(s, e);
      if (!r.eql(r.sqr(a), s))
        throw new Error("Cannot find square root");
      return a;
    };
  }
  if (t % O1 === S1) {
    const e = (t - S1) / O1;
    return function(r, s) {
      const a = r.mul(s, fa), i = r.pow(a, e), o = r.mul(s, i), c = r.mul(r.mul(o, fa), i), u = r.mul(o, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), s))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return kO(t);
}
const TO = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function SO(t) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = TO.reduce((r, s) => (r[s] = "function", r), e);
  return mu(t, n);
}
function OO(t, e, n) {
  if (n < st)
    throw new Error("Expected power > 0");
  if (n === st)
    return t.ONE;
  if (n === Qe)
    return e;
  let r = t.ONE, s = e;
  for (; n > st; )
    n & Qe && (r = t.mul(r, s)), s = t.sqr(s), n >>= Qe;
  return r;
}
function BO(t, e) {
  const n = new Array(e.length), r = e.reduce((a, i, o) => t.is0(i) ? a : (n[o] = a, t.mul(a, i)), t.ONE), s = t.inv(r);
  return e.reduceRight((a, i, o) => t.is0(i) ? a : (n[o] = t.mul(a, n[o]), t.mul(a, i)), s), n;
}
function U6(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function PO(t, e, n = !1, r = {}) {
  if (t <= st)
    throw new Error(`Expected Field ORDER > 0, got ${t}`);
  const { nBitLength: s, nByteLength: a } = U6(t, e);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = CO(t), o = Object.freeze({
    ORDER: t,
    BITS: s,
    BYTES: a,
    MASK: sy(s),
    ZERO: st,
    ONE: Qe,
    create: (c) => Qt(c, t),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return st <= c && c < t;
    },
    is0: (c) => c === st,
    isOdd: (c) => (c & Qe) === Qe,
    neg: (c) => Qt(-c, t),
    eql: (c, u) => c === u,
    sqr: (c) => Qt(c * c, t),
    add: (c, u) => Qt(c + u, t),
    sub: (c, u) => Qt(c - u, t),
    mul: (c, u) => Qt(c * u, t),
    pow: (c, u) => OO(o, c, u),
    div: (c, u) => Qt(c * Wm(u, t), t),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => Wm(c, t),
    sqrt: r.sqrt || ((c) => i(o, c)),
    invertBatch: (c) => BO(o, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => n ? ry(c, a) : uc(c, a),
    fromBytes: (c) => {
      if (c.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${c.length}`);
      return n ? ny(c) : ii(c);
    }
  });
  return Object.freeze(o);
}
function N6(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function R6(t) {
  const e = N6(t);
  return e + Math.ceil(e / 2);
}
function IO(t, e, n = !1) {
  const r = t.length, s = N6(e), a = R6(e);
  if (r < 16 || r < a || r > 1024)
    throw new Error(`expected ${a}-1024 bytes of input, got ${r}`);
  const i = n ? ii(t) : ny(t), o = Qt(i, e - Qe) + Qe;
  return n ? ry(o, s) : uc(o, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const UO = BigInt(0), Eh = BigInt(1);
function NO(t, e) {
  const n = (s, a) => {
    const i = a.negate();
    return s ? i : a;
  }, r = (s) => {
    const a = Math.ceil(e / s) + 1, i = 2 ** (s - 1);
    return { windows: a, windowSize: i };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(s, a) {
      let i = t.ZERO, o = s;
      for (; a > UO; )
        a & Eh && (i = i.add(o)), o = o.double(), a >>= Eh;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, a) {
      const { windows: i, windowSize: o } = r(a), c = [];
      let u = s, l = u;
      for (let d = 0; d < i; d++) {
        l = u, c.push(l);
        for (let f = 1; f < o; f++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, a, i) {
      const { windows: o, windowSize: c } = r(s);
      let u = t.ZERO, l = t.BASE;
      const d = BigInt(2 ** s - 1), f = 2 ** s, h = BigInt(s);
      for (let y = 0; y < o; y++) {
        const b = y * c;
        let g = Number(i & d);
        i >>= h, g > c && (g -= f, i += Eh);
        const w = b, v = b + Math.abs(g) - 1, A = y % 2 !== 0, P = g < 0;
        g === 0 ? l = l.add(n(A, a[w])) : u = u.add(n(P, a[v]));
      }
      return { p: u, f: l };
    },
    wNAFCached(s, a, i, o) {
      const c = s._WINDOW_SIZE || 1;
      let u = a.get(s);
      return u || (u = this.precomputeWindow(s, c), c !== 1 && a.set(s, o(u))), this.wNAF(c, u, i);
    }
  };
}
function F6(t) {
  return SO(t.Fp), mu(t, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...U6(t.n, t.nBitLength),
    ...t,
    p: t.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function RO(t) {
  const e = F6(t);
  mu(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: s } = e;
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: FO, hexToBytes: MO } = xO, xa = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(t) {
    const { Err: e } = xa;
    if (t.length < 2 || t[0] !== 2)
      throw new e("Invalid signature integer tag");
    const n = t[1], r = t.subarray(2, n + 2);
    if (!n || r.length !== n)
      throw new e("Invalid signature integer: wrong length");
    if (r[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: FO(r), l: t.subarray(n + 2) };
  },
  toSig(t) {
    const { Err: e } = xa, n = typeof t == "string" ? MO(t) : t;
    if (!(n instanceof Uint8Array))
      throw new Error("ui8a expected");
    let r = n.length;
    if (r < 2 || n[0] != 48)
      throw new e("Invalid signature tag");
    if (n[1] !== r - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: s, l: a } = xa._parseInt(n.subarray(2)), { d: i, l: o } = xa._parseInt(a);
    if (o.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: s, s: i };
  },
  hexFromSig(t) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, n = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, r = e(n(t.s)), s = e(n(t.r)), a = r.length / 2, i = s.length / 2, o = n(a), c = n(i);
    return `30${n(i + a + 4)}02${c}${s}02${o}${r}`;
  }
}, Yr = BigInt(0), Pn = BigInt(1);
BigInt(2);
const B1 = BigInt(3);
BigInt(4);
function DO(t) {
  const e = RO(t), { Fp: n } = e, r = e.toBytes || ((y, b, g) => {
    const w = b.toAffine();
    return Pl(Uint8Array.from([4]), n.toBytes(w.x), n.toBytes(w.y));
  }), s = e.fromBytes || ((y) => {
    const b = y.subarray(1), g = n.fromBytes(b.subarray(0, n.BYTES)), w = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES));
    return { x: g, y: w };
  });
  function a(y) {
    const { a: b, b: g } = e, w = n.sqr(y), v = n.mul(w, y);
    return n.add(n.add(v, n.mul(y, b)), g);
  }
  if (!n.eql(n.sqr(e.Gy), a(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function i(y) {
    return typeof y == "bigint" && Yr < y && y < e.n;
  }
  function o(y) {
    if (!i(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const { allowedPrivateKeyLengths: b, nByteLength: g, wrapPrivateKey: w, n: v } = e;
    if (b && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = cc(y)), typeof y != "string" || !b.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(g * 2, "0");
    }
    let A;
    try {
      A = typeof y == "bigint" ? y : ii(Hn("private key", y, g));
    } catch {
      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`);
    }
    return w && (A = Qt(A, v)), o(A), A;
  }
  const u = /* @__PURE__ */ new Map();
  function l(y) {
    if (!(y instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(b, g, w) {
      if (this.px = b, this.py = g, this.pz = w, b == null || !n.isValid(b))
        throw new Error("x required");
      if (g == null || !n.isValid(g))
        throw new Error("y required");
      if (w == null || !n.isValid(w))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: g, y: w } = b || {};
      if (!b || !n.isValid(g) || !n.isValid(w))
        throw new Error("invalid affine point");
      if (b instanceof d)
        throw new Error("projective point not allowed");
      const v = (A) => n.eql(A, n.ZERO);
      return v(g) && v(w) ? d.ZERO : new d(g, w, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const g = n.invertBatch(b.map((w) => w.pz));
      return b.map((w, v) => w.toAffine(g[v])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const g = d.fromAffine(s(Hn("pointHex", b)));
      return g.assertValidity(), g;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return d.BASE.multiply(c(b));
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      this._WINDOW_SIZE = b, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !n.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: g } = this.toAffine();
      if (!n.isValid(b) || !n.isValid(g))
        throw new Error("bad point: x or y not FE");
      const w = n.sqr(g), v = a(b);
      if (!n.eql(w, v))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      l(b);
      const { px: g, py: w, pz: v } = this, { px: A, py: P, pz: x } = b, O = n.eql(n.mul(g, x), n.mul(A, v)), I = n.eql(n.mul(w, x), n.mul(P, v));
      return O && I;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: g } = e, w = n.mul(g, B1), { px: v, py: A, pz: P } = this;
      let x = n.ZERO, O = n.ZERO, I = n.ZERO, T = n.mul(v, v), C = n.mul(A, A), N = n.mul(P, P), U = n.mul(v, A);
      return U = n.add(U, U), I = n.mul(v, P), I = n.add(I, I), x = n.mul(b, I), O = n.mul(w, N), O = n.add(x, O), x = n.sub(C, O), O = n.add(C, O), O = n.mul(x, O), x = n.mul(U, x), I = n.mul(w, I), N = n.mul(b, N), U = n.sub(T, N), U = n.mul(b, U), U = n.add(U, I), I = n.add(T, T), T = n.add(I, T), T = n.add(T, N), T = n.mul(T, U), O = n.add(O, T), N = n.mul(A, P), N = n.add(N, N), T = n.mul(N, U), x = n.sub(x, T), I = n.mul(N, C), I = n.add(I, I), I = n.add(I, I), new d(x, O, I);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      l(b);
      const { px: g, py: w, pz: v } = this, { px: A, py: P, pz: x } = b;
      let O = n.ZERO, I = n.ZERO, T = n.ZERO;
      const C = e.a, N = n.mul(e.b, B1);
      let U = n.mul(g, A), L = n.mul(w, P), $ = n.mul(v, x), _ = n.add(g, w), R = n.add(A, P);
      _ = n.mul(_, R), R = n.add(U, L), _ = n.sub(_, R), R = n.add(g, v);
      let M = n.add(A, x);
      return R = n.mul(R, M), M = n.add(U, $), R = n.sub(R, M), M = n.add(w, v), O = n.add(P, x), M = n.mul(M, O), O = n.add(L, $), M = n.sub(M, O), T = n.mul(C, R), O = n.mul(N, $), T = n.add(O, T), O = n.sub(L, T), T = n.add(L, T), I = n.mul(O, T), L = n.add(U, U), L = n.add(L, U), $ = n.mul(C, $), R = n.mul(N, R), L = n.add(L, $), $ = n.sub(U, $), $ = n.mul(C, $), R = n.add(R, $), U = n.mul(L, R), I = n.add(I, U), U = n.mul(M, R), O = n.mul(_, O), O = n.sub(O, U), U = n.mul(_, L), T = n.mul(M, T), T = n.add(T, U), new d(O, I, T);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(b) {
      return h.wNAFCached(this, u, b, (g) => {
        const w = n.invertBatch(g.map((v) => v.pz));
        return g.map((v, A) => v.toAffine(w[A])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const g = d.ZERO;
      if (b === Yr)
        return g;
      if (o(b), b === Pn)
        return this;
      const { endo: w } = e;
      if (!w)
        return h.unsafeLadder(this, b);
      let { k1neg: v, k1: A, k2neg: P, k2: x } = w.splitScalar(b), O = g, I = g, T = this;
      for (; A > Yr || x > Yr; )
        A & Pn && (O = O.add(T)), x & Pn && (I = I.add(T)), T = T.double(), A >>= Pn, x >>= Pn;
      return v && (O = O.negate()), P && (I = I.negate()), I = new d(n.mul(I.px, w.beta), I.py, I.pz), O.add(I);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      o(b);
      let g = b, w, v;
      const { endo: A } = e;
      if (A) {
        const { k1neg: P, k1: x, k2neg: O, k2: I } = A.splitScalar(g);
        let { p: T, f: C } = this.wNAF(x), { p: N, f: U } = this.wNAF(I);
        T = h.constTimeNegate(P, T), N = h.constTimeNegate(O, N), N = new d(n.mul(N.px, A.beta), N.py, N.pz), w = T.add(N), v = C.add(U);
      } else {
        const { p: P, f: x } = this.wNAF(g);
        w = P, v = x;
      }
      return d.normalizeZ([w, v])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, g, w) {
      const v = d.BASE, A = (x, O) => O === Yr || O === Pn || !x.equals(v) ? x.multiplyUnsafe(O) : x.multiply(O), P = A(this, g).add(A(b, w));
      return P.is0() ? void 0 : P;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      const { px: g, py: w, pz: v } = this, A = this.is0();
      b == null && (b = A ? n.ONE : n.inv(v));
      const P = n.mul(g, b), x = n.mul(w, b), O = n.mul(v, b);
      if (A)
        return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(O, n.ONE))
        throw new Error("invZ was invalid");
      return { x: P, y: x };
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: g } = e;
      if (b === Pn)
        return !0;
      if (g)
        return g(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: g } = e;
      return b === Pn ? this : g ? g(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(b = !0) {
      return this.assertValidity(), r(d, this, b);
    }
    toHex(b = !0) {
      return cc(this.toRawBytes(b));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
  const f = e.nBitLength, h = NO(d, e.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: a,
    isWithinCurveOrder: i
  };
}
function LO(t) {
  const e = F6(t);
  return mu(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function HO(t) {
  const e = LO(t), { Fp: n, n: r } = e, s = n.BYTES + 1, a = 2 * n.BYTES + 1;
  function i(R) {
    return Yr < R && R < n.ORDER;
  }
  function o(R) {
    return Qt(R, r);
  }
  function c(R) {
    return Wm(R, r);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: d, isWithinCurveOrder: f } = DO({
    ...e,
    toBytes(R, M, j) {
      const G = M.toAffine(), Z = n.toBytes(G.x), Y = Pl;
      return j ? Y(Uint8Array.from([M.hasEvenY() ? 2 : 3]), Z) : Y(Uint8Array.from([4]), Z, n.toBytes(G.y));
    },
    fromBytes(R) {
      const M = R.length, j = R[0], G = R.subarray(1);
      if (M === s && (j === 2 || j === 3)) {
        const Z = ii(G);
        if (!i(Z))
          throw new Error("Point is not on curve");
        const Y = d(Z);
        let X = n.sqrt(Y);
        const le = (X & Pn) === Pn;
        return (j & 1) === 1 !== le && (X = n.neg(X)), { x: Z, y: X };
      } else if (M === a && j === 4) {
        const Z = n.fromBytes(G.subarray(0, n.BYTES)), Y = n.fromBytes(G.subarray(n.BYTES, 2 * n.BYTES));
        return { x: Z, y: Y };
      } else
        throw new Error(`Point of length ${M} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`);
    }
  }), h = (R) => cc(uc(R, e.nByteLength));
  function y(R) {
    const M = r >> Pn;
    return R > M;
  }
  function b(R) {
    return y(R) ? o(-R) : R;
  }
  const g = (R, M, j) => ii(R.slice(M, j));
  class w {
    constructor(M, j, G) {
      this.r = M, this.s = j, this.recovery = G, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(M) {
      const j = e.nByteLength;
      return M = Hn("compactSignature", M, j * 2), new w(g(M, 0, j), g(M, j, 2 * j));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(M) {
      const { r: j, s: G } = xa.toSig(Hn("DER", M));
      return new w(j, G);
    }
    assertValidity() {
      if (!f(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!f(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(M) {
      return new w(this.r, this.s, M);
    }
    recoverPublicKey(M) {
      const { r: j, s: G, recovery: Z } = this, Y = I(Hn("msgHash", M));
      if (Z == null || ![0, 1, 2, 3].includes(Z))
        throw new Error("recovery id invalid");
      const X = Z === 2 || Z === 3 ? j + e.n : j;
      if (X >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const le = Z & 1 ? "03" : "02", J = u.fromHex(le + h(X)), ce = c(X), te = o(-Y * ce), ae = o(G * ce), he = u.BASE.multiplyAndAddUnsafe(J, te, ae);
      if (!he)
        throw new Error("point at infinify");
      return he.assertValidity(), he;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new w(this.r, o(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return lc(this.toDERHex());
    }
    toDERHex() {
      return xa.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return lc(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const v = {
    isValidPrivateKey(R) {
      try {
        return l(R), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const R = R6(e.n);
      return IO(e.randomBytes(R), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(R = 8, M = u.BASE) {
      return M._setWindowSize(R), M.multiply(BigInt(3)), M;
    }
  };
  function A(R, M = !0) {
    return u.fromPrivateKey(R).toRawBytes(M);
  }
  function P(R) {
    const M = R instanceof Uint8Array, j = typeof R == "string", G = (M || j) && R.length;
    return M ? G === s || G === a : j ? G === 2 * s || G === 2 * a : R instanceof u;
  }
  function x(R, M, j = !0) {
    if (P(R))
      throw new Error("first arg must be private key");
    if (!P(M))
      throw new Error("second arg must be public key");
    return u.fromHex(M).multiply(l(R)).toRawBytes(j);
  }
  const O = e.bits2int || function(R) {
    const M = ii(R), j = R.length * 8 - e.nBitLength;
    return j > 0 ? M >> BigInt(j) : M;
  }, I = e.bits2int_modN || function(R) {
    return o(O(R));
  }, T = sy(e.nBitLength);
  function C(R) {
    if (typeof R != "bigint")
      throw new Error("bigint expected");
    if (!(Yr <= R && R < T))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return uc(R, e.nByteLength);
  }
  function N(R, M, j = U) {
    if (["recovered", "canonical"].some((De) => De in j))
      throw new Error("sign() legacy options not supported");
    const { hash: G, randomBytes: Z } = e;
    let { lowS: Y, prehash: X, extraEntropy: le } = j;
    Y == null && (Y = !0), R = Hn("msgHash", R), X && (R = Hn("prehashed msgHash", G(R)));
    const J = I(R), ce = l(M), te = [C(ce), C(J)];
    if (le != null) {
      const De = le === !0 ? Z(n.BYTES) : le;
      te.push(Hn("extraEntropy", De));
    }
    const ae = Pl(...te), he = J;
    function Oe(De) {
      const ze = O(De);
      if (!f(ze))
        return;
      const at = c(ze), mn = u.BASE.multiply(ze).toAffine(), bt = o(mn.x);
      if (bt === Yr)
        return;
      const Ur = o(at * o(he + bt * ce));
      if (Ur === Yr)
        return;
      let Ug = (mn.x === bt ? 0 : 2) | Number(mn.y & Pn), Ng = Ur;
      return Y && y(Ur) && (Ng = b(Ur), Ug ^= 1), new w(bt, Ng, Ug);
    }
    return { seed: ae, k2sig: Oe };
  }
  const U = { lowS: e.lowS, prehash: !1 }, L = { lowS: e.lowS, prehash: !1 };
  function $(R, M, j = U) {
    const { seed: G, k2sig: Z } = N(R, M, j), Y = e;
    return I6(Y.hash.outputLen, Y.nByteLength, Y.hmac)(G, Z);
  }
  u.BASE._setWindowSize(8);
  function _(R, M, j, G = L) {
    var mn;
    const Z = R;
    if (M = Hn("msgHash", M), j = Hn("publicKey", j), "strict" in G)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Y, prehash: X } = G;
    let le, J;
    try {
      if (typeof Z == "string" || Z instanceof Uint8Array)
        try {
          le = w.fromDER(Z);
        } catch (bt) {
          if (!(bt instanceof xa.Err))
            throw bt;
          le = w.fromCompact(Z);
        }
      else if (typeof Z == "object" && typeof Z.r == "bigint" && typeof Z.s == "bigint") {
        const { r: bt, s: Ur } = Z;
        le = new w(bt, Ur);
      } else
        throw new Error("PARSE");
      J = u.fromHex(j);
    } catch (bt) {
      if (bt.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Y && le.hasHighS())
      return !1;
    X && (M = e.hash(M));
    const { r: ce, s: te } = le, ae = I(M), he = c(te), Oe = o(ae * he), De = o(ce * he), ze = (mn = u.BASE.multiplyAndAddUnsafe(J, Oe, De)) == null ? void 0 : mn.toAffine();
    return ze ? o(ze.x) === ce : !1;
  }
  return {
    CURVE: e,
    getPublicKey: A,
    getSharedSecret: x,
    sign: $,
    verify: _,
    ProjectivePoint: u,
    Signature: w,
    utils: v
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $O(t) {
  return {
    hash: t,
    hmac: (e, ...n) => c6(t, e, T7(...n)),
    randomBytes: S7
  };
}
function _O(t, e) {
  const n = (r) => HO({ ...t, ...$O(r) });
  return Object.freeze({ ...n(e), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const M6 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), P1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), GO = BigInt(1), Qm = BigInt(2), I1 = (t, e) => (t + e / Qm) / e;
function zO(t) {
  const e = M6, n = BigInt(3), r = BigInt(6), s = BigInt(11), a = BigInt(22), i = BigInt(23), o = BigInt(44), c = BigInt(88), u = t * t * t % e, l = u * u * t % e, d = yn(l, n, e) * l % e, f = yn(d, n, e) * l % e, h = yn(f, Qm, e) * u % e, y = yn(h, s, e) * h % e, b = yn(y, a, e) * y % e, g = yn(b, o, e) * b % e, w = yn(g, c, e) * g % e, v = yn(w, o, e) * b % e, A = yn(v, n, e) * l % e, P = yn(A, i, e) * y % e, x = yn(P, r, e) * u % e, O = yn(x, Qm, e);
  if (!Jm.eql(Jm.sqr(O), t))
    throw new Error("Cannot find square root");
  return O;
}
const Jm = PO(M6, void 0, void 0, { sqrt: zO }), gs = _O({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Jm,
  n: P1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t) => {
      const e = P1, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -GO * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = n, i = BigInt("0x100000000000000000000000000000000"), o = I1(a * t, e), c = I1(-r * t, e);
      let u = Qt(t - o * n - c * s, e), l = Qt(-o * r - c * a, e);
      const d = u > i, f = l > i;
      if (d && (u = e - u), f && (l = e - l), u > i || l > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + t);
      return { k1neg: d, k1: u, k2neg: f, k2: l };
    }
  }
}, u6);
BigInt(0);
gs.ProjectivePoint;
const ra = "0x0000000000000000000000000000000000000000", Xd = "0x0000000000000000000000000000000000000000000000000000000000000000", D6 = `Ethereum Signed Message:
`, U1 = BigInt(0), N1 = BigInt(1), R1 = BigInt(2), F1 = BigInt(27), M1 = BigInt(28), _u = BigInt(35), Ui = {};
function D1(t) {
  return fn(Xe(t), 32);
}
var ko, Co, To, qa;
const Ln = class Ln {
  /**
   *  @private
   */
  constructor(e, n, r, s) {
    B(this, ko);
    B(this, Co);
    B(this, To);
    B(this, qa);
    qf(e, Ui, "Signature"), E(this, ko, n), E(this, Co, r), E(this, To, s), E(this, qa, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return m(this, ko);
  }
  set r(e) {
    S(ai(e) === 32, "invalid r", "value", e), E(this, ko, V(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return m(this, Co);
  }
  set s(e) {
    S(ai(e) === 32, "invalid s", "value", e);
    const n = V(e);
    S(parseInt(n.substring(0, 3)) < 8, "non-canonical s", "value", n), E(this, Co, n);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return m(this, To);
  }
  set v(e) {
    const n = ge(e, "value");
    S(n === 27 || n === 28, "invalid v", "v", e), E(this, To, n);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return m(this, qa);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : Ln.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = Q(this.s);
    return this.yParity && (e[0] |= 128), V(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return Le([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return Le([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new Ln(Ui, this.r, this.s, this.v);
    return this.networkV && E(e, qa, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const n = ne(e, "v");
    return n == F1 || n == M1 ? U1 : (S(n >= _u, "invalid EIP-155 v", "v", e), (n - _u) / R1);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, n) {
    return ne(e) * R1 + BigInt(35 + n - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const n = ne(e);
    return n === U1 || n === F1 ? 27 : n === N1 || n === M1 ? 28 : (S(n >= _u, "invalid v", "v", e), n & N1 ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function n(u, l) {
      S(u, l, "signature", e);
    }
    if (e == null)
      return new Ln(Ui, Xd, Xd, 27);
    if (typeof e == "string") {
      const u = Q(e, "signature");
      if (u.length === 64) {
        const l = V(u.slice(0, 32)), d = u.slice(32, 64), f = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new Ln(Ui, l, V(d), f);
      }
      if (u.length === 65) {
        const l = V(u.slice(0, 32)), d = u.slice(32, 64);
        n((d[0] & 128) === 0, "non-canonical s");
        const f = Ln.getNormalizedV(u[64]);
        return new Ln(Ui, l, V(d), f);
      }
      n(!1, "invalid raw signature length");
    }
    if (e instanceof Ln)
      return e.clone();
    const r = e.r;
    n(r != null, "missing r");
    const s = D1(r), a = function(u, l) {
      if (u != null)
        return D1(u);
      if (l != null) {
        n(Ue(l, 32), "invalid yParityAndS");
        const d = Q(l);
        return d[0] &= 127, V(d);
      }
      n(!1, "missing s");
    }(e.s, e.yParityAndS);
    n((Q(a)[0] & 128) == 0, "non-canonical s");
    const { networkV: i, v: o } = function(u, l, d) {
      if (u != null) {
        const f = ne(u);
        return {
          networkV: f >= _u ? f : void 0,
          v: Ln.getNormalizedV(f)
        };
      }
      if (l != null)
        return n(Ue(l, 32), "invalid yParityAndS"), { v: Q(l)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (ge(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        n(!1, "invalid yParity");
      }
      n(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), c = new Ln(Ui, s, a, o);
    return i && E(c, qa, i), n(e.yParity == null || ge(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
ko = new WeakMap(), Co = new WeakMap(), To = new WeakMap(), qa = new WeakMap();
let en = Ln;
var jr;
const ma = class ma {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    B(this, jr);
    S(ai(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), E(this, jr, V(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return m(this, jr);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return ma.computePublicKey(m(this, jr));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return ma.computePublicKey(m(this, jr), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    S(ai(e) === 32, "invalid digest length", "digest", e);
    const n = gs.sign($t(e), $t(m(this, jr)), {
      lowS: !0
    });
    return en.from({
      r: Zn(n.r, 32),
      s: Zn(n.s, 32),
      v: n.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const n = ma.computePublicKey(e);
    return V(gs.getSharedSecret($t(m(this, jr)), Q(n), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, n) {
    let r = Q(e, "key");
    if (r.length === 32) {
      const a = gs.getPublicKey(r, !!n);
      return V(a);
    }
    if (r.length === 64) {
      const a = new Uint8Array(65);
      a[0] = 4, a.set(r, 1), r = a;
    }
    const s = gs.ProjectivePoint.fromHex(r);
    return V(s.toRawBytes(n));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, n) {
    S(ai(e) === 32, "invalid digest length", "digest", e);
    const r = en.from(n);
    let s = gs.Signature.fromCompact($t(Le([r.r, r.s])));
    s = s.addRecoveryBit(r.yParity);
    const a = s.recoverPublicKey($t(e));
    return S(a != null, "invalid signature for digest", "signature", n), "0x" + a.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, n, r) {
    const s = gs.ProjectivePoint.fromHex(ma.computePublicKey(e).substring(2)), a = gs.ProjectivePoint.fromHex(ma.computePublicKey(n).substring(2));
    return "0x" + s.add(a).toHex(!!r);
  }
};
jr = new WeakMap();
let Il = ma;
const VO = BigInt(0), jO = BigInt(36);
function L1(t) {
  t = t.toLowerCase();
  const e = t.substring(2).split(""), n = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    n[s] = e[s].charCodeAt(0);
  const r = Q(xe(n));
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
  return "0x" + e.join("");
}
const ay = {};
for (let t = 0; t < 10; t++)
  ay[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  ay[String.fromCharCode(65 + t)] = String(10 + t);
const H1 = 15;
function KO(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((r) => ay[r]).join("");
  for (; e.length >= H1; ) {
    let r = e.substring(0, H1);
    e = parseInt(r, 10) % 97 + e.substring(r.length);
  }
  let n = String(98 - parseInt(e, 10) % 97);
  for (; n.length < 2; )
    n = "0" + n;
  return n;
}
const qO = function() {
  const t = {};
  for (let e = 0; e < 36; e++) {
    const n = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    t[n] = BigInt(e);
  }
  return t;
}();
function WO(t) {
  t = t.toLowerCase();
  let e = VO;
  for (let n = 0; n < t.length; n++)
    e = e * jO + qO[t[n]];
  return e;
}
function ue(t) {
  if (S(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    t.startsWith("0x") || (t = "0x" + t);
    const e = L1(t);
    return S(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e;
  }
  if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    S(t.substring(2, 4) === KO(t), "bad icap checksum", "address", t);
    let e = WO(t.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return L1("0x" + e);
  }
  S(!1, "invalid address", "address", t);
}
function QO(t) {
  const e = ue(t.from);
  let r = ne(t.nonce, "tx.nonce").toString(16);
  return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, ue(_e(xe(ta([e, r])), 12));
}
function L6(t) {
  return t && typeof t.getAddress == "function";
}
function $1(t) {
  try {
    return ue(t), !0;
  } catch {
  }
  return !1;
}
async function xh(t, e) {
  const n = await e;
  return (n == null || n === "0x0000000000000000000000000000000000000000") && (K(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: t }), S(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), ue(n);
}
function Gt(t, e) {
  if (typeof t == "string")
    return t.match(/^0x[0-9a-f]{40}$/i) ? ue(t) : (K(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), xh(t, e.resolveName(t)));
  if (L6(t))
    return xh(t, t.getAddress());
  if (t && typeof t.then == "function")
    return xh(t, t);
  S(!1, "unsupported addressable value", "target", t);
}
const Dr = {};
function ee(t, e) {
  let n = !1;
  return e < 0 && (n = !0, e *= -1), new kt(Dr, `${n ? "" : "u"}int${e}`, t, { signed: n, width: e });
}
function Be(t, e) {
  return new kt(Dr, `bytes${e || ""}`, t, { size: e });
}
const _1 = Symbol.for("_ethers_typed");
var Wa;
const Lr = class Lr {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    F(this, "type");
    /**
     *  The actual value.
     */
    F(this, "value");
    B(this, Wa);
    /**
     *  @_ignore:
     */
    F(this, "_typedSymbol");
    s == null && (s = null), qf(Dr, e, "Typed"), oe(this, { _typedSymbol: _1, type: n, value: r }), E(this, Wa, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return m(this, Wa);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return m(this, Wa) === !0 ? -1 : m(this, Wa) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, n) {
    return new Lr(Dr, e, n);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return ee(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return ee(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return ee(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return ee(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return ee(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return ee(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return ee(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return ee(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return ee(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return ee(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return ee(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return ee(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return ee(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return ee(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return ee(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return ee(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return ee(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return ee(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return ee(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return ee(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return ee(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return ee(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return ee(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return ee(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return ee(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return ee(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return ee(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return ee(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return ee(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return ee(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return ee(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return ee(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return ee(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return ee(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return ee(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return ee(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return ee(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return ee(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return ee(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return ee(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return ee(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return ee(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return ee(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return ee(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return ee(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return ee(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return ee(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return ee(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return ee(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return ee(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return ee(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return ee(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return ee(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return ee(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return ee(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return ee(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return ee(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return ee(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return ee(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return ee(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return ee(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return ee(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return ee(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return ee(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return ee(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return ee(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Be(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Be(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Be(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Be(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Be(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Be(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Be(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Be(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Be(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Be(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Be(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Be(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Be(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Be(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Be(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Be(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Be(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Be(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Be(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Be(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Be(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Be(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Be(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Be(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Be(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Be(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Be(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Be(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Be(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Be(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Be(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Be(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new Lr(Dr, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new Lr(Dr, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new Lr(Dr, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new Lr(Dr, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, n) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new Lr(Dr, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === _1;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, n) {
    if (Lr.isTyped(e)) {
      if (e.type !== n)
        throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
Wa = new WeakMap();
let kt = Lr;
class JO extends is {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, n) {
    let r = kt.dereference(n, "string");
    try {
      r = ue(r);
    } catch (s) {
      return this._throwError(s.message, n);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return ue(Zn(e.readValue(), 20));
  }
}
class ZO extends is {
  constructor(n) {
    super(n.name, n.type, "_", n.dynamic);
    F(this, "coder");
    this.coder = n;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(n, r) {
    return this.coder.encode(n, r);
  }
  decode(n) {
    return this.coder.decode(n);
  }
}
function H6(t, e, n) {
  let r = [];
  if (Array.isArray(n))
    r = n;
  else if (n && typeof n == "object") {
    let c = {};
    r = e.map((u) => {
      const l = u.localName;
      return K(l, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), K(!c[l], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: n }), c[l] = !0, n[l];
    });
  } else
    S(!1, "invalid tuple value", "tuple", n);
  S(e.length === r.length, "types/value length mismatch", "tuple", n);
  let s = new zm(), a = new zm(), i = [];
  e.forEach((c, u) => {
    let l = r[u];
    if (c.dynamic) {
      let d = a.length;
      c.encode(a, l);
      let f = s.writeUpdatableValue();
      i.push((h) => {
        f(h + d);
      });
    } else
      c.encode(s, l);
  }), i.forEach((c) => {
    c(s.length);
  });
  let o = t.appendWriter(s);
  return o += t.appendWriter(a), o;
}
function $6(t, e) {
  let n = [], r = [], s = t.subReader(0);
  return e.forEach((a) => {
    let i = null;
    if (a.dynamic) {
      let o = t.readIndex(), c = s.subReader(o);
      try {
        i = a.decode(c);
      } catch (u) {
        if (dt(u, "BUFFER_OVERRUN"))
          throw u;
        i = u, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    } else
      try {
        i = a.decode(t);
      } catch (o) {
        if (dt(o, "BUFFER_OVERRUN"))
          throw o;
        i = o, i.baseType = a.name, i.name = a.localName, i.type = a.type;
      }
    if (i == null)
      throw new Error("investigate");
    n.push(i), r.push(a.localName || null);
  }), ic.fromItems(n, r);
}
class XO extends is {
  constructor(n, r, s) {
    const a = n.type + "[" + (r >= 0 ? r : "") + "]", i = r === -1 || n.dynamic;
    super("array", a, s, i);
    F(this, "coder");
    F(this, "length");
    oe(this, { coder: n, length: r });
  }
  defaultValue() {
    const n = this.coder.defaultValue(), r = [];
    for (let s = 0; s < this.length; s++)
      r.push(n);
    return r;
  }
  encode(n, r) {
    const s = kt.dereference(r, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let a = this.length;
    a === -1 && (a = s.length, n.writeValue(s.length)), j2(s.length, a, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let o = 0; o < s.length; o++)
      i.push(this.coder);
    return H6(n, i, s);
  }
  decode(n) {
    let r = this.length;
    r === -1 && (r = n.readIndex(), K(r * _t <= n.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: n.bytes, offset: r * _t, length: n.dataLength }));
    let s = [];
    for (let a = 0; a < r; a++)
      s.push(new ZO(this.coder));
    return $6(n, s);
  }
}
class YO extends is {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, n) {
    const r = kt.dereference(n, "bool");
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class _6 extends is {
  constructor(e, n) {
    super(e, e, n, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, n) {
    n = $t(n);
    let r = e.writeValue(n.length);
    return r += e.writeBytes(n), r;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class eB extends _6 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return V(super.decode(e));
  }
}
class tB extends is {
  constructor(n, r) {
    let s = "bytes" + String(n);
    super(s, s, r, !1);
    F(this, "size");
    oe(this, { size: n }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(n, r) {
    let s = $t(kt.dereference(r, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", r), n.writeBytes(s);
  }
  decode(n) {
    return V(n.readBytes(this.size));
  }
}
const nB = new Uint8Array([]);
class rB extends is {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, n) {
    return n != null && this._throwError("not null", n), e.writeBytes(nB);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const sB = BigInt(0), aB = BigInt(1), iB = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class oB extends is {
  constructor(n, r, s) {
    const a = (r ? "int" : "uint") + n * 8;
    super(a, a, s, !1);
    F(this, "size");
    F(this, "signed");
    oe(this, { size: n, signed: r }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(n, r) {
    let s = ne(kt.dereference(r, this.type)), a = Yc(iB, _t * 8);
    if (this.signed) {
      let i = Yc(a, this.size * 8 - 1);
      (s > i || s < -(i + aB)) && this._throwError("value out-of-bounds", r), s = Qb(s, 8 * _t);
    } else (s < sB || s > Yc(a, this.size * 8)) && this._throwError("value out-of-bounds", r);
    return n.writeValue(s);
  }
  decode(n) {
    let r = Yc(n.readValue(), this.size * 8);
    return this.signed && (r = r7(r, this.size * 8)), r;
  }
}
class cB extends _6 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, n) {
    return super.encode(e, Yt(kt.dereference(n, "string")));
  }
  decode(e) {
    return Jd(super.decode(e));
  }
}
class Gu extends is {
  constructor(n, r) {
    let s = !1;
    const a = [];
    n.forEach((o) => {
      o.dynamic && (s = !0), a.push(o.type);
    });
    const i = "tuple(" + a.join(",") + ")";
    super("tuple", i, r, s);
    F(this, "coders");
    oe(this, { coders: Object.freeze(n.slice()) });
  }
  defaultValue() {
    const n = [];
    this.coders.forEach((s) => {
      n.push(s.defaultValue());
    });
    const r = this.coders.reduce((s, a) => {
      const i = a.localName;
      return i && (s[i] || (s[i] = 0), s[i]++), s;
    }, {});
    return this.coders.forEach((s, a) => {
      let i = s.localName;
      !i || r[i] !== 1 || (i === "length" && (i = "_length"), n[i] == null && (n[i] = n[a]));
    }), Object.freeze(n);
  }
  encode(n, r) {
    const s = kt.dereference(r, "tuple");
    return H6(n, this.coders, s);
  }
  decode(n) {
    return $6(n, this.coders);
  }
}
function Ah(t, e) {
  return {
    address: ue(t),
    storageKeys: e.map((n, r) => (S(Ue(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
  };
}
function Oi(t) {
  if (Array.isArray(t))
    return t.map((n, r) => Array.isArray(n) ? (S(n.length === 2, "invalid slot set", `value[${r}]`, n), Ah(n[0], n[1])) : (S(n != null && typeof n == "object", "invalid address-slot set", "value", t), Ah(n.address, n.storageKeys)));
  S(t != null && typeof t == "object", "invalid access list", "value", t);
  const e = Object.keys(t).map((n) => {
    const r = t[n].reduce((s, a) => (s[a] = !0, s), {});
    return Ah(n, Object.keys(r).sort());
  });
  return e.sort((n, r) => n.address.localeCompare(r.address)), e;
}
function G6(t) {
  return {
    address: ue(t.address),
    nonce: ne(t.nonce != null ? t.nonce : 0),
    chainId: ne(t.chainId != null ? t.chainId : 0),
    signature: en.from(t.signature)
  };
}
function lB(t) {
  let e;
  return typeof t == "string" ? e = Il.computePublicKey(t, !1) : e = t.publicKey, ue(xe("0x" + e.substring(4)).substring(26));
}
function Zm(t, e) {
  return lB(Il.recoverPublicKey(t, e));
}
const nt = BigInt(0), uB = BigInt(2), dB = BigInt(27), fB = BigInt(28), pB = BigInt(35), hB = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), vh = 4096 * 32;
function mB(t) {
  return { blobToKzgCommitment: (r) => {
    if ("computeBlobProof" in t) {
      if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
        return Q(t.blobToKzgCommitment(V(r)));
    } else if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function")
      return Q(t.blobToKzgCommitment(r));
    if ("blobToKZGCommitment" in t && typeof t.blobToKZGCommitment == "function")
      return Q(t.blobToKZGCommitment(V(r)));
    S(!1, "unsupported KZG library", "kzg", t);
  }, computeBlobKzgProof: (r, s) => {
    if ("computeBlobProof" in t && typeof t.computeBlobProof == "function")
      return Q(t.computeBlobProof(V(r), V(s)));
    if ("computeBlobKzgProof" in t && typeof t.computeBlobKzgProof == "function")
      return t.computeBlobKzgProof(r, s);
    if ("computeBlobKZGProof" in t && typeof t.computeBlobKZGProof == "function")
      return Q(t.computeBlobKZGProof(V(r), V(s)));
    S(!1, "unsupported KZG library", "kzg", t);
  } };
}
function G1(t, e) {
  let n = t.toString(16);
  for (; n.length < 2; )
    n = "0" + n;
  return n += Ec(e).substring(4), "0x" + n;
}
function xc(t) {
  return t === "0x" ? null : ue(t);
}
function Yf(t, e) {
  try {
    return Oi(t);
  } catch (n) {
    S(!1, n.message, e, t);
  }
}
function bB(t, e) {
  try {
    if (!Array.isArray(t))
      throw new Error("authorizationList: invalid array");
    const n = [];
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (!Array.isArray(s))
        throw new Error(`authorization[${r}]: invalid array`);
      if (s.length !== 6)
        throw new Error(`authorization[${r}]: wrong length`);
      if (!s[1])
        throw new Error(`authorization[${r}]: null address`);
      n.push({
        address: xc(s[1]),
        nonce: Me(s[2], "nonce"),
        chainId: Me(s[0], "chainId"),
        signature: en.from({
          yParity: Bi(s[3], "yParity"),
          r: fn(s[4], 32),
          s: fn(s[5], 32)
        })
      });
    }
    return n;
  } catch (n) {
    S(!1, n.message, e, t);
  }
}
function Bi(t, e) {
  return t === "0x" ? 0 : ge(t, e);
}
function Me(t, e) {
  if (t === "0x")
    return nt;
  const n = ne(t, e);
  return S(n <= hB, "value exceeds uint size", e, n), n;
}
function ke(t, e) {
  const n = ne(t, "value"), r = Xe(n);
  return S(r.length <= 32, "value too large", `tx.${e}`, n), r;
}
function ep(t) {
  return Oi(t).map((e) => [e.address, e.storageKeys]);
}
function yB(t) {
  return t.map((e) => [
    ke(e.chainId, "chainId"),
    e.address,
    ke(e.nonce, "nonce"),
    ke(e.signature.yParity, "yParity"),
    Xe(e.signature.r),
    Xe(e.signature.s)
  ]);
}
function gB(t, e) {
  S(Array.isArray(t), `invalid ${e}`, "value", t);
  for (let n = 0; n < t.length; n++)
    S(Ue(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
  return t;
}
function wB(t) {
  const e = hu(t);
  S(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
  const n = {
    type: 0,
    nonce: Bi(e[0], "nonce"),
    gasPrice: Me(e[1], "gasPrice"),
    gasLimit: Me(e[2], "gasLimit"),
    to: xc(e[3]),
    value: Me(e[4], "value"),
    data: V(e[5]),
    chainId: nt
  };
  if (e.length === 6)
    return n;
  const r = Me(e[6], "v"), s = Me(e[7], "r"), a = Me(e[8], "s");
  if (s === nt && a === nt)
    n.chainId = r;
  else {
    let i = (r - pB) / uB;
    i < nt && (i = nt), n.chainId = i, S(i !== nt || r === dB || r === fB, "non-canonical legacy v", "v", e[6]), n.signature = en.from({
      r: fn(e[7], 32),
      s: fn(e[8], 32),
      v: r
    });
  }
  return n;
}
function EB(t, e) {
  const n = [
    ke(t.nonce, "nonce"),
    ke(t.gasPrice || 0, "gasPrice"),
    ke(t.gasLimit, "gasLimit"),
    t.to || "0x",
    ke(t.value, "value"),
    t.data
  ];
  let r = nt;
  if (t.chainId != nt)
    r = ne(t.chainId, "tx.chainId"), S(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
  else if (t.signature) {
    const a = t.signature.legacyChainId;
    a != null && (r = a);
  }
  if (!e)
    return r !== nt && (n.push(Xe(r)), n.push("0x"), n.push("0x")), ta(n);
  let s = BigInt(27 + e.yParity);
  return r !== nt ? s = en.getChainIdV(r, e.v) : BigInt(e.v) !== s && S(!1, "tx.chainId/sig.v mismatch", "sig", e), n.push(Xe(s)), n.push(Xe(e.r)), n.push(Xe(e.s)), ta(n);
}
function tp(t, e) {
  let n;
  try {
    if (n = Bi(e[0], "yParity"), n !== 0 && n !== 1)
      throw new Error("bad yParity");
  } catch {
    S(!1, "invalid yParity", "yParity", e[0]);
  }
  const r = fn(e[1], 32), s = fn(e[2], 32), a = en.from({ r, s, yParity: n });
  t.signature = a;
}
function xB(t) {
  const e = hu(Q(t).slice(1));
  S(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", V(t));
  const n = {
    type: 2,
    chainId: Me(e[0], "chainId"),
    nonce: Bi(e[1], "nonce"),
    maxPriorityFeePerGas: Me(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Me(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Me(e[4], "gasLimit"),
    to: xc(e[5]),
    value: Me(e[6], "value"),
    data: V(e[7]),
    accessList: Yf(e[8], "accessList")
  };
  return e.length === 9 || tp(n, e.slice(9)), n;
}
function AB(t, e) {
  const n = [
    ke(t.chainId, "chainId"),
    ke(t.nonce, "nonce"),
    ke(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ke(t.maxFeePerGas || 0, "maxFeePerGas"),
    ke(t.gasLimit, "gasLimit"),
    t.to || "0x",
    ke(t.value, "value"),
    t.data,
    ep(t.accessList || [])
  ];
  return e && (n.push(ke(e.yParity, "yParity")), n.push(Xe(e.r)), n.push(Xe(e.s))), Le(["0x02", ta(n)]);
}
function vB(t) {
  const e = hu(Q(t).slice(1));
  S(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", V(t));
  const n = {
    type: 1,
    chainId: Me(e[0], "chainId"),
    nonce: Bi(e[1], "nonce"),
    gasPrice: Me(e[2], "gasPrice"),
    gasLimit: Me(e[3], "gasLimit"),
    to: xc(e[4]),
    value: Me(e[5], "value"),
    data: V(e[6]),
    accessList: Yf(e[7], "accessList")
  };
  return e.length === 8 || tp(n, e.slice(8)), n;
}
function kB(t, e) {
  const n = [
    ke(t.chainId, "chainId"),
    ke(t.nonce, "nonce"),
    ke(t.gasPrice || 0, "gasPrice"),
    ke(t.gasLimit, "gasLimit"),
    t.to || "0x",
    ke(t.value, "value"),
    t.data,
    ep(t.accessList || [])
  ];
  return e && (n.push(ke(e.yParity, "recoveryParam")), n.push(Xe(e.r)), n.push(Xe(e.s))), Le(["0x01", ta(n)]);
}
function CB(t) {
  let e = hu(Q(t).slice(1)), n = "3", r = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    n = "3 (network format)";
    const a = e[1], i = e[2], o = e[3];
    S(Array.isArray(a), "invalid network format: blobs not an array", "fields[1]", a), S(Array.isArray(i), "invalid network format: commitments not an array", "fields[2]", i), S(Array.isArray(o), "invalid network format: proofs not an array", "fields[3]", o), S(a.length === i.length, "invalid network format: blobs/commitments length mismatch", "fields", e), S(a.length === o.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
    for (let c = 0; c < e[1].length; c++)
      r.push({
        data: a[c],
        commitment: i[c],
        proof: o[c]
      });
    e = e[0];
  }
  S(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${n}`, "data", V(t));
  const s = {
    type: 3,
    chainId: Me(e[0], "chainId"),
    nonce: Bi(e[1], "nonce"),
    maxPriorityFeePerGas: Me(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Me(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Me(e[4], "gasLimit"),
    to: xc(e[5]),
    value: Me(e[6], "value"),
    data: V(e[7]),
    accessList: Yf(e[8], "accessList"),
    maxFeePerBlobGas: Me(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  r && (s.blobs = r), S(s.to != null, `invalid address for transaction type: ${n}`, "data", t), S(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
  for (let a = 0; a < s.blobVersionedHashes.length; a++)
    S(Ue(s.blobVersionedHashes[a], 32), `invalid blobVersionedHash at index ${a}: must be length 32`, "data", t);
  return e.length === 11 || tp(s, e.slice(11)), s;
}
function TB(t, e, n) {
  const r = [
    ke(t.chainId, "chainId"),
    ke(t.nonce, "nonce"),
    ke(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ke(t.maxFeePerGas || 0, "maxFeePerGas"),
    ke(t.gasLimit, "gasLimit"),
    t.to || ra,
    ke(t.value, "value"),
    t.data,
    ep(t.accessList || []),
    ke(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    gB(t.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (r.push(ke(e.yParity, "yParity")), r.push(Xe(e.r)), r.push(Xe(e.s)), n) ? Le([
    "0x03",
    ta([
      r,
      n.map((s) => s.data),
      n.map((s) => s.commitment),
      n.map((s) => s.proof)
    ])
  ]) : Le(["0x03", ta(r)]);
}
function SB(t) {
  const e = hu(Q(t).slice(1));
  S(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", V(t));
  const n = {
    type: 4,
    chainId: Me(e[0], "chainId"),
    nonce: Bi(e[1], "nonce"),
    maxPriorityFeePerGas: Me(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Me(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Me(e[4], "gasLimit"),
    to: xc(e[5]),
    value: Me(e[6], "value"),
    data: V(e[7]),
    accessList: Yf(e[8], "accessList"),
    authorizationList: bB(e[9], "authorizationList")
  };
  return e.length === 10 || tp(n, e.slice(10)), n;
}
function OB(t, e) {
  const n = [
    ke(t.chainId, "chainId"),
    ke(t.nonce, "nonce"),
    ke(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ke(t.maxFeePerGas || 0, "maxFeePerGas"),
    ke(t.gasLimit, "gasLimit"),
    t.to || "0x",
    ke(t.value, "value"),
    t.data,
    ep(t.accessList || []),
    yB(t.authorizationList || [])
  ];
  return e && (n.push(ke(e.yParity, "yParity")), n.push(Xe(e.r)), n.push(Xe(e.s))), Le(["0x04", ta(n)]);
}
var zn, So, Oo, Bo, Po, Io, Uo, No, Ro, Fo, Mo, Do, Qa, Bs, hr, Ps, Lo, Ho, Cd;
const lr = class lr {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    B(this, Ho);
    B(this, zn);
    B(this, So);
    B(this, Oo);
    B(this, Bo);
    B(this, Po);
    B(this, Io);
    B(this, Uo);
    B(this, No);
    B(this, Ro);
    B(this, Fo);
    B(this, Mo);
    B(this, Do);
    B(this, Qa);
    B(this, Bs);
    B(this, hr);
    B(this, Ps);
    B(this, Lo);
    E(this, zn, null), E(this, So, null), E(this, Bo, 0), E(this, Po, nt), E(this, Io, null), E(this, Uo, null), E(this, No, null), E(this, Oo, "0x"), E(this, Ro, nt), E(this, Fo, nt), E(this, Mo, null), E(this, Do, null), E(this, Qa, null), E(this, Bs, null), E(this, hr, null), E(this, Ps, null), E(this, Lo, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return m(this, zn);
  }
  set type(e) {
    switch (e) {
      case null:
        E(this, zn, null);
        break;
      case 0:
      case "legacy":
        E(this, zn, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        E(this, zn, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        E(this, zn, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        E(this, zn, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        E(this, zn, 4);
        break;
      default:
        S(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = m(this, So);
    return e == null && this.type === 3 ? ra : e;
  }
  set to(e) {
    E(this, So, e == null ? null : ue(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return m(this, Bo);
  }
  set nonce(e) {
    E(this, Bo, ge(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return m(this, Po);
  }
  set gasLimit(e) {
    E(this, Po, ne(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = m(this, Io);
    return e == null && (this.type === 0 || this.type === 1) ? nt : e;
  }
  set gasPrice(e) {
    E(this, Io, e == null ? null : ne(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = m(this, Uo);
    return e ?? (this.type === 2 || this.type === 3 ? nt : null);
  }
  set maxPriorityFeePerGas(e) {
    E(this, Uo, e == null ? null : ne(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = m(this, No);
    return e ?? (this.type === 2 || this.type === 3 ? nt : null);
  }
  set maxFeePerGas(e) {
    E(this, No, e == null ? null : ne(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return m(this, Oo);
  }
  set data(e) {
    E(this, Oo, V(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return m(this, Ro);
  }
  set value(e) {
    E(this, Ro, ne(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return m(this, Fo);
  }
  set chainId(e) {
    E(this, Fo, ne(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return m(this, Mo) || null;
  }
  set signature(e) {
    E(this, Mo, e == null ? null : en.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = m(this, Do) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    E(this, Do, e == null ? null : Oi(e));
  }
  get authorizationList() {
    const e = m(this, Lo) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    E(this, Lo, e == null ? null : e.map((n) => G6(n)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = m(this, Qa);
    return e == null && this.type === 3 ? nt : e;
  }
  set maxFeePerBlobGas(e) {
    E(this, Qa, e == null ? null : ne(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = m(this, Bs);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      S(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let n = 0; n < e.length; n++)
        S(Ue(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n]);
    }
    E(this, Bs, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return m(this, Ps) == null ? null : m(this, Ps).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      E(this, Ps, null);
      return;
    }
    const n = [], r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (Ei(a)) {
        K(m(this, hr), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let i = Q(a);
        if (S(i.length <= vh, "blob is too large", `blobs[${s}]`, a), i.length !== vh) {
          const u = new Uint8Array(vh);
          u.set(i), i = u;
        }
        const o = m(this, hr).blobToKzgCommitment(i), c = V(m(this, hr).computeBlobKzgProof(i, o));
        n.push({
          data: V(i),
          commitment: V(o),
          proof: c
        }), r.push(G1(1, o));
      } else {
        const i = V(a.commitment);
        n.push({
          data: V(a.data),
          commitment: i,
          proof: V(a.proof)
        }), r.push(G1(1, i));
      }
    }
    E(this, Ps, n), E(this, Bs, r);
  }
  get kzg() {
    return m(this, hr);
  }
  set kzg(e) {
    e == null ? E(this, hr, null) : E(this, hr, mB(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : xe(z(this, Ho, Cd).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return xe(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : Zm(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : Il.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return z(this, Ho, Cd).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return z(this, Ho, Cd).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, s = m(this, Qa) != null || m(this, Bs);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && K(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), K(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), K(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const a = [];
    return this.type != null ? a.push(this.type) : this.authorizationList && this.authorizationList.length ? a.push(4) : n ? a.push(2) : e ? (a.push(1), r || a.push(0)) : r ? (a.push(1), a.push(2)) : (s && this.to || (a.push(0), a.push(1), a.push(2)), a.push(3)), a.sort(), a;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return lr.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (n) => n == null ? null : n.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new lr();
    if (typeof e == "string") {
      const r = Q(e);
      if (r[0] >= 127)
        return lr.from(wB(r));
      switch (r[0]) {
        case 1:
          return lr.from(vB(r));
        case 2:
          return lr.from(xB(r));
        case 3:
          return lr.from(CB(r));
        case 4:
          return lr.from(SB(r));
      }
      K(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const n = new lr();
    return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = en.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.authorizationList != null && (n.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (n.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (n.kzg = e.kzg), e.blobs != null && (n.blobs = e.blobs), e.hash != null && (S(n.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), S(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (S(n.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), S(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n;
  }
};
zn = new WeakMap(), So = new WeakMap(), Oo = new WeakMap(), Bo = new WeakMap(), Po = new WeakMap(), Io = new WeakMap(), Uo = new WeakMap(), No = new WeakMap(), Ro = new WeakMap(), Fo = new WeakMap(), Mo = new WeakMap(), Do = new WeakMap(), Qa = new WeakMap(), Bs = new WeakMap(), hr = new WeakMap(), Ps = new WeakMap(), Lo = new WeakMap(), Ho = new WeakSet(), Cd = function(e, n) {
  K(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const r = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return EB(this, r);
    case 1:
      return kB(this, r);
    case 2:
      return AB(this, r);
    case 3:
      return TB(this, r, n ? this.blobs : null);
    case 4:
      return OB(this, r);
  }
  K(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Yd = lr;
function Tr(t) {
  return xe(Yt(t));
}
var BB = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const z1 = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), V1 = 4;
function PB(t) {
  let e = 0;
  function n() {
    return t[e++] << 8 | t[e++];
  }
  let r = n(), s = 1, a = [0, 1];
  for (let x = 1; x < r; x++)
    a.push(s += n());
  let i = n(), o = e;
  e += i;
  let c = 0, u = 0;
  function l() {
    return c == 0 && (u = u << 8 | t[e++], c = 8), u >> --c & 1;
  }
  const d = 31, f = 2 ** d, h = f >>> 1, y = h >> 1, b = f - 1;
  let g = 0;
  for (let x = 0; x < d; x++) g = g << 1 | l();
  let w = [], v = 0, A = f;
  for (; ; ) {
    let x = Math.floor(((g - v + 1) * s - 1) / A), O = 0, I = r;
    for (; I - O > 1; ) {
      let N = O + I >>> 1;
      x < a[N] ? I = N : O = N;
    }
    if (O == 0) break;
    w.push(O);
    let T = v + Math.floor(A * a[O] / s), C = v + Math.floor(A * a[O + 1] / s) - 1;
    for (; !((T ^ C) & h); )
      g = g << 1 & b | l(), T = T << 1 & b, C = C << 1 & b | 1;
    for (; T & ~C & y; )
      g = g & h | g << 1 & b >>> 1 | l(), T = T << 1 ^ h, C = (C ^ h) << 1 | h | 1;
    v = T, A = 1 + C - T;
  }
  let P = r - 4;
  return w.map((x) => {
    switch (x - P) {
      case 3:
        return P + 65792 + (t[o++] << 16 | t[o++] << 8 | t[o++]);
      case 2:
        return P + 256 + (t[o++] << 8 | t[o++]);
      case 1:
        return P + t[o++];
      default:
        return x - 1;
    }
  });
}
function IB(t) {
  let e = 0;
  return () => t[e++];
}
function z6(t) {
  return IB(PB(UB(t)));
}
function UB(t) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, a) => e[s.charCodeAt(0)] = a);
  let n = t.length, r = new Uint8Array(6 * n >> 3);
  for (let s = 0, a = 0, i = 0, o = 0; s < n; s++)
    o = o << 6 | e[t.charCodeAt(s)], i += 6, i >= 8 && (r[a++] = o >> (i -= 8));
  return r;
}
function NB(t) {
  return t & 1 ? ~t >> 1 : t >> 1;
}
function RB(t, e) {
  let n = Array(t);
  for (let r = 0, s = 0; r < t; r++) n[r] = s += NB(e());
  return n;
}
function Ul(t, e = 0) {
  let n = [];
  for (; ; ) {
    let r = t(), s = t();
    if (!s) break;
    e += r;
    for (let a = 0; a < s; a++)
      n.push(e + a);
    e += s + 1;
  }
  return n;
}
function V6(t) {
  return Nl(() => {
    let e = Ul(t);
    if (e.length) return e;
  });
}
function j6(t) {
  let e = [];
  for (; ; ) {
    let n = t();
    if (n == 0) break;
    e.push(FB(n, t));
  }
  for (; ; ) {
    let n = t() - 1;
    if (n < 0) break;
    e.push(MB(n, t));
  }
  return e.flat();
}
function Nl(t) {
  let e = [];
  for (; ; ) {
    let n = t(e.length);
    if (!n) break;
    e.push(n);
  }
  return e;
}
function K6(t, e, n) {
  let r = Array(t).fill().map(() => []);
  for (let s = 0; s < e; s++)
    RB(t, n).forEach((a, i) => r[i].push(a));
  return r;
}
function FB(t, e) {
  let n = 1 + e(), r = e(), s = Nl(e);
  return K6(s.length, 1 + t, e).flatMap((i, o) => {
    let [c, ...u] = i;
    return Array(s[o]).fill().map((l, d) => {
      let f = d * r;
      return [c + d * n, u.map((h) => h + f)];
    });
  });
}
function MB(t, e) {
  let n = 1 + e();
  return K6(n, 1 + t, e).map((s) => [s[0], s.slice(1)]);
}
function DB(t) {
  let e = [], n = Ul(t);
  return s(r([]), []), e;
  function r(a) {
    let i = t(), o = Nl(() => {
      let c = Ul(t).map((u) => n[u]);
      if (c.length) return r(c);
    });
    return { S: i, B: o, Q: a };
  }
  function s({ S: a, B: i }, o, c) {
    if (!(a & 4 && c === o[o.length - 1])) {
      a & 2 && (c = o[o.length - 1]), a & 1 && e.push(o);
      for (let u of i)
        for (let l of u.Q)
          s(u, [...o, l], c);
    }
  }
}
function LB(t) {
  return t.toString(16).toUpperCase().padStart(2, "0");
}
function q6(t) {
  return `{${LB(t)}}`;
}
function HB(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; ) {
    let s = t.codePointAt(n);
    n += s < 65536 ? 1 : 2, e.push(s);
  }
  return e;
}
function dc(t) {
  let n = t.length;
  if (n < 4096) return String.fromCodePoint(...t);
  let r = [];
  for (let s = 0; s < n; )
    r.push(String.fromCodePoint(...t.slice(s, s += 4096)));
  return r.join("");
}
function $B(t, e) {
  let n = t.length, r = n - e.length;
  for (let s = 0; r == 0 && s < n; s++) r = t[s] - e[s];
  return r;
}
var _B = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const Rl = 44032, ef = 4352, tf = 4449, nf = 4519, W6 = 19, Q6 = 21, fc = 28, rf = Q6 * fc, GB = W6 * rf, zB = Rl + GB, VB = ef + W6, jB = tf + Q6, KB = nf + fc;
function tl(t) {
  return t >> 24 & 255;
}
function J6(t) {
  return t & 16777215;
}
let Xm, j1, Ym, Td;
function qB() {
  let t = z6(_B);
  Xm = new Map(V6(t).flatMap((e, n) => e.map((r) => [r, n + 1 << 24]))), j1 = new Set(Ul(t)), Ym = /* @__PURE__ */ new Map(), Td = /* @__PURE__ */ new Map();
  for (let [e, n] of j6(t)) {
    if (!j1.has(e) && n.length == 2) {
      let [r, s] = n, a = Td.get(r);
      a || (a = /* @__PURE__ */ new Map(), Td.set(r, a)), a.set(s, e);
    }
    Ym.set(e, n.reverse());
  }
}
function Z6(t) {
  return t >= Rl && t < zB;
}
function WB(t, e) {
  if (t >= ef && t < VB && e >= tf && e < jB)
    return Rl + (t - ef) * rf + (e - tf) * fc;
  if (Z6(t) && e > nf && e < KB && (t - Rl) % fc == 0)
    return t + (e - nf);
  {
    let n = Td.get(t);
    return n && (n = n.get(e), n) ? n : -1;
  }
}
function X6(t) {
  Xm || qB();
  let e = [], n = [], r = !1;
  function s(a) {
    let i = Xm.get(a);
    i && (r = !0, a |= i), e.push(a);
  }
  for (let a of t)
    for (; ; ) {
      if (a < 128)
        e.push(a);
      else if (Z6(a)) {
        let i = a - Rl, o = i / rf | 0, c = i % rf / fc | 0, u = i % fc;
        s(ef + o), s(tf + c), u > 0 && s(nf + u);
      } else {
        let i = Ym.get(a);
        i ? n.push(...i) : s(a);
      }
      if (!n.length) break;
      a = n.pop();
    }
  if (r && e.length > 1) {
    let a = tl(e[0]);
    for (let i = 1; i < e.length; i++) {
      let o = tl(e[i]);
      if (o == 0 || a <= o) {
        a = o;
        continue;
      }
      let c = i - 1;
      for (; ; ) {
        let u = e[c + 1];
        if (e[c + 1] = e[c], e[c] = u, !c || (a = tl(e[--c]), a <= o)) break;
      }
      a = tl(e[i]);
    }
  }
  return e;
}
function QB(t) {
  let e = [], n = [], r = -1, s = 0;
  for (let a of t) {
    let i = tl(a), o = J6(a);
    if (r == -1)
      i == 0 ? r = o : e.push(o);
    else if (s > 0 && s >= i)
      i == 0 ? (e.push(r, ...n), n.length = 0, r = o) : n.push(o), s = i;
    else {
      let c = WB(r, o);
      c >= 0 ? r = c : s == 0 && i == 0 ? (e.push(r), r = o) : (n.push(o), s = i);
    }
  }
  return r >= 0 && e.push(r, ...n), e;
}
function Y6(t) {
  return X6(t).map(J6);
}
function JB(t) {
  return QB(X6(t));
}
const K1 = 45, eA = ".", tA = 65039, nA = 1, sf = (t) => Array.from(t);
function Fl(t, e) {
  return t.P.has(e) || t.Q.has(e);
}
class ZB extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let e0, rA, Aa, t0, sA, Ji, kh, Mi, ua, q1, n0;
function iy() {
  if (e0) return;
  let t = z6(BB);
  const e = () => Ul(t), n = () => new Set(e()), r = (l, d) => d.forEach((f) => l.add(f));
  e0 = new Map(j6(t)), rA = n(), Aa = e(), t0 = new Set(e().map((l) => Aa[l])), Aa = new Set(Aa), sA = n(), n();
  let s = V6(t), a = t();
  const i = () => {
    let l = /* @__PURE__ */ new Set();
    return e().forEach((d) => r(l, s[d])), r(l, e()), l;
  };
  Ji = Nl((l) => {
    let d = Nl(t).map((f) => f + 96);
    if (d.length) {
      let f = l >= a;
      d[0] -= 32, d = dc(d), f && (d = `Restricted[${d}]`);
      let h = i(), y = i(), b = !t();
      return { N: d, P: h, Q: y, M: b, R: f };
    }
  }), kh = n(), Mi = /* @__PURE__ */ new Map();
  let o = e().concat(sf(kh)).sort((l, d) => l - d);
  o.forEach((l, d) => {
    let f = t(), h = o[d] = f ? o[d - f] : { V: [], M: /* @__PURE__ */ new Map() };
    h.V.push(l), kh.has(l) || Mi.set(l, h);
  });
  for (let { V: l, M: d } of new Set(Mi.values())) {
    let f = [];
    for (let y of l) {
      let b = Ji.filter((w) => Fl(w, y)), g = f.find(({ G: w }) => b.some((v) => w.has(v)));
      g || (g = { G: /* @__PURE__ */ new Set(), V: [] }, f.push(g)), g.V.push(y), r(g.G, b);
    }
    let h = f.flatMap((y) => sf(y.G));
    for (let { G: y, V: b } of f) {
      let g = new Set(h.filter((w) => !y.has(w)));
      for (let w of b)
        d.set(w, g);
    }
  }
  ua = /* @__PURE__ */ new Set();
  let c = /* @__PURE__ */ new Set();
  const u = (l) => ua.has(l) ? c.add(l) : ua.add(l);
  for (let l of Ji) {
    for (let d of l.P) u(d);
    for (let d of l.Q) u(d);
  }
  for (let l of ua)
    !Mi.has(l) && !c.has(l) && Mi.set(l, nA);
  r(ua, Y6(ua)), q1 = DB(t).map((l) => ZB.from(l)).sort($B), n0 = /* @__PURE__ */ new Map();
  for (let l of q1) {
    let d = [n0];
    for (let f of l) {
      let h = d.map((y) => {
        let b = y.get(f);
        return b || (b = /* @__PURE__ */ new Map(), y.set(f, b)), b;
      });
      f === tA ? d.push(...h) : d = h;
    }
    for (let f of d)
      f.V = l;
  }
}
function oy(t) {
  return (aA(t) ? "" : `${cy(np([t]))} `) + q6(t);
}
function cy(t) {
  return `"${t}"`;
}
function XB(t) {
  if (t.length >= 4 && t[2] == K1 && t[3] == K1)
    throw new Error(`invalid label extension: "${dc(t.slice(0, 4))}"`);
}
function YB(t) {
  for (let n = t.lastIndexOf(95); n > 0; )
    if (t[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function eP(t) {
  let e = t[0], n = z1.get(e);
  if (n) throw fl(`leading ${n}`);
  let r = t.length, s = -1;
  for (let a = 1; a < r; a++) {
    e = t[a];
    let i = z1.get(e);
    if (i) {
      if (s == a) throw fl(`${n} + ${i}`);
      s = a + 1, n = i;
    }
  }
  if (s == r) throw fl(`trailing ${n}`);
}
function np(t, e = 1 / 0, n = q6) {
  let r = [];
  tP(t[0]) && r.push(""), t.length > e && (e >>= 1, t = [...t.slice(0, e), 8230, ...t.slice(-e)]);
  let s = 0, a = t.length;
  for (let i = 0; i < a; i++) {
    let o = t[i];
    aA(o) && (r.push(dc(t.slice(s, i))), r.push(n(o)), s = i + 1);
  }
  return r.push(dc(t.slice(s, a))), r.join("");
}
function tP(t) {
  return iy(), Aa.has(t);
}
function aA(t) {
  return iy(), sA.has(t);
}
function nP(t) {
  return iP(rP(t, JB, lP));
}
function rP(t, e, n) {
  if (!t) return [];
  iy();
  let r = 0;
  return t.split(eA).map((s) => {
    let a = HB(s), i = {
      input: a,
      offset: r
      // codepoint, not substring!
    };
    r += a.length + 1;
    try {
      let o = i.tokens = cP(a, e, n), c = o.length, u;
      if (!c)
        throw new Error("empty label");
      let l = i.output = o.flat();
      if (YB(l), !(i.emoji = c > 1 || o[0].is_emoji) && l.every((f) => f < 128))
        XB(l), u = "ASCII";
      else {
        let f = o.flatMap((h) => h.is_emoji ? [] : h);
        if (!f.length)
          u = "Emoji";
        else {
          if (Aa.has(l[0])) throw fl("leading combining mark");
          for (let b = 1; b < c; b++) {
            let g = o[b];
            if (!g.is_emoji && Aa.has(g[0]))
              throw fl(`emoji + combining mark: "${dc(o[b - 1])} + ${np([g[0]])}"`);
          }
          eP(l);
          let h = sf(new Set(f)), [y] = aP(h);
          oP(y, f), sP(y, h), u = y.N;
        }
      }
      i.type = u;
    } catch (o) {
      i.error = o;
    }
    return i;
  });
}
function sP(t, e) {
  let n, r = [];
  for (let s of e) {
    let a = Mi.get(s);
    if (a === nA) return;
    if (a) {
      let i = a.M.get(s);
      if (n = n ? n.filter((o) => i.has(o)) : sf(i), !n.length) return;
    } else
      r.push(s);
  }
  if (n) {
    for (let s of n)
      if (r.every((a) => Fl(s, a)))
        throw new Error(`whole-script confusable: ${t.N}/${s.N}`);
  }
}
function aP(t) {
  let e = Ji;
  for (let n of t) {
    let r = e.filter((s) => Fl(s, n));
    if (!r.length)
      throw Ji.some((s) => Fl(s, n)) ? oA(e[0], n) : iA(n);
    if (e = r, r.length == 1) break;
  }
  return e;
}
function iP(t) {
  return t.map(({ input: e, error: n, output: r }) => {
    if (n) {
      let s = n.message;
      throw new Error(t.length == 1 ? s : `Invalid label ${cy(np(e, 63))}: ${s}`);
    }
    return dc(r);
  }).join(eA);
}
function iA(t) {
  return new Error(`disallowed character: ${oy(t)}`);
}
function oA(t, e) {
  let n = oy(e), r = Ji.find((s) => s.P.has(e));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`);
}
function fl(t) {
  return new Error(`illegal placement: ${t}`);
}
function oP(t, e) {
  for (let n of e)
    if (!Fl(t, n))
      throw oA(t, n);
  if (t.M) {
    let n = Y6(e);
    for (let r = 1, s = n.length; r < s; r++)
      if (t0.has(n[r])) {
        let a = r + 1;
        for (let i; a < s && t0.has(i = n[a]); a++)
          for (let o = r; o < a; o++)
            if (n[o] == i)
              throw new Error(`duplicate non-spacing marks: ${oy(i)}`);
        if (a - r > V1)
          throw new Error(`excessive non-spacing marks: ${cy(np(n.slice(r - 1, a)))} (${a - r}/${V1})`);
        r = a;
      }
  }
}
function cP(t, e, n) {
  let r = [], s = [];
  for (t = t.slice().reverse(); t.length; ) {
    let a = uP(t);
    if (a)
      s.length && (r.push(e(s)), s = []), r.push(n(a));
    else {
      let i = t.pop();
      if (ua.has(i))
        s.push(i);
      else {
        let o = e0.get(i);
        if (o)
          s.push(...o);
        else if (!rA.has(i))
          throw iA(i);
      }
    }
  }
  return s.length && r.push(e(s)), r;
}
function lP(t) {
  return t.filter((e) => e != tA);
}
function uP(t, e) {
  let n = n0, r, s = t.length;
  for (; s && (n = n.get(t[--s]), !!n); ) {
    let { V: a } = n;
    a && (r = a, t.length = s);
  }
  return r;
}
const cA = new Uint8Array(32);
cA.fill(0);
function W1(t) {
  return S(t.length !== 0, "invalid ENS name; empty component", "comp", t), t;
}
function lA(t) {
  const e = Yt(dP(t)), n = [];
  if (t.length === 0)
    return n;
  let r = 0;
  for (let s = 0; s < e.length; s++)
    e[s] === 46 && (n.push(W1(e.slice(r, s))), r = s + 1);
  return S(r < e.length, "invalid ENS name; empty component", "name", t), n.push(W1(e.slice(r))), n;
}
function dP(t) {
  try {
    if (t.length === 0)
      throw new Error("empty label");
    return nP(t);
  } catch (e) {
    S(!1, `invalid ENS name (${e.message})`, "name", t);
  }
}
function r0(t) {
  S(typeof t == "string", "invalid ENS name; not a string", "name", t), S(t.length, "invalid ENS name (empty label)", "name", t);
  let e = cA;
  const n = lA(t);
  for (; n.length; )
    e = xe(Le([e, xe(n.pop())]));
  return V(e);
}
function fP(t, e) {
  const n = e;
  return S(n <= 255, "DNS encoded label cannot exceed 255", "length", n), V(Le(lA(t).map((r) => {
    S(r.length <= n, `label ${JSON.stringify(t)} exceeds ${n} bytes`, "name", t);
    const s = new Uint8Array(r.length + 1);
    return s.set(r, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
function uA(t) {
  return typeof t == "string" && (t = Yt(t)), xe(Le([
    Yt(D6),
    Yt(String(t.length)),
    t
  ]));
}
const pP = new RegExp("^bytes([0-9]+)$"), hP = new RegExp("^(u?int)([0-9]*)$"), mP = new RegExp("^(.*)\\[([0-9]*)\\]$");
function dA(t, e, n) {
  switch (t) {
    case "address":
      return Q(n ? fn(e, 32) : ue(e));
    case "string":
      return Yt(e);
    case "bytes":
      return Q(e);
    case "bool":
      return e = e ? "0x01" : "0x00", Q(n ? fn(e, 32) : e);
  }
  let r = t.match(hP);
  if (r) {
    let s = r[1] === "int", a = parseInt(r[2] || "256");
    return S((!r[2] || r[2] === String(a)) && a % 8 === 0 && a !== 0 && a <= 256, "invalid number type", "type", t), n && (a = 256), s && (e = Qb(e, a)), Q(fn(Xe(e), a / 8));
  }
  if (r = t.match(pP), r) {
    const s = parseInt(r[1]);
    return S(String(s) === r[1] && s !== 0 && s <= 32, "invalid bytes type", "type", t), S(ai(e) === s, `invalid value for ${t}`, "value", e), n ? Q(W2(e, 32)) : e;
  }
  if (r = t.match(mP), r && Array.isArray(e)) {
    const s = r[1], a = parseInt(r[2] || String(e.length));
    S(a === e.length, `invalid array length for ${t}`, "value", e);
    const i = [];
    return e.forEach(function(o) {
      i.push(dA(s, o, !0));
    }), Q(Le(i));
  }
  S(!1, "invalid type", "type", t);
}
function Ee(t, e) {
  S(t.length === e.length, "wrong number of values; expected ${ types.length }", "values", e);
  const n = [];
  return t.forEach(function(r, s) {
    n.push(dA(r, e[s]));
  }), V(Le(n));
}
function oi(t, e) {
  return xe(Ee(t, e));
}
const fA = new Uint8Array(32);
fA.fill(0);
const bP = BigInt(-1), pA = BigInt(0), hA = BigInt(1), yP = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function gP(t) {
  const e = Q(t), n = e.length % 32;
  return n ? Le([e, fA.slice(n)]) : V(e);
}
const wP = Zn(hA, 32), EP = Zn(pA, 32), Q1 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Ch = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function J1(t) {
  return function(e) {
    return S(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e;
  };
}
const xP = {
  name: J1("name"),
  version: J1("version"),
  chainId: function(t) {
    const e = ne(t, "domain.chainId");
    return S(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : qn(e);
  },
  verifyingContract: function(t) {
    try {
      return ue(t).toLowerCase();
    } catch {
    }
    S(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t);
  },
  salt: function(t) {
    const e = Q(t, "domain.salt");
    return S(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), V(e);
  }
};
function Th(t) {
  {
    const e = t.match(/^(u?)int(\d+)$/);
    if (e) {
      const n = e[1] === "", r = parseInt(e[2]);
      S(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", t);
      const s = Yc(yP, n ? r - 1 : r), a = n ? (s + hA) * bP : pA;
      return function(i) {
        const o = ne(i, "value");
        return S(o >= a && o <= s, `value out-of-bounds for ${t}`, "value", o), Zn(n ? Qb(o, 256) : o, 32);
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const n = parseInt(e[1]);
      return S(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t), function(r) {
        const s = Q(r);
        return S(s.length === n, `invalid length for ${t}`, "value", r), gP(r);
      };
    }
  }
  switch (t) {
    case "address":
      return function(e) {
        return fn(ue(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? wP : EP;
      };
    case "bytes":
      return function(e) {
        return xe(e);
      };
    case "string":
      return function(e) {
        return Tr(e);
      };
  }
  return null;
}
function Z1(t, e) {
  return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
function zu(t) {
  const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: t };
}
var tu, Kr, $o, If, mA;
const En = class En {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    B(this, If);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    F(this, "primaryType");
    B(this, tu);
    B(this, Kr);
    B(this, $o);
    E(this, Kr, /* @__PURE__ */ new Map()), E(this, $o, /* @__PURE__ */ new Map());
    const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = {};
    Object.keys(e).forEach((c) => {
      a[c] = e[c].map(({ name: u, type: l }) => {
        let { base: d, index: f } = zu(l);
        return d === "int" && !e.int && (d = "int256"), d === "uint" && !e.uint && (d = "uint256"), { name: u, type: d + (f || "") };
      }), n.set(c, /* @__PURE__ */ new Set()), r.set(c, []), s.set(c, /* @__PURE__ */ new Set());
    }), E(this, tu, JSON.stringify(a));
    for (const c in a) {
      const u = /* @__PURE__ */ new Set();
      for (const l of a[c]) {
        S(!u.has(l.name), `duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(c)}`, "types", e), u.add(l.name);
        const d = zu(l.type).base;
        S(d !== c, `circular type reference to ${JSON.stringify(d)}`, "types", e), !Th(d) && (S(r.has(d), `unknown type ${JSON.stringify(d)}`, "types", e), r.get(d).push(c), n.get(c).add(d));
      }
    }
    const i = Array.from(r.keys()).filter((c) => r.get(c).length === 0);
    S(i.length !== 0, "missing primary type", "types", e), S(i.length === 1, `ambiguous primary types or unused types: ${i.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), oe(this, { primaryType: i[0] });
    function o(c, u) {
      S(!u.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), u.add(c);
      for (const l of n.get(c))
        if (r.has(l)) {
          o(l, u);
          for (const d of u)
            s.get(d).add(l);
        }
      u.delete(c);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [c, u] of s) {
      const l = Array.from(u);
      l.sort(), m(this, Kr).set(c, Z1(c, a[c]) + l.map((d) => Z1(d, a[d])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(m(this, tu));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let n = m(this, $o).get(e);
    return n || (n = z(this, If, mA).call(this, e), m(this, $o).set(e, n)), n;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const n = m(this, Kr).get(e);
    return S(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, n) {
    return this.getEncoder(e)(n);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, n) {
    return xe(this.encodeData(e, n));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, n, r) {
    if (Th(e))
      return r(e, n);
    const s = zu(e).array;
    if (s)
      return S(s.count === -1 || s.count === n.length, `array length mismatch; expected length ${s.count}`, "value", n), n.map((i) => this._visit(s.prefix, i, r));
    const a = this.types[e];
    if (a)
      return a.reduce((i, { name: o, type: c }) => (i[o] = this._visit(c, n[o], r), i), {});
    S(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, n) {
    return this._visit(this.primaryType, e, n);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new En(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return En.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, n, r) {
    return En.from(n).hashStruct(e, r);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const n = [];
    for (const r in e) {
      if (e[r] == null)
        continue;
      const s = Q1[r];
      S(s, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({ name: r, type: s });
    }
    return n.sort((r, s) => Ch.indexOf(r.name) - Ch.indexOf(s.name)), En.hashStruct("EIP712Domain", { EIP712Domain: n }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, n, r) {
    return Le([
      "0x1901",
      En.hashDomain(e),
      En.from(n).hash(r)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, n, r) {
    return xe(En.encode(e, n, r));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, n, r, s) {
    e = Object.assign({}, e);
    for (const o in e)
      e[o] == null && delete e[o];
    const a = {};
    e.verifyingContract && !Ue(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x");
    const i = En.from(n);
    i.visit(r, (o, c) => (o === "address" && !Ue(c, 20) && (a[c] = "0x"), c));
    for (const o in a)
      a[o] = await s(o);
    return e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]), r = i.visit(r, (o, c) => o === "address" && a[c] ? a[c] : c), { domain: e, value: r };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, n, r) {
    En.hashDomain(e);
    const s = {}, a = [];
    Ch.forEach((c) => {
      const u = e[c];
      u != null && (s[c] = xP[c](u), a.push({ name: c, type: Q1[c] }));
    });
    const i = En.from(n);
    n = i.types;
    const o = Object.assign({}, n);
    return S(o.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), o.EIP712Domain = a, i.encode(r), {
      types: o,
      domain: s,
      primaryType: i.primaryType,
      message: i.visit(r, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return V(Q(u));
        if (c.match(/^u?int/))
          return ne(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return S(typeof u == "string", "invalid string", "value", u), u;
        }
        S(!1, "unsupported type", "type", c);
      })
    };
  }
};
tu = new WeakMap(), Kr = new WeakMap(), $o = new WeakMap(), If = new WeakSet(), mA = function(e) {
  {
    const s = Th(e);
    if (s)
      return s;
  }
  const n = zu(e).array;
  if (n) {
    const s = n.prefix, a = this.getEncoder(s);
    return (i) => {
      S(n.count === -1 || n.count === i.length, `array length mismatch; expected length ${n.count}`, "value", i);
      let o = i.map(a);
      return m(this, Kr).has(s) && (o = o.map(xe)), xe(Le(o));
    };
  }
  const r = this.types[e];
  if (r) {
    const s = Tr(m(this, Kr).get(e));
    return (a) => {
      const i = r.map(({ name: o, type: c }) => {
        const u = this.getEncoder(c)(a[o]);
        return m(this, Kr).has(c) ? xe(u) : u;
      });
      return i.unshift(s), Le(i);
    };
  }
  S(!1, `unknown type: ${e}`, "type", e);
};
let Ml = En;
function zt(t) {
  const e = /* @__PURE__ */ new Set();
  return t.forEach((n) => e.add(n)), Object.freeze(e);
}
const AP = "external public payable override", vP = zt(AP.split(" ")), bA = "constant external internal payable private public pure view override", kP = zt(bA.split(" ")), yA = "constructor error event fallback function receive struct", gA = zt(yA.split(" ")), wA = "calldata memory storage payable indexed", CP = zt(wA.split(" ")), TP = "tuple returns", SP = [yA, wA, TP, bA].join(" "), OP = zt(SP.split(" ")), BP = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, PP = new RegExp("^(\\s*)"), IP = new RegExp("^([0-9]+)"), UP = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), EA = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), xA = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var it, Vn, nu, s0;
const Uf = class Uf {
  constructor(e) {
    B(this, nu);
    B(this, it);
    B(this, Vn);
    E(this, it, 0), E(this, Vn, e.slice());
  }
  get offset() {
    return m(this, it);
  }
  get length() {
    return m(this, Vn).length - m(this, it);
  }
  clone() {
    return new Uf(m(this, Vn));
  }
  reset() {
    E(this, it, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const n = this.peek();
    if (n.type !== "KEYWORD" || !e.has(n.text))
      throw new Error(`expected keyword ${n.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const n = this.peek();
      throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = z(this, nu, s0).call(this, m(this, it) + 1, e.match + 1);
    return E(this, it, e.match + 1), n;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const n = [];
    for (; m(this, it) < e.match - 1; ) {
      const r = this.peek().linkNext;
      n.push(z(this, nu, s0).call(this, m(this, it) + 1, r)), E(this, it, r);
    }
    return E(this, it, e.match + 1), n;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (m(this, it) >= m(this, Vn).length)
      throw new Error("out-of-bounds");
    return m(this, Vn)[m(this, it)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const n = this.peekType("KEYWORD");
    return n != null && e.has(n) ? n : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const n = this.peek();
    return n.type === e ? n.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return Ic(this, it)._++, e;
  }
  toString() {
    const e = [];
    for (let n = m(this, it); n < m(this, Vn).length; n++) {
      const r = m(this, Vn)[n];
      e.push(`${r.type}:${r.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
it = new WeakMap(), Vn = new WeakMap(), nu = new WeakSet(), s0 = function(e = 0, n = 0) {
  return new Uf(m(this, Vn).slice(e, n).map((r) => Object.freeze(Object.assign({}, r, {
    match: r.match - e,
    linkBack: r.linkBack - e,
    linkNext: r.linkNext - e
  }))));
};
let Yn = Uf;
function oa(t) {
  const e = [], n = (i) => {
    const o = a < t.length ? JSON.stringify(t[a]) : "$EOI";
    throw new Error(`invalid token ${o} at ${a}: ${i}`);
  };
  let r = [], s = [], a = 0;
  for (; a < t.length; ) {
    let i = t.substring(a), o = i.match(PP);
    o && (a += o[1].length, i = t.substring(a));
    const c = { depth: r.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: a, value: -1 };
    e.push(c);
    let u = BP[i[0]] || "";
    if (u) {
      if (c.type = u, c.text = i[0], a++, u === "OPEN_PAREN")
        r.push(e.length - 1), s.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        r.length === 0 && n("no matching open bracket"), c.match = r.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (u === "COMMA")
        c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1, s.push(e.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let l = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const d = e.pop().text;
          l = d + l, e[e.length - 1].value = ge(d);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += l;
      }
      continue;
    }
    if (o = i.match(UP), o) {
      if (c.text = o[1], a += c.text.length, OP.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(xA)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (o = i.match(IP), o) {
      c.text = o[1], c.type = "NUMBER", a += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(i[0])} at position ${a}`);
  }
  return new Yn(e.map((i) => Object.freeze(i)));
}
function X1(t, e) {
  let n = [];
  for (const r in e.keys())
    t.has(r) && n.push(r);
  if (n.length > 1)
    throw new Error(`conflicting types: ${n.join(", ")}`);
}
function rp(t, e) {
  if (e.peekKeyword(gA)) {
    const n = e.pop().text;
    if (n !== t)
      throw new Error(`expected ${t}, got ${n}`);
  }
  return e.popType("ID");
}
function ss(t, e) {
  const n = /* @__PURE__ */ new Set();
  for (; ; ) {
    const r = t.peekType("KEYWORD");
    if (r == null || e && !e.has(r))
      break;
    if (t.pop(), n.has(r))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    n.add(r);
  }
  return Object.freeze(n);
}
function AA(t) {
  let e = ss(t, kP);
  return X1(e, zt("constant payable nonpayable".split(" "))), X1(e, zt("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function ts(t, e) {
  return t.popParams().map((n) => pt.from(n, e));
}
function vA(t) {
  if (t.peekType("AT")) {
    if (t.pop(), t.peekType("NUMBER"))
      return ne(t.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function xi(t) {
  if (t.length)
    throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`);
}
const NP = new RegExp(/^(.*)\[([0-9]*)\]$/);
function Y1(t) {
  const e = t.match(xA);
  if (S(e, "invalid type", "type", t), t === "uint")
    return "uint256";
  if (t === "int")
    return "int256";
  if (e[2]) {
    const n = parseInt(e[2]);
    S(n !== 0 && n <= 32, "invalid bytes length", "type", t);
  } else if (e[3]) {
    const n = parseInt(e[3]);
    S(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t);
  }
  return t;
}
const Ge = {}, sn = Symbol.for("_ethers_internal"), ew = "_ParamTypeInternal", tw = "_ErrorInternal", nw = "_EventInternal", rw = "_ConstructorInternal", sw = "_FallbackInternal", aw = "_FunctionInternal", iw = "_StructInternal";
var _o, Sd;
const xn = class xn {
  /**
   *  @private
   */
  constructor(e, n, r, s, a, i, o, c) {
    B(this, _o);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    F(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    F(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    F(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    F(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    F(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    F(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    F(this, "arrayChildren");
    if (qf(e, Ge, "ParamType"), Object.defineProperty(this, sn, { value: ew }), i && (i = Object.freeze(i.slice())), s === "array") {
      if (o == null || c == null)
        throw new Error("");
    } else if (o != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (i == null)
        throw new Error("");
    } else if (i != null)
      throw new Error("");
    oe(this, {
      name: n,
      type: r,
      baseType: s,
      indexed: a,
      components: i,
      arrayLength: o,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const r = this.name || "";
      if (this.isArray()) {
        const a = JSON.parse(this.arrayChildren.format("json"));
        return a.name = r, a.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(a);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: r
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((a) => JSON.parse(a.format(e)))), JSON.stringify(s);
    }
    let n = "";
    return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? n += "(" + this.components.map((r) => r.format(e)).join(e === "full" ? ", " : ",") + ")" : n += this.type, e !== "sighash" && (this.indexed === !0 && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, n) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s) => r.arrayChildren.walk(s, n));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const r = this;
      return e.map((s, a) => r.components[a].walk(s, n));
    }
    return n(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, n) {
    const r = [], s = [e];
    return z(this, _o, Sd).call(this, r, e, n, (a) => {
      s[0] = a;
    }), r.length && await Promise.all(r), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, n) {
    if (xn.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return xn.from(oa(e), n);
      } catch {
        S(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof Yn) {
      let o = "", c = "", u = null;
      ss(e, zt(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", u = e.popParams().map((b) => xn.from(b)), o = `tuple(${u.map((b) => b.format()).join(",")})`) : (o = Y1(e.popType("TYPE")), c = o);
      let l = null, d = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const b = e.pop();
        l = new xn(Ge, "", o, c, null, u, d, l), d = b.value, o += b.text, c = "array", u = null;
      }
      let f = null;
      if (ss(e, CP).has("indexed")) {
        if (!n)
          throw new Error("");
        f = !0;
      }
      const y = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new xn(Ge, y, o, c, f, u, d, l);
    }
    const r = e.name;
    S(!r || typeof r == "string" && r.match(EA), "invalid name", "obj.name", r);
    let s = e.indexed;
    s != null && (S(n, "parameter cannot be indexed", "obj.indexed", e.indexed), s = !!s);
    let a = e.type, i = a.match(NP);
    if (i) {
      const o = parseInt(i[2] || "-1"), c = xn.from({
        type: i[1],
        components: e.components
      });
      return new xn(Ge, r || "", a, "array", s, null, o, c);
    }
    if (a === "tuple" || a.startsWith(
      "tuple("
      /* fix: ) */
    ) || a.startsWith(
      "("
      /* fix: ) */
    )) {
      const o = e.components != null ? e.components.map((u) => xn.from(u)) : null;
      return new xn(Ge, r || "", a, "tuple", s, o, null, null);
    }
    return a = Y1(e.type), new xn(Ge, r || "", a, a, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[sn] === ew;
  }
};
_o = new WeakSet(), Sd = function(e, n, r, s) {
  if (this.isArray()) {
    if (!Array.isArray(n))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && n.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const i = this.arrayChildren, o = n.slice();
    o.forEach((c, u) => {
      var l;
      z(l = i, _o, Sd).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  if (this.isTuple()) {
    const i = this.components;
    let o;
    if (Array.isArray(n))
      o = n.slice();
    else {
      if (n == null || typeof n != "object")
        throw new Error("invalid tuple value");
      o = i.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in n))
          throw new Error(`missing value for component ${c.name}`);
        return n[c.name];
      });
    }
    if (o.length !== this.components.length)
      throw new Error("array is wrong length");
    o.forEach((c, u) => {
      var l;
      z(l = i[u], _o, Sd).call(l, e, c, r, (d) => {
        o[u] = d;
      });
    }), s(o);
    return;
  }
  const a = r(this.type, n);
  a.then ? e.push(async function() {
    s(await a);
  }()) : s(a);
};
let pt = xn;
class Ai {
  /**
   *  @private
   */
  constructor(e, n, r) {
    /**
     *  The type of the fragment.
     */
    F(this, "type");
    /**
     *  The inputs for the fragment.
     */
    F(this, "inputs");
    qf(e, Ge, "Fragment"), r = Object.freeze(r.slice()), oe(this, { type: n, inputs: r });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        Ai.from(JSON.parse(e));
      } catch {
      }
      return Ai.from(oa(e));
    }
    if (e instanceof Yn)
      switch (e.peekKeyword(gA)) {
        case "constructor":
          return es.from(e);
        case "error":
          return Jt.from(e);
        case "event":
          return xr.from(e);
        case "fallback":
        case "receive":
          return $r.from(e);
        case "function":
          return Ar.from(e);
        case "struct":
          return ci.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return es.from(e);
        case "error":
          return Jt.from(e);
        case "event":
          return xr.from(e);
        case "fallback":
        case "receive":
          return $r.from(e);
        case "function":
          return Ar.from(e);
        case "struct":
          return ci.from(e);
      }
      K(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    S(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return es.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return Jt.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return xr.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return Ar.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return ci.isFragment(e);
  }
}
class sp extends Ai {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, r, a);
    /**
     *  The name of the fragment.
     */
    F(this, "name");
    S(typeof s == "string" && s.match(EA), "invalid identifier", "name", s), a = Object.freeze(a.slice()), oe(this, { name: s });
  }
}
function Dl(t, e) {
  return "(" + e.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")";
}
class Jt extends sp {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "error", n, r), Object.defineProperty(this, sn, { value: tw });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return Tr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    const n = [];
    return e !== "sighash" && n.push("error"), n.push(this.name + Dl(e, this.inputs)), n.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (Jt.isFragment(e))
      return e;
    if (typeof e == "string")
      return Jt.from(oa(e));
    if (e instanceof Yn) {
      const n = rp("error", e), r = ts(e);
      return xi(e), new Jt(Ge, n, r);
    }
    return new Jt(Ge, e.name, e.inputs ? e.inputs.map(pt.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[sn] === tw;
  }
}
class xr extends sp {
  /**
   *  @private
   */
  constructor(n, r, s, a) {
    super(n, "event", r, s);
    /**
     *  Whether this event is anonymous.
     */
    F(this, "anonymous");
    Object.defineProperty(this, sn, { value: nw }), oe(this, { anonymous: a });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return Tr(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("event"), r.push(this.name + Dl(n, this.inputs)), n !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(n, r) {
    return r = (r || []).map((a) => pt.from(a)), new xr(Ge, n, r, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(n) {
    if (xr.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return xr.from(oa(n));
      } catch {
        S(!1, "invalid event fragment", "obj", n);
      }
    else if (n instanceof Yn) {
      const r = rp("event", n), s = ts(n, !0), a = !!ss(n, zt(["anonymous"])).has("anonymous");
      return xi(n), new xr(Ge, r, s, a);
    }
    return new xr(Ge, n.name, n.inputs ? n.inputs.map((r) => pt.from(r, !0)) : [], !!n.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(n) {
    return n && n[sn] === nw;
  }
}
class es extends Ai {
  /**
   *  @private
   */
  constructor(n, r, s, a, i) {
    super(n, r, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    F(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    F(this, "gas");
    Object.defineProperty(this, sn, { value: rw }), oe(this, { payable: a, gas: i });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(n) {
    if (K(n != null && n !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), n === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [`constructor${Dl(n, this.inputs)}`];
    return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(n) {
    if (es.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return es.from(oa(n));
      } catch {
        S(!1, "invalid constuctor fragment", "obj", n);
      }
    else if (n instanceof Yn) {
      ss(n, zt(["constructor"]));
      const r = ts(n), s = !!ss(n, vP).has("payable"), a = vA(n);
      return xi(n), new es(Ge, "constructor", r, s, a);
    }
    return new es(Ge, "constructor", n.inputs ? n.inputs.map(pt.from) : [], !!n.payable, n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(n) {
    return n && n[sn] === rw;
  }
}
class $r extends Ai {
  constructor(n, r, s) {
    super(n, "fallback", r);
    /**
     *  If the function can be sent value during invocation.
     */
    F(this, "payable");
    Object.defineProperty(this, sn, { value: sw }), oe(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(n) {
    const r = this.inputs.length === 0 ? "receive" : "fallback";
    if (n === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: r, stateMutability: s });
    }
    return `${r}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(n) {
    if ($r.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return $r.from(oa(n));
      } catch {
        S(!1, "invalid fallback fragment", "obj", n);
      }
    else if (n instanceof Yn) {
      const r = n.toString(), s = n.peekKeyword(zt(["fallback", "receive"]));
      if (S(s, "type must be fallback or receive", "obj", r), n.popKeyword(zt(["fallback", "receive"])) === "receive") {
        const c = ts(n);
        return S(c.length === 0, "receive cannot have arguments", "obj.inputs", c), ss(n, zt(["payable"])), xi(n), new $r(Ge, [], !0);
      }
      let i = ts(n);
      i.length ? S(i.length === 1 && i[0].type === "bytes", "invalid fallback inputs", "obj.inputs", i.map((c) => c.format("minimal")).join(", ")) : i = [pt.from("bytes")];
      const o = AA(n);
      if (S(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o), ss(n, zt(["returns"])).has("returns")) {
        const c = ts(n);
        S(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return xi(n), new $r(Ge, i, o === "payable");
    }
    if (n.type === "receive")
      return new $r(Ge, [], !0);
    if (n.type === "fallback") {
      const r = [pt.from("bytes")], s = n.stateMutability === "payable";
      return new $r(Ge, r, s);
    }
    S(!1, "invalid fallback description", "obj", n);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(n) {
    return n && n[sn] === sw;
  }
}
class Ar extends sp {
  /**
   *  @private
   */
  constructor(n, r, s, a, i, o) {
    super(n, "function", r, a);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    F(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    F(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    F(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    F(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    F(this, "gas");
    Object.defineProperty(this, sn, { value: aw }), i = Object.freeze(i.slice()), oe(this, { constant: s === "view" || s === "pure", gas: o, outputs: i, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return Tr(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(n) {
    if (n == null && (n = "sighash"), n === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(n))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(n)))
      });
    const r = [];
    return n !== "sighash" && r.push("function"), r.push(this.name + Dl(n, this.inputs)), n !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(Dl(n, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(n, r) {
    return r = (r || []).map((a) => pt.from(a)), new Ar(Ge, n, "view", r, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(n) {
    if (Ar.isFragment(n))
      return n;
    if (typeof n == "string")
      try {
        return Ar.from(oa(n));
      } catch {
        S(!1, "invalid function fragment", "obj", n);
      }
    else if (n instanceof Yn) {
      const s = rp("function", n), a = ts(n), i = AA(n);
      let o = [];
      ss(n, zt(["returns"])).has("returns") && (o = ts(n));
      const c = vA(n);
      return xi(n), new Ar(Ge, s, i, a, o, c);
    }
    let r = n.stateMutability;
    return r == null && (r = "payable", typeof n.constant == "boolean" ? (r = "view", n.constant || (r = "payable", typeof n.payable == "boolean" && !n.payable && (r = "nonpayable"))) : typeof n.payable == "boolean" && !n.payable && (r = "nonpayable")), new Ar(Ge, n.name, r, n.inputs ? n.inputs.map(pt.from) : [], n.outputs ? n.outputs.map(pt.from) : [], n.gas != null ? n.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(n) {
    return n && n[sn] === aw;
  }
}
class ci extends sp {
  /**
   *  @private
   */
  constructor(e, n, r) {
    super(e, "struct", n, r), Object.defineProperty(this, sn, { value: iw });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return ci.from(oa(e));
      } catch {
        S(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof Yn) {
      const n = rp("struct", e), r = ts(e);
      return xi(e), new ci(Ge, n, r);
    }
    return new ci(Ge, e.name, e.inputs ? e.inputs.map(pt.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[sn] === iw;
  }
}
const nr = /* @__PURE__ */ new Map();
nr.set(0, "GENERIC_PANIC");
nr.set(1, "ASSERT_FALSE");
nr.set(17, "OVERFLOW");
nr.set(18, "DIVIDE_BY_ZERO");
nr.set(33, "ENUM_RANGE_ERROR");
nr.set(34, "BAD_STORAGE_DATA");
nr.set(49, "STACK_UNDERFLOW");
nr.set(50, "ARRAY_RANGE_ERROR");
nr.set(65, "OUT_OF_MEMORY");
nr.set(81, "UNINITIALIZED_FUNCTION_CALL");
const RP = new RegExp(/^bytes([0-9]*)$/), FP = new RegExp(/^(u?int)([0-9]*)$/);
let Sh = null, ow = 1024;
function MP(t, e, n, r) {
  let s = "missing revert data", a = null;
  const i = null;
  let o = null;
  if (n) {
    s = "execution reverted";
    const u = Q(n);
    if (n = V(n), u.length === 0)
      s += " (no data present; likely require(false) occurred", a = "require(false)";
    else if (u.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (V(u.slice(0, 4)) === "0x08c379a0")
      try {
        a = r.decode(["string"], u.slice(4))[0], o = {
          signature: "Error(string)",
          name: "Error",
          args: [a]
        }, s += `: ${JSON.stringify(a)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (V(u.slice(0, 4)) === "0x4e487b71")
      try {
        const l = Number(r.decode(["uint256"], u.slice(4))[0]);
        o = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [l]
        }, a = `Panic due to ${nr.get(l) || "UNKNOWN"}(${l})`, s += `: ${a}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: e.to ? ue(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = ue(e.from)), $e(s, "CALL_EXCEPTION", {
    action: t,
    data: n,
    reason: a,
    transaction: c,
    invocation: i,
    revert: o
  });
}
var Is, Di;
const Nf = class Nf {
  constructor() {
    B(this, Is);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const n = e.map((s) => z(this, Is, Di).call(this, pt.from(s)));
    return new Gu(n, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, n) {
    j2(n.length, e.length, "types/values length mismatch");
    const r = e.map((i) => z(this, Is, Di).call(this, pt.from(i))), s = new Gu(r, "_"), a = new zm();
    return s.encode(a, n), a.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, n, r) {
    const s = e.map((i) => z(this, Is, Di).call(this, pt.from(i)));
    return new Gu(s, "_").decode(new Vm(n, r, ow));
  }
  static _setDefaultMaxInflation(e) {
    S(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), ow = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return Sh == null && (Sh = new Nf()), Sh;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, n, r) {
    return MP(e, n, r, Nf.defaultAbiCoder());
  }
};
Is = new WeakSet(), Di = function(e) {
  if (e.isArray())
    return new XO(z(this, Is, Di).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new Gu(e.components.map((r) => z(this, Is, Di).call(this, r)), e.name);
  switch (e.baseType) {
    case "address":
      return new JO(e.name);
    case "bool":
      return new YO(e.name);
    case "string":
      return new cB(e.name);
    case "bytes":
      return new eB(e.name);
    case "":
      return new rB(e.name);
  }
  let n = e.type.match(FP);
  if (n) {
    let r = parseInt(n[2] || "256");
    return S(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new oB(r / 8, n[1] === "int", e.name);
  }
  if (n = e.type.match(RP), n) {
    let r = parseInt(n[1]);
    return S(r !== 0 && r <= 32, "invalid bytes length", "param", e), new tB(r, e.name);
  }
  S(!1, "invalid type", "type", e.type);
};
let Ot = Nf;
class DP {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    F(this, "fragment");
    /**
     *  The name of the Event.
     */
    F(this, "name");
    /**
     *  The full Event signature.
     */
    F(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    F(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    F(this, "args");
    const s = e.name, a = e.format();
    oe(this, {
      fragment: e,
      name: s,
      signature: a,
      topic: n,
      args: r
    });
  }
}
class LP {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    F(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    F(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    F(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    F(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    F(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    F(this, "value");
    const a = e.name, i = e.format();
    oe(this, {
      fragment: e,
      name: a,
      args: r,
      signature: i,
      selector: n,
      value: s
    });
  }
}
class HP {
  /**
   *  @_ignore:
   */
  constructor(e, n, r) {
    /**
     *  The matching fragment.
     */
    F(this, "fragment");
    /**
     *  The name of the Error.
     */
    F(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    F(this, "args");
    /**
     *  The full Error signature.
     */
    F(this, "signature");
    /**
     *  The selector for the Error.
     */
    F(this, "selector");
    const s = e.name, a = e.format();
    oe(this, {
      fragment: e,
      name: s,
      args: r,
      signature: a,
      selector: n
    });
  }
}
class cw {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    F(this, "hash");
    /**
     *  @_ignore:
     */
    F(this, "_isIndexed");
    oe(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const lw = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, uw = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (t) => `reverted with reason string ${JSON.stringify(t)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (t) => {
      let e = "unknown panic code";
      return t >= 0 && t <= 255 && lw[t.toString()] && (e = lw[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`;
    }
  }
};
var mr, br, yr, wt, kr, Od, Bd;
const ba = class ba {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    B(this, kr);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    F(this, "fragments");
    /**
     *  The Contract constructor.
     */
    F(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    F(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    F(this, "receive");
    B(this, mr);
    B(this, br);
    B(this, yr);
    //    #structs: Map<string, StructFragment>;
    B(this, wt);
    let n = [];
    typeof e == "string" ? n = JSON.parse(e) : n = e, E(this, yr, /* @__PURE__ */ new Map()), E(this, mr, /* @__PURE__ */ new Map()), E(this, br, /* @__PURE__ */ new Map());
    const r = [];
    for (const i of n)
      try {
        r.push(Ai.from(i));
      } catch (o) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(i)}:`, o.message);
      }
    oe(this, {
      fragments: Object.freeze(r)
    });
    let s = null, a = !1;
    E(this, wt, this.getAbiCoder()), this.fragments.forEach((i, o) => {
      let c;
      switch (i.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          oe(this, { deploy: i });
          return;
        case "fallback":
          i.inputs.length === 0 ? a = !0 : (S(!s || i.payable !== s.payable, "conflicting fallback fragments", `fragments[${o}]`, i), s = i, a = s.payable);
          return;
        case "function":
          c = m(this, yr);
          break;
        case "event":
          c = m(this, br);
          break;
        case "error":
          c = m(this, mr);
          break;
        default:
          return;
      }
      const u = i.format();
      c.has(u) || c.set(u, i);
    }), this.deploy || oe(this, {
      deploy: es.from("constructor()")
    }), oe(this, { fallback: s, receive: a });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const n = e ? "minimal" : "full";
    return this.fragments.map((s) => s.format(n));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((n) => n.format("json"));
    return JSON.stringify(e.map((n) => JSON.parse(n)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Ot.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const n = z(this, kr, Od).call(this, e, null, !1);
    return S(n, "no matching function", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!z(this, kr, Od).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, n) {
    return z(this, kr, Od).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const n = Array.from(m(this, yr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, yr).get(s), r);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const n = z(this, kr, Bd).call(this, e, null, !1);
    return S(n, "no matching event", "key", e), n.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!z(this, kr, Bd).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, n) {
    return z(this, kr, Bd).call(this, e, n || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const n = Array.from(m(this, br).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, br).get(s), r);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, n) {
    if (Ue(e)) {
      const s = e.toLowerCase();
      if (uw[s])
        return Jt.from(uw[s].signature);
      for (const a of m(this, mr).values())
        if (s === a.selector)
          return a;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [a, i] of m(this, mr))
        a.split(
          "("
          /* fix:) */
        )[0] === e && s.push(i);
      if (s.length === 0)
        return e === "Error" ? Jt.from("error Error(string)") : e === "Panic" ? Jt.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const a = s.map((i) => JSON.stringify(i.format())).join(", ");
        S(!1, `ambiguous error description (i.e. ${a})`, "name", e);
      }
      return s[0];
    }
    if (e = Jt.from(e).format(), e === "Error(string)")
      return Jt.from("error Error(string)");
    if (e === "Panic(uint256)")
      return Jt.from("error Panic(uint256)");
    const r = m(this, mr).get(e);
    return r || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const n = Array.from(m(this, mr).keys());
    n.sort((r, s) => r.localeCompare(s));
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      e(m(this, mr).get(s), r);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, n) {
    return m(this, wt).decode(e, n);
  }
  _encodeParams(e, n) {
    return m(this, wt).encode(e, n);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      S(r, "unknown error", "fragment", e), e = r;
    }
    return S(_e(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, _e(n, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, n) {
    if (typeof e == "string") {
      const r = this.getError(e);
      S(r, "unknown error", "fragment", e), e = r;
    }
    return Le([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return S(_e(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, _e(n, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return Le([
      e.selector,
      this._encodeParams(e.inputs, n || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const a = this.getFunction(e);
      S(a, "unknown function", "fragment", e), e = a;
    }
    let r = "invalid length for result data";
    const s = $t(n);
    if (s.length % 32 === 0)
      try {
        return m(this, wt).decode(e.outputs, s);
      } catch {
        r = "could not decode result data";
      }
    K(!1, r, "BAD_DATA", {
      value: V(s),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, n) {
    const r = Q(e, "data"), s = Ot.getBuiltinCallException("call", n, r);
    if (s.message.startsWith("execution reverted (unknown custom error)")) {
      const o = V(r.slice(0, 4)), c = this.getError(o);
      if (c)
        try {
          const u = m(this, wt).decode(c.inputs, r.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const i = this.parseTransaction(n);
    return i && (s.invocation = {
      method: i.name,
      signature: i.signature,
      args: i.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, n) {
    if (typeof e == "string") {
      const r = this.getFunction(e);
      S(r, "unknown function", "fragment", e), e = r;
    }
    return V(m(this, wt).encode(e.outputs, n || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, n) {
    if (typeof e == "string") {
      const a = this.getEvent(e);
      S(a, "unknown event", "eventFragment", e), e = a;
    }
    K(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: n.length, expectedCount: e.inputs.length });
    const r = [];
    e.anonymous || r.push(e.topicHash);
    const s = (a, i) => a.type === "string" ? Tr(i) : a.type === "bytes" ? xe(V(i)) : (a.type === "bool" && typeof i == "boolean" ? i = i ? "0x01" : "0x00" : a.type.match(/^u?int/) ? i = Zn(i) : a.type.match(/^bytes/) ? i = W2(i, 32) : a.type === "address" && m(this, wt).encode(["address"], [i]), fn(V(i), 32));
    for (n.forEach((a, i) => {
      const o = e.inputs[i];
      if (!o.indexed) {
        S(a == null, "cannot filter non-indexed parameters; must be null", "contract." + o.name, a);
        return;
      }
      a == null ? r.push(null) : o.baseType === "array" || o.baseType === "tuple" ? S(!1, "filtering with tuples or arrays not supported", "contract." + o.name, a) : Array.isArray(a) ? r.push(a.map((c) => s(o, c))) : r.push(s(o, a));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(e, n) {
    if (typeof e == "string") {
      const i = this.getEvent(e);
      S(i, "unknown event", "eventFragment", e), e = i;
    }
    const r = [], s = [], a = [];
    return e.anonymous || r.push(e.topicHash), S(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((i, o) => {
      const c = n[o];
      if (i.indexed)
        if (i.type === "string")
          r.push(Tr(c));
        else if (i.type === "bytes")
          r.push(xe(c));
        else {
          if (i.baseType === "tuple" || i.baseType === "array")
            throw new Error("not implemented");
          r.push(m(this, wt).encode([i.type], [c]));
        }
      else
        s.push(i), a.push(c);
    }), {
      data: m(this, wt).encode(s, a),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, n, r) {
    if (typeof e == "string") {
      const h = this.getEvent(e);
      S(h, "unknown event", "eventFragment", e), e = h;
    }
    if (r != null && !e.anonymous) {
      const h = e.topicHash;
      S(Ue(r[0], 32) && r[0].toLowerCase() === h, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
    }
    const s = [], a = [], i = [];
    e.inputs.forEach((h, y) => {
      h.indexed ? h.type === "string" || h.type === "bytes" || h.baseType === "tuple" || h.baseType === "array" ? (s.push(pt.from({ type: "bytes32", name: h.name })), i.push(!0)) : (s.push(h), i.push(!1)) : (a.push(h), i.push(!1));
    });
    const o = r != null ? m(this, wt).decode(s, Le(r)) : null, c = m(this, wt).decode(a, n, !0), u = [], l = [];
    let d = 0, f = 0;
    return e.inputs.forEach((h, y) => {
      let b = null;
      if (h.indexed)
        if (o == null)
          b = new cw(null);
        else if (i[y])
          b = new cw(o[f++]);
        else
          try {
            b = o[f++];
          } catch (g) {
            b = g;
          }
      else
        try {
          b = c[d++];
        } catch (g) {
          b = g;
        }
      u.push(b), l.push(h.name || null);
    }), ic.fromItems(u, l);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const n = Q(e.data, "tx.data"), r = ne(e.value != null ? e.value : 0, "tx.value"), s = this.getFunction(V(n.slice(0, 4)));
    if (!s)
      return null;
    const a = m(this, wt).decode(s.inputs, n.slice(4));
    return new LP(s, s.selector, a, r);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const n = this.getEvent(e.topics[0]);
    return !n || n.anonymous ? null : new DP(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const n = V(e), r = this.getError(_e(n, 0, 4));
    if (!r)
      return null;
    const s = m(this, wt).decode(r.inputs, _e(n, 4));
    return new HP(r, r.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof ba ? e : typeof e == "string" ? new ba(JSON.parse(e)) : typeof e.formatJson == "function" ? new ba(e.formatJson()) : typeof e.format == "function" ? new ba(e.format("json")) : new ba(e);
  }
};
mr = new WeakMap(), br = new WeakMap(), yr = new WeakMap(), wt = new WeakMap(), kr = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
Od = function(e, n, r) {
  if (Ue(e)) {
    const a = e.toLowerCase();
    for (const i of m(this, yr).values())
      if (a === i.selector)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of m(this, yr))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      const i = n.length > 0 ? n[n.length - 1] : null;
      let o = n.length, c = !0;
      kt.isTyped(i) && i.type === "overrides" && (c = !1, o--);
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs.length;
        l !== o && (!c || l !== o - 1) && a.splice(u, 1);
      }
      for (let u = a.length - 1; u >= 0; u--) {
        const l = a[u].inputs;
        for (let d = 0; d < n.length; d++)
          if (kt.isTyped(n[d])) {
            if (d >= l.length) {
              if (n[d].type === "overrides")
                continue;
              a.splice(u, 1);
              break;
            }
            if (n[d].type !== l[d].baseType) {
              a.splice(u, 1);
              break;
            }
          }
      }
    }
    if (a.length === 1 && n && n.length !== a[0].inputs.length) {
      const i = n[n.length - 1];
      (i == null || Array.isArray(i) || typeof i != "object") && a.splice(0, 1);
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      S(!1, `ambiguous function description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = m(this, yr).get(Ar.from(e).format());
  return s || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
Bd = function(e, n, r) {
  if (Ue(e)) {
    const a = e.toLowerCase();
    for (const i of m(this, br).values())
      if (a === i.topicHash)
        return i;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const a = [];
    for (const [i, o] of m(this, br))
      i.split(
        "("
        /* fix:) */
      )[0] === e && a.push(o);
    if (n) {
      for (let i = a.length - 1; i >= 0; i--)
        a[i].inputs.length < n.length && a.splice(i, 1);
      for (let i = a.length - 1; i >= 0; i--) {
        const o = a[i].inputs;
        for (let c = 0; c < n.length; c++)
          if (kt.isTyped(n[c]) && n[c].type !== o[c].baseType) {
            a.splice(i, 1);
            break;
          }
      }
    }
    if (a.length === 0)
      return null;
    if (a.length > 1 && r) {
      const i = a.map((o) => JSON.stringify(o.format())).join(", ");
      S(!1, `ambiguous event description (i.e. matches ${i})`, "key", e);
    }
    return a[0];
  }
  const s = m(this, br).get(xr.from(e).format());
  return s || null;
};
let Bt = ba;
const kA = BigInt(0);
function Zi(t) {
  return t ?? null;
}
function We(t) {
  return t == null ? null : t.toString();
}
class dw {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, n, r) {
    /**
     *  The gas price for legacy networks.
     */
    F(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    F(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    F(this, "maxPriorityFeePerGas");
    oe(this, {
      gasPrice: Zi(e),
      maxFeePerGas: Zi(n),
      maxPriorityFeePerGas: Zi(r)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: n, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: We(e),
      maxFeePerGas: We(n),
      maxPriorityFeePerGas: We(r)
    };
  }
}
function af(t) {
  const e = {};
  t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = V(t.data));
  const n = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of n)
    !(s in t) || t[s] == null || (e[s] = ne(t[s], `request.${s}`));
  const r = "type,nonce".split(/,/);
  for (const s of r)
    !(s in t) || t[s] == null || (e[s] = ge(t[s], `request.${s}`));
  return t.accessList && (e.accessList = Oi(t.accessList)), t.authorizationList && (e.authorizationList = t.authorizationList.slice()), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map((s) => Ei(s) ? V(s) : Object.assign({}, s))), e;
}
var qr;
class $P {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, n) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    F(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    F(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    F(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    F(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    F(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    F(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    F(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    F(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    F(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    F(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    F(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    F(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    F(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    F(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    F(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    F(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    F(this, "baseFeePerGas");
    B(this, qr);
    E(this, qr, e.transactions.map((r) => typeof r != "string" ? new Ll(r, n) : r)), oe(this, {
      provider: n,
      hash: Zi(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      parentBeaconBlockRoot: e.parentBeaconBlockRoot,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      blobGasUsed: e.blobGasUsed,
      excessBlobGas: e.excessBlobGas,
      miner: e.miner,
      prevRandao: Zi(e.prevRandao),
      extraData: e.extraData,
      baseFeePerGas: Zi(e.baseFeePerGas),
      stateRoot: e.stateRoot,
      receiptsRoot: e.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return m(this, qr).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = m(this, qr).slice();
    return e.length === 0 ? [] : (K(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: n, extraData: r, gasLimit: s, gasUsed: a, hash: i, miner: o, prevRandao: c, nonce: u, number: l, parentHash: d, parentBeaconBlockRoot: f, stateRoot: h, receiptsRoot: y, timestamp: b, transactions: g } = this;
    return {
      _type: "Block",
      baseFeePerGas: We(e),
      difficulty: We(n),
      extraData: r,
      gasLimit: We(s),
      gasUsed: We(a),
      blobGasUsed: We(this.blobGasUsed),
      excessBlobGas: We(this.excessBlobGas),
      hash: i,
      miner: o,
      prevRandao: c,
      nonce: u,
      number: l,
      parentHash: d,
      timestamp: b,
      parentBeaconBlockRoot: f,
      stateRoot: h,
      receiptsRoot: y,
      transactions: g
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const n = this.transactions;
    return {
      next: () => e < this.length ? {
        value: n[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return m(this, qr).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let n;
    if (typeof e == "number")
      n = m(this, qr)[e];
    else {
      const r = e.toLowerCase();
      for (const s of m(this, qr))
        if (typeof s == "string") {
          if (s !== r)
            continue;
          n = s;
          break;
        } else {
          if (s.hash !== r)
            continue;
          n = s;
          break;
        }
    }
    if (n == null)
      throw new Error("no such tx");
    return typeof n == "string" ? await this.provider.getTransaction(n) : n;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const n = this.prefetchedTransactions;
    if (typeof e == "number")
      return n[e];
    e = e.toLowerCase();
    for (const r of n)
      if (r.hash === e)
        return r;
    S(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return _P(this);
  }
}
qr = new WeakMap();
class bu {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    F(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    F(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    F(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    F(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    F(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    F(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    F(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    F(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    F(this, "transactionIndex");
    this.provider = n;
    const r = Object.freeze(e.topics.slice());
    oe(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: r,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: n, blockNumber: r, data: s, index: a, removed: i, topics: o, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: e,
      blockHash: n,
      blockNumber: r,
      data: s,
      index: a,
      removed: i,
      topics: o,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return K(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return K(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return K(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return GP(this);
  }
}
var ru;
class CA {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    F(this, "to");
    /**
     *  The sender of the transaction.
     */
    F(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    F(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    F(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    F(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    F(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    F(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    F(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    F(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    F(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    F(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    F(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    F(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    F(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    F(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    F(this, "root");
    B(this, ru);
    E(this, ru, Object.freeze(e.logs.map((s) => new bu(s, n))));
    let r = kA;
    e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), oe(this, {
      provider: n,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      blobGasUsed: e.blobGasUsed,
      gasPrice: r,
      blobGasPrice: e.blobGasPrice,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return m(this, ru);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: n,
      contractAddress: r,
      hash: s,
      index: a,
      blockHash: i,
      blockNumber: o,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: l,
      root: d
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: i,
      blockNumber: o,
      //byzantium, 
      contractAddress: r,
      cumulativeGasUsed: We(this.cumulativeGasUsed),
      from: n,
      gasPrice: We(this.gasPrice),
      blobGasUsed: We(this.blobGasUsed),
      blobGasPrice: We(this.blobGasPrice),
      gasUsed: We(this.gasUsed),
      hash: s,
      index: a,
      logs: u,
      logsBloom: c,
      root: d,
      status: l,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return SA(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return K(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), TA(this, e);
  }
}
ru = new WeakMap();
var Us;
const Ig = class Ig {
  /**
   *  @_ignore:
   */
  constructor(e, n) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    F(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    F(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    F(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    F(this, "index");
    /**
     *  The transaction hash.
     */
    F(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    F(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    F(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    F(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    F(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    F(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    F(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    F(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    F(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    F(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    F(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    F(this, "value");
    /**
     *  The chain ID.
     */
    F(this, "chainId");
    /**
     *  The signature.
     */
    F(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    F(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    F(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    F(this, "authorizationList");
    B(this, Us);
    this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, E(this, Us, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: n, index: r, hash: s, type: a, to: i, from: o, nonce: c, data: u, signature: l, accessList: d, blobVersionedHashes: f } = this;
    return {
      _type: "TransactionResponse",
      accessList: d,
      blockNumber: e,
      blockHash: n,
      blobVersionedHashes: f,
      chainId: We(this.chainId),
      data: u,
      from: o,
      gasLimit: We(this.gasLimit),
      gasPrice: We(this.gasPrice),
      hash: s,
      maxFeePerGas: We(this.maxFeePerGas),
      maxPriorityFeePerGas: We(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: We(this.maxFeePerBlobGas),
      nonce: c,
      signature: l,
      to: i,
      index: r,
      type: a,
      value: We(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const r = await this.getTransaction();
      r && (e = r.blockNumber);
    }
    if (e == null)
      return null;
    const n = this.provider.getBlock(e);
    if (n == null)
      throw new Error("TODO");
    return n;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: n, blockNumber: r } = await ot({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, n) {
    const r = e ?? 1, s = n ?? 0;
    let a = m(this, Us), i = -1, o = a === -1;
    const c = async () => {
      if (o)
        return null;
      const { blockNumber: f, nonce: h } = await ot({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (h < this.nonce) {
        a = f;
        return;
      }
      if (o)
        return null;
      const y = await this.getTransaction();
      if (!(y && y.blockNumber != null))
        for (i === -1 && (i = a - 3, i < m(this, Us) && (i = m(this, Us))); i <= f; ) {
          if (o)
            return null;
          const b = await this.provider.getBlock(i, !0);
          if (b == null)
            return;
          for (const g of b)
            if (g === this.hash)
              return;
          for (let g = 0; g < b.length; g++) {
            const w = await b.getTransaction(g);
            if (w.from === this.from && w.nonce === this.nonce) {
              if (o)
                return null;
              const v = await this.provider.getTransactionReceipt(w.hash);
              if (v == null || f - v.blockNumber + 1 < r)
                return;
              let A = "replaced";
              w.data === this.data && w.to === this.to && w.value === this.value ? A = "repriced" : w.data === "0x" && w.from === w.to && w.value === kA && (A = "cancelled"), K(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: A === "replaced" || A === "cancelled",
                reason: A,
                replacement: w.replaceableTransaction(a),
                hash: w.hash,
                receipt: v
              });
            }
          }
          i++;
        }
    }, u = (f) => {
      if (f == null || f.status !== 0)
        return f;
      K(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: f.to,
          from: f.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: f
      });
    }, l = await this.provider.getTransactionReceipt(this.hash);
    if (r === 0)
      return u(l);
    if (l) {
      if (r === 1 || await l.confirmations() >= r)
        return u(l);
    } else if (await c(), r === 0)
      return null;
    return await new Promise((f, h) => {
      const y = [], b = () => {
        y.forEach((w) => w());
      };
      if (y.push(() => {
        o = !0;
      }), s > 0) {
        const w = setTimeout(() => {
          b(), h($e("wait for transaction timeout", "TIMEOUT"));
        }, s);
        y.push(() => {
          clearTimeout(w);
        });
      }
      const g = async (w) => {
        if (await w.confirmations() >= r) {
          b();
          try {
            f(u(w));
          } catch (v) {
            h(v);
          }
        }
      };
      if (y.push(() => {
        this.provider.off(this.hash, g);
      }), this.provider.on(this.hash, g), a >= 0) {
        const w = async () => {
          try {
            await c();
          } catch (v) {
            if (dt(v, "TRANSACTION_REPLACED")) {
              b(), h(v);
              return;
            }
          }
          o || this.provider.once("block", w);
        };
        y.push(() => {
          this.provider.off("block", w);
        }), this.provider.once("block", w);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return K(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), SA(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return K(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), K(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), TA(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    S(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const n = new Ig(this, this.provider);
    return E(n, Us, e), n;
  }
};
Us = new WeakMap();
let Ll = Ig;
function _P(t) {
  return { orphan: "drop-block", hash: t.hash, number: t.number };
}
function TA(t, e) {
  return { orphan: "reorder-transaction", tx: t, other: e };
}
function SA(t) {
  return { orphan: "drop-transaction", tx: t };
}
function GP(t) {
  return { orphan: "drop-log", log: {
    transactionHash: t.transactionHash,
    blockHash: t.blockHash,
    blockNumber: t.blockNumber,
    address: t.address,
    data: t.data,
    topics: Object.freeze(t.topics.slice()),
    index: t.index
  } };
}
class ly extends bu {
  /**
   * @_ignore:
   */
  constructor(n, r, s) {
    super(n, n.provider);
    /**
     *  The Contract Interface.
     */
    F(this, "interface");
    /**
     *  The matching event.
     */
    F(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    F(this, "args");
    const a = r.decodeEventLog(s, n.data, n.topics);
    oe(this, { args: a, fragment: s, interface: r });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class OA extends bu {
  /**
   * @_ignore:
   */
  constructor(n, r) {
    super(n, n.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    F(this, "error");
    oe(this, { error: r });
  }
}
var Go;
class zP extends CA {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    B(this, Go);
    E(this, Go, n);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((n) => {
      const r = n.topics.length ? m(this, Go).getEvent(n.topics[0]) : null;
      if (r)
        try {
          return new ly(n, m(this, Go), r);
        } catch (s) {
          return new OA(n, s);
        }
      return n;
    });
  }
}
Go = new WeakMap();
var su;
class uy extends Ll {
  /**
   *  @_ignore:
   */
  constructor(n, r, s) {
    super(s, r);
    B(this, su);
    E(this, su, n);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(n, r) {
    const s = await super.wait(n, r);
    return s == null ? null : new zP(m(this, su), this.provider, s);
  }
}
su = new WeakMap();
class BA extends Q2 {
  /**
   *  @_event:
   */
  constructor(n, r, s, a) {
    super(n, r, s);
    /**
     *  The log with no matching events.
     */
    F(this, "log");
    oe(this, { log: a });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class VP extends BA {
  /**
   *  @_ignore:
   */
  constructor(e, n, r, s, a) {
    super(e, n, r, new ly(a, e.interface, s));
    const i = e.interface.decodeEventLog(s, this.log.data, this.log.topics);
    oe(this, { args: i, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const fw = BigInt(0);
function PA(t) {
  return t && typeof t.call == "function";
}
function IA(t) {
  return t && typeof t.estimateGas == "function";
}
function ap(t) {
  return t && typeof t.resolveName == "function";
}
function UA(t) {
  return t && typeof t.sendTransaction == "function";
}
function NA(t) {
  if (t != null) {
    if (ap(t))
      return t;
    if (t.provider)
      return t.provider;
  }
}
var au;
class jP {
  constructor(e, n, r) {
    B(this, au);
    F(this, "fragment");
    if (oe(this, { fragment: n }), n.inputs.length < r.length)
      throw new Error("too many arguments");
    const s = vi(e.runner, "resolveName"), a = ap(s) ? s : null;
    E(this, au, async function() {
      const i = await Promise.all(n.inputs.map((o, c) => r[c] == null ? null : o.walkAsync(r[c], (l, d) => l === "address" ? Array.isArray(d) ? Promise.all(d.map((f) => Gt(f, a))) : Gt(d, a) : d)));
      return e.interface.encodeFilterTopics(n, i);
    }());
  }
  getTopicFilter() {
    return m(this, au);
  }
}
au = new WeakMap();
function vi(t, e) {
  return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null;
}
function va(t) {
  return t == null ? null : t.provider || null;
}
async function RA(t, e) {
  const n = kt.dereference(t, "overrides");
  S(typeof n == "object", "invalid overrides parameter", "overrides", t);
  const r = af(n);
  return S(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), S(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
}
async function KP(t, e, n) {
  const r = vi(t, "resolveName"), s = ap(r) ? r : null;
  return await Promise.all(e.map((a, i) => a.walkAsync(n[i], (o, c) => (c = kt.dereference(c, o), o === "address" ? Gt(c, s) : c))));
}
function qP(t) {
  const e = async function(i) {
    const o = await RA(i, ["data"]);
    o.to = await t.getAddress(), o.from && (o.from = await Gt(o.from, NA(t.runner)));
    const c = t.interface, u = ne(o.value || fw, "overrides.value") === fw, l = (o.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !l && !u && S(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", i), S(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data);
    const d = c.receive || c.fallback && c.fallback.payable;
    return S(d || u, "cannot send value to non-payable fallback", "overrides.value", o.value), S(c.fallback || l, "cannot send data to receive-only contract", "overrides.data", o.data), o;
  }, n = async function(i) {
    const o = vi(t.runner, "call");
    K(PA(o), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await e(i);
    try {
      return await o.call(c);
    } catch (u) {
      throw Wb(u) && u.data ? t.interface.makeError(u.data, c) : u;
    }
  }, r = async function(i) {
    const o = t.runner;
    K(UA(o), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await o.sendTransaction(await e(i)), u = va(t.runner);
    return new uy(t.interface, u, c);
  }, s = async function(i) {
    const o = vi(t.runner, "estimateGas");
    return K(IA(o), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await o.estimateGas(await e(i));
  }, a = async (i) => await r(i);
  return oe(a, {
    _contract: t,
    estimateGas: s,
    populateTransaction: e,
    send: r,
    staticCall: n
  }), a;
}
function WP(t, e) {
  const n = function(...u) {
    const l = t.interface.getFunction(e, u);
    return K(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: u }
    }), l;
  }, r = async function(...u) {
    const l = n(...u);
    let d = {};
    if (l.inputs.length + 1 === u.length && (d = await RA(u.pop()), d.from && (d.from = await Gt(d.from, NA(t.runner)))), l.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const f = await KP(t.runner, l.inputs, u);
    return Object.assign({}, d, await ot({
      to: t.getAddress(),
      data: t.interface.encodeFunctionData(l, f)
    }));
  }, s = async function(...u) {
    const l = await o(...u);
    return l.length === 1 ? l[0] : l;
  }, a = async function(...u) {
    const l = t.runner;
    K(UA(l), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const d = await l.sendTransaction(await r(...u)), f = va(t.runner);
    return new uy(t.interface, f, d);
  }, i = async function(...u) {
    const l = vi(t.runner, "estimateGas");
    return K(IA(l), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await l.estimateGas(await r(...u));
  }, o = async function(...u) {
    const l = vi(t.runner, "call");
    K(PA(l), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const d = await r(...u);
    let f = "0x";
    try {
      f = await l.call(d);
    } catch (y) {
      throw Wb(y) && y.data ? t.interface.makeError(y.data, d) : y;
    }
    const h = n(...u);
    return t.interface.decodeFunctionResult(h, f);
  }, c = async (...u) => n(...u).constant ? await s(...u) : await a(...u);
  return oe(c, {
    name: t.interface.getFunctionName(e),
    _contract: t,
    _key: e,
    getFragment: n,
    estimateGas: i,
    populateTransaction: r,
    send: a,
    staticCall: s,
    staticCallResult: o
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = t.interface.getFunction(e);
      return K(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), u;
    }
  }), c;
}
function QP(t, e) {
  const n = function(...s) {
    const a = t.interface.getEvent(e, s);
    return K(a, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: s }
    }), a;
  }, r = function(...s) {
    return new jP(t, n(...s), s);
  };
  return oe(r, {
    name: t.interface.getEventName(e),
    _contract: t,
    _key: e,
    getFragment: n
  }), Object.defineProperty(r, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = t.interface.getEvent(e);
      return K(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), s;
    }
  }), r;
}
const of = Symbol.for("_ethersInternal_contract"), FA = /* @__PURE__ */ new WeakMap();
function JP(t, e) {
  FA.set(t[of], e);
}
function on(t) {
  return FA.get(t[of]);
}
function ZP(t) {
  return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment;
}
async function dy(t, e) {
  let n, r = null;
  if (Array.isArray(e)) {
    const a = function(i) {
      if (Ue(i, 32))
        return i;
      const o = t.interface.getEvent(i);
      return S(o, "unknown fragment", "name", i), o.topicHash;
    };
    n = e.map((i) => i == null ? null : Array.isArray(i) ? i.map(a) : a(i));
  } else e === "*" ? n = [null] : typeof e == "string" ? Ue(e, 32) ? n = [e] : (r = t.interface.getEvent(e), S(r, "unknown fragment", "event", e), n = [r.topicHash]) : ZP(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [r.topicHash]) : S(!1, "unknown event name", "event", e);
  n = n.map((a) => {
    if (a == null)
      return null;
    if (Array.isArray(a)) {
      const i = Array.from(new Set(a.map((o) => o.toLowerCase())).values());
      return i.length === 1 ? i[0] : (i.sort(), i);
    }
    return a.toLowerCase();
  });
  const s = n.map((a) => a == null ? "null" : Array.isArray(a) ? a.join("|") : a).join("&");
  return { fragment: r, tag: s, topics: n };
}
async function nl(t, e) {
  const { subs: n } = on(t);
  return n.get((await dy(t, e)).tag) || null;
}
async function pw(t, e, n) {
  const r = va(t.runner);
  K(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: s, tag: a, topics: i } = await dy(t, n), { addr: o, subs: c } = on(t);
  let u = c.get(a);
  if (!u) {
    const d = { address: o || t, topics: i }, f = (g) => {
      let w = s;
      if (w == null)
        try {
          w = t.interface.getEvent(g.topics[0]);
        } catch {
        }
      if (w) {
        const v = w, A = s ? t.interface.decodeEventLog(s, g.data, g.topics) : [];
        i0(t, n, A, (P) => new VP(t, P, n, v, g));
      } else
        i0(t, n, [], (v) => new BA(t, v, n, g));
    };
    let h = [];
    u = { tag: a, listeners: [], start: () => {
      h.length || h.push(r.on(d, f));
    }, stop: async () => {
      if (h.length == 0)
        return;
      let g = h;
      h = [], await Promise.all(g), r.off(d, f);
    } }, c.set(a, u);
  }
  return u;
}
let a0 = Promise.resolve();
async function XP(t, e, n, r) {
  await a0;
  const s = await nl(t, e);
  if (!s)
    return !1;
  const a = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: i, once: o }) => {
    const c = Array.from(n);
    r && c.push(r(o ? null : i));
    try {
      i.call(t, ...c);
    } catch {
    }
    return !o;
  }), s.listeners.length === 0 && (s.stop(), on(t).subs.delete(s.tag)), a > 0;
}
async function i0(t, e, n, r) {
  try {
    await a0;
  } catch {
  }
  const s = XP(t, e, n, r);
  return a0 = s, await s;
}
const Vu = ["then"];
var DE;
DE = of;
const Sl = class Sl {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, n, r, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    F(this, "target");
    /**
     *  The contract Interface.
     */
    F(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    F(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    F(this, "filters");
    /**
     *  @_ignore:
     */
    F(this, DE);
    /**
     *  The fallback or receive function if any.
     */
    F(this, "fallback");
    S(typeof e == "string" || L6(e), "invalid value for Contract target", "target", e), r == null && (r = null);
    const a = Bt.from(n);
    oe(this, { target: e, runner: r, interface: a }), Object.defineProperty(this, of, { value: {} });
    let i, o = null, c = null;
    if (s) {
      const d = va(r);
      c = new uy(this.interface, d, s);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (Ue(e))
        o = e, i = Promise.resolve(e);
      else {
        const d = vi(r, "resolveName");
        if (!ap(d))
          throw $e("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        i = d.resolveName(e).then((f) => {
          if (f == null)
            throw $e("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return on(this).addr = f, f;
        });
      }
    else
      i = e.getAddress().then((d) => {
        if (d == null)
          throw new Error("TODO");
        return on(this).addr = d, d;
      });
    JP(this, { addrPromise: i, addr: o, deployTx: c, subs: u });
    const l = new Proxy({}, {
      get: (d, f, h) => {
        if (typeof f == "symbol" || Vu.indexOf(f) >= 0)
          return Reflect.get(d, f, h);
        try {
          return this.getEvent(f);
        } catch (y) {
          if (!dt(y, "INVALID_ARGUMENT") || y.argument !== "key")
            throw y;
        }
      },
      has: (d, f) => Vu.indexOf(f) >= 0 ? Reflect.has(d, f) : Reflect.has(d, f) || this.interface.hasEvent(String(f))
    });
    return oe(this, { filters: l }), oe(this, {
      fallback: a.receive || a.fallback ? qP(this) : null
    }), new Proxy(this, {
      get: (d, f, h) => {
        if (typeof f == "symbol" || f in d || Vu.indexOf(f) >= 0)
          return Reflect.get(d, f, h);
        try {
          return d.getFunction(f);
        } catch (y) {
          if (!dt(y, "INVALID_ARGUMENT") || y.argument !== "key")
            throw y;
        }
      },
      has: (d, f) => typeof f == "symbol" || f in d || Vu.indexOf(f) >= 0 ? Reflect.has(d, f) : d.interface.hasFunction(f)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new Sl(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new Sl(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await on(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = va(this.runner);
    K(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const n = await e.getCode(await this.getAddress());
    return n === "0x" ? null : n;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const r = va(this.runner);
    return K(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, a) => {
      const i = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          r.once("block", i);
        } catch (o) {
          a(o);
        }
      };
      i();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return on(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), WP(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), QP(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, n, r) {
    n == null && (n = 0), r == null && (r = "latest");
    const { addr: s, addrPromise: a } = on(this), i = s || await a, { fragment: o, topics: c } = await dy(this, e), u = { address: i, topics: c, fromBlock: n, toBlock: r }, l = va(this.runner);
    return K(l, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await l.getLogs(u)).map((d) => {
      let f = o;
      if (f == null)
        try {
          f = this.interface.getEvent(d.topics[0]);
        } catch {
        }
      if (f)
        try {
          return new ly(d, this.interface, f);
        } catch (h) {
          return new OA(d, h);
        }
      return new bu(d, l);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, n) {
    const r = await pw(this, "on", e);
    return r.listeners.push({ listener: n, once: !1 }), r.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, n) {
    const r = await pw(this, "once", e);
    return r.listeners.push({ listener: n, once: !0 }), r.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...n) {
    return await i0(this, e, n, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const s = await nl(this, e);
      return s ? s.listeners.length : 0;
    }
    const { subs: n } = on(this);
    let r = 0;
    for (const { listeners: s } of n.values())
      r += s.length;
    return r;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const s = await nl(this, e);
      return s ? s.listeners.map(({ listener: a }) => a) : [];
    }
    const { subs: n } = on(this);
    let r = [];
    for (const { listeners: s } of n.values())
      r = r.concat(s.map(({ listener: a }) => a));
    return r;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, n) {
    const r = await nl(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (n == null || r.listeners.length === 0) && (r.stop(), on(this).subs.delete(r.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const n = await nl(this, e);
      if (!n)
        return this;
      n.stop(), on(this).subs.delete(n.tag);
    } else {
      const { subs: n } = on(this);
      for (const { tag: r, stop: s } of n.values())
        s(), n.delete(r);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, n) {
    return await this.on(e, n);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, n) {
    return await this.off(e, n);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class n extends Sl {
      constructor(s, a = null) {
        super(s, e, a);
      }
    }
    return n;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, n, r) {
    return r == null && (r = null), new this(e, n, r);
  }
};
let o0 = Sl;
function YP() {
  return o0;
}
class vr extends YP() {
}
function Oh(t) {
  return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : S(!1, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`;
}
class e9 {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    /**
     *  The name.
     */
    F(this, "name");
    oe(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, n) {
    throw new Error("unsupported coin");
  }
}
const MA = new RegExp("^(ipfs)://(.*)$", "i"), hw = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  MA,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var Ns, Ja, Rs, Li, Rf, DA;
const qi = class qi {
  constructor(e, n, r) {
    B(this, Rs);
    /**
     *  The connected provider.
     */
    F(this, "provider");
    /**
     *  The address of the resolver.
     */
    F(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    F(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    B(this, Ns);
    B(this, Ja);
    oe(this, { provider: e, address: n, name: r }), E(this, Ns, null), E(this, Ja, new vr(n, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return m(this, Ns) == null && E(this, Ns, (async () => {
      try {
        return await m(this, Ja).supportsInterface("0x9061b923");
      } catch (e) {
        if (dt(e, "CALL_EXCEPTION"))
          return !1;
        throw E(this, Ns, null), e;
      }
    })()), await m(this, Ns);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const a = await z(this, Rs, Li).call(this, "addr(bytes32)");
        return a == null || a === ra ? null : a;
      } catch (a) {
        if (dt(a, "CALL_EXCEPTION"))
          return null;
        throw a;
      }
    if (e >= 0 && e < 2147483648) {
      let a = e + 2147483648;
      const i = await z(this, Rs, Li).call(this, "addr(bytes32,uint)", [a]);
      if (Ue(i, 20))
        return ue(i);
    }
    let n = null;
    for (const a of this.provider.plugins)
      if (a instanceof e9 && a.supportsCoinType(e)) {
        n = a;
        break;
      }
    if (n == null)
      return null;
    const r = await z(this, Rs, Li).call(this, "addr(bytes32,uint)", [e]);
    if (r == null || r === "0x")
      return null;
    const s = await n.decodeAddress(e, r);
    if (s != null)
      return s;
    K(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: r }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const n = await z(this, Rs, Li).call(this, "text(bytes32,string)", [e]);
    return n == null || n === "0x" ? null : n;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await z(this, Rs, Li).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (n) {
      const s = n[1] === "e3010170" ? "ipfs" : "ipns", a = parseInt(n[4], 16);
      if (n[5].length === a * 2)
        return `${s}://${a7("0x" + n[2])}`;
    }
    const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (r && r[1].length === 64)
      return `bzz://${r[1]}`;
    K(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const n = await this.getText("avatar");
      if (n == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: n });
      for (let r = 0; r < hw.length; r++) {
        const s = n.match(hw[r]);
        if (s == null)
          continue;
        const a = s[1].toLowerCase();
        switch (a) {
          case "https":
          case "data":
            return e.push({ type: "url", value: n }), { linkage: e, url: n };
          case "ipfs": {
            const i = Oh(n);
            return e.push({ type: "ipfs", value: n }), e.push({ type: "url", value: i }), { linkage: e, url: i };
          }
          case "erc721":
          case "erc1155": {
            const i = a === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: a, value: n });
            const o = await this.getAddress();
            if (o == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return e.push({ type: `!${a}caip`, value: s[2] || "" }), { url: null, linkage: e };
            const u = c[1], l = new vr(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (a === "erc721") {
              const b = await l.ownerOf(u);
              if (o !== b)
                return e.push({ type: "!owner", value: b }), { url: null, linkage: e };
              e.push({ type: "owner", value: b });
            } else if (a === "erc1155") {
              const b = await l.balanceOf(o, u);
              if (!b)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: b.toString() });
            }
            let d = await l[i](u);
            if (d == null || d === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: d }), a === "erc1155" && (d = d.replace("{id}", Zn(u, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: d })), d.match(/^ipfs:/i) && (d = Oh(d)), e.push({ type: "metadata-url", value: d });
            let f = {};
            const h = await new Cr(d).send();
            h.assertOk();
            try {
              f = h.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: h.bodyText });
              } catch {
                const w = h.body;
                return w && e.push({ type: "!metadata", value: V(w) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!f)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(f) });
            let y = f.image;
            if (typeof y != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!y.match(/^(https:\/\/|data:)/i)) {
              if (y.match(MA) == null)
                return e.push({ type: "!imageUrl-ipfs", value: y }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: y }), y = Oh(y);
            }
            return e.push({ type: "url", value: y }), { linkage: e, url: y };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const n = await e.getNetwork(), r = n.getPlugin("org.ethers.plugins.network.Ens");
    return K(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: n }
    }), r.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, n) {
    var s;
    let r = n;
    for (; ; ) {
      if (r === "" || r === "." || n !== "eth" && r === "eth")
        return null;
      const a = await z(s = qi, Rf, DA).call(s, e, r);
      if (a != null) {
        const i = new qi(e, a, n);
        return r !== n && !await i.supportsWildcard() ? null : i;
      }
      r = r.split(".").slice(1).join(".");
    }
  }
};
Ns = new WeakMap(), Ja = new WeakMap(), Rs = new WeakSet(), Li = async function(e, n) {
  n = (n || []).slice();
  const r = m(this, Ja).interface;
  n.unshift(r0(this.name));
  let s = null;
  await this.supportsWildcard() && (s = r.getFunction(e), K(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: e }
  }), n = [
    fP(this.name, 255),
    r.encodeFunctionData(s, n)
  ], e = "resolve(bytes,bytes)"), n.push({
    enableCcipRead: !0
  });
  try {
    const a = await m(this, Ja)[e](...n);
    return s ? r.decodeFunctionResult(s, a)[0] : a;
  } catch (a) {
    if (!dt(a, "CALL_EXCEPTION"))
      throw a;
  }
  return null;
}, Rf = new WeakSet(), DA = async function(e, n) {
  const r = await qi.getEnsAddress(e);
  try {
    const a = await new vr(r, [
      "function resolver(bytes32) view returns (address)"
    ], e).resolver(r0(n), {
      enableCcipRead: !0
    });
    return a === ra ? null : a;
  } catch (s) {
    throw s;
  }
  return null;
}, B(qi, Rf);
let cf = qi;
const mw = BigInt(0);
function ve(t, e) {
  return function(n) {
    return n == null ? e : t(n);
  };
}
function Hl(t, e) {
  return (n) => {
    if (e && n == null)
      return null;
    if (!Array.isArray(n))
      throw new Error("not an array");
    return n.map((r) => t(r));
  };
}
function yu(t, e) {
  return (n) => {
    const r = {};
    for (const s in t) {
      let a = s;
      if (e && s in e && !(a in n)) {
        for (const i of e[s])
          if (i in n) {
            a = i;
            break;
          }
      }
      try {
        const i = t[s](n[a]);
        i !== void 0 && (r[s] = i);
      } catch (i) {
        const o = i instanceof Error ? i.message : "not-an-error";
        K(!1, `invalid value for value.${s} (${o})`, "BAD_DATA", { value: n });
      }
    }
    return r;
  };
}
function t9(t) {
  switch (t) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  S(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
}
function pc(t) {
  return S(Ue(t, !0), "invalid data", "value", t), t;
}
function ct(t) {
  return S(Ue(t, 32), "invalid hash", "value", t), t;
}
const n9 = yu({
  address: ue,
  blockHash: ct,
  blockNumber: ge,
  data: pc,
  index: ge,
  removed: ve(t9, !1),
  topics: Hl(ct),
  transactionHash: ct,
  transactionIndex: ge
}, {
  index: ["logIndex"]
});
function r9(t) {
  return n9(t);
}
const s9 = yu({
  hash: ve(ct),
  parentHash: ct,
  parentBeaconBlockRoot: ve(ct, null),
  number: ge,
  timestamp: ge,
  nonce: ve(pc),
  difficulty: ne,
  gasLimit: ne,
  gasUsed: ne,
  stateRoot: ve(ct, null),
  receiptsRoot: ve(ct, null),
  blobGasUsed: ve(ne, null),
  excessBlobGas: ve(ne, null),
  miner: ve(ue),
  prevRandao: ve(ct, null),
  extraData: pc,
  baseFeePerGas: ve(ne)
}, {
  prevRandao: ["mixHash"]
});
function a9(t) {
  const e = s9(t);
  return e.transactions = t.transactions.map((n) => typeof n == "string" ? n : LA(n)), e;
}
const i9 = yu({
  transactionIndex: ge,
  blockNumber: ge,
  transactionHash: ct,
  address: ue,
  topics: Hl(ct),
  data: pc,
  index: ge,
  blockHash: ct
}, {
  index: ["logIndex"]
});
function o9(t) {
  return i9(t);
}
const c9 = yu({
  to: ve(ue, null),
  from: ve(ue, null),
  contractAddress: ve(ue, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: ge,
  root: ve(V),
  gasUsed: ne,
  blobGasUsed: ve(ne, null),
  logsBloom: ve(pc),
  blockHash: ct,
  hash: ct,
  logs: Hl(o9),
  blockNumber: ge,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: ne,
  effectiveGasPrice: ve(ne),
  blobGasPrice: ve(ne, null),
  status: ve(ge),
  type: ve(ge, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function l9(t) {
  return c9(t);
}
function LA(t) {
  t.to && ne(t.to) === mw && (t.to = "0x0000000000000000000000000000000000000000");
  const e = yu({
    hash: ct,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: ve(ge, void 0),
    type: (n) => n === "0x" || n == null ? 0 : ge(n),
    accessList: ve(Oi, null),
    blobVersionedHashes: ve(Hl(ct, !0), null),
    authorizationList: ve(Hl((n) => {
      let r;
      if (n.signature)
        r = n.signature;
      else {
        let s = n.yParity;
        s === "0x1b" ? s = 0 : s === "0x1c" && (s = 1), r = Object.assign({}, n, { yParity: s });
      }
      return {
        address: ue(n.address),
        chainId: ne(n.chainId),
        nonce: ne(n.nonce),
        signature: en.from(r)
      };
    }, !1), null),
    blockHash: ve(ct, null),
    blockNumber: ve(ge, null),
    transactionIndex: ve(ge, null),
    from: ue,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: ve(ne),
    maxPriorityFeePerGas: ve(ne),
    maxFeePerGas: ve(ne),
    maxFeePerBlobGas: ve(ne, null),
    gasLimit: ne,
    to: ve(ue, null),
    value: ne,
    nonce: ge,
    data: pc,
    creates: ve(ue, null),
    chainId: ve(ne, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(t);
  if (e.to == null && e.creates == null && (e.creates = QO(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = en.from(t.signature) : e.signature = en.from(t), e.chainId == null) {
    const n = e.signature.legacyChainId;
    n != null && (e.chainId = n);
  }
  return e.blockHash && ne(e.blockHash) === mw && (e.blockHash = null), e;
}
const u9 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class gu {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    F(this, "name");
    oe(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new gu(this.name);
  }
}
class ip extends gu {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(n, r) {
    n == null && (n = 0);
    super(`org.ethers.network.plugins.GasCost#${n || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    F(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    F(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    F(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    F(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    F(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    F(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    F(this, "txAccessListAddress");
    const s = { effectiveBlock: n };
    function a(i, o) {
      let c = (r || {})[i];
      c == null && (c = o), S(typeof c == "number", `invalud value for ${i}`, "costs", r), s[i] = c;
    }
    a("txBase", 21e3), a("txCreate", 32e3), a("txDataZero", 4), a("txDataNonzero", 16), a("txAccessListStorageKey", 1900), a("txAccessListAddress", 2400), oe(this, s);
  }
  clone() {
    return new ip(this.effectiveBlock, this);
  }
}
class op extends gu {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    F(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    F(this, "targetNetwork");
    oe(this, {
      address: n || u9,
      targetNetwork: r ?? 1
    });
  }
  clone() {
    return new op(this.address, this.targetNetwork);
  }
}
var iu, ou;
class d9 extends gu {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(n, r) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    B(this, iu);
    B(this, ou);
    E(this, iu, n), E(this, ou, r);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return m(this, iu);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return m(this, ou);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
iu = new WeakMap(), ou = new WeakMap();
const Bh = /* @__PURE__ */ new Map();
var zo, Vo, Fs;
const Wi = class Wi {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, n) {
    B(this, zo);
    B(this, Vo);
    B(this, Fs);
    E(this, zo, e), E(this, Vo, ne(n)), E(this, Fs, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return m(this, zo);
  }
  set name(e) {
    E(this, zo, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return m(this, Vo);
  }
  set chainId(e) {
    E(this, Vo, ne(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === ne(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === ne(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === ne(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(m(this, Fs).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (m(this, Fs).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, Fs).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return m(this, Fs).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((n) => n.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new Wi(this.name, this.chainId);
    return this.plugins.forEach((n) => {
      e.attachPlugin(n.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new ip();
    let r = n.txBase;
    if (e.to == null && (r += n.txCreate), e.data)
      for (let s = 2; s < e.data.length; s += 2)
        e.data.substring(s, s + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
    if (e.accessList) {
      const s = Oi(e.accessList);
      for (const a in s)
        r += n.txAccessListAddress + n.txAccessListStorageKey * s[a].storageKeys.length;
    }
    return r;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (f9(), e == null)
      return Wi.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const n = Bh.get(e);
      if (n)
        return n();
      if (typeof e == "bigint")
        return new Wi("unknown", e);
      S(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      S(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const n = new Wi(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new op(e.ensAddress, e.ensNetwork)), n;
    }
    S(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, n) {
    typeof e == "number" && (e = BigInt(e));
    const r = Bh.get(e);
    r && S(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), Bh.set(e, n);
  }
};
zo = new WeakMap(), Vo = new WeakMap(), Fs = new WeakMap();
let Jn = Wi;
function bw(t, e) {
  const n = String(t);
  if (!n.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${t}`);
  const r = n.split(".");
  if (r.length === 1 && r.push(""), r.length !== 2)
    throw new Error(`invalid gwei value: ${t}`);
  for (; r[1].length < e; )
    r[1] += "0";
  if (r[1].length > 9) {
    let s = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || s++, r[1] = s.toString();
  }
  return BigInt(r[0] + r[1]);
}
function yw(t) {
  return new d9(t, async (e, n, r) => {
    r.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [a, i] = await Promise.all([
        r.send(),
        e()
      ]);
      s = a;
      const o = s.bodyJson.standard;
      return {
        gasPrice: i.gasPrice,
        maxFeePerGas: bw(o.maxFee, 9),
        maxPriorityFeePerGas: bw(o.maxPriorityFee, 9)
      };
    } catch (a) {
      K(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", { request: r, response: s, error: a });
    }
  });
}
let gw = !1;
function f9() {
  if (gw)
    return;
  gw = !0;
  function t(e, n, r) {
    const s = function() {
      const a = new Jn(e, n);
      return r.ensNetwork != null && a.attachPlugin(new op(null, r.ensNetwork)), a.attachPlugin(new ip()), (r.plugins || []).forEach((i) => {
        a.attachPlugin(i);
      }), a;
    };
    Jn.register(e, s), Jn.register(n, s), r.altNames && r.altNames.forEach((a) => {
      Jn.register(a, s);
    });
  }
  t("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), t("ropsten", 3, { ensNetwork: 3 }), t("rinkeby", 4, { ensNetwork: 4 }), t("goerli", 5, { ensNetwork: 5 }), t("kovan", 42, { ensNetwork: 42 }), t("sepolia", 11155111, { ensNetwork: 11155111 }), t("holesky", 17e3, { ensNetwork: 17e3 }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
    ensNetwork: 1
  }), t("arbitrum-goerli", 421613, {}), t("arbitrum-sepolia", 421614, {}), t("base", 8453, { ensNetwork: 1 }), t("base-goerli", 84531, {}), t("base-sepolia", 84532, {}), t("bnb", 56, { ensNetwork: 1 }), t("bnbt", 97, {}), t("linea", 59144, { ensNetwork: 1 }), t("linea-goerli", 59140, {}), t("linea-sepolia", 59141, {}), t("matic", 137, {
    ensNetwork: 1,
    plugins: [
      yw("https://gasstation.polygon.technology/v2")
    ]
  }), t("matic-amoy", 80002, {}), t("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      yw("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), t("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), t("optimism-goerli", 420, {}), t("optimism-sepolia", 11155420, {}), t("xdai", 100, { ensNetwork: 1 });
}
function c0(t) {
  return JSON.parse(JSON.stringify(t));
}
var Wr, Tn, Ms, gr, jo, Pd;
class p9 {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    B(this, jo);
    B(this, Wr);
    B(this, Tn);
    B(this, Ms);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    B(this, gr);
    E(this, Wr, e), E(this, Tn, null), E(this, Ms, 4e3), E(this, gr, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return m(this, Ms);
  }
  set pollingInterval(e) {
    E(this, Ms, e);
  }
  start() {
    m(this, Tn) || (E(this, Tn, m(this, Wr)._setTimeout(z(this, jo, Pd).bind(this), m(this, Ms))), z(this, jo, Pd).call(this));
  }
  stop() {
    m(this, Tn) && (m(this, Wr)._clearTimeout(m(this, Tn)), E(this, Tn, null));
  }
  pause(e) {
    this.stop(), e && E(this, gr, -2);
  }
  resume() {
    this.start();
  }
}
Wr = new WeakMap(), Tn = new WeakMap(), Ms = new WeakMap(), gr = new WeakMap(), jo = new WeakSet(), Pd = async function() {
  try {
    const e = await m(this, Wr).getBlockNumber();
    if (m(this, gr) === -2) {
      E(this, gr, e);
      return;
    }
    if (e !== m(this, gr)) {
      for (let n = m(this, gr) + 1; n <= e; n++) {
        if (m(this, Tn) == null)
          return;
        await m(this, Wr).emit("block", n);
      }
      E(this, gr, e);
    }
  } catch {
  }
  m(this, Tn) != null && E(this, Tn, m(this, Wr)._setTimeout(z(this, jo, Pd).bind(this), m(this, Ms)));
};
var Za, Xa, Ds;
class fy {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    B(this, Za);
    B(this, Xa);
    B(this, Ds);
    E(this, Za, e), E(this, Ds, !1), E(this, Xa, (n) => {
      this._poll(n, m(this, Za));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, n) {
    throw new Error("sub-classes must override this");
  }
  start() {
    m(this, Ds) || (E(this, Ds, !0), m(this, Xa).call(this, -2), m(this, Za).on("block", m(this, Xa)));
  }
  stop() {
    m(this, Ds) && (E(this, Ds, !1), m(this, Za).off("block", m(this, Xa)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
Za = new WeakMap(), Xa = new WeakMap(), Ds = new WeakMap();
var Ko, Qr;
class h9 extends fy {
  constructor(n, r) {
    super(n);
    B(this, Ko);
    B(this, Qr);
    E(this, Ko, r), E(this, Qr, -2);
  }
  pause(n) {
    n && E(this, Qr, -2), super.pause(n);
  }
  async _poll(n, r) {
    const s = await r.getBlock(m(this, Ko));
    s != null && (m(this, Qr) === -2 ? E(this, Qr, s.number) : s.number > m(this, Qr) && (r.emit(m(this, Ko), s.number), E(this, Qr, s.number)));
  }
}
Ko = new WeakMap(), Qr = new WeakMap();
var Ff;
class m9 extends fy {
  constructor(n, r) {
    super(n);
    B(this, Ff);
    E(this, Ff, c0(r));
  }
  async _poll(n, r) {
    throw new Error("@TODO");
  }
}
Ff = new WeakMap();
var qo;
class b9 extends fy {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(n, r) {
    super(n);
    B(this, qo);
    E(this, qo, r);
  }
  async _poll(n, r) {
    const s = await r.getTransactionReceipt(m(this, qo));
    s && r.emit(m(this, qo), s);
  }
}
qo = new WeakMap();
var Jr, Wo, Qo, Ls, Sn, Mf, HA;
class py {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, n) {
    B(this, Mf);
    B(this, Jr);
    B(this, Wo);
    B(this, Qo);
    B(this, Ls);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    B(this, Sn);
    E(this, Jr, e), E(this, Wo, c0(n)), E(this, Qo, z(this, Mf, HA).bind(this)), E(this, Ls, !1), E(this, Sn, -2);
  }
  start() {
    m(this, Ls) || (E(this, Ls, !0), m(this, Sn) === -2 && m(this, Jr).getBlockNumber().then((e) => {
      E(this, Sn, e);
    }), m(this, Jr).on("block", m(this, Qo)));
  }
  stop() {
    m(this, Ls) && (E(this, Ls, !1), m(this, Jr).off("block", m(this, Qo)));
  }
  pause(e) {
    this.stop(), e && E(this, Sn, -2);
  }
  resume() {
    this.start();
  }
}
Jr = new WeakMap(), Wo = new WeakMap(), Qo = new WeakMap(), Ls = new WeakMap(), Sn = new WeakMap(), Mf = new WeakSet(), HA = async function(e) {
  if (m(this, Sn) === -2)
    return;
  const n = c0(m(this, Wo));
  n.fromBlock = m(this, Sn) + 1, n.toBlock = e;
  const r = await m(this, Jr).getLogs(n);
  if (r.length === 0) {
    m(this, Sn) < e - 60 && E(this, Sn, e - 60);
    return;
  }
  for (const s of r)
    m(this, Jr).emit(m(this, Wo), s), E(this, Sn, s.blockNumber);
};
const y9 = BigInt(2), g9 = 10;
function ju(t) {
  return t && typeof t.then == "function";
}
function Id(t, e) {
  return t + ":" + JSON.stringify(e, (n, r) => {
    if (r == null)
      return "null";
    if (typeof r == "bigint")
      return `bigint:${r.toString()}`;
    if (typeof r == "string")
      return r.toLowerCase();
    if (typeof r == "object" && !Array.isArray(r)) {
      const s = Object.keys(r);
      return s.sort(), s.reduce((a, i) => (a[i] = r[i], a), {});
    }
    return r;
  });
}
class $A {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    /**
     *  The name fof the event.
     */
    F(this, "name");
    oe(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function w9(t) {
  return JSON.parse(JSON.stringify(t));
}
function l0(t) {
  return t = Array.from(new Set(t).values()), t.sort(), t;
}
async function Ph(t, e) {
  if (t == null)
    throw new Error("invalid event");
  if (Array.isArray(t) && (t = { topics: t }), typeof t == "string")
    switch (t) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: t, tag: t };
    }
  if (Ue(t, 32)) {
    const n = t.toLowerCase();
    return { type: "transaction", tag: Id("tx", { hash: n }), hash: n };
  }
  if (t.orphan) {
    const n = t;
    return { type: "orphan", tag: Id("orphan", n), filter: w9(n) };
  }
  if (t.address || t.topics) {
    const n = t, r = {
      topics: (n.topics || []).map((s) => s == null ? null : Array.isArray(s) ? l0(s.map((a) => a.toLowerCase())) : s.toLowerCase())
    };
    if (n.address) {
      const s = [], a = [], i = (o) => {
        Ue(o) ? s.push(o) : a.push((async () => {
          s.push(await Gt(o, e));
        })());
      };
      Array.isArray(n.address) ? n.address.forEach(i) : i(n.address), a.length && await Promise.all(a), r.address = l0(s.map((o) => o.toLowerCase()));
    }
    return { filter: r, tag: Id("event", r), type: "event" };
  }
  S(!1, "unknown ProviderEvent", "event", t);
}
function Ih() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const E9 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var Et, Hs, xt, Jo, dn, Ya, $s, Zr, cu, On, Zo, Xo, ye, an, u0, d0, rl, f0, sl, Ud;
class x9 {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, n) {
    B(this, ye);
    B(this, Et);
    B(this, Hs);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    B(this, xt);
    B(this, Jo);
    B(this, dn);
    B(this, Ya);
    B(this, $s);
    // The most recent block number if running an event or -1 if no "block" event
    B(this, Zr);
    B(this, cu);
    B(this, On);
    B(this, Zo);
    B(this, Xo);
    if (E(this, Xo, Object.assign({}, E9, n || {})), e === "any")
      E(this, Ya, !0), E(this, dn, null);
    else if (e) {
      const r = Jn.from(e);
      E(this, Ya, !1), E(this, dn, Promise.resolve(r)), setTimeout(() => {
        this.emit("network", r, null);
      }, 0);
    } else
      E(this, Ya, !1), E(this, dn, null);
    E(this, Zr, -1), E(this, $s, /* @__PURE__ */ new Map()), E(this, Et, /* @__PURE__ */ new Map()), E(this, Hs, /* @__PURE__ */ new Map()), E(this, xt, null), E(this, Jo, !1), E(this, cu, 1), E(this, On, /* @__PURE__ */ new Map()), E(this, Zo, !1);
  }
  get pollingInterval() {
    return m(this, Xo).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(m(this, Hs).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (m(this, Hs).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, Hs).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return m(this, Hs).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return m(this, Zo);
  }
  set disableCcipRead(e) {
    E(this, Zo, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, n, r) {
    if (this.disableCcipRead || r.length === 0 || e.to == null)
      return null;
    const s = e.to.toLowerCase(), a = n.toLowerCase(), i = [];
    for (let o = 0; o < r.length; o++) {
      const c = r[o], u = c.replace("{sender}", s).replace("{data}", a), l = new Cr(u);
      c.indexOf("{data}") === -1 && (l.body = { data: a, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: l, index: o, urls: r });
      let d = "unknown error", f;
      try {
        f = await l.send();
      } catch (h) {
        i.push(h.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: { error: h } });
        continue;
      }
      try {
        const h = f.bodyJson;
        if (h.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: l, result: h }), h.data;
        h.message && (d = h.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: l, result: h });
      } catch {
      }
      K(f.statusCode < 400 || f.statusCode >= 500, `response not found during CCIP fetch: ${d}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: c, errorMessage: d } }), i.push(d);
    }
    K(!1, `error encountered during CCIP fetch: ${i.map((o) => JSON.stringify(o)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: r, errorMessages: i }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, n) {
    return new $P(a9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, n) {
    return new bu(r9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, n) {
    return new CA(l9(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, n) {
    return new Ll(LA(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    K(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    K(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = ge(await z(this, ye, an).call(this, { method: "getBlockNumber" }), "%response");
    return m(this, Zr) >= 0 && E(this, Zr, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return Gt(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (Ue(e))
      return Ue(e, 32) ? e : qn(e);
    if (typeof e == "bigint" && (e = ge(e, "blockTag")), typeof e == "number")
      return e >= 0 ? qn(e) : m(this, Zr) >= 0 ? qn(m(this, Zr) + e) : this.getBlockNumber().then((n) => qn(n + e));
    S(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const n = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? l0(c.map((u) => u.toLowerCase())) : c.toLowerCase()), r = "blockHash" in e ? e.blockHash : void 0, s = (c, u, l) => {
      let d;
      switch (c.length) {
        case 0:
          break;
        case 1:
          d = c[0];
          break;
        default:
          c.sort(), d = c;
      }
      if (r && (u != null || l != null))
        throw new Error("invalid filter");
      const f = {};
      return d && (f.address = d), n.length && (f.topics = n), u && (f.fromBlock = u), l && (f.toBlock = l), r && (f.blockHash = r), f;
    };
    let a = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const c of e.address)
          a.push(this._getAddress(c));
      else
        a.push(this._getAddress(e.address));
    let i;
    "fromBlock" in e && (i = this._getBlockTag(e.fromBlock));
    let o;
    return "toBlock" in e && (o = this._getBlockTag(e.toBlock)), a.filter((c) => typeof c != "string").length || i != null && typeof i != "string" || o != null && typeof o != "string" ? Promise.all([Promise.all(a), i, o]).then((c) => s(c[0], c[1], c[2])) : s(a, i, o);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const n = af(e), r = [];
    if (["to", "from"].forEach((s) => {
      if (n[s] == null)
        return;
      const a = Gt(n[s], this);
      ju(a) ? r.push(async function() {
        n[s] = await a;
      }()) : n[s] = a;
    }), n.blockTag != null) {
      const s = this._getBlockTag(n.blockTag);
      ju(s) ? r.push(async function() {
        n.blockTag = await s;
      }()) : n.blockTag = s;
    }
    return r.length ? async function() {
      return await Promise.all(r), n;
    }() : n;
  }
  async getNetwork() {
    if (m(this, dn) == null) {
      const s = (async () => {
        try {
          const a = await this._detectNetwork();
          return this.emit("network", a, null), a;
        } catch (a) {
          throw m(this, dn) === s && E(this, dn, null), a;
        }
      })();
      return E(this, dn, s), (await s).clone();
    }
    const e = m(this, dn), [n, r] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return n.chainId !== r.chainId && (m(this, Ya) ? (this.emit("network", r, n), m(this, dn) === e && E(this, dn, Promise.resolve(r))) : K(!1, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), n.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), n = async () => {
      const { _block: s, gasPrice: a, priorityFee: i } = await ot({
        _block: z(this, ye, f0).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const l = await z(this, ye, an).call(this, { method: "getGasPrice" });
            return ne(l, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const l = await z(this, ye, an).call(this, { method: "getPriorityFee" });
            return ne(l, "%response");
          } catch {
          }
          return null;
        })()
      });
      let o = null, c = null;
      const u = this._wrapBlock(s, e);
      return u && u.baseFeePerGas && (c = i ?? BigInt("1000000000"), o = u.baseFeePerGas * y9 + c), new dw(a, o, c);
    }, r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (r) {
      const s = new Cr(r.url), a = await r.processFunc(n, this, s);
      return new dw(a.gasPrice, a.maxFeePerGas, a.maxPriorityFeePerGas);
    }
    return await n();
  }
  async estimateGas(e) {
    let n = this._getTransactionRequest(e);
    return ju(n) && (n = await n), ne(await z(this, ye, an).call(this, {
      method: "estimateGas",
      transaction: n
    }), "%response");
  }
  async call(e) {
    const { tx: n, blockTag: r } = await ot({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await z(this, ye, d0).call(this, z(this, ye, u0).call(this, n, r, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, n) {
    return ne(await z(this, ye, rl).call(this, { method: "getBalance" }, e, n), "%response");
  }
  async getTransactionCount(e, n) {
    return ge(await z(this, ye, rl).call(this, { method: "getTransactionCount" }, e, n), "%response");
  }
  async getCode(e, n) {
    return V(await z(this, ye, rl).call(this, { method: "getCode" }, e, n));
  }
  async getStorage(e, n, r) {
    const s = ne(n, "position");
    return V(await z(this, ye, rl).call(this, { method: "getStorage", position: s }, e, r));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: n, hash: r, network: s } = await ot({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), a = Yd.from(e);
    if (a.hash !== r)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(a, s).replaceableTransaction(n);
  }
  // Queries
  async getBlock(e, n) {
    const { network: r, params: s } = await ot({
      network: this.getNetwork(),
      params: z(this, ye, f0).call(this, e, !!n)
    });
    return s == null ? null : this._wrapBlock(s, r);
  }
  async getTransaction(e) {
    const { network: n, params: r } = await ot({
      network: this.getNetwork(),
      params: z(this, ye, an).call(this, { method: "getTransaction", hash: e })
    });
    return r == null ? null : this._wrapTransactionResponse(r, n);
  }
  async getTransactionReceipt(e) {
    const { network: n, params: r } = await ot({
      network: this.getNetwork(),
      params: z(this, ye, an).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (r == null)
      return null;
    if (r.gasPrice == null && r.effectiveGasPrice == null) {
      const s = await z(this, ye, an).call(this, { method: "getTransaction", hash: e });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      r.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(r, n);
  }
  async getTransactionResult(e) {
    const { result: n } = await ot({
      network: this.getNetwork(),
      result: z(this, ye, an).call(this, { method: "getTransactionResult", hash: e })
    });
    return n == null ? null : V(n);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let n = this._getFilter(e);
    ju(n) && (n = await n);
    const { network: r, params: s } = await ot({
      network: this.getNetwork(),
      params: z(this, ye, an).call(this, { method: "getLogs", filter: n })
    });
    return s.map((a) => this._wrapLog(a, r));
  }
  // ENS
  _getProvider(e) {
    K(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await cf.fromName(this, e);
  }
  async getAvatar(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAvatar() : null;
  }
  async resolveName(e) {
    const n = await this.getResolver(e);
    return n ? await n.getAddress() : null;
  }
  async lookupAddress(e) {
    e = ue(e);
    const n = r0(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const r = await cf.getEnsAddress(this), a = await new vr(r, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(n);
      if (a == null || a === ra)
        return null;
      const o = await new vr(a, [
        "function name(bytes32) view returns (string)"
      ], this).name(n);
      return await this.resolveName(o) !== e ? null : o;
    } catch (r) {
      if (dt(r, "BAD_DATA") && r.value === "0x" || dt(r, "CALL_EXCEPTION"))
        return null;
      throw r;
    }
    return null;
  }
  async waitForTransaction(e, n, r) {
    const s = n ?? 1;
    return s === 0 ? this.getTransactionReceipt(e) : new Promise(async (a, i) => {
      let o = null;
      const c = async (u) => {
        try {
          const l = await this.getTransactionReceipt(e);
          if (l != null && u - l.blockNumber + 1 >= s) {
            a(l), o && (clearTimeout(o), o = null);
            return;
          }
        } catch (l) {
          console.log("EEE", l);
        }
        this.once("block", c);
      };
      r != null && (o = setTimeout(() => {
        o != null && (o = null, this.off("block", c), i($e("timeout", "TIMEOUT", { reason: "timeout" })));
      }, r)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    K(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const n = m(this, On).get(e);
    n && (n.timer && clearTimeout(n.timer), m(this, On).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, n) {
    n == null && (n = 0);
    const r = Ic(this, cu)._++, s = () => {
      m(this, On).delete(r), e();
    };
    if (this.paused)
      m(this, On).set(r, { timer: null, func: s, time: n });
    else {
      const a = setTimeout(s, n);
      m(this, On).set(r, { timer: a, func: s, time: Ih() });
    }
    return r;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const n of m(this, Et).values())
      e(n.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new $A(e.type);
      case "block": {
        const n = new p9(this);
        return n.pollingInterval = this.pollingInterval, n;
      }
      case "safe":
      case "finalized":
        return new h9(this, e.type);
      case "event":
        return new py(this, e.filter);
      case "transaction":
        return new b9(this, e.hash);
      case "orphan":
        return new m9(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, n) {
    for (const r of m(this, Et).values())
      if (r.subscriber === e) {
        r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), m(this, xt) != null && n.pause(m(this, xt));
        break;
      }
  }
  async on(e, n) {
    const r = await z(this, ye, Ud).call(this, e);
    return r.listeners.push({ listener: n, once: !1 }), r.started || (r.subscriber.start(), r.started = !0, m(this, xt) != null && r.subscriber.pause(m(this, xt))), this;
  }
  async once(e, n) {
    const r = await z(this, ye, Ud).call(this, e);
    return r.listeners.push({ listener: n, once: !0 }), r.started || (r.subscriber.start(), r.started = !0, m(this, xt) != null && r.subscriber.pause(m(this, xt))), this;
  }
  async emit(e, ...n) {
    const r = await z(this, ye, sl).call(this, e, n);
    if (!r || r.listeners.length === 0)
      return !1;
    const s = r.listeners.length;
    return r.listeners = r.listeners.filter(({ listener: a, once: i }) => {
      const o = new Q2(this, i ? null : a, e);
      try {
        a.call(this, ...n, o);
      } catch {
      }
      return !i;
    }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), m(this, Et).delete(r.tag)), s > 0;
  }
  async listenerCount(e) {
    if (e) {
      const r = await z(this, ye, sl).call(this, e);
      return r ? r.listeners.length : 0;
    }
    let n = 0;
    for (const { listeners: r } of m(this, Et).values())
      n += r.length;
    return n;
  }
  async listeners(e) {
    if (e) {
      const r = await z(this, ye, sl).call(this, e);
      return r ? r.listeners.map(({ listener: s }) => s) : [];
    }
    let n = [];
    for (const { listeners: r } of m(this, Et).values())
      n = n.concat(r.map(({ listener: s }) => s));
    return n;
  }
  async off(e, n) {
    const r = await z(this, ye, sl).call(this, e);
    if (!r)
      return this;
    if (n) {
      const s = r.listeners.map(({ listener: a }) => a).indexOf(n);
      s >= 0 && r.listeners.splice(s, 1);
    }
    return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), m(this, Et).delete(r.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: n, started: r, subscriber: s } = await z(this, ye, Ud).call(this, e);
      r && s.stop(), m(this, Et).delete(n);
    } else
      for (const [n, { started: r, subscriber: s }] of m(this, Et))
        r && s.stop(), m(this, Et).delete(n);
    return this;
  }
  // Alias for "on"
  async addListener(e, n) {
    return await this.on(e, n);
  }
  // Alias for "off"
  async removeListener(e, n) {
    return this.off(e, n);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return m(this, Jo);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of m(this, On).keys())
      this._clearTimeout(e);
    E(this, Jo, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return m(this, xt) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (E(this, Zr, -1), m(this, xt) != null) {
      if (m(this, xt) == !!e)
        return;
      K(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((n) => n.pause(e)), E(this, xt, !!e);
    for (const n of m(this, On).values())
      n.timer && clearTimeout(n.timer), n.time = Ih() - n.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (m(this, xt) != null) {
      this._forEachSubscriber((e) => e.resume()), E(this, xt, null);
      for (const e of m(this, On).values()) {
        let n = e.time;
        n < 0 && (n = 0), e.time = Ih(), setTimeout(e.func, n);
      }
    }
  }
}
Et = new WeakMap(), Hs = new WeakMap(), xt = new WeakMap(), Jo = new WeakMap(), dn = new WeakMap(), Ya = new WeakMap(), $s = new WeakMap(), Zr = new WeakMap(), cu = new WeakMap(), On = new WeakMap(), Zo = new WeakMap(), Xo = new WeakMap(), ye = new WeakSet(), an = async function(e) {
  const n = m(this, Xo).cacheTimeout;
  if (n < 0)
    return await this._perform(e);
  const r = Id(e.method, e);
  let s = m(this, $s).get(r);
  return s || (s = this._perform(e), m(this, $s).set(r, s), setTimeout(() => {
    m(this, $s).get(r) === s && m(this, $s).delete(r);
  }, n)), await s;
}, u0 = async function(e, n, r) {
  K(r < g9, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, e, { blockTag: n, enableCcipRead: !0 })
  });
  const s = af(e);
  try {
    return V(await this._perform({ method: "call", transaction: s, blockTag: n }));
  } catch (a) {
    if (!this.disableCcipRead && Wb(a) && a.data && r >= 0 && n === "latest" && s.to != null && _e(a.data, 0, 4) === "0x556f1830") {
      const i = a.data, o = await Gt(s.to, this);
      let c;
      try {
        c = T9(_e(a.data, 4));
      } catch (d) {
        K(!1, d.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: i }
        });
      }
      K(c.sender.toLowerCase() === o.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: i,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(s, c.calldata, c.urls);
      K(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: a.data, errorArgs: c.errorArgs }
      });
      const l = {
        to: o,
        data: Le([c.selector, C9([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: l });
      try {
        const d = await z(this, ye, u0).call(this, l, n, r + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, l), result: d }), d;
      } catch (d) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, l), error: d }), d;
      }
    }
    throw a;
  }
}, d0 = async function(e) {
  const { value: n } = await ot({
    network: this.getNetwork(),
    value: e
  });
  return n;
}, rl = async function(e, n, r) {
  let s = this._getAddress(n), a = this._getBlockTag(r);
  return (typeof s != "string" || typeof a != "string") && ([s, a] = await Promise.all([s, a])), await z(this, ye, d0).call(this, z(this, ye, an).call(this, Object.assign(e, { address: s, blockTag: a })));
}, f0 = async function(e, n) {
  if (Ue(e, 32))
    return await z(this, ye, an).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: n
    });
  let r = this._getBlockTag(e);
  return typeof r != "string" && (r = await r), await z(this, ye, an).call(this, {
    method: "getBlock",
    blockTag: r,
    includeTransactions: n
  });
}, sl = async function(e, n) {
  let r = await Ph(e, this);
  return r.type === "event" && n && n.length > 0 && n[0].removed === !0 && (r = await Ph({ orphan: "drop-log", log: n[0] }, this)), m(this, Et).get(r.tag) || null;
}, Ud = async function(e) {
  const n = await Ph(e, this), r = n.tag;
  let s = m(this, Et).get(r);
  return s || (s = { subscriber: this._getSubscriber(n), tag: r, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, m(this, Et).set(r, s)), s;
};
function A9(t, e) {
  try {
    const n = p0(t, e);
    if (n)
      return Jd(n);
  } catch {
  }
  return null;
}
function p0(t, e) {
  if (t === "0x")
    return null;
  try {
    const n = ge(_e(t, e, e + 32)), r = ge(_e(t, n, n + 32));
    return _e(t, n + 32, n + 32 + r);
  } catch {
  }
  return null;
}
function ww(t) {
  const e = Xe(t);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const n = new Uint8Array(32);
  return n.set(e, 32 - e.length), n;
}
function v9(t) {
  if (t.length % 32 === 0)
    return t;
  const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
  return e.set(t), e;
}
const k9 = new Uint8Array([]);
function C9(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++)
    e.push(k9), n += 32;
  for (let r = 0; r < t.length; r++) {
    const s = Q(t[r]);
    e[r] = ww(n), e.push(ww(s.length)), e.push(v9(s)), n += 32 + Math.ceil(s.length / 32) * 32;
  }
  return Le(e);
}
const Ew = "0x0000000000000000000000000000000000000000000000000000000000000000";
function T9(t) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  K(ai(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const n = _e(t, 0, 32);
  K(_e(n, 0, 12) === _e(Ew, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = _e(n, 12);
  try {
    const r = [], s = ge(_e(t, 32, 64)), a = ge(_e(t, s, s + 32)), i = _e(t, s + 32);
    for (let o = 0; o < a; o++) {
      const c = A9(i, o * 32);
      if (c == null)
        throw new Error("abort");
      r.push(c);
    }
    e.urls = r;
  } catch {
    K(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const r = p0(t, 64);
    if (r == null)
      throw new Error("abort");
    e.calldata = r;
  } catch {
    K(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  K(_e(t, 100, 128) === _e(Ew, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = _e(t, 96, 100);
  try {
    const r = p0(t, 128);
    if (r == null)
      throw new Error("abort");
    e.extraData = r;
  } catch {
    K(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => e[r]), e;
}
function la(t, e) {
  if (t.provider)
    return t.provider;
  K(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function xw(t, e) {
  let n = af(e);
  if (n.to != null && (n.to = Gt(n.to, t)), n.from != null) {
    const r = n.from;
    n.from = Promise.all([
      t.getAddress(),
      Gt(r, t)
    ]).then(([s, a]) => (S(s.toLowerCase() === a.toLowerCase(), "transaction from mismatch", "tx.from", a), s));
  } else
    n.from = t.getAddress();
  return await ot(n);
}
class _A {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    /**
     *  The provider this signer is connected to.
     */
    F(this, "provider");
    oe(this, { provider: e || null });
  }
  async getNonce(e) {
    return la(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await xw(this, e);
  }
  async populateTransaction(e) {
    const n = la(this, "populateTransaction"), r = await xw(this, e);
    r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
    const s = await this.provider.getNetwork();
    if (r.chainId != null) {
      const i = ne(r.chainId);
      S(i === s.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      r.chainId = s.chainId;
    const a = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
    if (r.gasPrice != null && (r.type === 2 || a) ? S(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && a && S(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
      r.type = 2;
    else if (r.type === 0 || r.type === 1) {
      const i = await n.getFeeData();
      K(i.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), r.gasPrice == null && (r.gasPrice = i.gasPrice);
    } else {
      const i = await n.getFeeData();
      if (r.type == null)
        if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
          if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, r.gasPrice != null) {
            const o = r.gasPrice;
            delete r.gasPrice, r.maxFeePerGas = o, r.maxPriorityFeePerGas = o;
          } else
            r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
        else i.gasPrice != null ? (K(!a, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : K(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
    }
    return await ot(r);
  }
  async populateAuthorization(e) {
    const n = Object.assign({}, e);
    return n.chainId == null && (n.chainId = (await la(this, "getNetwork").getNetwork()).chainId), n.nonce == null && (n.nonce = await this.getNonce()), n;
  }
  async estimateGas(e) {
    return la(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return la(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await la(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const n = la(this, "sendTransaction"), r = await this.populateTransaction(e);
    delete r.from;
    const s = Yd.from(r);
    return await n.broadcastTransaction(await this.signTransaction(s));
  }
  // @TODO: in v7 move this to be abstract
  authorize(e) {
    K(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
function S9(t) {
  return JSON.parse(JSON.stringify(t));
}
var Dt, wr, ei, _s, ti, Yo, ia, h0, m0;
class GA {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    B(this, ia);
    B(this, Dt);
    B(this, wr);
    B(this, ei);
    B(this, _s);
    B(this, ti);
    B(this, Yo);
    E(this, Dt, e), E(this, wr, null), E(this, ei, z(this, ia, h0).bind(this)), E(this, _s, !1), E(this, ti, null), E(this, Yo, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, n) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    m(this, _s) || (E(this, _s, !0), z(this, ia, h0).call(this, -2));
  }
  stop() {
    m(this, _s) && (E(this, _s, !1), E(this, Yo, !0), z(this, ia, m0).call(this), m(this, Dt).off("block", m(this, ei)));
  }
  pause(e) {
    e && z(this, ia, m0).call(this), m(this, Dt).off("block", m(this, ei));
  }
  resume() {
    this.start();
  }
}
Dt = new WeakMap(), wr = new WeakMap(), ei = new WeakMap(), _s = new WeakMap(), ti = new WeakMap(), Yo = new WeakMap(), ia = new WeakSet(), h0 = async function(e) {
  try {
    m(this, wr) == null && E(this, wr, this._subscribe(m(this, Dt)));
    let n = null;
    try {
      n = await m(this, wr);
    } catch (a) {
      if (!dt(a, "UNSUPPORTED_OPERATION") || a.operation !== "eth_newFilter")
        throw a;
    }
    if (n == null) {
      E(this, wr, null), m(this, Dt)._recoverSubscriber(this, this._recover(m(this, Dt)));
      return;
    }
    const r = await m(this, Dt).getNetwork();
    if (m(this, ti) || E(this, ti, r), m(this, ti).chainId !== r.chainId)
      throw new Error("chaid changed");
    if (m(this, Yo))
      return;
    const s = await m(this, Dt).send("eth_getFilterChanges", [n]);
    await this._emitResults(m(this, Dt), s);
  } catch (n) {
    console.log("@TODO", n);
  }
  m(this, Dt).once("block", m(this, ei));
}, m0 = function() {
  const e = m(this, wr);
  e && (E(this, wr, null), e.then((n) => {
    m(this, Dt).destroyed || m(this, Dt).send("eth_uninstallFilter", [n]);
  }));
};
var ni;
class O9 extends GA {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(n, r) {
    super(n);
    B(this, ni);
    E(this, ni, S9(r));
  }
  _recover(n) {
    return new py(n, m(this, ni));
  }
  async _subscribe(n) {
    return await n.send("eth_newFilter", [m(this, ni)]);
  }
  async _emitResults(n, r) {
    for (const s of r)
      n.emit(m(this, ni), n._wrapLog(s, n._network));
  }
}
ni = new WeakMap();
class B9 extends GA {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, n) {
    for (const r of n)
      e.emit("pending", r);
  }
}
const P9 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Nd(t) {
  if (t == null || P9.indexOf(typeof t) >= 0 || typeof t.getAddress == "function")
    return t;
  if (Array.isArray(t))
    return t.map(Nd);
  if (typeof t == "object")
    return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
  throw new Error(`should not happen: ${t} (${typeof t})`);
}
function I9(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function Ni(t) {
  return t && t.toLowerCase();
}
function Aw(t) {
  return t && typeof t.pollingInterval == "number";
}
const zA = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class Uh extends _A {
  constructor(n, r) {
    super(n);
    F(this, "address");
    r = ue(r), oe(this, { address: r });
  }
  connect(n) {
    K(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(n) {
    return await this.populateCall(n);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(n) {
    const r = Nd(n), s = [];
    if (r.from) {
      const i = r.from;
      s.push((async () => {
        const o = await Gt(i, this.provider);
        S(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = o;
      })());
    } else
      r.from = this.address;
    if (r.gasLimit == null && s.push((async () => {
      r.gasLimit = await this.provider.estimateGas({ ...r, from: this.address });
    })()), r.to != null) {
      const i = r.to;
      s.push((async () => {
        r.to = await Gt(i, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const a = this.provider.getRpcTransaction(r);
    return this.provider.send("eth_sendTransaction", [a]);
  }
  async sendTransaction(n) {
    const r = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(n);
    return await new Promise((a, i) => {
      const o = [1e3, 100];
      let c = 0;
      const u = async () => {
        try {
          const l = await this.provider.getTransaction(s);
          if (l != null) {
            a(l.replaceableTransaction(r));
            return;
          }
        } catch (l) {
          if (dt(l, "CANCELLED") || dt(l, "BAD_DATA") || dt(l, "NETWORK_ERROR") || dt(l, "UNSUPPORTED_OPERATION")) {
            l.info == null && (l.info = {}), l.info.sendTransactionHash = s, i(l);
            return;
          }
          if (dt(l, "INVALID_ARGUMENT") && (c++, l.info == null && (l.info = {}), l.info.sendTransactionHash = s, c > 10)) {
            i(l);
            return;
          }
          this.provider.emit("error", $e("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: l }));
        }
        this.provider._setTimeout(() => {
          u();
        }, o.pop() || 4e3);
      };
      u();
    });
  }
  async signTransaction(n) {
    const r = Nd(n);
    if (r.from) {
      const a = await Gt(r.from, this.provider);
      S(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = a;
    } else
      r.from = this.address;
    const s = this.provider.getRpcTransaction(r);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(n) {
    const r = typeof n == "string" ? Yt(n) : n;
    return await this.provider.send("personal_sign", [
      V(r),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(n, r, s) {
    const a = Nd(s), i = await Ml.resolveNames(n, r, a, async (o) => {
      const c = await Gt(o);
      return S(c != null, "TypedData does not support null address", "value", o), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(Ml.getPayload(i.domain, r, i.value))
    ]);
  }
  async unlock(n) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      n,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(n) {
    const r = typeof n == "string" ? Yt(n) : n;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      V(r)
    ]);
  }
}
var ri, ec, Xr, Er, jn, Bn, Wt, lu, b0;
class U9 extends x9 {
  constructor(n, r) {
    super(n, r);
    B(this, lu);
    B(this, ri);
    // The next ID to use for the JSON-RPC ID field
    B(this, ec);
    // Payloads are queued and triggered in batches using the drainTimer
    B(this, Xr);
    B(this, Er);
    B(this, jn);
    B(this, Bn);
    B(this, Wt);
    E(this, ec, 1), E(this, ri, Object.assign({}, zA, r || {})), E(this, Xr, []), E(this, Er, null), E(this, Bn, null), E(this, Wt, null);
    {
      let a = null;
      const i = new Promise((o) => {
        a = o;
      });
      E(this, jn, { promise: i, resolve: a });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (S(!s || n !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), s && n != null && E(this, Bn, Jn.from(n))) : s && (S(n == null || s.matches(n), "staticNetwork MUST match network object", "options", r), E(this, Bn, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(n) {
    return m(this, ri)[n];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return K(m(this, Bn), "network is not available yet", "NETWORK_ERROR"), m(this, Bn);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(n) {
    if (n.method === "call" || n.method === "estimateGas") {
      let s = n.transaction;
      if (s && s.type != null && ne(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const a = await this.getFeeData();
        a.maxFeePerGas == null && a.maxPriorityFeePerGas == null && (n = Object.assign({}, n, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const r = this.getRpcRequest(n);
    return r != null ? await this.send(r.method, r.args) : super._perform(n);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const n = this._getOption("staticNetwork");
    if (n)
      if (n === !0) {
        if (m(this, Bn))
          return m(this, Bn);
      } else
        return n;
    return m(this, Wt) ? await m(this, Wt) : this.ready ? (E(this, Wt, (async () => {
      try {
        const r = Jn.from(ne(await this.send("eth_chainId", [])));
        return E(this, Wt, null), r;
      } catch (r) {
        throw E(this, Wt, null), r;
      }
    })()), await m(this, Wt)) : (E(this, Wt, (async () => {
      const r = {
        id: Ic(this, ec)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: r });
      let s;
      try {
        s = (await this._send(r))[0], E(this, Wt, null);
      } catch (a) {
        throw E(this, Wt, null), this.emit("debug", { action: "receiveRpcError", error: a }), a;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return Jn.from(ne(s.result));
      throw this.getRpcError(r, s);
    })()), await m(this, Wt));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    m(this, jn) == null || m(this, jn).resolve == null || (m(this, jn).resolve(), E(this, jn, null), (async () => {
      for (; m(this, Bn) == null && !this.destroyed; )
        try {
          E(this, Bn, await this._detectNetwork());
        } catch (n) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", $e("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: n } })), await I9(1e3);
        }
      z(this, lu, b0).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (m(this, jn) != null)
      return await m(this, jn).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(n) {
    return n.type === "pending" ? new B9(this) : n.type === "event" ? this._getOption("polling") ? new py(this, n.filter) : new O9(this, n.filter) : n.type === "orphan" && n.filter.orphan === "drop-log" ? new $A("orphan") : super._getSubscriber(n);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return m(this, jn) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(n) {
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (n[s] == null)
        return;
      let a = s;
      s === "gasLimit" && (a = "gas"), r[a] = qn(ne(n[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      n[s] != null && (r[s] = V(n[s]));
    }), n.accessList && (r.accessList = Oi(n.accessList)), n.blobVersionedHashes && (r.blobVersionedHashes = n.blobVersionedHashes.map((s) => s.toLowerCase())), n.authorizationList && (r.authorizationList = n.authorizationList.map((s) => {
      const a = G6(s);
      return {
        address: a.address,
        nonce: qn(a.nonce),
        chainId: qn(a.chainId),
        yParity: qn(a.signature.yParity),
        r: qn(a.signature.r),
        s: qn(a.signature.s)
      };
    })), r;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(n) {
    switch (n.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [Ni(n.address), n.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [Ni(n.address), n.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [Ni(n.address), n.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            Ni(n.address),
            "0x" + n.position.toString(16),
            n.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [n.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in n)
          return {
            method: "eth_getBlockByNumber",
            args: [n.blockTag, !!n.includeTransactions]
          };
        if ("blockHash" in n)
          return {
            method: "eth_getBlockByHash",
            args: [n.blockHash, !!n.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [n.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [n.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(n.transaction), n.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(n.transaction)]
        };
      case "getLogs":
        return n.filter && n.filter.address != null && (Array.isArray(n.filter.address) ? n.filter.address = n.filter.address.map(Ni) : n.filter.address = Ni(n.filter.address)), { method: "eth_getLogs", args: [n.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(n, r) {
    const { method: s } = n, { error: a } = r;
    if (s === "eth_estimateGas" && a.message) {
      const c = a.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return $e("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
      if (c.match(/nonce/i) && c.match(/too low/i))
        return $e("nonce has already been used", "NONCE_EXPIRED", {
          transaction: n.params[0],
          info: { payload: n, error: a }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = y0(a), u = Ot.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", n.params[0], c ? c.data : null);
      return u.info = { error: a, payload: n }, u;
    }
    const i = JSON.stringify(R9(a));
    if (typeof a.message == "string" && a.message.match(/user denied|ethers-user-denied/i))
      return $e("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: n, error: a }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = n.params[0];
      if (i.match(/insufficient funds|base fee exceeds gas limit/i))
        return $e("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: a }
        });
      if (i.match(/nonce/i) && i.match(/too low/i))
        return $e("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: a } });
      if (i.match(/replacement transaction/i) && i.match(/underpriced/i))
        return $e("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: a } });
      if (i.match(/only replay-protected/i))
        return $e("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: a } }
        });
    }
    let o = !!i.match(/the method .* does not exist/i);
    return o || a && a.details && a.details.startsWith("Unauthorized method:") && (o = !0), o ? $e("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: n.method,
      info: { error: a, payload: n }
    }) : $e("could not coalesce error", "UNKNOWN_ERROR", { error: a, payload: n });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(n, r) {
    if (this.destroyed)
      return Promise.reject($e("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n }));
    const s = Ic(this, ec)._++, a = new Promise((i, o) => {
      m(this, Xr).push({
        resolve: i,
        reject: o,
        payload: { method: n, params: r, id: s, jsonrpc: "2.0" }
      });
    });
    return z(this, lu, b0).call(this), a;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(n) {
    n == null && (n = 0);
    const r = this.send("eth_accounts", []);
    if (typeof n == "number") {
      const a = await r;
      if (n >= a.length)
        throw new Error("no such account");
      return new Uh(this, a[n]);
    }
    const { accounts: s } = await ot({
      network: this.getNetwork(),
      accounts: r
    });
    n = ue(n);
    for (const a of s)
      if (ue(a) === n)
        return new Uh(this, n);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((r) => new Uh(this, r));
  }
  destroy() {
    m(this, Er) && (clearTimeout(m(this, Er)), E(this, Er, null));
    for (const { payload: n, reject: r } of m(this, Xr))
      r($e("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: n.method }));
    E(this, Xr, []), super.destroy();
  }
}
ri = new WeakMap(), ec = new WeakMap(), Xr = new WeakMap(), Er = new WeakMap(), jn = new WeakMap(), Bn = new WeakMap(), Wt = new WeakMap(), lu = new WeakSet(), b0 = function() {
  if (m(this, Er))
    return;
  const n = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  E(this, Er, setTimeout(() => {
    E(this, Er, null);
    const r = m(this, Xr);
    for (E(this, Xr, []); r.length; ) {
      const s = [r.shift()];
      for (; r.length && s.length !== m(this, ri).batchMaxCount; )
        if (s.push(r.shift()), JSON.stringify(s.map((i) => i.payload)).length > m(this, ri).batchMaxSize) {
          r.unshift(s.pop());
          break;
        }
      (async () => {
        const a = s.length === 1 ? s[0].payload : s.map((i) => i.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: a });
        try {
          const i = await this._send(a);
          this.emit("debug", { action: "receiveRpcResult", result: i });
          for (const { resolve: o, reject: c, payload: u } of s) {
            if (this.destroyed) {
              c($e("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const l = i.filter((d) => d.id === u.id)[0];
            if (l == null) {
              const d = $e("missing response for request", "BAD_DATA", {
                value: i,
                info: { payload: u }
              });
              this.emit("error", d), c(d);
              continue;
            }
            if ("error" in l) {
              c(this.getRpcError(u, l));
              continue;
            }
            o(l.result);
          }
        } catch (i) {
          this.emit("debug", { action: "receiveRpcError", error: i });
          for (const { reject: o } of s)
            o(i);
        }
      })();
    }
  }, n));
};
var Gs;
class N9 extends U9 {
  constructor(n, r) {
    super(n, r);
    B(this, Gs);
    let s = this._getOption("pollingInterval");
    s == null && (s = zA.pollingInterval), E(this, Gs, s);
  }
  _getSubscriber(n) {
    const r = super._getSubscriber(n);
    return Aw(r) && (r.pollingInterval = m(this, Gs)), r;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return m(this, Gs);
  }
  set pollingInterval(n) {
    if (!Number.isInteger(n) || n < 0)
      throw new Error("invalid interval");
    E(this, Gs, n), this._forEachSubscriber((r) => {
      Aw(r) && (r.pollingInterval = m(this, Gs));
    });
  }
}
Gs = new WeakMap();
var tc, LE;
let hy = (LE = class extends N9 {
  constructor(n, r, s) {
    n == null && (n = "http://localhost:8545");
    super(r, s);
    B(this, tc);
    typeof n == "string" ? E(this, tc, new Cr(n)) : E(this, tc, n.clone());
  }
  _getConnection() {
    return m(this, tc).clone();
  }
  async send(n, r) {
    return await this._start(), await super.send(n, r);
  }
  async _send(n) {
    const r = this._getConnection();
    r.body = JSON.stringify(n), r.setHeader("content-type", "application/json");
    const s = await r.send();
    s.assertOk();
    let a = s.bodyJson;
    return Array.isArray(a) || (a = [a]), a;
  }
}, tc = new WeakMap(), LE);
function y0(t) {
  if (t == null)
    return null;
  if (typeof t.message == "string" && t.message.match(/revert/i) && Ue(t.data))
    return { message: t.message, data: t.data };
  if (typeof t == "object") {
    for (const e in t) {
      const n = y0(t[e]);
      if (n)
        return n;
    }
    return null;
  }
  if (typeof t == "string")
    try {
      return y0(JSON.parse(t));
    } catch {
    }
  return null;
}
function g0(t, e) {
  if (t != null) {
    if (typeof t.message == "string" && e.push(t.message), typeof t == "object")
      for (const n in t)
        g0(t[n], e);
    if (typeof t == "string")
      try {
        return g0(JSON.parse(t), e);
      } catch {
      }
  }
}
function R9(t) {
  const e = [];
  return g0(t, e), e;
}
const F9 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), w0 = (t) => {
  const e = t.toString(16);
  return `${e.length % 2 === 0 ? "0x" : "0x0"}${e}`;
}, al = (t, e) => typeof e == "bigint" ? {
  $bigint: e.toString()
} : e, M9 = (t, e, n) => Ee(["string", "uint256", "address", "bytes32"], ["", e, t, n]), vw = (t, e, n) => xe(M9(t, e, n));
function lf() {
  return lf = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, lf.apply(null, arguments);
}
var Dn = /* @__PURE__ */ function(t) {
  return t[t.DEBUG = 1] = "DEBUG", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.DISABLED = 5] = "DISABLED", t;
}(Dn || {});
class D9 {
  constructor(e) {
    this.config = e, this.logLevel = void 0, this.configure(e);
  }
  configure(e) {
    switch (this.config = lf({}, this.config, e), this.config.logLevel) {
      case "DEBUG":
        this.logLevel = Dn.DEBUG;
        break;
      case "INFO":
        this.logLevel = Dn.INFO;
        break;
      case "WARN":
        this.logLevel = Dn.WARN;
        break;
      case "ERROR":
        this.logLevel = Dn.ERROR;
        break;
      case "DISABLED":
        this.logLevel = Dn.DISABLED;
        break;
      default:
        this.logLevel = Dn.INFO;
        break;
    }
    this.config.silence === void 0 && (this.config.silence = !1);
  }
  debug(e, ...n) {
    this.config.silence !== !0 && this.logLevel === Dn.DEBUG && console.log(e, ...n);
  }
  info(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Dn.INFO && console.log(e, ...n);
  }
  warn(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Dn.WARN && (console.warn(e, ...n), this.config.onwarn && this.config.onwarn(e, n));
  }
  error(e, ...n) {
    this.config.silence !== !0 && this.logLevel <= Dn.ERROR && (console.error(e, ...n), this.config.onerror && this.config.onerror(e, n));
  }
}
const Fn = new D9({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: !0
}), VA = (t, e, n) => {
  const r = new Cr(t);
  return n && r.setHeader("Authorization", `BEARER ${n}`), e && r.setHeader("X-Access-Key", e), r;
}, L9 = (t) => {
  const e = lf({}, t.types);
  return delete e.EIP712Domain, Ml.hash(t.domain, e, t.message);
}, jA = (t) => Q(L9(t));
function hc() {
  return hc = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, hc.apply(null, arguments);
}
const H9 = (t, e = !1, n = !1) => {
  if (!t) throw new Error("invalid network config: empty config");
  const r = [];
  if (Array.isArray(t) ? r.push(...t) : r.push(t), r.length === 0) {
    if (e) throw new Error("invalid network config: empty config");
    return !1;
  }
  const s = r.map((u) => u.chainId).sort(), a = s.filter((u, l) => s.indexOf(u) !== l);
  if (a.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate chainIds ${a}`);
    return !1;
  }
  r.forEach((u) => u.name = u.name.toLowerCase());
  const i = r.map((u) => u.name).sort(), o = i.filter((u, l) => i.indexOf(u) !== l);
  if (o.length > 0) {
    if (e) throw new Error(`invalid network config: duplicate network names ${o}`);
    return !1;
  }
  let c = !1;
  for (let u = 0; u < r.length; u++) {
    const l = r[u];
    if ((!l.rpcUrl || l.rpcUrl === "") && !l.provider) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: rpcUrl or provider must be provided`);
      return !1;
    }
    if (!n && !l.relayer) {
      if (e) throw new Error(`invalid network config for chainId ${l.chainId}: relayer must be provided`);
      return !1;
    }
    if (l.isDefaultChain) {
      if (c) {
        if (e) throw new Error(`invalid network config for chainId ${l.chainId}: DefaultChain is already set by another config`);
        return !1;
      }
      c = !0;
    }
  }
  if (!c) {
    if (e) throw new Error("invalid network config: DefaultChain must be set");
    return !1;
  }
  return !0;
}, $9 = (t, e = !1) => (H9(t, !0, e), t), _9 = (t) => $9(G9(t)), G9 = (t) => {
  if (!t)
    return [];
  const e = t.sort((r, s) => r.chainId === s.chainId ? 0 : r.chainId < s.chainId ? -1 : 1), n = e.findIndex((r) => r.isDefaultChain);
  return n > 0 && e.splice(0, 0, e.splice(n, 1)[0]), e;
}, my = (t, e) => typeof t == "string" ? (e = e || {}, t.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(n, r) {
  let s = e[r];
  return typeof s == "function" ? s = s() : s == null ? s = "" : typeof s == "object" || typeof s == "symbol" ? s = s.toString() : s = s.valueOf(), s;
})) : "", z9 = (t) => my("https://${network}-indexer.sequence.app", {
  network: t
}), V9 = (t) => my("https://${network}-relayer.sequence.app", {
  network: t
}), j9 = (t) => my("https://nodes.sequence.app/${network}", {
  network: t
}), ie = (t, e) => {
  const n = $m[t];
  if (!n)
    throw new Error(`Network with chainId ${t} not found`);
  const r = j9(n.name);
  return hc({}, n, {
    rpcUrl: r,
    indexerUrl: z9(n.name),
    relayer: {
      url: V9(n.name),
      provider: {
        url: r
      }
    }
  }, e);
}, K9 = [hc({}, $m[k.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), hc({}, $m[k.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})], q9 = _9([hc({}, ie(k.POLYGON), {
  isDefaultChain: !0,
  isAuthChain: !0
}), ie(k.MAINNET), ie(k.BSC), ie(k.AVALANCHE), ie(k.ARBITRUM), ie(k.ARBITRUM_NOVA), ie(k.OPTIMISM), ie(k.OPTIMISM_SEPOLIA), ie(k.POLYGON_ZKEVM), ie(k.GNOSIS), ie(k.RINKEBY, {
  disabled: !0
}), ie(k.GOERLI, {
  disabled: !0
}), ie(k.SEPOLIA), ie(k.POLYGON_MUMBAI, {
  disabled: !0
}), ie(k.POLYGON_AMOY), ie(k.BSC_TESTNET), ie(k.ARBITRUM_SEPOLIA), ie(k.BASE), ie(k.BASE_SEPOLIA), ie(k.HOMEVERSE), ie(k.HOMEVERSE_TESTNET), ie(k.XAI), ie(k.XAI_SEPOLIA), ie(k.AVALANCHE_TESTNET), ie(k.B3), ie(k.B3_SEPOLIA), ie(k.APECHAIN), ie(k.APECHAIN_TESTNET), ie(k.BLAST), ie(k.BLAST_SEPOLIA), ie(k.TELOS), ie(k.TELOS_TESTNET), ie(k.BORNE_TESTNET), ie(k.SKALE_NEBULA), ie(k.SKALE_NEBULA_TESTNET), ie(k.SONEIUM), ie(k.SONEIUM_MINATO), ie(k.TOY_TESTNET), ie(k.IMMUTABLE_ZKEVM), ie(k.IMMUTABLE_ZKEVM_TESTNET), ie(k.ROOT_NETWORK), ie(k.ROOT_NETWORK_PORCINI), ie(k.LAOS), ie(k.LAOS_SIGMA_TESTNET), ie(k.MOONBEAM), ie(k.MOONBASE_ALPHA), ie(k.ETHERLINK), ie(k.ETHERLINK_TESTNET), ie(k.SOMNIA_TESTNET), ie(k.MONAD_TESTNET), ie(k.INCENTIV_TESTNET), ...K9]);
function p(t) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...t
  };
}
const W9 = /* @__PURE__ */ p({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: !1
}), KA = "2.31.6";
let Dc = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) => e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
  version: `viem@${KA}`
}, D = class E0 extends Error {
  constructor(e, n = {}) {
    var o;
    const r = (() => {
      var c;
      return n.cause instanceof E0 ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof E0 && n.cause.docsPath || n.docsPath, a = (o = Dc.getDocsUrl) == null ? void 0 : o.call(Dc, { ...n, docsPath: s }), i = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...r ? [`Details: ${r}`] : [],
      ...Dc.version ? [`Version: ${Dc.version}`] : []
    ].join(`
`);
    super(i, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = s, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = e, this.version = KA;
  }
  walk(e) {
    return qA(this, e);
  }
};
function qA(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? qA(t.cause, e) : e ? null : t;
}
let WA = class extends D {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
};
class Q9 extends D {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class J9 extends D {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function sa(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function je(t) {
  return sa(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
function Sr(t, { dir: e = "left" } = {}) {
  let n = typeof t == "string" ? t.replace("0x", "") : t, r = 0;
  for (let s = 0; s < n.length - 1 && n[e === "left" ? s : n.length - s - 1].toString() === "0"; s++)
    r++;
  return n = e === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof t == "string" ? (n.length === 1 && e === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
class QA extends D {
  constructor({ offset: e, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
let JA = class extends D {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
class kw extends D {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function At(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string" ? qs(t, { dir: e, size: n }) : Z9(t, { dir: e, size: n });
}
function qs(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  const r = t.replace("0x", "");
  if (r.length > n * 2)
    throw new JA({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function Z9(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  if (t.length > n)
    throw new JA({
      size: t.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let s = 0; s < n; s++) {
    const a = e === "right";
    r[a ? s : n - s - 1] = t[a ? s : t.length - s - 1];
  }
  return r;
}
const X9 = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Se(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? W(t, e) : typeof t == "string" ? $l(t, e) : typeof t == "boolean" ? ZA(t, e) : Pt(t, e);
}
function ZA(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Ir(n, { size: e.size }), At(n, { size: e.size })) : n;
}
function Pt(t, e = {}) {
  let n = "";
  for (let s = 0; s < t.length; s++)
    n += X9[t[s]];
  const r = `0x${n}`;
  return typeof e.size == "number" ? (Ir(r, { size: e.size }), At(r, { dir: "right", size: e.size })) : r;
}
function W(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const c = typeof t == "bigint" ? "n" : "";
    throw new WA({
      max: a ? `${a}${c}` : void 0,
      min: `${i}${c}`,
      signed: n,
      size: r,
      value: `${t}${c}`
    });
  }
  const o = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? At(o, { size: r }) : o;
}
const Y9 = /* @__PURE__ */ new TextEncoder();
function $l(t, e = {}) {
  const n = Y9.encode(t);
  return Pt(n, e);
}
const eI = /* @__PURE__ */ new TextEncoder();
function Xi(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? nI(t, e) : typeof t == "boolean" ? tI(t, e) : sa(t) ? tn(t, e) : XA(t, e);
}
function tI(t, e = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(t), typeof e.size == "number" ? (Ir(n, { size: e.size }), At(n, { size: e.size })) : n;
}
const Fr = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Cw(t) {
  if (t >= Fr.zero && t <= Fr.nine)
    return t - Fr.zero;
  if (t >= Fr.A && t <= Fr.F)
    return t - (Fr.A - 10);
  if (t >= Fr.a && t <= Fr.f)
    return t - (Fr.a - 10);
}
function tn(t, e = {}) {
  let n = t;
  e.size && (Ir(n, { size: e.size }), n = At(n, { dir: "right", size: e.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const s = r.length / 2, a = new Uint8Array(s);
  for (let i = 0, o = 0; i < s; i++) {
    const c = Cw(r.charCodeAt(o++)), u = Cw(r.charCodeAt(o++));
    if (c === void 0 || u === void 0)
      throw new D(`Invalid byte sequence ("${r[o - 2]}${r[o - 1]}" in "${r}").`);
    a[i] = c * 16 + u;
  }
  return a;
}
function nI(t, e) {
  const n = W(t, e);
  return tn(n);
}
function XA(t, e = {}) {
  const n = eI.encode(t);
  return typeof e.size == "number" ? (Ir(n, { size: e.size }), At(n, { dir: "right", size: e.size })) : n;
}
function Ir(t, { size: e }) {
  if (je(t) > e)
    throw new J9({
      givenSize: je(t),
      maxSize: e
    });
}
function Te(t, e = {}) {
  const { signed: n } = e;
  e.size && Ir(t, { size: e.size });
  const r = BigInt(t);
  if (!n)
    return r;
  const s = (t.length - 2) / 2, a = (1n << BigInt(s) * 8n - 1n) - 1n;
  return r <= a ? r : r - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function er(t, e = {}) {
  return Number(Te(t, e));
}
function cp(t, e) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (s) => {
      const a = e(s);
      if (n)
        for (const i of n)
          delete a[i];
      return {
        ...a,
        ...r(s)
      };
    },
    type: t
  });
}
const YA = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function lp(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? er(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? er(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? YA[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = rI(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
const by = /* @__PURE__ */ cp("transaction", lp);
function rI(t) {
  return t.map((e) => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function ev(t) {
  const e = (t.transactions ?? []).map((n) => typeof n == "string" ? n : lp(n));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
const yy = /* @__PURE__ */ cp("block", ev);
function gy(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...n ? { args: e, eventName: n } : {}
  };
}
const tv = {
  "0x0": "reverted",
  "0x1": "success"
};
function nv(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map((n) => gy(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? er(t.transactionIndex) : null,
    status: t.status ? tv[t.status] : null,
    type: t.type ? YA[t.type] || t.type : null
  };
  return t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)), t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)), e;
}
const rv = /* @__PURE__ */ cp("transactionReceipt", nv), sI = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function wu(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = aI(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((n) => Pt(n)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = W(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = W(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = W(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = W(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = W(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = W(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = sI[t.type]), typeof t.value < "u" && (e.value = W(t.value)), e;
}
const sv = /* @__PURE__ */ cp("transactionRequest", wu);
function aI(t) {
  return t.map((e) => ({
    address: e.address,
    r: e.r ? W(BigInt(e.r)) : e.r,
    s: e.s ? W(BigInt(e.s)) : e.s,
    chainId: W(e.chainId),
    nonce: W(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: W(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: W(e.v) } : {}
  }));
}
const iI = 2n ** 16n - 1n, Eu = 2n ** 256n - 1n, wy = 50000n, Tw = iI * 32n, av = {
  block: /* @__PURE__ */ yy({
    format(t) {
      var n;
      const e = (n = t.transactions) == null ? void 0 : n.map((r) => {
        var a;
        if (typeof r == "string")
          return r;
        const s = (a = av.transaction) == null ? void 0 : a.format(r);
        return s.typeHex === "0x71" ? s.type = "eip712" : s.typeHex === "0xff" && (s.type = "priority"), s;
      });
      return {
        l1BatchNumber: t.l1BatchNumber ? Te(t.l1BatchNumber) : null,
        l1BatchTimestamp: t.l1BatchTimestamp ? Te(t.l1BatchTimestamp) : null,
        transactions: e
      };
    }
  }),
  transaction: /* @__PURE__ */ by({
    format(t) {
      const e = {};
      return t.type === "0x71" ? e.type = "eip712" : t.type === "0xff" && (e.type = "priority"), {
        ...e,
        l1BatchNumber: t.l1BatchNumber ? Te(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Te(t.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: /* @__PURE__ */ rv({
    format(t) {
      return {
        l1BatchNumber: t.l1BatchNumber ? Te(t.l1BatchNumber) : null,
        l1BatchTxIndex: t.l1BatchTxIndex ? Te(t.l1BatchTxIndex) : null,
        logs: t.logs.map((e) => ({
          ...gy(e),
          l1BatchNumber: e.l1BatchNumber ? Te(e.l1BatchNumber) : null,
          transactionLogIndex: er(e.transactionLogIndex),
          logType: e.logType
        })),
        l2ToL1Logs: t.l2ToL1Logs.map((e) => ({
          blockNumber: Te(e.blockHash),
          blockHash: e.blockHash,
          l1BatchNumber: e.l1BatchNumber ? Te(e.l1BatchNumber) : null,
          transactionIndex: Te(e.transactionIndex),
          shardId: Te(e.shardId),
          isService: e.isService,
          sender: e.sender,
          key: e.key,
          value: e.value,
          transactionHash: e.transactionHash,
          logIndex: Te(e.logIndex)
        }))
      };
    }
  }),
  transactionRequest: /* @__PURE__ */ sv({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(t) {
      return t.gasPerPubdata || t.paymaster && t.paymasterInput || t.factoryDeps || t.customSignature ? {
        eip712Meta: {
          ...t.gasPerPubdata ? { gasPerPubdata: Se(t.gasPerPubdata) } : { gasPerPubdata: Se(wy) },
          ...t.paymaster && t.paymasterInput ? {
            paymasterParams: {
              paymaster: t.paymaster,
              paymasterInput: Array.from(tn(t.paymasterInput))
            }
          } : {},
          ...t.factoryDeps ? {
            factoryDeps: t.factoryDeps.map((e) => Array.from(tn(e)))
          } : {},
          ...t.customSignature ? {
            customSignature: Array.from(tn(t.customSignature))
          } : {}
        },
        type: "0x71"
      } : {};
    }
  })
};
function Ct(t) {
  return typeof t[0] == "string" ? Rn(t) : oI(t);
}
function oI(t) {
  let e = 0;
  for (const s of t)
    e += s.length;
  const n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function Rn(t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
class Sw extends D {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class cI extends D {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class lI extends D {
  constructor({ count: e, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const uI = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new lI({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new cI({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new Sw({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new Sw({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const n = e ?? this.position;
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(t);
    return this.position += e ?? t, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Ey(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(uI);
  return n.bytes = t, n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = e, n;
}
function Or(t, e = "hex") {
  const n = iv(t), r = Ey(new Uint8Array(n.length));
  return n.encode(r), e === "hex" ? Pt(r.bytes) : r.bytes;
}
function iv(t) {
  return Array.isArray(t) ? dI(t.map((e) => iv(e))) : fI(t);
}
function dI(t) {
  const e = t.reduce((s, a) => s + a.length, 0), n = ov(e);
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(s) {
      e <= 55 ? s.pushByte(192 + e) : (s.pushByte(247 + n), n === 1 ? s.pushUint8(e) : n === 2 ? s.pushUint16(e) : n === 3 ? s.pushUint24(e) : s.pushUint32(e));
      for (const { encode: a } of t)
        a(s);
    }
  };
}
function fI(t) {
  const e = typeof t == "string" ? tn(t) : t, n = ov(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + n + e.length,
    encode(s) {
      e.length === 1 && e[0] < 128 ? s.pushBytes(e) : e.length <= 55 ? (s.pushByte(128 + e.length), s.pushBytes(e)) : (s.pushByte(183 + n), n === 1 ? s.pushUint8(e.length) : n === 2 ? s.pushUint16(e.length) : n === 3 ? s.pushUint24(e.length) : s.pushUint32(e.length), s.pushBytes(e));
    }
  };
}
function ov(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new D("Length is too large.");
}
const pI = {
  gwei: 9,
  wei: 18
}, hI = {
  ether: -9,
  wei: 9
};
function cv(t, e) {
  let n = t.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(e, "0");
  let [s, a] = [
    n.slice(0, n.length - e),
    n.slice(n.length - e)
  ];
  return a = a.replace(/(0+)$/, ""), `${r ? "-" : ""}${s || "0"}${a ? `.${a}` : ""}`;
}
function xy(t, e = "wei") {
  return cv(t, pI[e]);
}
function Tt(t, e = "wei") {
  return cv(t, hI[e]);
}
function Ac(t) {
  const e = Object.entries(t).map(([r, s]) => s === void 0 || s === !1 ? null : [r, s]).filter(Boolean), n = e.reduce((r, [s]) => Math.max(r, s.length), 0);
  return e.map(([r, s]) => `  ${`${r}:`.padEnd(n + 1)}  ${s}`).join(`
`);
}
class mI extends D {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class bI extends D {
  constructor({ v: e }) {
    super(`Invalid \`v\` value "${e}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class yI extends D {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Ac(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class gI extends D {
  constructor({ storageKey: e }) {
    super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
class wI extends D {
  constructor(e, { account: n, docsPath: r, chain: s, data: a, gas: i, gasPrice: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, to: d, value: f }) {
    var y;
    const h = Ac({
      chain: s && `${s == null ? void 0 : s.name} (id: ${s == null ? void 0 : s.id})`,
      from: n == null ? void 0 : n.address,
      to: d,
      value: typeof f < "u" && `${xy(f)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || "ETH"}`,
      data: a,
      gas: i,
      gasPrice: typeof o < "u" && `${Tt(o)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Tt(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Tt(u)} gwei`,
      nonce: l
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        h
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
function EI(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (const n of t) {
    const { chainId: r, nonce: s, ...a } = n, i = n.address;
    e.push([
      r ? Se(r) : "0x",
      i,
      s ? Se(s) : "0x",
      ...kc({}, a)
    ]);
  }
  return e;
}
function Ay(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((a) => tn(a)) : t.blobs, s = [];
  for (const a of r)
    s.push(Uint8Array.from(e.blobToKzgCommitment(a)));
  return n === "bytes" ? s : s.map((a) => Pt(a));
}
function vy(t) {
  const { kzg: e } = t, n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), r = typeof t.blobs[0] == "string" ? t.blobs.map((i) => tn(i)) : t.blobs, s = typeof t.commitments[0] == "string" ? t.commitments.map((i) => tn(i)) : t.commitments, a = [];
  for (let i = 0; i < r.length; i++) {
    const o = r[i], c = s[i];
    a.push(Uint8Array.from(e.computeBlobKzgProof(o, c)));
  }
  return n === "bytes" ? a : a.map((i) => Pt(i));
}
function lv(t, e) {
  const n = e || "hex", r = K5(sa(t, { strict: !1 }) ? Xi(t) : t);
  return n === "bytes" ? r : Se(r);
}
function xI(t) {
  const { commitment: e, version: n = 1 } = t, r = t.to ?? (typeof e == "string" ? "hex" : "bytes"), s = lv(e, "bytes");
  return s.set([n], 0), r === "bytes" ? s : Pt(s);
}
function uv(t) {
  const { commitments: e, version: n } = t, r = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), s = [];
  for (const a of e)
    s.push(xI({
      commitment: a,
      to: r,
      version: n
    }));
  return s;
}
const Ow = 6, dv = 32, ky = 4096, fv = dv * ky, Bw = fv * Ow - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * ky * Ow, pv = 1;
class AI extends D {
  constructor({ maxSize: e, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class hv extends D {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class vI extends D {
  constructor({ hash: e, size: n }) {
    super(`Versioned hash "${e}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class kI extends D {
  constructor({ hash: e, version: n }) {
    super(`Versioned hash "${e}" version is invalid.`, {
      metaMessages: [
        `Expected: ${pv}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function CI(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), n = typeof t.data == "string" ? tn(t.data) : t.data, r = je(n);
  if (!r)
    throw new hv();
  if (r > Bw)
    throw new AI({
      maxSize: Bw,
      size: r
    });
  const s = [];
  let a = !0, i = 0;
  for (; a; ) {
    const o = Ey(new Uint8Array(fv));
    let c = 0;
    for (; c < ky; ) {
      const u = n.slice(i, i + (dv - 1));
      if (o.pushByte(0), o.pushBytes(u), u.length < 31) {
        o.pushByte(128), a = !1;
        break;
      }
      c++, i += 31;
    }
    s.push(o);
  }
  return e === "bytes" ? s.map((o) => o.bytes) : s.map((o) => Pt(o.bytes));
}
function mv(t) {
  const { data: e, kzg: n, to: r } = t, s = t.blobs ?? CI({ data: e, to: r }), a = t.commitments ?? Ay({ blobs: s, kzg: n, to: r }), i = t.proofs ?? vy({ blobs: s, commitments: a, kzg: n, to: r }), o = [];
  for (let c = 0; c < s.length; c++)
    o.push({
      blob: s[c],
      commitment: a[c],
      proof: i[c]
    });
  return o;
}
class Je extends D {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class x0 extends D {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...e && r.blockCreated && r.blockCreated > e ? [
          `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`
        ] : [
          `- The chain does not have the contract "${r.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class TI extends D {
  constructor({ chain: e, currentChainId: n }) {
    super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${n}`,
        `Expected Chain ID: ${e.id}  ${e.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class SI extends D {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
class bv extends D {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class vc extends D {
  constructor({ chainId: e }) {
    super(typeof e == "number" ? `Chain ID "${e}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
let zi = class extends D {
  constructor({ cause: e, message: n } = {}) {
    var s;
    const r = (s = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : s.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
};
Object.defineProperty(zi, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(zi, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class aa extends D {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Tt(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(aa, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class A0 extends D {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${Tt(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(A0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class v0 extends D {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(v0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class k0 extends D {
  constructor({ cause: e, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(k0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class C0 extends D {
  constructor({ cause: e, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(C0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class T0 extends D {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(T0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class S0 extends D {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(S0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class O0 extends D {
  constructor({ cause: e, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(O0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class B0 extends D {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(B0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class mc extends D {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${Tt(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${Tt(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(mc, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class up extends D {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
class dp extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
function qe(t, e) {
  const n = e || "hex", r = Ox(sa(t, { strict: !1 }) ? Xi(t) : t);
  return n === "bytes" ? r : Se(r);
}
const Nh = /* @__PURE__ */ new dp(8192);
function fp(t, e) {
  if (Nh.has(`${t}.${e}`))
    return Nh.get(`${t}.${e}`);
  const n = t.substring(2).toLowerCase(), r = qe(XA(n), "bytes"), s = n.split("");
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && s[i] && (s[i] = s[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && s[i + 1] && (s[i + 1] = s[i + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return Nh.set(`${t}.${e}`, a), a;
}
function TZ(t, e) {
  if (!He(t, { strict: !1 }))
    throw new Je({ address: t });
  return fp(t, e);
}
const OI = /^0x[a-fA-F0-9]{40}$/, Rh = /* @__PURE__ */ new dp(8192);
function He(t, e) {
  const { strict: n = !0 } = e ?? {}, r = `${t}.${n}`;
  if (Rh.has(r))
    return Rh.get(r);
  const s = OI.test(t) ? t.toLowerCase() === t ? !0 : n ? fp(t) === t : !0 : !1;
  return Rh.set(r, s), s;
}
function _l(t, e, n, { strict: r } = {}) {
  return sa(t, { strict: !1 }) ? P0(t, e, n, {
    strict: r
  }) : wv(t, e, n, {
    strict: r
  });
}
function yv(t, e) {
  if (typeof e == "number" && e > 0 && e > je(t) - 1)
    throw new QA({
      offset: e,
      position: "start",
      size: je(t)
    });
}
function gv(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && je(t) !== n - e)
    throw new QA({
      offset: n,
      position: "end",
      size: je(t)
    });
}
function wv(t, e, n, { strict: r } = {}) {
  yv(t, e);
  const s = t.slice(e, n);
  return r && gv(s, e, n), s;
}
function P0(t, e, n, { strict: r } = {}) {
  yv(t, e);
  const s = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return r && gv(s, e, n), s;
}
function BI(t) {
  const { authorizationList: e } = t;
  if (e)
    for (const n of e) {
      const { chainId: r } = n, s = n.address;
      if (!He(s))
        throw new Je({ address: s });
      if (r < 0)
        throw new vc({ chainId: r });
    }
  Cy(t);
}
function PI(t) {
  const { blobVersionedHashes: e } = t;
  if (e) {
    if (e.length === 0)
      throw new hv();
    for (const n of e) {
      const r = je(n), s = er(_l(n, 0, 1));
      if (r !== 32)
        throw new vI({ hash: n, size: r });
      if (s !== pv)
        throw new kI({
          hash: n,
          version: s
        });
    }
  }
  Cy(t);
}
function Cy(t) {
  const { chainId: e, maxPriorityFeePerGas: n, maxFeePerGas: r, to: s } = t;
  if (e <= 0)
    throw new vc({ chainId: e });
  if (s && !He(s))
    throw new Je({ address: s });
  if (r && r > Eu)
    throw new aa({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new mc({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function II(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (e <= 0)
    throw new vc({ chainId: e });
  if (a && !He(a))
    throw new Je({ address: a });
  if (n || s)
    throw new D("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > Eu)
    throw new aa({ maxFeePerGas: r });
}
function UI(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a } = t;
  if (a && !He(a))
    throw new Je({ address: a });
  if (typeof e < "u" && e <= 0)
    throw new vc({ chainId: e });
  if (n || s)
    throw new D("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > Eu)
    throw new aa({ maxFeePerGas: r });
}
function Ev(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new yI({ transaction: t });
}
function xu(t) {
  if (!t || t.length === 0)
    return [];
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const { address: r, storageKeys: s } = t[n];
    for (let a = 0; a < s.length; a++)
      if (s[a].length - 2 !== 64)
        throw new gI({ storageKey: s[a] });
    if (!He(r, { strict: !1 }))
      throw new Je({ address: r });
    e.push([r, s]);
  }
  return e;
}
function Ty(t, e) {
  const n = Ev(t);
  return n === "eip1559" ? FI(t, e) : n === "eip2930" ? MI(t, e) : n === "eip4844" ? RI(t, e) : n === "eip7702" ? NI(t, e) : DI(t, e);
}
function NI(t, e) {
  const { authorizationList: n, chainId: r, gas: s, nonce: a, to: i, value: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  BI(t);
  const f = xu(l), h = EI(n);
  return Rn([
    "0x04",
    Or([
      W(r),
      a ? W(a) : "0x",
      u ? W(u) : "0x",
      c ? W(c) : "0x",
      s ? W(s) : "0x",
      i ?? "0x",
      o ? W(o) : "0x",
      d ?? "0x",
      f,
      h,
      ...kc(t, e)
    ])
  ]);
}
function RI(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerBlobGas: o, maxFeePerGas: c, maxPriorityFeePerGas: u, accessList: l, data: d } = t;
  PI(t);
  let f = t.blobVersionedHashes, h = t.sidecars;
  if (t.blobs && (typeof f > "u" || typeof h > "u")) {
    const A = typeof t.blobs[0] == "string" ? t.blobs : t.blobs.map((O) => Pt(O)), P = t.kzg, x = Ay({
      blobs: A,
      kzg: P
    });
    if (typeof f > "u" && (f = uv({
      commitments: x
    })), typeof h > "u") {
      const O = vy({ blobs: A, commitments: x, kzg: P });
      h = mv({ blobs: A, commitments: x, proofs: O });
    }
  }
  const y = xu(l), b = [
    W(n),
    s ? W(s) : "0x",
    u ? W(u) : "0x",
    c ? W(c) : "0x",
    r ? W(r) : "0x",
    a ?? "0x",
    i ? W(i) : "0x",
    d ?? "0x",
    y,
    o ? W(o) : "0x",
    f ?? [],
    ...kc(t, e)
  ], g = [], w = [], v = [];
  if (h)
    for (let A = 0; A < h.length; A++) {
      const { blob: P, commitment: x, proof: O } = h[A];
      g.push(P), w.push(x), v.push(O);
    }
  return Rn([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    Or(h ? [b, g, w, v] : b)
  ]);
}
function FI(t, e) {
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, data: l } = t;
  Cy(t);
  const d = xu(u), f = [
    W(n),
    s ? W(s) : "0x",
    c ? W(c) : "0x",
    o ? W(o) : "0x",
    r ? W(r) : "0x",
    a ?? "0x",
    i ? W(i) : "0x",
    l ?? "0x",
    d,
    ...kc(t, e)
  ];
  return Rn([
    "0x02",
    Or(f)
  ]);
}
function MI(t, e) {
  const { chainId: n, gas: r, data: s, nonce: a, to: i, value: o, accessList: c, gasPrice: u } = t;
  II(t);
  const l = xu(c), d = [
    W(n),
    a ? W(a) : "0x",
    u ? W(u) : "0x",
    r ? W(r) : "0x",
    i ?? "0x",
    o ? W(o) : "0x",
    s ?? "0x",
    l,
    ...kc(t, e)
  ];
  return Rn([
    "0x01",
    Or(d)
  ]);
}
function DI(t, e) {
  const { chainId: n = 0, gas: r, data: s, nonce: a, to: i, value: o, gasPrice: c } = t;
  UI(t);
  let u = [
    a ? W(a) : "0x",
    c ? W(c) : "0x",
    r ? W(r) : "0x",
    i ?? "0x",
    o ? W(o) : "0x",
    s ?? "0x"
  ];
  if (e) {
    const l = (() => {
      if (e.v >= 35n)
        return (e.v - 35n) / 2n > 0 ? e.v : 27n + (e.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + e.v - 27n);
      const h = 27n + (e.v === 27n ? 0n : 1n);
      if (e.v !== h)
        throw new bI({ v: e.v });
      return h;
    })(), d = Sr(e.r), f = Sr(e.s);
    u = [
      ...u,
      W(l),
      d === "0x00" ? "0x" : d,
      f === "0x00" ? "0x" : f
    ];
  } else n > 0 && (u = [
    ...u,
    W(n),
    "0x",
    "0x"
  ]);
  return Or(u);
}
function kc(t, e) {
  const n = e ?? t, { v: r, yParity: s } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof s > "u")
    return [];
  const a = Sr(n.r), i = Sr(n.s);
  return [typeof s == "number" ? s ? W(1) : "0x" : r === 0n ? "0x" : r === 1n ? W(1) : r === 27n ? "0x" : W(1), a === "0x00" ? "0x" : a, i === "0x00" ? "0x" : i];
}
class LI extends D {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join(`
`), { name: "InvalidEip712TransactionError" });
  }
}
function xv(t) {
  return !!(t.type === "eip712" || "customSignature" in t && t.customSignature || "paymaster" in t && t.paymaster || "paymasterInput" in t && t.paymasterInput || "gasPerPubdata" in t && typeof t.gasPerPubdata == "bigint" || "factoryDeps" in t && t.factoryDeps);
}
function Av(t) {
  const { chainId: e, to: n, from: r, paymaster: s, paymasterInput: a } = t;
  if (!xv(t))
    throw new LI();
  if (!e || e <= 0)
    throw new vc({ chainId: e });
  if (n && !He(n))
    throw new Je({ address: n });
  if (r && !He(r))
    throw new Je({ address: r });
  if (s && !He(s))
    throw new Je({ address: s });
  if (s && !a)
    throw new D("`paymasterInput` must be provided when `paymaster` is defined");
  if (!s && a)
    throw new D("`paymaster` must be provided when `paymasterInput` is defined");
}
function HI(t, e) {
  return xv(t) ? _I(t) : Ty(t, e);
}
const $I = {
  transaction: HI
};
function _I(t) {
  const { chainId: e, gas: n, nonce: r, to: s, from: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, customSignature: u, factoryDeps: l, paymaster: d, paymasterInput: f, gasPerPubdata: h, data: y } = t;
  Av(t);
  const b = [
    r ? Se(r) : "0x",
    c ? Se(c) : "0x",
    o ? Se(o) : "0x",
    n ? Se(n) : "0x",
    s ?? "0x",
    i ? Se(i) : "0x",
    y ?? "0x",
    Se(e),
    Se(""),
    Se(""),
    Se(e),
    a ?? "0x",
    Se(h || wy),
    l ?? [],
    u ?? "0x",
    // EIP712 signature
    d && f ? [d, f] : []
  ];
  return Rn([
    "0x71",
    Or(b)
  ]);
}
class GI extends D {
  constructor({ givenLength: e, maxBytecodeSize: n }) {
    super(`Bytecode cannot be longer than ${n} bytes. Given length: ${e}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
}
class zI extends D {
  constructor({ givenLengthInWords: e }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${e}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
}
class VI extends D {
  constructor({ givenLength: e }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${e}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
}
function jI(t) {
  const e = Xi(t);
  if (e.length % 32 !== 0)
    throw new VI({
      givenLength: e.length
    });
  if (e.length > Tw)
    throw new GI({
      givenLength: e.length,
      maxBytecodeSize: Tw
    });
  const n = lv(e), r = Xi(n), s = e.length / 32;
  if (s % 2 === 0)
    throw new zI({
      givenLengthInWords: s
    });
  const a = Xi(s), i = At(a, { size: 2 }), o = new Uint8Array([1, 0]);
  return r.set(o, 0), r.set(i, 2), r;
}
const KI = (t) => {
  Av(t);
  const e = qI(t);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: t.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message: e
  };
};
function qI(t) {
  const { gas: e, nonce: n, to: r, from: s, value: a, maxFeePerGas: i, maxPriorityFeePerGas: o, factoryDeps: c, paymaster: u, paymasterInput: l, gasPerPubdata: d, data: f } = t;
  return {
    txType: 113n,
    from: BigInt(s),
    to: r ? BigInt(r) : 0n,
    gasLimit: e ?? 0n,
    gasPerPubdataByteLimit: d ?? wy,
    maxFeePerGas: i ?? 0n,
    maxPriorityFeePerGas: o ?? 0n,
    paymaster: u ? BigInt(u) : 0n,
    nonce: n ? BigInt(n) : 0n,
    value: a ?? 0n,
    data: f ?? "0x",
    factoryDeps: (c == null ? void 0 : c.map((h) => Se(jI(h)))) ?? [],
    paymasterInput: l || "0x"
  };
}
const hn = {
  blockTime: 1e3,
  formatters: av,
  serializers: $I,
  custom: {
    getEip712Domain: KI
  }
}, WI = /* @__PURE__ */ p({
  ...hn,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
}), QI = /* @__PURE__ */ p({
  ...hn,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
}), JI = /* @__PURE__ */ p({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: !1
}), ZI = /* @__PURE__ */ p({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: !1
}), XI = /* @__PURE__ */ p({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: !1
}), YI = /* @__PURE__ */ p({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: !1
}), e4 = /* @__PURE__ */ p({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
}), t4 = /* @__PURE__ */ p({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: !0
}), n4 = /* @__PURE__ */ p({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: !1
}), r4 = /* @__PURE__ */ p({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: !0
}), vv = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, Sy = {
  block: /* @__PURE__ */ yy({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const s = lp(r);
          return s.typeHex === "0x7e" && (s.isSystemTx = r.isSystemTx, s.mint = r.mint ? Te(r.mint) : void 0, s.sourceHash = r.sourceHash, s.type = "deposit"), s;
        }),
        stateRoot: t.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ by({
    format(t) {
      const e = {};
      return t.type === "0x7e" && (e.isSystemTx = t.isSystemTx, e.mint = t.mint ? Te(t.mint) : void 0, e.sourceHash = t.sourceHash, e.type = "deposit"), e;
    }
  }),
  transactionReceipt: /* @__PURE__ */ rv({
    format(t) {
      return {
        l1GasPrice: t.l1GasPrice ? Te(t.l1GasPrice) : null,
        l1GasUsed: t.l1GasUsed ? Te(t.l1GasUsed) : null,
        l1Fee: t.l1Fee ? Te(t.l1Fee) : null,
        l1FeeScalar: t.l1FeeScalar ? Number(t.l1FeeScalar) : null
      };
    }
  })
};
function kv(t, e) {
  return i4(t) ? a4(t) : Ty(t, e);
}
const s4 = {
  transaction: kv
};
function a4(t) {
  o4(t);
  const { sourceHash: e, data: n, from: r, gas: s, isSystemTx: a, mint: i, to: o, value: c } = t, u = [
    e,
    r,
    o ?? "0x",
    i ? Se(i) : "0x",
    c ? Se(c) : "0x",
    s ? Se(s) : "0x",
    a ? "0x1" : "0x",
    n ?? "0x"
  ];
  return Rn([
    "0x7e",
    Or(u)
  ]);
}
function i4(t) {
  return t.type === "deposit" || typeof t.sourceHash < "u";
}
function o4(t) {
  const { from: e, to: n } = t;
  if (e && !He(e))
    throw new Je({ address: e });
  if (n && !He(n))
    throw new Je({ address: n });
}
const q = {
  blockTime: 2e3,
  contracts: vv,
  formatters: Sy,
  serializers: s4
}, Ku = 1, c4 = /* @__PURE__ */ p({
  ...q,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Ku]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [Ku]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [Ku]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId: Ku
}), qu = 11155111, l4 = /* @__PURE__ */ p({
  ...q,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [qu]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [qu]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [qu]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: qu
}), u4 = /* @__PURE__ */ p({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), d4 = 42161, f4 = /* @__PURE__ */ p({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: d4
}), p4 = /* @__PURE__ */ p({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: !0
}), pl = /* @__PURE__ */ p({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), h4 = /* @__PURE__ */ p({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: !0
}), Cv = /* @__PURE__ */ p({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
}), m4 = /* @__PURE__ */ p({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: !0
}), b4 = /* @__PURE__ */ p({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
}), y4 = /* @__PURE__ */ p({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: !1
}), g4 = /* @__PURE__ */ p({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: !0
}), w4 = /* @__PURE__ */ p({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: !0
}), E4 = /* @__PURE__ */ p({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
}), x4 = /* @__PURE__ */ p({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
}), A4 = /* @__PURE__ */ p({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: !1,
  contracts: {}
}), v4 = /* @__PURE__ */ p({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
}), k4 = /* @__PURE__ */ p({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: !1
}), C4 = /* @__PURE__ */ p({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: !1
}), T4 = /* @__PURE__ */ p({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: !0
}), S4 = /* @__PURE__ */ p({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: !0
}), O4 = /* @__PURE__ */ p({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
}), B4 = /* @__PURE__ */ p({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: !0
}), P4 = /* @__PURE__ */ p({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: !0
}), I4 = /* @__PURE__ */ p({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), U4 = /* @__PURE__ */ p({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: !0
}), N4 = 8453, R4 = /* @__PURE__ */ p({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: N4
}), F4 = 168587773, M4 = /* @__PURE__ */ p({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: !0,
  sourceId: F4
}), D4 = /* @__PURE__ */ p({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
}), Lc = 1, hl = /* @__PURE__ */ p({
  ...q,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Lc]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [Lc]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [Lc]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [Lc]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: Lc
}), L4 = /* @__PURE__ */ p({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: !0
}), Wu = 5, Tv = /* @__PURE__ */ p({
  ...q,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Wu]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [Wu]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [Wu]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: !0,
  sourceId: Wu
}), Hc = 11155111, Sv = /* @__PURE__ */ p({
  ...q,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Hc]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [Hc]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [Hc]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [Hc]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: !0,
  sourceId: Hc
}), H4 = /* @__PURE__ */ p({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
}), $4 = /* @__PURE__ */ p({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: !0
}), _4 = /* @__PURE__ */ p({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
}), G4 = /* @__PURE__ */ p({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: !0
}), z4 = /* @__PURE__ */ p({
  id: 80094,
  name: "Berachain",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 877008
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: !1
}), V4 = /* @__PURE__ */ p({
  id: 80069,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: !0
}), j4 = /* @__PURE__ */ p({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: !0
}), K4 = /* @__PURE__ */ p({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: !0
}), q4 = /* @__PURE__ */ p({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
}), W4 = /* @__PURE__ */ p({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: !1
}), Q4 = /* @__PURE__ */ p({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: !1
}), J4 = /* @__PURE__ */ p({
  id: 96,
  name: "KUB Mainnet",
  nativeCurrency: { name: "KUB Coin", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KUB Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
}), Z4 = /* @__PURE__ */ p({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: !0
}), X4 = /* @__PURE__ */ p({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
}), Y4 = /* @__PURE__ */ p({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: !0
}), eU = /* @__PURE__ */ p({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: !1
}), tU = /* @__PURE__ */ p({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
}), nU = /* @__PURE__ */ p({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: !0
}), rU = p({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
}), Qu = 1, sU = /* @__PURE__ */ p({
  ...q,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    },
    l2OutputOracle: {
      [Qu]: {
        address: "0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76",
        blockCreated: 19300358
      }
    },
    portal: {
      [Qu]: {
        address: "0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb",
        blockCreated: 19300357
      }
    },
    l1StandardBridge: {
      [Qu]: {
        address: "0x697402166Fbf2F22E970df8a6486Ef171dbfc524",
        blockCreated: 19300360
      }
    }
  },
  sourceId: Qu
}), aU = 11155111, iU = /* @__PURE__ */ p({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: !0,
  sourceId: aU
}), Fh = 1, oU = p({
  ...q,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [Fh]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [Fh]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: Fh
}), cU = /* @__PURE__ */ p({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
}), lU = /* @__PURE__ */ p({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: !0
}), Mh = 11155111, uU = p({
  ...q,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [Mh]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [Mh]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: !0,
  sourceId: Mh
}), dU = /* @__PURE__ */ p({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: !1
}), fU = /* @__PURE__ */ p({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Botanix", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: !0
}), pU = /* @__PURE__ */ p({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: !1
}), hU = /* @__PURE__ */ p({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: !0
}), mU = /* @__PURE__ */ p({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
}), bU = /* @__PURE__ */ p({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: !0
}), yU = /* @__PURE__ */ p({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), gU = /* @__PURE__ */ p({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: !1
}), wU = /* @__PURE__ */ p({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: !0
}), EU = /* @__PURE__ */ p({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
}), xU = /* @__PURE__ */ p({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: !0
}), AU = /* @__PURE__ */ p({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
}), vU = /* @__PURE__ */ p({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: !0
}), kU = /* @__PURE__ */ p({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
}), CU = /* @__PURE__ */ p({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: !0
}), TU = /* @__PURE__ */ p({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), SU = /* @__PURE__ */ p({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
}), OU = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (t) => {
    var s;
    if (!((s = t.request) != null && s.feeCurrency))
      return null;
    const [e, n] = await Promise.all([
      BU(t.client, t.request.feeCurrency),
      PU(t.client, t.request.feeCurrency)
    ]);
    return {
      maxFeePerGas: t.multiply(e - n) + n,
      maxPriorityFeePerGas: n
    };
  }
};
async function BU(t, e) {
  const n = await t.request({
    method: "eth_gasPrice",
    params: [e]
  });
  return BigInt(n);
}
async function PU(t, e) {
  const n = await t.request({
    method: "eth_maxPriorityFeePerGas",
    params: [e]
  });
  return BigInt(n);
}
function Ov(t) {
  return t === 0 || t === 0n || t === void 0 || t === null || t === "0" || t === "" || typeof t == "string" && (Sr(t).toLowerCase() === "0x" || Sr(t).toLowerCase() === "0x00");
}
function il(t) {
  return !Ov(t);
}
function IU(t) {
  return typeof t.maxFeePerGas < "u" && typeof t.maxPriorityFeePerGas < "u";
}
function Bv(t) {
  return t.type === "cip64" ? !0 : IU(t) && il(t.feeCurrency);
}
const UU = {
  block: /* @__PURE__ */ yy({
    format(t) {
      var n;
      return {
        transactions: (n = t.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : {
          ...lp(r),
          ...r.gatewayFee ? {
            gatewayFee: Te(r.gatewayFee),
            gatewayFeeRecipient: r.gatewayFeeRecipient
          } : {},
          feeCurrency: r.feeCurrency
        })
      };
    }
  }),
  transaction: /* @__PURE__ */ by({
    format(t) {
      if (t.type === "0x7e")
        return {
          isSystemTx: t.isSystemTx,
          mint: t.mint ? Te(t.mint) : void 0,
          sourceHash: t.sourceHash,
          type: "deposit"
        };
      const e = { feeCurrency: t.feeCurrency };
      return t.type === "0x7b" ? e.type = "cip64" : (t.type === "0x7c" && (e.type = "cip42"), e.gatewayFee = t.gatewayFee ? Te(t.gatewayFee) : null, e.gatewayFeeRecipient = t.gatewayFeeRecipient), e;
    }
  }),
  transactionRequest: /* @__PURE__ */ sv({
    format(t) {
      const e = {};
      return t.feeCurrency && (e.feeCurrency = t.feeCurrency), Bv(t) && (e.type = "0x7b"), e;
    }
  })
};
function NU(t, e) {
  return Bv(t) ? FU(t, e) : kv(t, e);
}
const RU = {
  transaction: NU
};
function FU(t, e) {
  DU(t);
  const { chainId: n, gas: r, nonce: s, to: a, value: i, maxFeePerGas: o, maxPriorityFeePerGas: c, accessList: u, feeCurrency: l, data: d } = t, f = [
    Se(n),
    s ? Se(s) : "0x",
    c ? Se(c) : "0x",
    o ? Se(o) : "0x",
    r ? Se(r) : "0x",
    a ?? "0x",
    i ? Se(i) : "0x",
    d ?? "0x",
    xu(u),
    l,
    ...kc(t, e)
  ];
  return Rn([
    "0x7b",
    Or(f)
  ]);
}
const MU = Eu;
function DU(t) {
  const { chainId: e, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: s, to: a, feeCurrency: i } = t;
  if (e <= 0)
    throw new vc({ chainId: e });
  if (a && !He(a))
    throw new Je({ address: a });
  if (r)
    throw new D("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (il(s) && s > MU)
    throw new aa({ maxFeePerGas: s });
  if (il(n) && il(s) && n > s)
    throw new mc({ maxFeePerGas: s, maxPriorityFeePerGas: n });
  if (il(i) && !He(i))
    throw new D("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  if (Ov(i))
    throw new D("`feeCurrency` must be provided for CIP-64 transactions.");
}
const I0 = {
  blockTime: 1e3,
  contracts: vv,
  formatters: UU,
  serializers: RU,
  fees: OU
}, LU = /* @__PURE__ */ p({
  ...I0,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: !1
}), Ju = 17e3, HU = /* @__PURE__ */ p({
  ...I0,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...I0.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [Ju]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [Ju]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [Ju]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [Ju]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: !0
}), $U = /* @__PURE__ */ p({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
}), _U = /* @__PURE__ */ p({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiliz.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8080847
    }
  }
}), GU = /* @__PURE__ */ p({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
}), zU = /* @__PURE__ */ p({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: !0
}), VU = /* @__PURE__ */ p({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
}), jU = /* @__PURE__ */ p({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: !1
}), KU = /* @__PURE__ */ p({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: !1
}), qU = /* @__PURE__ */ p({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
}), WU = /* @__PURE__ */ p({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: !0,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
}), QU = /* @__PURE__ */ p({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: !1
}), JU = /* @__PURE__ */ p({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: !0
}), ZU = /* @__PURE__ */ p({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: !0
}), XU = 1, YU = /* @__PURE__ */ p({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: XU
}), eN = 11155111, tN = /* @__PURE__ */ p({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: !0,
  sourceId: eN
}), nN = p({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
}), rN = p({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), sN = /* @__PURE__ */ p({
  id: 102030,
  name: "Creditcoin3 Mainnet",
  nativeCurrency: { name: "Creditcoin3 Mainnet", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: !1
}), aN = /* @__PURE__ */ p({
  id: 102031,
  name: "Creditcoin3 Testnet",
  nativeCurrency: { name: "Creditcoin3 Testnet", symbol: "TCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: !0
}), iN = /* @__PURE__ */ p({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
}), oN = /* @__PURE__ */ p({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://cronos.org/explorer/testnet3"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: !0
}), cN = /* @__PURE__ */ p({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
}), lN = /* @__PURE__ */ p({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: !0
}), uN = /* @__PURE__ */ p({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
}), dN = /* @__PURE__ */ p({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: !0
}), fN = /* @__PURE__ */ p({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), pN = /* @__PURE__ */ p({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: !0
}), hN = /* @__PURE__ */ p({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: !1
}), mN = /* @__PURE__ */ p({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: !0
}), bN = /* @__PURE__ */ p({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
}), yN = /* @__PURE__ */ p({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: !1
}), gN = /* @__PURE__ */ p({
  ...q,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...q.contracts
  }
}), wN = /* @__PURE__ */ p({
  ...q,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...q.contracts
  }
}), EN = /* @__PURE__ */ p({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
}), xN = /* @__PURE__ */ p({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: !0
}), AN = /* @__PURE__ */ p({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
}), vN = /* @__PURE__ */ p({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
}), kN = /* @__PURE__ */ p({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: !1
}), CN = /* @__PURE__ */ p({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
}), TN = p({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: !0
}), SN = /* @__PURE__ */ p({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
}), ON = /* @__PURE__ */ p({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), BN = /* @__PURE__ */ p({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
}), PN = /* @__PURE__ */ p({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: !0
}), IN = /* @__PURE__ */ p({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});
function UN({ chain: t, currentChainId: e }) {
  if (!t)
    throw new SI();
  if (e !== t.id)
    throw new TI({ chain: t, currentChainId: e });
}
function NN({ blockNumber: t, chain: e, contract: n }) {
  var s;
  const r = (s = e == null ? void 0 : e.contracts) == null ? void 0 : s[n];
  if (!r)
    throw new x0({
      chain: e,
      contract: { name: n }
    });
  if (t && r.blockCreated && r.blockCreated > t)
    throw new x0({
      blockNumber: t,
      chain: e,
      contract: {
        name: n,
        blockCreated: r.blockCreated
      }
    });
  return r.address;
}
const RN = /* @__PURE__ */ p({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: !0
}), FN = /* @__PURE__ */ p({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: !1
}), MN = /* @__PURE__ */ p({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: !1
}), DN = /* @__PURE__ */ p({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: !0
}), LN = /* @__PURE__ */ p({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
}), HN = /* @__PURE__ */ p({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
}), $N = /* @__PURE__ */ p({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
}), _N = /* @__PURE__ */ p({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
}), GN = /* @__PURE__ */ p({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
}), zN = /* @__PURE__ */ p({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: !1
}), VN = /* @__PURE__ */ p({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: !0
}), jN = /* @__PURE__ */ p({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
}), KN = /* @__PURE__ */ p({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: !0
}), qN = /* @__PURE__ */ p({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: !1
}), WN = /* @__PURE__ */ p({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: !0
}), QN = /* @__PURE__ */ p({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: !1
}), JN = /* @__PURE__ */ p({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: !0
}), ZN = /* @__PURE__ */ p({
  ...q,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: !0
}), XN = /* @__PURE__ */ p({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: !1
}), YN = /* @__PURE__ */ p({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: !1
}), eR = /* @__PURE__ */ p({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
}), tR = /* @__PURE__ */ p({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
}), nR = /* @__PURE__ */ p({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: !0
}), rR = /* @__PURE__ */ p({
  id: 42793,
  name: "Etherlink",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
}), sR = /* @__PURE__ */ p({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: !0
}), aR = /* @__PURE__ */ p({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), iR = /* @__PURE__ */ p({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
}), oR = /* @__PURE__ */ p({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
}), cR = /* @__PURE__ */ p({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
}), lR = /* @__PURE__ */ p({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
}), uR = /* @__PURE__ */ p({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: !1
}), dR = /* @__PURE__ */ p({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
}), fR = /* @__PURE__ */ p({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
}), pR = /* @__PURE__ */ p({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
}), hR = /* @__PURE__ */ p({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: !0
}), mR = /* @__PURE__ */ p({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: !0
}), bR = /* @__PURE__ */ p({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
}), yR = /* @__PURE__ */ p({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
}), gR = /* @__PURE__ */ p({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: !0
}), wR = /* @__PURE__ */ p({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: !0
}), ER = /* @__PURE__ */ p({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: !1
}), xR = /* @__PURE__ */ p({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
}), AR = /* @__PURE__ */ p({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
}), vR = /* @__PURE__ */ p({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: !0
}), kR = /* @__PURE__ */ p({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  },
  blockTime: 800
}), CR = /* @__PURE__ */ p({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
}), TR = /* @__PURE__ */ p({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: !0,
  blockTime: 800
}), SR = /* @__PURE__ */ p({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
}), OR = /* @__PURE__ */ p({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: !0
}), BR = /* @__PURE__ */ p({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: !0
}), PR = /* @__PURE__ */ p({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: !0
}), IR = /* @__PURE__ */ p({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
}), Ri = 1, UR = /* @__PURE__ */ p({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...q.contracts,
    addressManager: {
      [Ri]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [Ri]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [Ri]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [Ri]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [Ri]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: Ri
}), NR = /* @__PURE__ */ p({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: !0
}), Fi = 11155111, RR = /* @__PURE__ */ p({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...q.contracts,
    addressManager: {
      [Fi]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [Fi]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [Fi]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [Fi]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [Fi]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0,
  sourceId: Fi
}), FR = /* @__PURE__ */ p({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
}), MR = /* @__PURE__ */ p({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
}), Zu = 1, DR = /* @__PURE__ */ p({
  ...q,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Zu]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Zu]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [Zu]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: Zu
}), Xu = 17e3, LR = /* @__PURE__ */ p({
  ...q,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [Xu]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Xu]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [Xu]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: Xu
}), HR = 1, $R = /* @__PURE__ */ p({
  ...q,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...q.contracts
  },
  sourceId: HR
}), _R = 11155111, GR = p({
  ...q,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: !0,
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: _R
}), zR = /* @__PURE__ */ p({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
}), VR = /* @__PURE__ */ p({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
}), jR = /* @__PURE__ */ p({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: !1
}), KR = /* @__PURE__ */ p({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: !0
}), Yu = 17e3, qR = p({
  ...q,
  name: "Garnet Testnet",
  testnet: !0,
  id: 17069,
  sourceId: Yu,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Yu]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [Yu]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [Yu]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
}), WR = /* @__PURE__ */ p({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
}), QR = /* @__PURE__ */ p({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: !1
}), JR = /* @__PURE__ */ p({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), ZR = /* @__PURE__ */ p({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: !1
}), XR = /* @__PURE__ */ p({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
}), YR = /* @__PURE__ */ p({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: !0
}), eF = /* @__PURE__ */ p({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
}), tF = /* @__PURE__ */ p({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: !0
}), nF = /* @__PURE__ */ p({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: !1
}), rF = /* @__PURE__ */ p({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: !1
}), sF = /* @__PURE__ */ p({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), aF = /* @__PURE__ */ p({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
}), iF = /* @__PURE__ */ p({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
}), oF = /* @__PURE__ */ p({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: !1
}), cF = /* @__PURE__ */ p({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: !0
}), lF = /* @__PURE__ */ p({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
}), uF = /* @__PURE__ */ p({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0
}), dF = /* @__PURE__ */ p({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
}), fF = /* @__PURE__ */ p({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
}), pF = /* @__PURE__ */ p({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), hF = /* @__PURE__ */ p({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
}), mF = /* @__PURE__ */ p({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), bF = /* @__PURE__ */ p({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://hashkeychain-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkeychain-testnet-explorer.alt.technology"
    }
  },
  testnet: !0
}), yF = /* @__PURE__ */ p({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: !0
}), gF = /* @__PURE__ */ p({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: !1
}), wF = /* @__PURE__ */ p({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: !0
}), EF = /* @__PURE__ */ p({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: !0
}), xF = /* @__PURE__ */ p({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: !1
}), AF = /* @__PURE__ */ p({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: !1
}), vF = /* @__PURE__ */ p({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: !0
}), kF = /* @__PURE__ */ p({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: !0
}), CF = /* @__PURE__ */ p({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: !0
}), TF = /* @__PURE__ */ p({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: !1
}), SF = 42161, OF = /* @__PURE__ */ p({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: SF
}), BF = 421614, PF = /* @__PURE__ */ p({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: BF
}), IF = /* @__PURE__ */ p({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
}), UF = /* @__PURE__ */ p({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), NF = /* @__PURE__ */ p({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: !1
}), RF = /* @__PURE__ */ p({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: !0
}), FF = /* @__PURE__ */ p({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: !1
}), MF = /* @__PURE__ */ p({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
}), DF = /* @__PURE__ */ p({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: !0
}), LF = /* @__PURE__ */ p({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
}), HF = /* @__PURE__ */ p({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
}), $F = /* @__PURE__ */ p({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: !0
}), ed = 1, _F = /* @__PURE__ */ p({
  ...q,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...q.contracts,
    disputeGameFactory: {
      [ed]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [ed]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [ed]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: !1,
  sourceId: ed
}), td = 11155111, GF = /* @__PURE__ */ p({
  ...q,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [td]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [td]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [td]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: !0,
  sourceId: td
}), zF = /* @__PURE__ */ p({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
}), VF = /* @__PURE__ */ p({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: !0
}), jF = /* @__PURE__ */ p({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
}), KF = /* @__PURE__ */ p({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: !0
}), qF = /* @__PURE__ */ p({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
}), WF = /* @__PURE__ */ p({
  id: 8899,
  name: "JB Chain",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: !1
}), QF = /* @__PURE__ */ p({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: !0
}), JF = /* @__PURE__ */ p({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
}), ZF = /* @__PURE__ */ p({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
}), XF = /* @__PURE__ */ p({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
}), YF = /* @__PURE__ */ p({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
}), eM = /* @__PURE__ */ p({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
}), tM = /* @__PURE__ */ p({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
}), nM = /* @__PURE__ */ p({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
}), rM = /* @__PURE__ */ p({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
}), sM = /* @__PURE__ */ p({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
}), aM = /* @__PURE__ */ p({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
}), iM = /* @__PURE__ */ p({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: !0
}), oM = /* @__PURE__ */ p({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
}), cM = /* @__PURE__ */ p({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
}), lM = /* @__PURE__ */ p({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: !1
}), uM = /* @__PURE__ */ p({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), dM = /* @__PURE__ */ p({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: !0
}), fM = /* @__PURE__ */ p({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: !1
}), pM = /* @__PURE__ */ p({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: !1
}), hM = /* @__PURE__ */ p({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: !0
}), mM = /* @__PURE__ */ p({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: !1
}), bM = /* @__PURE__ */ p({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: !1
}), yM = /* @__PURE__ */ p({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), gM = /* @__PURE__ */ p({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
}), wM = /* @__PURE__ */ p({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), EM = /* @__PURE__ */ p({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: !0
}), xM = p({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: !0
}), AM = /* @__PURE__ */ p({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: !1
}), vM = /* @__PURE__ */ p({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: !0
}), kM = /* @__PURE__ */ p({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: !1
}), CM = /* @__PURE__ */ p({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: !0
}), TM = /* @__PURE__ */ p({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: !1
}), SM = /* @__PURE__ */ p({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
}), OM = /* @__PURE__ */ p({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: !0
}), BM = /* @__PURE__ */ p({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: !0
}), PM = /* @__PURE__ */ p({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: !0
}), IM = /* @__PURE__ */ p({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: !1
});
function ht(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
class ca extends D {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class Dh extends D {
  constructor({ docsPath: e, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: e,
      metaMessages: n,
      name: "AccountTypeNotSupportedError"
    });
  }
}
const UM = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, NM = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, RM = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function bc(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new qM(t.type);
  return `${t.name}(${Oy(t.inputs, { includeName: e })})`;
}
function Oy(t, { includeName: e = !1 } = {}) {
  return t ? t.map((n) => FM(n, { includeName: e })).join(e ? ", " : ",") : "";
}
function FM(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${Oy(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
class MM extends D {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class Pw extends D {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class DM extends D {
  constructor({ data: e, params: n, size: r }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${Oy(n, { includeName: !0 })})`,
        `Data:   ${e} (${r} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = n, this.size = r;
  }
}
class By extends D {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class LM extends D {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super([
      `ABI encoding array length mismatch for type ${r}.`,
      `Expected length: ${e}`,
      `Given length: ${n}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class HM extends D {
  constructor({ expectedSize: e, value: n }) {
    super(`Size of bytes "${n}" (bytes${je(n)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class $M extends D {
  constructor({ expectedLength: e, givenLength: n }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${n}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class SZ extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,
      "Cannot encode error result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the inputs exist on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorInputsNotFoundError"
    });
  }
}
class OZ extends D {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Error ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorNotFoundError"
    });
  }
}
class Pv extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class uf extends D {
  constructor(e, { docsPath: n } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class _M extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Function "${e}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class BZ extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Encoded function signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: n,
      name: "AbiFunctionSignatureNotFoundError"
    });
  }
}
class GM extends D {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${bc(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${bc(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class zM extends D {
  constructor({ expectedSize: e, givenSize: n }) {
    super(`Expected bytes${e}, got bytes${n}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class VM extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiEncodingType" });
  }
}
class jM extends D {
  constructor(e, { docsPath: n }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: n, name: "InvalidAbiDecodingType" });
  }
}
class KM extends D {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class qM extends D {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
const WM = (t) => qe(Xi(t));
function QM(t) {
  return WM(t);
}
function JM(t) {
  let e = !0, n = "", r = 0, s = "", a = !1;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    if (["(", ")", ","].includes(o) && (e = !0), o === "(" && r++, o === ")" && r--, !!e) {
      if (r === 0) {
        if (o === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += o, o === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (o === " ") {
        t[i - 1] !== "," && n !== "," && n !== ",(" && (n = "", e = !1);
        continue;
      }
      s += o, n += o;
    }
  }
  if (!a)
    throw new D("Unable to normalize signature.");
  return s;
}
const ZM = (t) => {
  const e = typeof t == "string" ? t : Kd(t);
  return JM(e);
};
function Iv(t) {
  return QM(ZM(t));
}
const Py = (t) => _l(Iv(t), 0, 4);
function XM(t, e = {}) {
  typeof e.size < "u" && Ir(t, { size: e.size });
  const n = Pt(t, e);
  return Te(n, e);
}
function YM(t, e = {}) {
  let n = t;
  if (typeof e.size < "u" && (Ir(n, { size: e.size }), n = Sr(n)), n.length > 1 || n[0] > 1)
    throw new Q9(n);
  return !!n[0];
}
function ns(t, e = {}) {
  typeof e.size < "u" && Ir(t, { size: e.size });
  const n = Pt(t, e);
  return er(n, e);
}
function eD(t, e = {}) {
  let n = t;
  return typeof e.size < "u" && (Ir(n, { size: e.size }), n = Sr(n, { dir: "right" })), new TextDecoder().decode(n);
}
const tD = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, Uv = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function Ws(t, e) {
  if (t.length !== e.length)
    throw new $M({
      expectedLength: t.length,
      givenLength: e.length
    });
  const n = nD({
    params: t,
    values: e
  }), r = Uy(n);
  return r.length === 0 ? "0x" : r;
}
function nD({ params: t, values: e }) {
  const n = [];
  for (let r = 0; r < t.length; r++)
    n.push(Iy({ param: t[r], value: e[r] }));
  return n;
}
function Iy({ param: t, value: e }) {
  const n = Ny(t.type);
  if (n) {
    const [r, s] = n;
    return sD(e, { length: r, param: { ...t, type: s } });
  }
  if (t.type === "tuple")
    return lD(e, {
      param: t
    });
  if (t.type === "address")
    return rD(e);
  if (t.type === "bool")
    return iD(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const r = t.type.startsWith("int"), [, , s = "256"] = Uv.exec(t.type) ?? [];
    return oD(e, {
      signed: r,
      size: Number(s)
    });
  }
  if (t.type.startsWith("bytes"))
    return aD(e, { param: t });
  if (t.type === "string")
    return cD(e);
  throw new VM(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Uy(t) {
  let e = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? e += 32 : e += je(o);
  }
  const n = [], r = [];
  let s = 0;
  for (let a = 0; a < t.length; a++) {
    const { dynamic: i, encoded: o } = t[a];
    i ? (n.push(W(e + s, { size: 32 })), r.push(o), s += je(o)) : n.push(o);
  }
  return Ct([...n, ...r]);
}
function rD(t) {
  if (!He(t))
    throw new Je({ address: t });
  return { dynamic: !1, encoded: qs(t.toLowerCase()) };
}
function sD(t, { length: e, param: n }) {
  const r = e === null;
  if (!Array.isArray(t))
    throw new KM(t);
  if (!r && t.length !== e)
    throw new LM({
      expectedLength: e,
      givenLength: t.length,
      type: `${n.type}[${e}]`
    });
  let s = !1;
  const a = [];
  for (let i = 0; i < t.length; i++) {
    const o = Iy({ param: n, value: t[i] });
    o.dynamic && (s = !0), a.push(o);
  }
  if (r || s) {
    const i = Uy(a);
    if (r) {
      const o = W(a.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: a.length > 0 ? Ct([o, i]) : o
      };
    }
    if (s)
      return { dynamic: !0, encoded: i };
  }
  return {
    dynamic: !1,
    encoded: Ct(a.map(({ encoded: i }) => i))
  };
}
function aD(t, { param: e }) {
  const [, n] = e.type.split("bytes"), r = je(t);
  if (!n) {
    let s = t;
    return r % 32 !== 0 && (s = qs(s, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Ct([qs(W(r, { size: 32 })), s])
    };
  }
  if (r !== Number.parseInt(n))
    throw new HM({
      expectedSize: Number.parseInt(n),
      value: t
    });
  return { dynamic: !1, encoded: qs(t, { dir: "right" }) };
}
function iD(t) {
  if (typeof t != "boolean")
    throw new D(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: qs(ZA(t)) };
}
function oD(t, { signed: e, size: n = 256 }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n, s = e ? -r - 1n : 0n;
    if (t > r || t < s)
      throw new WA({
        max: r.toString(),
        min: s.toString(),
        signed: e,
        size: n / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: W(t, {
      size: 32,
      signed: e
    })
  };
}
function cD(t) {
  const e = $l(t), n = Math.ceil(je(e) / 32), r = [];
  for (let s = 0; s < n; s++)
    r.push(qs(_l(e, s * 32, (s + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Ct([
      qs(W(je(e), { size: 32 })),
      ...r
    ])
  };
}
function lD(t, { param: e }) {
  let n = !1;
  const r = [];
  for (let s = 0; s < e.components.length; s++) {
    const a = e.components[s], i = Array.isArray(t) ? s : a.name, o = Iy({
      param: a,
      value: t[i]
    });
    r.push(o), o.dynamic && (n = !0);
  }
  return {
    dynamic: n,
    encoded: n ? Uy(r) : Ct(r.map(({ encoded: s }) => s))
  };
}
function Ny(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
function Nv(t, e) {
  const n = typeof e == "string" ? tn(e) : e, r = Ey(n);
  if (je(n) === 0 && t.length > 0)
    throw new By();
  if (je(e) && je(e) < 32)
    throw new DM({
      data: typeof e == "string" ? e : Pt(e),
      params: t,
      size: je(e)
    });
  let s = 0;
  const a = [];
  for (let i = 0; i < t.length; ++i) {
    const o = t[i];
    r.setPosition(s);
    const [c, u] = Yi(r, o, {
      staticPosition: 0
    });
    s += u, a.push(c);
  }
  return a;
}
function Yi(t, e, { staticPosition: n }) {
  const r = Ny(e.type);
  if (r) {
    const [s, a] = r;
    return dD(t, { ...e, type: a }, { length: s, staticPosition: n });
  }
  if (e.type === "tuple")
    return mD(t, e, { staticPosition: n });
  if (e.type === "address")
    return uD(t);
  if (e.type === "bool")
    return fD(t);
  if (e.type.startsWith("bytes"))
    return pD(t, e, { staticPosition: n });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return hD(t, e);
  if (e.type === "string")
    return bD(t, { staticPosition: n });
  throw new jM(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const Iw = 32, U0 = 32;
function uD(t) {
  const e = t.readBytes(32);
  return [fp(Pt(wv(e, -20))), 32];
}
function dD(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const i = ns(t.readBytes(U0)), o = r + i, c = o + Iw;
    t.setPosition(o);
    const u = ns(t.readBytes(Iw)), l = Gl(e);
    let d = 0;
    const f = [];
    for (let h = 0; h < u; ++h) {
      t.setPosition(c + (l ? h * 32 : d));
      const [y, b] = Yi(t, e, {
        staticPosition: c
      });
      d += b, f.push(y);
    }
    return t.setPosition(r + 32), [f, 32];
  }
  if (Gl(e)) {
    const i = ns(t.readBytes(U0)), o = r + i, c = [];
    for (let u = 0; u < n; ++u) {
      t.setPosition(o + u * 32);
      const [l] = Yi(t, e, {
        staticPosition: o
      });
      c.push(l);
    }
    return t.setPosition(r + 32), [c, 32];
  }
  let s = 0;
  const a = [];
  for (let i = 0; i < n; ++i) {
    const [o, c] = Yi(t, e, {
      staticPosition: r + s
    });
    s += c, a.push(o);
  }
  return [a, s];
}
function fD(t) {
  return [YM(t.readBytes(32), { size: 32 }), 32];
}
function pD(t, e, { staticPosition: n }) {
  const [r, s] = e.type.split("bytes");
  if (!s) {
    const i = ns(t.readBytes(32));
    t.setPosition(n + i);
    const o = ns(t.readBytes(32));
    if (o === 0)
      return t.setPosition(n + 32), ["0x", 32];
    const c = t.readBytes(o);
    return t.setPosition(n + 32), [Pt(c), 32];
  }
  return [Pt(t.readBytes(Number.parseInt(s), 32)), 32];
}
function hD(t, e) {
  const n = e.type.startsWith("int"), r = Number.parseInt(e.type.split("int")[1] || "256"), s = t.readBytes(32);
  return [
    r > 48 ? XM(s, { signed: n }) : ns(s, { signed: n }),
    32
  ];
}
function mD(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: i }) => !i), s = r ? [] : {};
  let a = 0;
  if (Gl(e)) {
    const i = ns(t.readBytes(U0)), o = n + i;
    for (let c = 0; c < e.components.length; ++c) {
      const u = e.components[c];
      t.setPosition(o + a);
      const [l, d] = Yi(t, u, {
        staticPosition: o
      });
      a += d, s[r ? c : u == null ? void 0 : u.name] = l;
    }
    return t.setPosition(n + 32), [s, 32];
  }
  for (let i = 0; i < e.components.length; ++i) {
    const o = e.components[i], [c, u] = Yi(t, o, {
      staticPosition: n
    });
    s[r ? i : o == null ? void 0 : o.name] = c, a += u;
  }
  return [s, a];
}
function bD(t, { staticPosition: e }) {
  const n = ns(t.readBytes(32)), r = e + n;
  t.setPosition(r);
  const s = ns(t.readBytes(32));
  if (s === 0)
    return t.setPosition(e + 32), ["", 32];
  const a = t.readBytes(s, 32), i = eD(Sr(a));
  return t.setPosition(e + 32), [i, 32];
}
function Gl(t) {
  var r;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (r = t.components) == null ? void 0 : r.some(Gl);
  const n = Ny(t.type);
  return !!(n && Gl({ ...t, type: n[1] }));
}
function Rv(t) {
  const { abi: e, data: n } = t, r = _l(n, 0, 4);
  if (r === "0x")
    throw new By();
  const a = [...e || [], NM, RM].find((i) => i.type === "error" && r === Py(bc(i)));
  if (!a)
    throw new Pv(r, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: a,
    args: "inputs" in a && a.inputs && a.inputs.length > 0 ? Nv(a.inputs, _l(n, 4)) : void 0,
    errorName: a.name
  };
}
const Pi = (t, e, n) => JSON.stringify(t, (r, s) => typeof s == "bigint" ? s.toString() : s, n);
function Fv({ abiItem: t, args: e, includeFunctionName: n = !0, includeName: r = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${n ? t.name : ""}(${t.inputs.map((s, a) => `${r && s.name ? `${s.name}: ` : ""}${typeof e[a] == "object" ? Pi(e[a]) : e[a]}`).join(", ")})`;
}
const yD = Iv;
function Ry(t) {
  const { abi: e, args: n = [], name: r } = t, s = sa(r, { strict: !1 }), a = e.filter((o) => s ? o.type === "function" ? Py(o) === r : o.type === "event" ? yD(o) === r : !1 : "name" in o && o.name === r);
  if (a.length === 0)
    return;
  if (a.length === 1)
    return a[0];
  let i;
  for (const o of a) {
    if (!("inputs" in o))
      continue;
    if (!n || n.length === 0) {
      if (!o.inputs || o.inputs.length === 0)
        return o;
      continue;
    }
    if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== n.length)
      continue;
    if (n.every((u, l) => {
      const d = "inputs" in o && o.inputs[l];
      return d ? N0(u, d) : !1;
    })) {
      if (i && "inputs" in i && i.inputs) {
        const u = Mv(o.inputs, i.inputs, n);
        if (u)
          throw new GM({
            abiItem: o,
            type: u[0]
          }, {
            abiItem: i,
            type: u[1]
          });
      }
      i = o;
    }
  }
  return i || a[0];
}
function N0(t, e) {
  const n = typeof t, r = e.type;
  switch (r) {
    case "address":
      return He(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e ? Object.values(e.components).every((s, a) => N0(Object.values(t)[a], s)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(t) && t.every((s) => N0(s, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function Mv(t, e, n) {
  for (const r in t) {
    const s = t[r], a = e[r];
    if (s.type === "tuple" && a.type === "tuple" && "components" in s && "components" in a)
      return Mv(s.components, a.components, n[r]);
    const i = [s.type, a.type];
    if (i.includes("address") && i.includes("bytes20") ? !0 : i.includes("address") && i.includes("string") ? He(n[r], { strict: !1 }) : i.includes("address") && i.includes("bytes") ? He(n[r], { strict: !1 }) : !1)
      return i;
  }
}
class gD extends D {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class wD extends D {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function Uw(t) {
  return t.reduce((e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`, "");
}
function ED(t) {
  return t.reduce((e, { address: n, ...r }) => {
    let s = `${e}    ${n}:
`;
    return r.nonce && (s += `      nonce: ${r.nonce}
`), r.balance && (s += `      balance: ${r.balance}
`), r.code && (s += `      code: ${r.code}
`), r.state && (s += `      state:
`, s += Uw(r.state)), r.stateDiff && (s += `      stateDiff:
`, s += Uw(r.stateDiff)), s;
  }, `  State Override:
`).slice(0, -1);
}
const xD = (t) => t, Dv = (t) => t;
class AD extends D {
  constructor(e, { account: n, docsPath: r, chain: s, data: a, gas: i, gasPrice: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, to: d, value: f, stateOverride: h }) {
    var g;
    const y = n ? ht(n) : void 0;
    let b = Ac({
      from: y == null ? void 0 : y.address,
      to: d,
      value: typeof f < "u" && `${xy(f)} ${((g = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : g.symbol) || "ETH"}`,
      data: a,
      gas: i,
      gasPrice: typeof o < "u" && `${Tt(o)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Tt(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Tt(u)} gwei`,
      nonce: l
    });
    h && (b += `
${ED(h)}`), super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Raw Call Arguments:",
        b
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class Lv extends D {
  constructor(e, { abi: n, args: r, contractAddress: s, docsPath: a, functionName: i, sender: o }) {
    const c = Ry({ abi: n, args: r, name: i }), u = c ? Fv({
      abiItem: c,
      args: r,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, l = c ? bc(c, { includeName: !0 }) : void 0, d = Ac({
      address: s && xD(s),
      function: l,
      args: u && u !== "()" && `${[...Array((i == null ? void 0 : i.length) ?? 0).keys()].map(() => " ").join("")}${u}`,
      sender: o
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${i}".`, {
      cause: e,
      docsPath: a,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        d && "Contract Call:",
        d
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = n, this.args = r, this.cause = e, this.contractAddress = s, this.functionName = i, this.sender = o;
  }
}
class Hv extends D {
  constructor({ abi: e, data: n, functionName: r, message: s }) {
    let a, i, o, c;
    if (n && n !== "0x")
      try {
        i = Rv({ abi: e, data: n });
        const { abiItem: l, errorName: d, args: f } = i;
        if (d === "Error")
          c = f[0];
        else if (d === "Panic") {
          const [h] = f;
          c = UM[h];
        } else {
          const h = l ? bc(l, { includeName: !0 }) : void 0, y = l && f ? Fv({
            abiItem: l,
            args: f,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          o = [
            h ? `Error: ${h}` : "",
            y && y !== "()" ? `       ${[...Array((d == null ? void 0 : d.length) ?? 0).keys()].map(() => " ").join("")}${y}` : ""
          ];
        }
      } catch (l) {
        a = l;
      }
    else s && (c = s);
    let u;
    a instanceof Pv && (u = a.signature, o = [
      `Unable to decode signature "${u}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`
    ]), super(c && c !== "execution reverted" || u ? [
      `The contract function "${r}" reverted with the following ${u ? "signature" : "reason"}:`,
      c || u
    ].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: a,
      metaMessages: o,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "raw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = i, this.raw = n, this.reason = c, this.signature = u;
  }
}
class $v extends D {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class vD extends D {
  constructor({ factory: e }) {
    super(`Deployment for counterfactual contract call failed${e ? ` for factory "${e}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class _v extends D {
  constructor({ data: e, message: n }) {
    super(n || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class PZ extends D {
  constructor({ body: e, cause: n, details: r, headers: s, status: a, url: i }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        a && `Status: ${a}`,
        `URL: ${Dv(i)}`,
        e && `Request body: ${Pi(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = s, this.status = a, this.url = i;
  }
}
class Gv extends D {
  constructor({ body: e, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${Dv(r)}`, `Request body: ${Pi(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code, this.data = n.data;
  }
}
const kD = -1;
class zv extends D {
  constructor(e, { code: n, docsPath: r, metaMessages: s, name: a, shortMessage: i }) {
    super(i, {
      cause: e,
      docsPath: r,
      metaMessages: s || (e == null ? void 0 : e.metaMessages),
      name: a || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = a || e.name, this.code = e instanceof Gv ? e.code : n ?? kD;
  }
}
class Vv extends zv {
  constructor(e, n) {
    super(e, n), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n.data;
  }
}
class pp extends zv {
  constructor(e) {
    super(e, {
      code: pp.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(pp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class hp extends Vv {
  constructor(e) {
    super(e, {
      code: hp.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage: "This Wallet does not support a capability that was not marked as optional."
    });
  }
}
Object.defineProperty(hp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5700
});
class mp extends Vv {
  constructor(e) {
    super(e, {
      code: mp.code,
      name: "AtomicityNotSupportedError",
      shortMessage: "The wallet does not support atomic execution but the request requires it."
    });
  }
}
Object.defineProperty(mp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5760
});
function Fy(t, e) {
  const n = (t.details || "").toLowerCase(), r = t instanceof D ? t.walk((s) => (s == null ? void 0 : s.code) === zi.code) : t;
  return r instanceof D ? new zi({
    cause: t,
    message: r.details
  }) : zi.nodeMessage.test(n) ? new zi({
    cause: t,
    message: t.details
  }) : aa.nodeMessage.test(n) ? new aa({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : A0.nodeMessage.test(n) ? new A0({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : v0.nodeMessage.test(n) ? new v0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : k0.nodeMessage.test(n) ? new k0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : C0.nodeMessage.test(n) ? new C0({ cause: t, nonce: e == null ? void 0 : e.nonce }) : T0.nodeMessage.test(n) ? new T0({ cause: t }) : S0.nodeMessage.test(n) ? new S0({ cause: t, gas: e == null ? void 0 : e.gas }) : O0.nodeMessage.test(n) ? new O0({ cause: t, gas: e == null ? void 0 : e.gas }) : B0.nodeMessage.test(n) ? new B0({ cause: t }) : mc.nodeMessage.test(n) ? new mc({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new up({
    cause: t
  });
}
function jv(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = Fy(t, n);
    return s instanceof up ? t : s;
  })();
  return new AD(r, {
    docsPath: e,
    ...n
  });
}
function bp(t, { format: e }) {
  if (!e)
    return {};
  const n = {};
  function r(a) {
    const i = Object.keys(a);
    for (const o of i)
      o in t && (n[o] = t[o]), a[o] && typeof a[o] == "object" && !Array.isArray(a[o]) && r(a[o]);
  }
  const s = e(t || {});
  return r(s), n;
}
function Au(t) {
  const { account: e, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: s, to: a } = t, i = e ? ht(e) : void 0;
  if (i && !He(i.address))
    throw new Je({ address: i.address });
  if (a && !He(a))
    throw new Je({ address: a });
  if (typeof n < "u" && (typeof r < "u" || typeof s < "u"))
    throw new mI();
  if (r && r > Eu)
    throw new aa({ maxFeePerGas: r });
  if (s && r && s > r)
    throw new mc({ maxFeePerGas: r, maxPriorityFeePerGas: s });
}
async function CD(t, e) {
  var s, a, i;
  const { account: n = t.account } = e;
  if (!n)
    throw new ca();
  const r = ht(n);
  try {
    const { accessList: o, blockNumber: c, blockTag: u, data: l, gas: d, gasPrice: f, maxFeePerGas: h, maxPriorityFeePerGas: y, nonce: b, to: g, value: w, ...v } = e, P = (typeof c == "bigint" ? W(c) : void 0) || u;
    Au(e);
    const x = (i = (a = (s = t.chain) == null ? void 0 : s.formatters) == null ? void 0 : a.transactionRequest) == null ? void 0 : i.format, I = (x || wu)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...bp(v, { format: x }),
      from: r == null ? void 0 : r.address,
      accessList: o,
      data: l,
      gas: d,
      gasPrice: f,
      maxFeePerGas: h,
      maxPriorityFeePerGas: y,
      nonce: b,
      to: g,
      value: w
    }), { baseFeePerGas: T, gasLimit: C, priorityFeePerGas: N } = await t.request({
      method: "linea_estimateGas",
      params: P ? [I, P] : [I]
    });
    return {
      baseFeePerGas: BigInt(T),
      gasLimit: BigInt(C),
      priorityFeePerGas: BigInt(N)
    };
  } catch (o) {
    throw jv(o, {
      ...e,
      account: r,
      chain: t.chain
    });
  }
}
const My = {
  fees: {
    estimateFeesPerGas: Nw,
    async maxPriorityFeePerGas({ block: t, client: e, request: n }) {
      const r = await Nw({
        block: t,
        client: e,
        multiply: (s) => s,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function Nw({ client: t, multiply: e, request: n, type: r }) {
  try {
    const s = await CD(t, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: a } = s, o = e(BigInt(s.baseFeePerGas)) + a;
    return r === "legacy" ? { gasPrice: o } : {
      maxFeePerGas: o,
      maxPriorityFeePerGas: a
    };
  } catch {
    return null;
  }
}
const TD = /* @__PURE__ */ p({
  ...My,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x3aA974fb3f8C1E02796048BDCdeD79e9D53a6965",
      blockCreated: 6683e3
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !1
}), SD = /* @__PURE__ */ p({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), OD = /* @__PURE__ */ p({
  ...My,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x72560a31B3DAEE82B984a7F51c6b3b1bb7CC9F50",
      blockCreated: 2395255
    }
  },
  ensTlds: [".linea.eth"],
  testnet: !0
}), BD = /* @__PURE__ */ p({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), nd = 1, PD = /* @__PURE__ */ p({
  ...q,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [nd]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [nd]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [nd]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: nd
}), rd = 11155111, ID = /* @__PURE__ */ p({
  ...q,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [rd]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [rd]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [rd]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: !0,
  sourceId: rd
}), UD = /* @__PURE__ */ p({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
}), ND = /* @__PURE__ */ p({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: !1
}), RD = /* @__PURE__ */ p({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
}), FD = /* @__PURE__ */ p({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: !0
}), MD = /* @__PURE__ */ p({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: !1
}), DD = /* @__PURE__ */ p({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: !0
}), LD = /* @__PURE__ */ p({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: !1
}), HD = /* @__PURE__ */ p({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: !0
}), $D = /* @__PURE__ */ p({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
}), _D = /* @__PURE__ */ p({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
}), ml = /* @__PURE__ */ p({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), GD = /* @__PURE__ */ p({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: !0
}), zD = /* @__PURE__ */ p({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
}), VD = /* @__PURE__ */ p({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: !0
}), jD = /* @__PURE__ */ p({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: !0
}), KD = /* @__PURE__ */ p({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
}), qD = /* @__PURE__ */ p({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: !0
}), WD = /* @__PURE__ */ p({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: !0
}), QD = /* @__PURE__ */ p({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: !1
}), JD = /* @__PURE__ */ p({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
}), ZD = /* @__PURE__ */ p({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: !0
}), XD = /* @__PURE__ */ p({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: !1
}), YD = /* @__PURE__ */ p({
  id: 6342,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: !0
}), eL = /* @__PURE__ */ p({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: !0
}), tL = /* @__PURE__ */ p({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
}), nL = /* @__PURE__ */ p({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
}), rL = /* @__PURE__ */ p({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
}), sL = /* @__PURE__ */ p({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: !0
}), aL = /* @__PURE__ */ p({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
}), iL = /* @__PURE__ */ p({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: !0
}), oL = /* @__PURE__ */ p({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: !1
}), sd = 1, cL = /* @__PURE__ */ p({
  ...q,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [sd]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [sd]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [sd]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: sd
}), lL = /* @__PURE__ */ p({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
}), uL = /* @__PURE__ */ p({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
}), dL = /* @__PURE__ */ p({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
}), fL = /* @__PURE__ */ p({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
}), pL = /* @__PURE__ */ p({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
}), hL = /* @__PURE__ */ p({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
}), mL = /* @__PURE__ */ p({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: !0
}), bL = /* @__PURE__ */ p({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: !1
}), yL = /* @__PURE__ */ p({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: !0
}), gL = /* @__PURE__ */ p({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: !0
}), ad = 1, wL = /* @__PURE__ */ p({
  ...q,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [ad]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [ad]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [ad]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: ad
}), id = 11155111, EL = /* @__PURE__ */ p({
  ...q,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [id]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [id]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [id]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: !0,
  sourceId: id
}), xL = /* @__PURE__ */ p({
  id: 10143,
  name: "Monad Testnet",
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: !0
}), AL = /* @__PURE__ */ p({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: !0
}), vL = /* @__PURE__ */ p({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: !1
}), kL = /* @__PURE__ */ p({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
}), CL = /* @__PURE__ */ p({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: !1
}), TL = /* @__PURE__ */ p({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3654913
    }
  },
  testnet: !1
}), SL = /* @__PURE__ */ p({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: !0
}), OL = /* @__PURE__ */ p({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: !0
}), BL = /* @__PURE__ */ p({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: !1
}), PL = /* @__PURE__ */ p({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
}), IL = /* @__PURE__ */ p({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: !1
}), UL = /* @__PURE__ */ p({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: !0
}), NL = /* @__PURE__ */ p({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: !0
}), RL = /* @__PURE__ */ p({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: !1
}), FL = /* @__PURE__ */ p({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: !1
}), ML = /* @__PURE__ */ p({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: !0
}), DL = /* @__PURE__ */ p({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: !1
}), LL = /* @__PURE__ */ p({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
}), HL = /* @__PURE__ */ p({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
}), $L = /* @__PURE__ */ p({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
}), _L = /* @__PURE__ */ p({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: !0
}), GL = /* @__PURE__ */ p({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
}), zL = /* @__PURE__ */ p({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: !0
}), VL = /* @__PURE__ */ p({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
}), jL = /* @__PURE__ */ p({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: !1
}), KL = p({
  id: 166,
  name: "Omni",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.omni.network"],
      webSocket: ["wss://mainnet.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "OmniScan",
      url: "https://omniscan.network"
    }
  },
  testnet: !1
}), qL = /* @__PURE__ */ p({
  id: 164,
  name: "Omni Omega",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://omega.omni.network"],
      webSocket: ["wss://omega.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Omega OmniScan",
      url: "https://omega.omniscan.network/"
    }
  },
  testnet: !0
}), WL = /* @__PURE__ */ p({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: !1
}), QL = /* @__PURE__ */ p({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
}), od = 56, JL = /* @__PURE__ */ p({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [od]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [od]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [od]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: od
}), cd = 97, ZL = /* @__PURE__ */ p({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [cd]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [cd]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [cd]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: !0,
  sourceId: cd
}), $c = 1, bl = /* @__PURE__ */ p({
  ...q,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [$c]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [$c]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [$c]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [$c]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: $c
}), ld = 5, XL = /* @__PURE__ */ p({
  ...q,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [ld]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [ld]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [ld]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: !0,
  sourceId: ld
}), _c = 11155111, YL = /* @__PURE__ */ p({
  ...q,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [_c]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [_c]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [_c]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [_c]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: !0,
  sourceId: _c
}), eH = /* @__PURE__ */ p({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: !1
}), tH = /* @__PURE__ */ p({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: !0
}), nH = /* @__PURE__ */ p({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: !1
}), rH = /* @__PURE__ */ p({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: !0
}), sH = /* @__PURE__ */ p({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
}), aH = /* @__PURE__ */ p({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
}), iH = /* @__PURE__ */ p({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: !0
}), oH = /* @__PURE__ */ p({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://peaq-rpc.publicnode.com",
        "https://peaq.api.onfinality.io/public",
        "https://peaq-rpc.dwellir.com",
        "https://evm.peaq.network"
      ],
      webSocket: [
        "wss://peaq-rpc.publicnode.com",
        "wss://peaq.api.onfinality.io/public",
        "wss://peaq-rpc.dwellir.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
}), ud = 1, cH = /* @__PURE__ */ p({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [ud]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [ud]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [ud]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: Sy,
  sourceId: ud
}), dd = 11155111, lH = /* @__PURE__ */ p({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [dd]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [dd]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [dd]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: Sy,
  sourceId: dd,
  testnet: !0
}), uH = /* @__PURE__ */ p({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
}), dH = /* @__PURE__ */ p({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: !1
}), fH = /* @__PURE__ */ p({
  ...hn,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: !0
}), pH = /* @__PURE__ */ p({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
}), hH = 1, mH = /* @__PURE__ */ p({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: hH
}), bH = 11155111, yH = /* @__PURE__ */ p({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: !0,
  sourceId: bH
}), gH = 1, wH = /* @__PURE__ */ p({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: gH
}), EH = 11155111, xH = /* @__PURE__ */ p({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: !0,
  sourceId: EH
}), AH = 11155111, vH = /* @__PURE__ */ p({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: !0,
  sourceId: AH
}), kH = /* @__PURE__ */ p({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: !0
}), Rd = /* @__PURE__ */ p({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
}), CH = /* @__PURE__ */ p({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: !0
}), TH = /* @__PURE__ */ p({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
}), SH = /* @__PURE__ */ p({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
}), OH = /* @__PURE__ */ p({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
}), BH = /* @__PURE__ */ p({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
}), PH = /* @__PURE__ */ p({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: !1,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), IH = /* @__PURE__ */ p({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
}), UH = /* @__PURE__ */ p({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: !0
}), NH = /* @__PURE__ */ p({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: !1,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), RH = /* @__PURE__ */ p({
  id: 943,
  name: "PulseChain V4",
  testnet: !0,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), FH = /* @__PURE__ */ p({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: !0
}), Rw = 11155111, MH = p({
  ...q,
  name: "Pyrope Testnet",
  testnet: !0,
  id: 695569,
  sourceId: Rw,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...q.contracts,
    l1StandardBridge: {
      [Rw]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
}), DH = /* @__PURE__ */ p({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: !1
}), LH = /* @__PURE__ */ p({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
}), HH = /* @__PURE__ */ p({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: !0
}), $H = /* @__PURE__ */ p({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
}), _H = /* @__PURE__ */ p({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: !1
}), GH = /* @__PURE__ */ p({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: !0
}), fd = 1, zH = p({
  ...q,
  name: "Redstone",
  id: 690,
  sourceId: fd,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [fd]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [fd]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [fd]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
}), VH = /* @__PURE__ */ p({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: !1
}), jH = /* @__PURE__ */ p({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: !1
}), KH = /* @__PURE__ */ p({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: !0
}), qH = /* @__PURE__ */ p({
  id: 11155931,
  name: "RISE Testnet",
  nativeCurrency: { name: "RISE Testnet Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.riselabs.xyz"],
      webSocket: ["wss://testnet.riselabs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.testnet.riselabs.xyz/",
      apiUrl: "https://explorer.testnet.riselabs.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  },
  testnet: !0
}), WH = /* @__PURE__ */ p({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), QH = /* @__PURE__ */ p({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
}), JH = /* @__PURE__ */ p({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
}), ZH = /* @__PURE__ */ p({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
}), XH = /* @__PURE__ */ p({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
}), YH = /* @__PURE__ */ p({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: !0
}), e$ = /* @__PURE__ */ p({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
}), t$ = /* @__PURE__ */ p({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: !0
}), pd = 1, n$ = /* @__PURE__ */ p({
  ...q,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [pd]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [pd]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [pd]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: pd
}), hd = 11155111, r$ = /* @__PURE__ */ p({
  ...q,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [hd]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [hd]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [hd]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: !0,
  sourceId: hd
}), s$ = /* @__PURE__ */ p({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: !1
}), a$ = /* @__PURE__ */ p({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
}), i$ = /* @__PURE__ */ p({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: !0
}), o$ = /* @__PURE__ */ p({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: !1
}), c$ = /* @__PURE__ */ p({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
}), l$ = /* @__PURE__ */ p({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: !0
}), u$ = /* @__PURE__ */ p({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
}), d$ = /* @__PURE__ */ p({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: !0
}), f$ = /* @__PURE__ */ p({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: !1
}), p$ = /* @__PURE__ */ p({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: !0
}), h$ = /* @__PURE__ */ p({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
}), m$ = /* @__PURE__ */ p({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: !0
}), b$ = /* @__PURE__ */ p({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: !0
}), y$ = /* @__PURE__ */ p({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: !0
}), Kv = /* @__PURE__ */ p({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: !0
}), md = 1, g$ = /* @__PURE__ */ p({
  ...q,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [md]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [md]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [md]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: md
}), w$ = 11155111, E$ = /* @__PURE__ */ p({
  ...q,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: w$
}), x$ = /* @__PURE__ */ p({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: !1
}), A$ = /* @__PURE__ */ p({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: !0
}), v$ = /* @__PURE__ */ p({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
}), k$ = /* @__PURE__ */ p({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: !0
}), C$ = /* @__PURE__ */ p({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: !1
}), T$ = /* @__PURE__ */ p({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
}), S$ = /* @__PURE__ */ p({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: !0
}), O$ = /* @__PURE__ */ p({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
}), B$ = /* @__PURE__ */ p({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
}), P$ = /* @__PURE__ */ p({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: !0
}), I$ = /* @__PURE__ */ p({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: !1
}), U$ = /* @__PURE__ */ p({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), N$ = /* @__PURE__ */ p({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
}), R$ = /* @__PURE__ */ p({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: !0
}), F$ = /* @__PURE__ */ p({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), M$ = /* @__PURE__ */ p({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), D$ = /* @__PURE__ */ p({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
}), L$ = /* @__PURE__ */ p({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: !0
}), H$ = /* @__PURE__ */ p({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), $$ = /* @__PURE__ */ p({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), _$ = /* @__PURE__ */ p({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
}), G$ = /* @__PURE__ */ p({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: !0
}), z$ = /* @__PURE__ */ p({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
}), V$ = /* @__PURE__ */ p({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
}), j$ = /* @__PURE__ */ p({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: !0
}), K$ = /* @__PURE__ */ p({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: !0
}), Gc = 1, q$ = /* @__PURE__ */ p({
  ...q,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Gc]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [Gc]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [Gc]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [Gc]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: Gc
}), zc = 11155111, W$ = /* @__PURE__ */ p({
  ...q,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [zc]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [zc]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [zc]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [zc]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: !0,
  sourceId: zc
}), Q$ = /* @__PURE__ */ p({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://shannon-explorer.somnia.network/",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x841b8199E6d3Db3C6f264f6C2bd8848b3cA64223",
      blockCreated: 71314235
    }
  },
  testnet: !0
}), Vc = 1, J$ = /* @__PURE__ */ p({
  ...q,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Vc]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [Vc]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [Vc]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [Vc]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: Vc
}), jc = 11155111, Z$ = /* @__PURE__ */ p({
  ...q,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [jc]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [jc]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [jc]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [jc]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: !0,
  sourceId: jc
}), X$ = /* @__PURE__ */ p({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: !1
}), Y$ = /* @__PURE__ */ p({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: !0
}), e_ = /* @__PURE__ */ p({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: !0
}), t_ = /* @__PURE__ */ p({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
}), n_ = /* @__PURE__ */ p({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: !0
}), r_ = /* @__PURE__ */ p({
  ...hn,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: !1
}), s_ = /* @__PURE__ */ p({
  ...hn,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: !0
}), a_ = /* @__PURE__ */ p({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: !0
}), Fw = /* @__PURE__ */ p({
  ...My,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: !0
}), i_ = /* @__PURE__ */ p({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: !1
}), o_ = /* @__PURE__ */ p({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.xyz",
      apiUrl: "https://storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !1
}), c_ = /* @__PURE__ */ p({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.xyz",
      apiUrl: "https://aeneid.storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: !0
}), l_ = /* @__PURE__ */ p({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: !0
}), u_ = /* @__PURE__ */ p({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: !0
}), d_ = /* @__PURE__ */ p({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
}), f_ = /* @__PURE__ */ p({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: !1
}), p_ = /* @__PURE__ */ p({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: !1
}), Kc = 1, h_ = /* @__PURE__ */ p({
  ...q,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    disputeGameFactory: {
      [Kc]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [Kc]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [Kc]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [Kc]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: Kc
}), Lh = 11155111, m_ = /* @__PURE__ */ p({
  ...q,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [Lh]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [Lh]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: !0,
  sourceId: Lh
}), b_ = /* @__PURE__ */ p({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: !1
}), y_ = /* @__PURE__ */ p({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io	"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: !0
}), g_ = /* @__PURE__ */ p({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: !0
}), w_ = /* @__PURE__ */ p({
  ...q,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), E_ = /* @__PURE__ */ p({
  ...q,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
}), x_ = /* @__PURE__ */ p({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: !1
}), A_ = /* @__PURE__ */ p({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
}), v_ = /* @__PURE__ */ p({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
}), k_ = /* @__PURE__ */ p({
  id: 239,
  name: "TAC",
  nativeCurrency: { name: "TAC", symbol: "TAC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/tac"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://tac.blockscout.com",
      apiUrl: "https://tac.blockscout.com/api"
    },
    native: {
      name: "TAC Explorer",
      url: "https://explorer.tac.build",
      apiUrl: "https://explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
}), C_ = /* @__PURE__ */ p({
  id: 2391,
  name: "TAC SPB Testnet",
  nativeCurrency: {
    name: "TAC",
    symbol: "TAC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://spb.rpc.tac.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "TAC",
      url: "https://spb.explorer.tac.build",
      apiUrl: "https://spb.explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 471429
    }
  },
  testnet: !0
}), T_ = /* @__PURE__ */ p({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
}), S_ = /* @__PURE__ */ p({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: !0
}), O_ = /* @__PURE__ */ p({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: !0
}), B_ = /* @__PURE__ */ p({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
}), P_ = /* @__PURE__ */ p({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
}), I_ = /* @__PURE__ */ p({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
}), U_ = /* @__PURE__ */ p({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: !0
}), N_ = /* @__PURE__ */ p({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: !0
}), R_ = /* @__PURE__ */ p({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
}), F_ = /* @__PURE__ */ p({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: !0
}), M_ = /* @__PURE__ */ p({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: !1
}), D_ = /* @__PURE__ */ p({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: !1
}), L_ = /* @__PURE__ */ p({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: !1
}), H_ = /* @__PURE__ */ p({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: !1
}), $_ = /* @__PURE__ */ p({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: !1
}), __ = /* @__PURE__ */ p({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: !0
}), G_ = /* @__PURE__ */ p({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: !1
}), z_ = /* @__PURE__ */ p({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: !0
}), V_ = /* @__PURE__ */ p({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: !0
}), j_ = /* @__PURE__ */ p({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: !1
}), K_ = /* @__PURE__ */ p({
  ...hn,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: !1
}), q_ = /* @__PURE__ */ p({
  ...hn,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: !0
}), W_ = /* @__PURE__ */ p({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
}), Q_ = /* @__PURE__ */ p({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: !0
}), J_ = /* @__PURE__ */ p({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: !1
}), Z_ = /* @__PURE__ */ p({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
}), X_ = /* @__PURE__ */ p({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: !0
}), Y_ = /* @__PURE__ */ p({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: !1
}), eG = /* @__PURE__ */ p({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: !0
}), bd = 1, tG = /* @__PURE__ */ p({
  ...q,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [bd]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [bd]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [bd]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: bd
}), yd = 11155111, nG = /* @__PURE__ */ p({
  ...q,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [yd]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [yd]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [yd]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: !0,
  sourceId: yd
}), rG = /* @__PURE__ */ p({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
}), sG = /* @__PURE__ */ p({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: !0
}), aG = /* @__PURE__ */ p({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
}), iG = /* @__PURE__ */ p({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: !0,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
}), oG = /* @__PURE__ */ p({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: !1
}), cG = /* @__PURE__ */ p({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
}), lG = /* @__PURE__ */ p({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: !1
}), uG = /* @__PURE__ */ p({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: !1
}), dG = /* @__PURE__ */ p({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: !0
}), fG = /* @__PURE__ */ p({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: !1
}), pG = /* @__PURE__ */ p({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: !0
}), hG = /* @__PURE__ */ p({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
}), mG = /* @__PURE__ */ p({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: !0
}), bG = /* @__PURE__ */ p({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: !0
}), yG = /* @__PURE__ */ p({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
}), gG = /* @__PURE__ */ p({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: !0
}), wG = /* @__PURE__ */ p({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: !0
}), EG = /* @__PURE__ */ p({
  testnet: !1,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
}), xG = /* @__PURE__ */ p({
  testnet: !0,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
}), AG = /* @__PURE__ */ p({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: !0
}), qc = 1, vG = /* @__PURE__ */ p({
  ...q,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [qc]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [qc]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [qc]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [qc]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: !1,
  sourceId: qc
}), Wc = 11155111, kG = /* @__PURE__ */ p({
  ...q,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [Wc]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [Wc]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [Wc]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [Wc]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: !0,
  sourceId: Wc
}), CG = /* @__PURE__ */ p({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: !1
}), TG = /* @__PURE__ */ p({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: !1
}), SG = /* @__PURE__ */ p({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: !0
}), OG = /* @__PURE__ */ p({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
}), BG = /* @__PURE__ */ p({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
}), PG = /* @__PURE__ */ p({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
}), Mw = /* @__PURE__ */ p({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: !0
}), IG = /* @__PURE__ */ p({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: !1
}), UG = /* @__PURE__ */ p({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: !0
}), NG = /* @__PURE__ */ p({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: !0
}), RG = /* @__PURE__ */ p({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: !0
}), FG = /* @__PURE__ */ p({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
}), MG = /* @__PURE__ */ p({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: !0
}), DG = /* @__PURE__ */ p({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: !0
}), LG = /* @__PURE__ */ p({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: !1
}), HG = /* @__PURE__ */ p({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: !0
}), $G = /* @__PURE__ */ p({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: !1
}), _G = /* @__PURE__ */ p({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://explorer.zetachain.com"
    }
  },
  testnet: !1
}), GG = /* @__PURE__ */ p({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://athens.explorer.zetachain.com"
    }
  },
  testnet: !0
}), zG = /* @__PURE__ */ p({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: !0
}), VG = /* @__PURE__ */ p({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: !1
}), jG = /* @__PURE__ */ p({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: !0
}), Hh = 1, KG = /* @__PURE__ */ p({
  ...q,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [Hh]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [Hh]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [Hh]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: !1
}), $h = 11155111, qG = /* @__PURE__ */ p({
  ...q,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [$h]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [$h]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [$h]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: !0
}), _h = 11155111, WG = /* @__PURE__ */ p({
  ...q,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [_h]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [_h]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [_h]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: !0
}), QG = /* @__PURE__ */ p({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: !1
}), JG = /* @__PURE__ */ p({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: !0
}), ZG = /* @__PURE__ */ p({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
}), XG = /* @__PURE__ */ p({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
}), Dw = /* @__PURE__ */ p({
  ...hn,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
}), Lw = /* @__PURE__ */ p({
  ...hn,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: !0
}), YG = /* @__PURE__ */ p({
  ...hn,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), ez = /* @__PURE__ */ p({
  ...hn,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: !0
}), tz = /* @__PURE__ */ p({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: !0
}), Hw = /* @__PURE__ */ p({
  ...hn,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: !0
}), $w = /* @__PURE__ */ p({
  ...hn,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: !0
}), gd = 1, qv = /* @__PURE__ */ p({
  ...q,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [gd]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [gd]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [gd]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: gd
}), wd = 11155111, nz = /* @__PURE__ */ p({
  ...q,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    l2OutputOracle: {
      [wd]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [wd]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [wd]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: wd,
  testnet: !0
}), _w = 5, rz = /* @__PURE__ */ p({
  ...q,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...q.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [_w]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: _w,
  testnet: !0
}), vu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abey: W9,
  abstract: WI,
  abstractTestnet: QI,
  acala: JI,
  acria: ZI,
  adf: XI,
  aioz: YI,
  alephZero: e4,
  alephZeroTestnet: t4,
  alienx: n4,
  alienxHalTestnet: r4,
  ancient8: c4,
  ancient8Sepolia: l4,
  anvil: u4,
  apeChain: f4,
  apexTestnet: p4,
  arbitrum: pl,
  arbitrumGoerli: h4,
  arbitrumNova: Cv,
  arbitrumSepolia: m4,
  arenaz: b4,
  areonNetwork: y4,
  areonNetworkTestnet: g4,
  artelaTestnet: w4,
  arthera: E4,
  artheraTestnet: x4,
  assetChain: A4,
  assetChainTestnet: v4,
  astar: k4,
  astarZkEVM: C4,
  astarZkyoto: T4,
  atletaOlympia: S4,
  aurora: O4,
  auroraTestnet: B4,
  auroria: P4,
  avalanche: I4,
  avalancheFuji: U4,
  b3: R4,
  b3Sepolia: M4,
  bahamut: D4,
  base: hl,
  baseGoerli: Tv,
  baseSepolia: Sv,
  basecampTestnet: L4,
  beam: H4,
  beamTestnet: $4,
  bearNetworkChainMainnet: _4,
  bearNetworkChainTestnet: G4,
  berachain: z4,
  berachainBepolia: V4,
  berachainTestnet: j4,
  berachainTestnetbArtio: K4,
  bevmMainnet: q4,
  bifrost: W4,
  birdlayer: rU,
  bitTorrent: tU,
  bitTorrentTestnet: nU,
  bitgert: Q4,
  bitkub: J4,
  bitkubTestnet: Z4,
  bitlayer: X4,
  bitlayerTestnet: Y4,
  bitrock: eU,
  blast: sU,
  blastSepolia: iU,
  bob: oU,
  bobSepolia: uU,
  boba: cU,
  bobaSepolia: lU,
  boolBetaMainnet: dU,
  botanixTestnet: fU,
  bounceBit: pU,
  bounceBitTestnet: hU,
  bronos: mU,
  bronosTestnet: bU,
  bsc: yU,
  bscGreenfield: gU,
  bscTestnet: wU,
  bsquared: EU,
  bsquaredTestnet: xU,
  btr: AU,
  btrTestnet: vU,
  bxn: kU,
  bxnTestnet: CU,
  cannon: TU,
  canto: SU,
  celo: LU,
  celoAlfajores: HU,
  chang: $U,
  chiliz: _U,
  chips: GU,
  citreaTestnet: zU,
  classic: VU,
  coinbit: jU,
  coinex: KU,
  confluxESpace: qU,
  confluxESpaceTestnet: WU,
  coreDao: QU,
  coreTestnet1: JU,
  coreTestnet2: ZU,
  corn: YU,
  cornTestnet: tN,
  crab: nN,
  creatorTestnet: rN,
  creditCoin3Mainnet: sN,
  creditCoin3Testnet: aN,
  cronos: iN,
  cronosTestnet: oN,
  cronoszkEVM: cN,
  cronoszkEVMTestnet: lN,
  crossbell: uN,
  curtis: dN,
  cyber: fN,
  cyberTestnet: pN,
  dailyNetwork: hN,
  dailyNetworkTestnet: mN,
  darwinia: bN,
  dbkchain: yN,
  dchain: gN,
  dchainTestnet: wN,
  defichainEvm: EN,
  defichainEvmTestnet: xN,
  degen: AN,
  dfk: vN,
  diode: kN,
  disChain: CN,
  dodochainTestnet: TN,
  dogechain: SN,
  donatuz: ON,
  dosChain: BN,
  dosChainTestnet: PN,
  dreyerxMainnet: IN,
  dreyerxTestnet: RN,
  dustboyIoT: FN,
  dymension: MN,
  edexa: LN,
  edexaTestnet: DN,
  edgeless: HN,
  edgelessTestnet: $N,
  edgeware: _N,
  edgewareTestnet: GN,
  eduChain: zN,
  eduChainTestnet: VN,
  ekta: jN,
  ektaTestnet: KN,
  elastos: qN,
  elastosTestnet: WN,
  electroneum: QN,
  electroneumTestnet: JN,
  elysiumTestnet: ZN,
  energy: XN,
  enuls: YN,
  eon: eR,
  eos: tR,
  eosTestnet: nR,
  etherlink: rR,
  etherlinkTestnet: sR,
  ethernity: aR,
  etp: iR,
  evmos: oR,
  evmosTestnet: cR,
  excelonMainnet: lR,
  expanse: uR,
  exsat: dR,
  exsatTestnet: fR,
  fantom: pR,
  fantomSonicTestnet: hR,
  fantomTestnet: mR,
  fibo: bR,
  filecoin: yR,
  filecoinCalibration: gR,
  filecoinHyperspace: wR,
  fireChain: ER,
  flame: xR,
  flare: AR,
  flareTestnet: vR,
  flowMainnet: kR,
  flowPreviewnet: CR,
  flowTestnet: TR,
  fluence: SR,
  fluenceStage: OR,
  fluenceTestnet: BR,
  fluentTestnet: PR,
  form: UR,
  formTestnet: RR,
  forma: IR,
  formicarium: NR,
  forta: FR,
  foundry: MR,
  fraxtal: DR,
  fraxtalTestnet: LR,
  funkiMainnet: $R,
  funkiSepolia: GR,
  fuse: zR,
  fuseSparknet: VR,
  fusion: jR,
  fusionTestnet: KR,
  garnet: qR,
  geist: WR,
  genesys: QR,
  glideL1Protocol: JR,
  glideL2Protocol: ZR,
  gnosis: XR,
  gnosisChiado: YR,
  goChain: nF,
  goat: eF,
  gobi: tF,
  godwoken: rF,
  goerli: sF,
  gravity: aF,
  gunz: iF,
  guruNetwork: oF,
  guruTestnet: cF,
  ham: lF,
  happychainTestnet: uF,
  haqqMainnet: dF,
  haqqTestedge2: fF,
  hardhat: pF,
  harmonyOne: hF,
  hashkey: mF,
  hashkeyTestnet: bF,
  haustTestnet: yF,
  hedera: gF,
  hederaPreviewnet: wF,
  hederaTestnet: EF,
  hela: xF,
  hemi: AF,
  hemiSepolia: vF,
  holesky: kF,
  hoodi: CF,
  hpb: TF,
  huddle01Mainnet: OF,
  huddle01Testnet: PF,
  humanode: IF,
  humanodeTestnet5: UF,
  hychain: NF,
  hychainTestnet: RF,
  iSunCoin: qF,
  idchain: FF,
  immutableZkEvm: MF,
  immutableZkEvmTestnet: DF,
  inEVM: LF,
  initVerse: HF,
  initVerseGenesis: $F,
  ink: _F,
  inkSepolia: GF,
  iota: zF,
  iotaTestnet: VF,
  iotex: jF,
  iotexTestnet: KF,
  jbc: WF,
  jbcTestnet: QF,
  juneo: JF,
  juneoBCH1Chain: ZF,
  juneoDAI1Chain: XF,
  juneoDOGE1Chain: YF,
  juneoEUR1Chain: eM,
  juneoGLD1Chain: tM,
  juneoLINK1Chain: nM,
  juneoLTC1Chain: rM,
  juneoSGD1Chain: aM,
  juneoSocotraTestnet: iM,
  juneoUSD1Chain: oM,
  juneoUSDT1Chain: cM,
  juneomBTC1Chain: sM,
  kaia: gM,
  kairos: wM,
  kakarotSepolia: uM,
  kakarotStarknetSepolia: dM,
  kardiaChain: fM,
  karura: lM,
  kava: pM,
  kavaTestnet: hM,
  kcc: mM,
  kinto: bM,
  klaytn: yM,
  klaytnBaobab: EM,
  koi: xM,
  kroma: AM,
  kromaSepolia: vM,
  l3x: kM,
  l3xTestnet: CM,
  lavita: TM,
  lens: SM,
  lensTestnet: OM,
  lestnet: BM,
  lightlinkPegasus: PM,
  lightlinkPhoenix: IM,
  linea: TD,
  lineaGoerli: SD,
  lineaSepolia: OD,
  lineaTestnet: BD,
  lisk: PD,
  liskSepolia: ID,
  localhost: UD,
  loop: ND,
  lukso: RD,
  luksoTestnet: FD,
  lumiaMainnet: MD,
  lumiaTestnet: DD,
  lumoz: LD,
  lumozTestnet: HD,
  lycan: $D,
  lyra: _D,
  mainnet: ml,
  mandala: GD,
  manta: zD,
  mantaSepoliaTestnet: VD,
  mantaTestnet: jD,
  mantle: KD,
  mantleSepoliaTestnet: qD,
  mantleTestnet: WD,
  mapProtocol: QD,
  matchain: JD,
  matchainTestnet: ZD,
  mchVerse: XD,
  megaethTestnet: YD,
  mekong: eL,
  meld: tL,
  memecore: nL,
  merlin: rL,
  merlinErigonTestnet: sL,
  metachain: aL,
  metachainIstanbul: iL,
  metadium: oL,
  metalL2: cL,
  meter: lL,
  meterTestnet: uL,
  metis: dL,
  metisGoerli: pL,
  metisSepolia: fL,
  mev: hL,
  mevTestnet: mL,
  mint: bL,
  mintSepoliaTestnet: yL,
  mitosisTestnet: gL,
  mode: wL,
  modeTestnet: EL,
  monadTestnet: xL,
  moonbaseAlpha: AL,
  moonbeam: vL,
  moonbeamDev: kL,
  moonriver: CL,
  morph: TL,
  morphHolesky: SL,
  morphSepolia: OL,
  nahmii: BL,
  nautilus: PL,
  near: IL,
  nearTestnet: UL,
  neonDevnet: NL,
  neonMainnet: RL,
  neoxMainnet: FL,
  neoxT4: ML,
  newton: DL,
  nexi: LL,
  nexilix: HL,
  nibiru: $L,
  oasisTestnet: _L,
  oasys: GL,
  odysseyTestnet: zL,
  okc: VL,
  omax: jL,
  omni: KL,
  omniOmega: qL,
  oneWorld: WL,
  oortMainnetDev: QL,
  opBNB: JL,
  opBNBTestnet: ZL,
  optimism: bl,
  optimismGoerli: XL,
  optimismSepolia: YL,
  optopia: eH,
  optopiaTestnet: tH,
  orderly: nH,
  orderlySepolia: rH,
  otimDevnet: sH,
  palm: aH,
  palmTestnet: iH,
  peaq: oH,
  pgn: cH,
  pgnTestnet: lH,
  phoenix: uH,
  planq: dH,
  playfiAlbireo: fH,
  plinga: pH,
  plume: mH,
  plumeDevnet: yH,
  plumeMainnet: wH,
  plumeSepolia: xH,
  plumeTestnet: vH,
  polterTestnet: kH,
  polygon: Rd,
  polygonAmoy: CH,
  polygonMumbai: TH,
  polygonZkEvm: SH,
  polygonZkEvmCardona: OH,
  polygonZkEvmTestnet: BH,
  polynomial: PH,
  polynomialSepolia: IH,
  premiumBlockTestnet: UH,
  pulsechain: NH,
  pulsechainV4: RH,
  pumpfiTestnet: FH,
  pyrope: MH,
  qMainnet: LH,
  qTestnet: HH,
  ql1: DH,
  real: $H,
  redbellyMainnet: _H,
  redbellyTestnet: GH,
  reddioSepolia: KH,
  redstone: zH,
  rei: VH,
  reyaNetwork: jH,
  riseTestnet: qH,
  rivalz: WH,
  rollux: QH,
  rolluxTestnet: JH,
  ronin: ZH,
  root: XH,
  rootPorcini: YH,
  rootstock: e$,
  rootstockTestnet: t$,
  rss3: n$,
  rss3Sepolia: r$,
  saakuru: s$,
  saga: a$,
  saigon: i$,
  sanko: o$,
  sapphire: c$,
  sapphireTestnet: l$,
  satoshiVM: u$,
  satoshiVMTestnet: d$,
  scroll: f$,
  scrollSepolia: p$,
  sei: h$,
  seiDevnet: m$,
  seiTestnet: y$,
  seismicDevnet: b$,
  sepolia: Kv,
  shape: g$,
  shapeSepolia: E$,
  shardeum: x$,
  shardeumSphinx: A$,
  shibarium: v$,
  shibariumTestnet: k$,
  shiden: C$,
  shimmer: T$,
  shimmerTestnet: S$,
  sidraChain: O$,
  silicon: B$,
  siliconSepolia: P$,
  sixProtocol: I$,
  skaleBlockBrawlers: U$,
  skaleCalypso: N$,
  skaleCalypsoTestnet: R$,
  skaleCryptoBlades: F$,
  skaleCryptoColosseum: M$,
  skaleEuropa: D$,
  skaleEuropaTestnet: L$,
  skaleExorde: H$,
  skaleHumanProtocol: $$,
  skaleNebula: _$,
  skaleNebulaTestnet: G$,
  skaleRazor: z$,
  skaleTitan: V$,
  skaleTitanTestnet: j$,
  sketchpad: K$,
  snax: q$,
  snaxTestnet: W$,
  somniaTestnet: Q$,
  soneium: J$,
  soneiumMinato: Z$,
  songbird: t_,
  songbirdTestnet: n_,
  sonic: X$,
  sonicBlazeTestnet: e_,
  sonicTestnet: Y$,
  sophon: r_,
  sophonTestnet: s_,
  spicy: a_,
  statusNetworkSepolia: Fw,
  statusSepolia: Fw,
  step: i_,
  story: o_,
  storyAeneid: c_,
  storyOdyssey: l_,
  storyTestnet: u_,
  stratis: d_,
  superlumio: f_,
  superposition: p_,
  superseed: h_,
  superseedSepolia: m_,
  swan: b_,
  swanProximaTestnet: y_,
  swanSaturnTestnet: g_,
  swellchain: w_,
  swellchainTestnet: E_,
  swissdlt: x_,
  syscoin: A_,
  syscoinTestnet: v_,
  tac: k_,
  tacSPB: C_,
  taiko: T_,
  taikoHekla: S_,
  taikoJolnir: O_,
  taikoKatla: B_,
  taikoTestnetSepolia: P_,
  taraxa: I_,
  taraxaTestnet: U_,
  telcoinTestnet: N_,
  telos: R_,
  telosTestnet: F_,
  tenet: M_,
  ternoa: D_,
  thaiChain: L_,
  that: H_,
  theta: $_,
  thetaTestnet: __,
  thunderCore: G_,
  thunderTestnet: z_,
  tiktrixTestnet: V_,
  tomb: j_,
  treasure: K_,
  treasureTopaz: q_,
  tron: W_,
  tronShasta: Q_,
  ubiq: J_,
  ultra: Z_,
  ultraTestnet: X_,
  ultron: Y_,
  ultronTestnet: eG,
  unichain: tG,
  unichainSepolia: nG,
  unique: rG,
  uniqueOpal: sG,
  uniqueQuartz: aG,
  unreal: iG,
  vanar: oG,
  vechain: cG,
  velas: lG,
  viction: uG,
  victionTestnet: dG,
  vision: fG,
  visionTestnet: pG,
  wanchain: hG,
  wanchainTestnet: mG,
  weaveVMAlphanet: bG,
  wemix: yG,
  wemixTestnet: gG,
  westendAssetHub: wG,
  whitechain: EG,
  whitechainTestnet: xG,
  wmcTestnet: AG,
  worldLand: CG,
  worldchain: vG,
  worldchainSepolia: kG,
  x1Testnet: Mw,
  xLayer: PG,
  xLayerTestnet: Mw,
  xai: TG,
  xaiTestnet: SG,
  xdc: OG,
  xdcTestnet: BG,
  xrOne: IG,
  xrSepolia: RG,
  xrplevmDevnet: UG,
  xrplevmTestnet: NG,
  yooldoVerse: FG,
  yooldoVerseTestnet: MG,
  zenchainTestnet: DG,
  zeniq: LG,
  zeroG: HG,
  zeroNetwork: $G,
  zetachain: _G,
  zetachainAthensTestnet: GG,
  zhejiang: zG,
  zilliqa: VG,
  zilliqaTestnet: jG,
  zircuit: KG,
  zircuitGarfieldTestnet: qG,
  zircuitTestnet: WG,
  zkFair: QG,
  zkFairTestnet: JG,
  zkLinkNova: ZG,
  zkLinkNovaSepoliaTestnet: XG,
  zkSync: Dw,
  zkSyncInMemoryNode: Lw,
  zkSyncLocalNode: Hw,
  zkSyncSepoliaTestnet: $w,
  zksync: Dw,
  zksyncInMemoryNode: Lw,
  zksyncLocalCustomHyperchain: YG,
  zksyncLocalHyperchain: ez,
  zksyncLocalHyperchainL1: tz,
  zksyncLocalNode: Hw,
  zksyncSepoliaTestnet: $w,
  zora: qv,
  zoraSepolia: nz,
  zoraTestnet: rz
}, Symbol.toStringTag, { value: "Module" })), IZ = "0xd7571bd1e3af468c3a49966c9a92a2e907cdfa52", sz = "0xaA3f6B332237aFb83789d3F5FBaD817EF3102648", Wv = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", UZ = "0xffb40760fb475f7d8f5a806b2e3535a642ec8752", az = "0xffb40760fb475f7d8f5a806b2e3535a642ec8752", NZ = "0xffb40760fb475f7d8f5a806b2e3535a642ec8752", iz = "https://dev-indexer.sequence.app", oz = "https://v3-api.sequence.app", RZ = "dev", FZ = [
  { id: ml.id, name: ml.name, chain: ml },
  { id: hl.id, name: hl.name, chain: hl },
  {
    id: bl.id,
    name: bl.name,
    chain: bl
  },
  {
    id: pl.id,
    name: pl.name,
    chain: pl
  },
  { id: Rd.id, name: Rd.name, chain: Rd }
], MZ = [
  {
    symbol: "ETH",
    name: "Ethereum",
    imageUrl: "https://assets.sequence.info/images/tokens/small/1/0x0000000000000000000000000000000000000000.webp",
    decimals: 18
  },
  {
    symbol: "USDC",
    name: "USD Coin",
    imageUrl: "https://assets.sequence.info/images/tokens/small/1/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.webp",
    decimals: 6
  },
  {
    symbol: "USDT",
    name: "Tether",
    imageUrl: "https://assets.sequence.info/images/tokens/small/1/0xdac17f958d2ee523a2206206994597c13d831ec7.webp",
    decimals: 6
  },
  {
    symbol: "BAT",
    name: "Basic Attention Token",
    imageUrl: "https://assets.sequence.info/images/tokens/small/1/0x0d8775f648430679a709e98d2b0cb6250d2887ef.webp",
    decimals: 18
  },
  {
    symbol: "ARB",
    name: "Arbitrum",
    imageUrl: "https://assets.sequence.info/images/tokens/small/42161/0x912ce59144191c1204e64559fe8253a0e49e6548.webp",
    decimals: 18
  }
];
function cz({
  apiUrl: t = oz,
  projectAccessKey: e,
  jwt: n
}) {
  return new rC(t, e, n);
}
const lz = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = c2();
  return Hf(() => cz({
    apiUrl: (t == null ? void 0 : t.apiUrl) ?? r.apiUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.apiUrl, t]);
};
async function ku(t, e) {
  try {
    let n = await t.getChainId();
    if (n === e) {
      console.log("Chain already switched to:", e);
      return;
    }
    if (console.log(
      "Switching to chain:",
      e,
      "currentChainId",
      n
    ), await t.switchChain({ id: e }), n = await t.getChainId(), n !== e)
      throw new Error("Failed to switch chain");
    console.log("Chain switched to:", e);
  } catch (n) {
    throw console.error("Chain switch failed:", n), new Error(
      `Failed to switch chain: ${n instanceof Error ? n.message : "Unknown error"}`
    );
  }
}
function uz(t) {
  return Object.values(vu).find(
    (e) => e.id === t
  ) || null;
}
function Dy(t, e) {
  const n = MT(
    "function transfer(address,uint256) returns (bool)"
  );
  return qx(n, [
    t,
    e
  ]);
}
function dz(t) {
  console.log(
    "Finding precondition address from:",
    JSON.stringify(t, null, 2)
  );
  const e = ["erc20-balance", "native-balance"];
  for (const r of e) {
    const s = t.find(
      (a) => {
        var i;
        return a.type === r && ((i = a.data) == null ? void 0 : i.address);
      }
    );
    if (s)
      return console.log(
        `Found ${r} precondition with address:`,
        s.data.address
      ), s.data.address;
  }
  const n = `N/A (No ${e.join(" or ")} precondition with address found)`;
  return console.log(n), n;
}
function fz(t, e) {
  return t.find(
    (r) => (r.type === "erc20-balance" || r.type === "native-balance") && r.chainId === (e == null ? void 0 : e.toString())
  ) ?? null;
}
async function pz(t, e) {
  return t.getIntentCallsPayloads(e);
}
function Qv(t, e, n, r = "relay") {
  console.log("calculateIntentAddress inputs:", {
    mainSigner: t,
    calls: JSON.stringify(e, null, 2),
    executionInfosArg: JSON.stringify(n, null, 2)
  });
  const s = {
    factory: "0xBd0F8abD58B4449B39C57Ac9D5C67433239aC447",
    stage1: "0x53bA242E7C2501839DF2972c75075dc693176Cd0",
    creationCode: "0x603e600e3d39601e805130553df33d3d34601c57363d3d373d363d30545af43d82803e903d91601c57fd5bf3"
  }, a = e.map((c) => ({
    type: "call",
    chainId: c.chainId.toString(),
    space: c.space ? c.space.toString() : "0",
    nonce: c.nonce ? c.nonce.toString() : "0",
    calls: c.calls.map((u) => {
      var l, d;
      return {
        to: si(u.to),
        value: ((l = u.value) == null ? void 0 : l.toString()) || "0",
        data: js(wi(u.data || "0x")),
        gasLimit: ((d = u.gasLimit) == null ? void 0 : d.toString()) || "0",
        delegateCall: !!u.delegateCall,
        onlyFallback: !!u.onlyFallback,
        behaviorOnError: u.behaviorOnError
      };
    })
  })), i = n == null ? void 0 : n.map(
    (c) => ({
      originToken: si(c.originToken),
      amount: c.amount,
      originChainId: c.originChainId,
      destinationChainId: c.destinationChainId
    })
  );
  console.log(
    "Transformed coreExecutionInfos:",
    JSON.stringify(
      i,
      (c, u) => typeof u == "bigint" ? u.toString() : u,
      2
    )
  );
  const o = yz(
    si(t),
    a,
    s,
    Wv,
    i,
    r
  );
  return console.log("Final calculated address:", o.toString()), o;
}
function hz(t, e, n, r, s, a = "relay") {
  console.log("commitIntentConfig inputs:", {
    mainSignerAddress: e,
    calls: JSON.stringify(n, null, 2),
    preconditions: JSON.stringify(r, null, 2),
    executionInfos: JSON.stringify(s, null, 2)
  });
  const i = Qv(
    e,
    n,
    s,
    a
  ), o = dz(r);
  console.log("Address comparison:", {
    receivedAddress: o,
    calculatedAddress: i.toString(),
    match: W3(si(o), i)
  });
  const c = {
    walletAddress: i.toString(),
    mainSigner: e,
    calls: n,
    preconditions: r,
    anypayInfos: s,
    sapientType: a
  };
  return console.log("args", c), t.commitIntentConfig(c);
}
async function R0(t, e, n) {
  const r = await e.getChainId();
  return r.toString() !== n.chain.id.toString() && (console.log(
    "sendOriginTransaction: switching chain",
    "want:",
    n.chain.id,
    "current:",
    r
  ), await e.switchChain({ id: n.chain.id }), console.log(
    "sendOriginTransaction: switched chain to",
    n.chain.id
  )), await e.sendTransaction({
    account: t,
    to: n.to,
    data: n.data,
    value: BigInt(n.value),
    chain: n.chain
  });
}
function DZ({
  userAddress: t,
  nonce: e,
  originTokens: n,
  destinationCalls: r,
  destinationTokens: s
}) {
  if (!t || t === "0x0000000000000000000000000000000000000000")
    throw new Error("UserAddress is zero");
  if (typeof e != "bigint") throw new Error("Nonce is not a bigint");
  if (!n || n.length === 0)
    throw new Error("OriginTokens is empty");
  if (!r || r.length === 0)
    throw new Error("DestinationCalls is empty");
  if (!s || s.length === 0)
    throw new Error("DestinationTokens is empty");
  for (let y = 0; y < r.length; y++) {
    const b = r[y];
    if (!b) throw new Error(`DestinationCalls[${y}] is nil`);
    if (!b.calls || b.calls.length === 0)
      throw new Error(`DestinationCalls[${y}] has no calls`);
  }
  const a = n.map((y) => ({
    address: y.address,
    chainId: y.chainId
  }));
  let i = wi(new Uint8Array(32));
  for (let y = 0; y < r.length; y++) {
    const b = r[y];
    if (!b) throw new Error(`DestinationCalls[${y}] is nil`);
    const g = HE.hash(
      Wv,
      BigInt(b.chainId),
      {
        type: "call",
        space: b.space ? BigInt(b.space) : 0n,
        nonce: b.nonce ? BigInt(b.nonce) : 0n,
        calls: b.calls.map((w) => {
          var v, A;
          return {
            type: "call",
            to: w.to,
            value: BigInt(((v = w.value) == null ? void 0 : v.toString()) || "0"),
            data: js(wi(w.data || "0x")),
            gasLimit: BigInt(((A = w.gasLimit) == null ? void 0 : A.toString()) || "0"),
            delegateCall: !!w.delegateCall,
            onlyFallback: !!w.onlyFallback,
            behaviorOnError: w.behaviorOnError === 0 ? "ignore" : w.behaviorOnError === 1 ? "revert" : "abort"
          };
        })
      }
    );
    i = ea(
      _b(i, g),
      {
        as: "Bytes"
      }
    );
  }
  const o = js(i), c = s.map((y) => ({
    address: y.address,
    chainId: y.chainId,
    amount: y.amount
  })), l = Vb([
    { type: "address" },
    { type: "uint256" },
    {
      type: "tuple[]",
      components: [
        { name: "address", type: "address" },
        { name: "chainId", type: "uint256" }
      ]
    },
    {
      type: "tuple[]",
      components: [
        { name: "address", type: "address" },
        { name: "chainId", type: "uint256" },
        { name: "amount", type: "uint256" }
      ]
    },
    { type: "bytes32" }
  ], [
    t,
    e,
    a,
    c,
    o
  ]), d = ga(l), f = ea(d);
  return js(f);
}
function mz(t, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function bz(t, e) {
  if (!t || t.length === 0)
    throw new Error("executionInfos is empty");
  if (!e || e === "0x0000000000000000000000000000000000000000")
    throw new Error("attestationAddress is zero");
  const n = [
    { name: "originToken", type: "address" },
    { name: "amount", type: "uint256" },
    { name: "originChainId", type: "uint256" },
    { name: "destinationChainId", type: "uint256" }
  ], r = t.map((c) => ({
    originToken: c.originToken,
    amount: c.amount,
    originChainId: c.originChainId,
    destinationChainId: c.destinationChainId
  })), a = Vb([
    {
      type: "tuple[]",
      name: "executionInfos",
      components: n
    },
    { type: "address", name: "attestationAddress" }
  ], [
    r,
    e
  ]), i = ga(a), o = ea(i);
  return js(o);
}
function yz(t, e, n, r, s, a = "relay") {
  const i = gz(
    t,
    e,
    r,
    s,
    a
  ), o = eC.hashConfiguration(i);
  return mS({
    from: n.factory,
    bytecodeHash: ea(
      _b(
        wi(n.creationCode),
        Hx(wi(n.stage1), 32)
      ),
      { as: "Bytes" }
    ),
    salt: o
  });
}
function gz(t, e, n, r, s = "relay") {
  const a = {
    type: "signer",
    address: t,
    weight: 1n
  };
  console.log("mainSignerLeaf:", a);
  const i = e.map(
    (u) => {
      const l = HE.hash(
        si("0x0000000000000000000000000000000000000000"),
        BigInt(u.chainId),
        {
          type: "call",
          space: BigInt(u.space || 0),
          nonce: BigInt(u.nonce || 0),
          calls: u.calls.map((d) => {
            var f, h;
            return {
              type: "call",
              to: d.to,
              value: BigInt(((f = d.value) == null ? void 0 : f.toString()) || "0"),
              data: js(wi(d.data || "0x")),
              gasLimit: BigInt(((h = d.gasLimit) == null ? void 0 : h.toString()) || "0"),
              delegateCall: !!d.delegateCall,
              onlyFallback: !!d.onlyFallback,
              behaviorOnError: d.behaviorOnError === 0 ? "ignore" : d.behaviorOnError === 1 ? "revert" : "abort"
            };
          })
        }
      );
      return console.log("digest:", js(l)), {
        type: "any-address-subdigest",
        digest: js(l)
      };
    }
  );
  console.log("calls:", e), console.log("subdigestLeaves:", i);
  const o = [...i];
  if (r && r.length > 0 && n) {
    const u = {
      type: "sapient-signer",
      address: s === "lifi" ? sz : az,
      weight: 1n,
      imageHash: bz(
        r,
        n
      )
    };
    o.push(u);
  }
  if (o.length === 0)
    throw new Error(
      "Intent configuration must have at least one call or LiFi information."
    );
  let c;
  return o.length === 1 ? c = o[0] : c = wz(o), console.log(
    "Topology:",
    JSON.stringify([a, c], mz, 2)
  ), {
    threshold: 1n,
    checkpoint: 0n,
    topology: [a, c]
  };
}
function wz(t) {
  if (t.length === 0)
    throw new Error("Cannot create a tree from empty members");
  if (t.length === 1)
    return t[0];
  let e = [...t];
  for (; e.length > 1; ) {
    const n = [];
    for (let r = 0; r < e.length; r += 2) {
      const s = e[r];
      if (r + 1 < e.length) {
        const a = e[r + 1];
        n.push([s, a]);
      } else
        n.push(s);
    }
    e = n;
  }
  return e[0];
}
const Gw = 3e3, Ez = async (t, e, n) => t.status(e, BigInt(n)), LZ = (t, e) => {
  const n = vC({
    queries: (t || []).map((s) => {
      const a = s.id;
      return {
        queryKey: ["metaTxnStatus", s.chainId, s.id],
        queryFn: async () => {
          const i = e(parseInt(s.chainId));
          if (!a)
            return {
              status: "failed",
              reason: "Missing operation hash for monitoring."
            };
          if (!i)
            return {
              status: "failed",
              reason: `Relayer not available for chain ${s.chainId}.`
            };
          const o = await i.status(
            a,
            BigInt(s.chainId)
          );
          let c;
          if (o.status === "confirmed")
            c = {
              status: "confirmed",
              transactionHash: o.transactionHash,
              data: o.data
            };
          else if (o.status === "failed")
            c = {
              status: "failed",
              reason: o.reason,
              data: o.data
            };
          else if (o.status === "pending")
            c = {
              status: "pending"
            };
          else if (o.status === "unknown")
            c = {
              status: "unknown"
            };
          else {
            const u = o.status;
            console.warn(
              ` Unexpected relayer status "${u}" for ${a}:`,
              o
            ), c = {
              status: "unknown"
            };
          }
          return c;
        },
        refetchInterval: (i) => {
          const o = i.state.data;
          return o && o.status === "confirmed" ? !1 : Gw;
        },
        enabled: !!s && !!s.id && !!s.chainId,
        retry: (i, o) => i >= 30 ? (console.error(
          ` Giving up on transaction ${a} after 3 failed API attempts:`,
          o
        ), !1) : !0
      };
    })
  });
  return Hf(() => {
    const s = {};
    return (t || []).forEach((a, i) => {
      var u;
      const o = `${a.chainId}-${a.id}`, c = n[i];
      c ? c.isLoading && c.fetchStatus !== "idle" && !c.data ? s[o] = {
        status: "pending"
      } : c.isError ? s[o] = {
        status: "failed",
        reason: ((u = c.error) == null ? void 0 : u.message) || "An unknown error occurred"
      } : c.data ? s[o] = c.data : s[o] = {
        status: "unknown"
      } : s[o] = {
        status: "failed",
        reason: "Query result unexpectedly missing"
      };
    }), s;
  }, [t, n]);
};
var lt = typeof globalThis < "u" && globalThis || typeof self < "u" && self || // eslint-disable-next-line no-undef
typeof global < "u" && global || {}, Lt = {
  searchParams: "URLSearchParams" in lt,
  iterable: "Symbol" in lt && "iterator" in Symbol,
  blob: "FileReader" in lt && "Blob" in lt && function() {
    try {
      return new Blob(), !0;
    } catch {
      return !1;
    }
  }(),
  formData: "FormData" in lt,
  arrayBuffer: "ArrayBuffer" in lt
};
function xz(t) {
  return t && DataView.prototype.isPrototypeOf(t);
}
if (Lt.arrayBuffer)
  var Az = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ], vz = ArrayBuffer.isView || function(t) {
    return t && Az.indexOf(Object.prototype.toString.call(t)) > -1;
  };
function Cc(t) {
  if (typeof t != "string" && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t) || t === "")
    throw new TypeError('Invalid character in header field name: "' + t + '"');
  return t.toLowerCase();
}
function Ly(t) {
  return typeof t != "string" && (t = String(t)), t;
}
function Hy(t) {
  var e = {
    next: function() {
      var n = t.shift();
      return { done: n === void 0, value: n };
    }
  };
  return Lt.iterable && (e[Symbol.iterator] = function() {
    return e;
  }), e;
}
function et(t) {
  this.map = {}, t instanceof et ? t.forEach(function(e, n) {
    this.append(n, e);
  }, this) : Array.isArray(t) ? t.forEach(function(e) {
    if (e.length != 2)
      throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + e.length);
    this.append(e[0], e[1]);
  }, this) : t && Object.getOwnPropertyNames(t).forEach(function(e) {
    this.append(e, t[e]);
  }, this);
}
et.prototype.append = function(t, e) {
  t = Cc(t), e = Ly(e);
  var n = this.map[t];
  this.map[t] = n ? n + ", " + e : e;
};
et.prototype.delete = function(t) {
  delete this.map[Cc(t)];
};
et.prototype.get = function(t) {
  return t = Cc(t), this.has(t) ? this.map[t] : null;
};
et.prototype.has = function(t) {
  return this.map.hasOwnProperty(Cc(t));
};
et.prototype.set = function(t, e) {
  this.map[Cc(t)] = Ly(e);
};
et.prototype.forEach = function(t, e) {
  for (var n in this.map)
    this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this);
};
et.prototype.keys = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push(n);
  }), Hy(t);
};
et.prototype.values = function() {
  var t = [];
  return this.forEach(function(e) {
    t.push(e);
  }), Hy(t);
};
et.prototype.entries = function() {
  var t = [];
  return this.forEach(function(e, n) {
    t.push([n, e]);
  }), Hy(t);
};
Lt.iterable && (et.prototype[Symbol.iterator] = et.prototype.entries);
function Gh(t) {
  if (!t._noBody) {
    if (t.bodyUsed)
      return Promise.reject(new TypeError("Already read"));
    t.bodyUsed = !0;
  }
}
function Jv(t) {
  return new Promise(function(e, n) {
    t.onload = function() {
      e(t.result);
    }, t.onerror = function() {
      n(t.error);
    };
  });
}
function kz(t) {
  var e = new FileReader(), n = Jv(e);
  return e.readAsArrayBuffer(t), n;
}
function Cz(t) {
  var e = new FileReader(), n = Jv(e), r = /charset=([A-Za-z0-9_-]+)/.exec(t.type), s = r ? r[1] : "utf-8";
  return e.readAsText(t, s), n;
}
function Tz(t) {
  for (var e = new Uint8Array(t), n = new Array(e.length), r = 0; r < e.length; r++)
    n[r] = String.fromCharCode(e[r]);
  return n.join("");
}
function zw(t) {
  if (t.slice)
    return t.slice(0);
  var e = new Uint8Array(t.byteLength);
  return e.set(new Uint8Array(t)), e.buffer;
}
function Zv() {
  return this.bodyUsed = !1, this._initBody = function(t) {
    this.bodyUsed = this.bodyUsed, this._bodyInit = t, t ? typeof t == "string" ? this._bodyText = t : Lt.blob && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : Lt.formData && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : Lt.searchParams && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : Lt.arrayBuffer && Lt.blob && xz(t) ? (this._bodyArrayBuffer = zw(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : Lt.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(t) || vz(t)) ? this._bodyArrayBuffer = zw(t) : this._bodyText = t = Object.prototype.toString.call(t) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof t == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Lt.searchParams && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
  }, Lt.blob && (this.blob = function() {
    var t = Gh(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return Promise.resolve(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as blob");
    return Promise.resolve(new Blob([this._bodyText]));
  }), this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var t = Gh(this);
      return t || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
        this._bodyArrayBuffer.buffer.slice(
          this._bodyArrayBuffer.byteOffset,
          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
        )
      ) : Promise.resolve(this._bodyArrayBuffer));
    } else {
      if (Lt.blob)
        return this.blob().then(kz);
      throw new Error("could not read as ArrayBuffer");
    }
  }, this.text = function() {
    var t = Gh(this);
    if (t)
      return t;
    if (this._bodyBlob)
      return Cz(this._bodyBlob);
    if (this._bodyArrayBuffer)
      return Promise.resolve(Tz(this._bodyArrayBuffer));
    if (this._bodyFormData)
      throw new Error("could not read FormData body as text");
    return Promise.resolve(this._bodyText);
  }, Lt.formData && (this.formData = function() {
    return this.text().then(Bz);
  }), this.json = function() {
    return this.text().then(JSON.parse);
  }, this;
}
var Sz = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function Oz(t) {
  var e = t.toUpperCase();
  return Sz.indexOf(e) > -1 ? e : t;
}
function ki(t, e) {
  if (!(this instanceof ki))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  e = e || {};
  var n = e.body;
  if (t instanceof ki) {
    if (t.bodyUsed)
      throw new TypeError("Already read");
    this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new et(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, !n && t._bodyInit != null && (n = t._bodyInit, t.bodyUsed = !0);
  } else
    this.url = String(t);
  if (this.credentials = e.credentials || this.credentials || "same-origin", (e.headers || !this.headers) && (this.headers = new et(e.headers)), this.method = Oz(e.method || this.method || "GET"), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal || function() {
    if ("AbortController" in lt) {
      var a = new AbortController();
      return a.signal;
    }
  }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && n)
    throw new TypeError("Body not allowed for GET or HEAD requests");
  if (this._initBody(n), (this.method === "GET" || this.method === "HEAD") && (e.cache === "no-store" || e.cache === "no-cache")) {
    var r = /([?&])_=[^&]*/;
    if (r.test(this.url))
      this.url = this.url.replace(r, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
    else {
      var s = /\?/;
      this.url += (s.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
    }
  }
}
ki.prototype.clone = function() {
  return new ki(this, { body: this._bodyInit });
};
function Bz(t) {
  var e = new FormData();
  return t.trim().split("&").forEach(function(n) {
    if (n) {
      var r = n.split("="), s = r.shift().replace(/\+/g, " "), a = r.join("=").replace(/\+/g, " ");
      e.append(decodeURIComponent(s), decodeURIComponent(a));
    }
  }), e;
}
function Pz(t) {
  var e = new et(), n = t.replace(/\r?\n[\t ]+/g, " ");
  return n.split("\r").map(function(r) {
    return r.indexOf(`
`) === 0 ? r.substr(1, r.length) : r;
  }).forEach(function(r) {
    var s = r.split(":"), a = s.shift().trim();
    if (a) {
      var i = s.join(":").trim();
      try {
        e.append(a, i);
      } catch (o) {
        console.warn("Response " + o.message);
      }
    }
  }), e;
}
Zv.call(ki.prototype);
function Br(t, e) {
  if (!(this instanceof Br))
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  if (e || (e = {}), this.type = "default", this.status = e.status === void 0 ? 200 : e.status, this.status < 200 || this.status > 599)
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  this.ok = this.status >= 200 && this.status < 300, this.statusText = e.statusText === void 0 ? "" : "" + e.statusText, this.headers = new et(e.headers), this.url = e.url || "", this._initBody(t);
}
Zv.call(Br.prototype);
Br.prototype.clone = function() {
  return new Br(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new et(this.headers),
    url: this.url
  });
};
Br.error = function() {
  var t = new Br(null, { status: 200, statusText: "" });
  return t.ok = !1, t.status = 0, t.type = "error", t;
};
var Iz = [301, 302, 303, 307, 308];
Br.redirect = function(t, e) {
  if (Iz.indexOf(e) === -1)
    throw new RangeError("Invalid status code");
  return new Br(null, { status: e, headers: { location: t } });
};
var pa = lt.DOMException;
try {
  new pa();
} catch {
  pa = function(e, n) {
    this.message = e, this.name = n;
    var r = Error(e);
    this.stack = r.stack;
  }, pa.prototype = Object.create(Error.prototype), pa.prototype.constructor = pa;
}
function Xv(t, e) {
  return new Promise(function(n, r) {
    var s = new ki(t, e);
    if (s.signal && s.signal.aborted)
      return r(new pa("Aborted", "AbortError"));
    var a = new XMLHttpRequest();
    function i() {
      a.abort();
    }
    a.onload = function() {
      var u = {
        statusText: a.statusText,
        headers: Pz(a.getAllResponseHeaders() || "")
      };
      s.url.indexOf("file://") === 0 && (a.status < 200 || a.status > 599) ? u.status = 200 : u.status = a.status, u.url = "responseURL" in a ? a.responseURL : u.headers.get("X-Request-URL");
      var l = "response" in a ? a.response : a.responseText;
      setTimeout(function() {
        n(new Br(l, u));
      }, 0);
    }, a.onerror = function() {
      setTimeout(function() {
        r(new TypeError("Network request failed"));
      }, 0);
    }, a.ontimeout = function() {
      setTimeout(function() {
        r(new TypeError("Network request timed out"));
      }, 0);
    }, a.onabort = function() {
      setTimeout(function() {
        r(new pa("Aborted", "AbortError"));
      }, 0);
    };
    function o(u) {
      try {
        return u === "" && lt.location.href ? lt.location.href : u;
      } catch {
        return u;
      }
    }
    if (a.open(s.method, o(s.url), !0), s.credentials === "include" ? a.withCredentials = !0 : s.credentials === "omit" && (a.withCredentials = !1), "responseType" in a && (Lt.blob ? a.responseType = "blob" : Lt.arrayBuffer && (a.responseType = "arraybuffer")), e && typeof e.headers == "object" && !(e.headers instanceof et || lt.Headers && e.headers instanceof lt.Headers)) {
      var c = [];
      Object.getOwnPropertyNames(e.headers).forEach(function(u) {
        c.push(Cc(u)), a.setRequestHeader(u, Ly(e.headers[u]));
      }), s.headers.forEach(function(u, l) {
        c.indexOf(l) === -1 && a.setRequestHeader(l, u);
      });
    } else
      s.headers.forEach(function(u, l) {
        a.setRequestHeader(l, u);
      });
    s.signal && (s.signal.addEventListener("abort", i), a.onreadystatechange = function() {
      a.readyState === 4 && s.signal.removeEventListener("abort", i);
    }), a.send(typeof s._bodyInit > "u" ? null : s._bodyInit);
  });
}
Xv.polyfill = !0;
lt.fetch || (lt.fetch = Xv, lt.Headers = et, lt.Request = ki, lt.Response = Br);
var Uz = self.fetch.bind(self);
const Nz = /* @__PURE__ */ aC(Uz);
function Yv(t) {
  const e = Object.values(vu).find(
    (n) => n.id === t
  );
  if (!e)
    throw new Error(`Chain with id ${t} not found`);
  return e;
}
function Rz(t) {
  if (t === 42161)
    return new am.Rpc.RpcRelayer(
      "https://a1b4a8c5d856.ngrok.app/",
      t,
      "https://nodes.sequence.app/arbitrum"
    );
  if (t === 8453)
    return new am.Rpc.RpcRelayer(
      "https://644a6aeb891e.ngrok.app/",
      t,
      "https://nodes.sequence.app/base"
    );
}
function e8(t, e) {
  let n;
  if (t.env === "local") {
    if (e === 1)
      n = "http://0.0.0.0:9969";
    else if (e === 42161)
      n = "http://0.0.0.0:9997";
    else if (e === 10 || e === 420)
      n = "http://0.0.0.0:9998";
    else if (e === 137)
      n = "http://0.0.0.0:9999";
    else if (e === 8453)
      n = "http://0.0.0.0:9996";
    else
      return "";
    return n;
  }
  const r = t.env === "cors-anywhere" ? "http://localhost:8080/https://" : t.env === "dev" && t.useV3Relayers ? "https://v3-" : t.env === "dev" ? "https://dev-relayer.sequence.app" : "https://";
  return t.env === "dev" && t.useV3Relayers ? (e === 42161 ? n = "https://v3-arbitrum-relayer.sequence.app" : e === 8453 ? n = "https://v3-base-relayer.sequence.app" : e === 10 ? n = "https://v3-optimism-relayer.sequence.app" : e === 137 ? n = "https://v3-polygon-relayer.sequence.app" : e === 1 ? n = "https://v3-mainnet-relayer.sequence.app" : n = `${r}${Yv(e).name}-relayer.sequence.app`, n) : (e === 42161 ? n = `${r}arbitrum-relayer.sequence.app` : e === 10 ? n = `${r}optimism-relayer.sequence.app` : e === 137 ? n = `${r}polygon-relayer.sequence.app` : e === 8453 ? n = `${r}base-relayer.sequence.app` : e === 43114 ? n = `${r}avalanche-relayer.sequence.app` : e === 56 ? n = `${r}bsc-relayer.sequence.app` : e === 1 ? n = `${r}mainnet-relayer.sequence.app` : n = `${r}relayer.sequence.app`, n);
}
function Fz(t, e) {
  const n = Yv(e);
  if (!n)
    throw new Error(`Chain with id ${e} not found`);
  const r = n.rpcUrls.default.http[0];
  if (!r)
    throw new Error(`No RPC URL found for chain ${e}`);
  const s = e8(t, e);
  return new am.Rpc.RpcRelayer(s, e, r, Nz);
}
function HZ(t) {
  const e = Hf(() => /* @__PURE__ */ new Map(), []);
  return {
    relayers: e,
    getRelayer: (r) => {
      let s = e.get(r);
      return s || (s = Fz(t, r), e.set(r, s)), s;
    },
    getBackupRelayer: Rz
  };
}
function Mz({
  indexerGatewayUrl: t = iz,
  projectAccessKey: e,
  jwt: n
}) {
  return new e7(
    t,
    e,
    n
  );
}
const Dz = (t) => {
  const { projectAccessKey: e, jwt: n, env: r } = c2();
  return Hf(() => Mz({
    indexerGatewayUrl: (t == null ? void 0 : t.indexerGatewayUrl) ?? r.indexerGatewayUrl,
    projectAccessKey: (t == null ? void 0 : t.projectAccessKey) ?? e,
    jwt: (t == null ? void 0 : t.jwt) ?? n
  }), [e, n, r.indexerGatewayUrl, t]);
};
async function Lz(t, e, n) {
  const { opHash: r } = await t.sendMetaTxn(
    e.walletAddress,
    e.contract,
    e.input,
    BigInt(e.chainId),
    void 0,
    n
  );
  return r;
}
function t8() {
  return Se(pu.utils.randomPrivateKey());
}
function n8(t) {
  if (typeof t == "string") {
    if (!He(t, { strict: !1 }))
      throw new Je({ address: t });
    return {
      address: t,
      type: "json-rpc"
    };
  }
  if (!He(t.address, { strict: !1 }))
    throw new Je({ address: t.address });
  return {
    address: t.address,
    nonceManager: t.nonceManager,
    sign: t.sign,
    signAuthorization: t.signAuthorization,
    signMessage: t.signMessage,
    signTransaction: t.signTransaction,
    signTypedData: t.signTypedData,
    source: "custom",
    type: "local"
  };
}
function r8(t) {
  const e = qe(`0x${t.substring(4)}`).substring(26);
  return fp(`0x${e}`);
}
function Hz({ r: t, s: e, to: n = "hex", v: r, yParity: s }) {
  const a = (() => {
    if (s === 0 || s === 1)
      return s;
    if (r && (r === 27n || r === 28n || r >= 35n))
      return r % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), i = `0x${new pu.Signature(Te(t), Te(e)).toCompactHex()}${a === 0 ? "1b" : "1c"}`;
  return n === "hex" ? i : tn(i);
}
let $z = !1;
async function Cu({ hash: t, privateKey: e, to: n = "object" }) {
  const { r, s, recovery: a } = pu.sign(t.slice(2), e.slice(2), { lowS: !0, extraEntropy: $z }), i = {
    r: W(r, { size: 32 }),
    s: W(s, { size: 32 }),
    v: a ? 28n : 27n,
    yParity: a
  };
  return n === "bytes" || n === "hex" ? Hz({ ...i, to: n }) : i;
}
function s8(t) {
  const { chainId: e, nonce: n, to: r } = t, s = t.contractAddress ?? t.address, a = qe(Rn([
    "0x05",
    Or([
      e ? W(e) : "0x",
      s,
      n ? W(n) : "0x"
    ])
  ]));
  return r === "bytes" ? tn(a) : a;
}
async function _z(t) {
  const { chainId: e, nonce: n, privateKey: r, to: s = "object" } = t, a = t.contractAddress ?? t.address, i = await Cu({
    hash: s8({ address: a, chainId: e, nonce: n }),
    privateKey: r,
    to: s
  });
  return s === "object" ? {
    address: a,
    chainId: e,
    nonce: n,
    ...i
  } : i;
}
const Gz = `Ethereum Signed Message:
`;
function zz(t) {
  const e = typeof t == "string" ? $l(t) : typeof t.raw == "string" ? t.raw : Pt(t.raw), n = $l(`${Gz}${je(e)}`);
  return Ct([n, e]);
}
function Vz(t, e) {
  return qe(zz(t), e);
}
async function jz({ message: t, privateKey: e }) {
  return await Cu({ hash: Vz(t), privateKey: e, to: "hex" });
}
async function Kz(t) {
  const { privateKey: e, transaction: n, serializer: r = Ty } = t, s = n.type === "eip4844" ? {
    ...n,
    sidecars: !1
  } : n, a = await Cu({
    hash: qe(r(s)),
    privateKey: e
  });
  return r(n, a);
}
class qz extends D {
  constructor({ domain: e }) {
    super(`Invalid domain "${Pi(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class Wz extends D {
  constructor({ primaryType: e, types: n }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(n))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class Qz extends D {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function Jz(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (c, u) => {
    const l = { ...u };
    for (const d of c) {
      const { name: f, type: h } = d;
      h === "address" && (l[f] = l[f].toLowerCase());
    }
    return l;
  }, i = s.EIP712Domain ? e ? a(s.EIP712Domain, e) : {} : {}, o = (() => {
    if (r !== "EIP712Domain")
      return a(s[r], n);
  })();
  return Pi({ domain: i, message: o, primaryType: r, types: s });
}
function a8(t) {
  const { domain: e, message: n, primaryType: r, types: s } = t, a = (i, o) => {
    for (const c of i) {
      const { name: u, type: l } = c, d = o[u], f = l.match(Uv);
      if (f && (typeof d == "number" || typeof d == "bigint")) {
        const [b, g, w] = f;
        W(d, {
          signed: g === "int",
          size: Number.parseInt(w) / 8
        });
      }
      if (l === "address" && typeof d == "string" && !He(d))
        throw new Je({ address: d });
      const h = l.match(tD);
      if (h) {
        const [b, g] = h;
        if (g && je(d) !== Number.parseInt(g))
          throw new zM({
            expectedSize: Number.parseInt(g),
            givenSize: je(d)
          });
      }
      const y = s[l];
      y && (Zz(l), a(y, d));
    }
  };
  if (s.EIP712Domain && e) {
    if (typeof e != "object")
      throw new qz({ domain: e });
    a(s.EIP712Domain, e);
  }
  if (r !== "EIP712Domain")
    if (s[r])
      a(s[r], n);
    else
      throw new Wz({ primaryType: r, types: s });
}
function i8({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    (typeof (t == null ? void 0 : t.chainId) == "number" || typeof (t == null ? void 0 : t.chainId) == "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function Zz(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new Qz({ type: t });
}
function o8(t) {
  const { domain: e = {}, message: n, primaryType: r } = t, s = {
    EIP712Domain: i8({ domain: e }),
    ...t.types
  };
  a8({
    domain: e,
    message: n,
    primaryType: r,
    types: s
  });
  const a = ["0x1901"];
  return e && a.push(Xz({
    domain: e,
    types: s
  })), r !== "EIP712Domain" && a.push(c8({
    data: n,
    primaryType: r,
    types: s
  })), qe(Ct(a));
}
function Xz({ domain: t, types: e }) {
  return c8({
    data: t,
    primaryType: "EIP712Domain",
    types: e
  });
}
function c8({ data: t, primaryType: e, types: n }) {
  const r = l8({
    data: t,
    primaryType: e,
    types: n
  });
  return qe(r);
}
function l8({ data: t, primaryType: e, types: n }) {
  const r = [{ type: "bytes32" }], s = [Yz({ primaryType: e, types: n })];
  for (const a of n[e]) {
    const [i, o] = d8({
      types: n,
      name: a.name,
      type: a.type,
      value: t[a.name]
    });
    r.push(i), s.push(o);
  }
  return Ws(r, s);
}
function Yz({ primaryType: t, types: e }) {
  const n = Se(eV({ primaryType: t, types: e }));
  return qe(n);
}
function eV({ primaryType: t, types: e }) {
  let n = "";
  const r = u8({ primaryType: t, types: e });
  r.delete(t);
  const s = [t, ...Array.from(r).sort()];
  for (const a of s)
    n += `${a}(${e[a].map(({ name: i, type: o }) => `${o} ${i}`).join(",")})`;
  return n;
}
function u8({ primaryType: t, types: e }, n = /* @__PURE__ */ new Set()) {
  const r = t.match(/^\w*/u), s = r == null ? void 0 : r[0];
  if (n.has(s) || e[s] === void 0)
    return n;
  n.add(s);
  for (const a of e[s])
    u8({ primaryType: a.type, types: e }, n);
  return n;
}
function d8({ types: t, name: e, type: n, value: r }) {
  if (t[n] !== void 0)
    return [
      { type: "bytes32" },
      qe(l8({ data: r, primaryType: n, types: t }))
    ];
  if (n === "bytes")
    return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`, [{ type: "bytes32" }, qe(r)];
  if (n === "string")
    return [{ type: "bytes32" }, qe(Se(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const s = n.slice(0, n.lastIndexOf("[")), a = r.map((i) => d8({
      name: e,
      type: s,
      types: t,
      value: i
    }));
    return [
      { type: "bytes32" },
      qe(Ws(a.map(([i]) => i), a.map(([, i]) => i)))
    ];
  }
  return [{ type: n }, r];
}
async function tV(t) {
  const { privateKey: e, ...n } = t;
  return await Cu({
    hash: o8(n),
    privateKey: e,
    to: "hex"
  });
}
function df(t, e = {}) {
  const { nonceManager: n } = e, r = Se(pu.getPublicKey(t.slice(2), !1)), s = r8(r);
  return {
    ...n8({
      address: s,
      nonceManager: n,
      async sign({ hash: i }) {
        return Cu({ hash: i, privateKey: t, to: "hex" });
      },
      async signAuthorization(i) {
        return _z({ ...i, privateKey: t });
      },
      async signMessage({ message: i }) {
        return jz({ message: i, privateKey: t });
      },
      async signTransaction(i, { serializer: o } = {}) {
        return Kz({ privateKey: t, transaction: i, serializer: o });
      },
      async signTypedData(i) {
        return tV({ ...i, privateKey: t });
      }
    }),
    publicKey: r,
    source: "privateKey"
  };
}
async function f8(t, { address: e, blockTag: n = "latest", blockNumber: r }) {
  const s = await t.request({
    method: "eth_getTransactionCount",
    params: [
      e,
      typeof r == "bigint" ? W(r) : n
    ]
  }, {
    dedupe: !!r
  });
  return er(s);
}
function nV(t) {
  const { source: e } = t, n = /* @__PURE__ */ new Map(), r = new dp(8192), s = /* @__PURE__ */ new Map(), a = ({ address: i, chainId: o }) => `${i}.${o}`;
  return {
    async consume({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o }), l = this.get({ address: i, chainId: o, client: c });
      this.increment({ address: i, chainId: o });
      const d = await l;
      return await e.set({ address: i, chainId: o }, d), r.set(u, d), d;
    },
    async increment({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o }), u = n.get(c) ?? 0;
      n.set(c, u + 1);
    },
    async get({ address: i, chainId: o, client: c }) {
      const u = a({ address: i, chainId: o });
      let l = s.get(u);
      return l || (l = (async () => {
        try {
          const f = await e.get({ address: i, chainId: o, client: c }), h = r.get(u) ?? 0;
          return h > 0 && f <= h ? h + 1 : (r.delete(u), f);
        } finally {
          this.reset({ address: i, chainId: o });
        }
      })(), s.set(u, l)), (n.get(u) ?? 0) + await l;
    },
    reset({ address: i, chainId: o }) {
      const c = a({ address: i, chainId: o });
      n.delete(c), s.delete(c);
    }
  };
}
function rV(t, e) {
  var r, s;
  const n = Object.values(vu);
  for (const a of n)
    if (a.id === e)
      return `${(s = (r = a.blockExplorers) == null ? void 0 : r.default) == null ? void 0 : s.url}/tx/${t}`;
  return "";
}
const sV = {
  name: "permit",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "owner", type: "address" },
    { name: "spender", type: "address" },
    { name: "value", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "v", type: "uint8" },
    { name: "r", type: "bytes32" },
    { name: "s", type: "bytes32" }
  ],
  outputs: []
}, aV = {
  name: "transferFrom",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
}, iV = {
  name: "transfer",
  type: "function",
  stateMutability: "nonpayable",
  inputs: [
    { name: "to", type: "address" },
    { name: "amount", type: "uint256" }
  ],
  outputs: [{ name: "", type: "bool" }]
};
function p8(t, e, n, r, s) {
  const a = s.slice(2), i = `0x${a.slice(0, 64)}`, o = `0x${a.slice(64, 128)}`, c = parseInt(a.slice(128, 130), 16);
  return console.log("Split signature:", { r: i, s: o, v: c }), Xs({
    abi: [sV],
    functionName: "permit",
    args: [t, e, n, r, c, i, o]
  });
}
function h8(t, e, n) {
  return Xs({
    abi: [aV],
    functionName: "transferFrom",
    args: [t, e, n]
  });
}
function m8(t, e) {
  return Xs({
    abi: [iV],
    functionName: "transfer",
    args: [t, e]
  });
}
function oV(t, e, n, r, s, a, i) {
  const o = p8(
    t,
    e,
    n,
    r,
    s
  ), c = h8(
    t,
    e,
    n
  ), u = m8(a, n);
  return [o, c, u].map(
    (l) => ({
      to: i,
      data: l,
      value: "0"
    })
  );
}
async function b8(t, e, n, r, s, a, i) {
  if (!e.account)
    throw new Error("No account found");
  const o = BigInt(Math.floor(Date.now() / 1e3) + 3600), c = await t.readContract({
    address: s,
    abi: [
      {
        name: "nonces",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "owner", type: "address" }],
        outputs: [{ name: "", type: "uint256" }]
      }
    ],
    functionName: "nonces",
    args: [n]
  });
  console.log("Nonce:", c.toString());
  const u = await t.readContract({
    address: s,
    abi: [
      {
        name: "name",
        type: "function",
        stateMutability: "view",
        inputs: [],
        outputs: [{ name: "", type: "string" }]
      }
    ],
    functionName: "name"
  });
  let l = "1";
  try {
    l = await t.readContract({
      address: s,
      abi: [
        {
          name: "version",
          type: "function",
          stateMutability: "view",
          inputs: [],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "version"
    });
  } catch {
    console.warn('Token does not implement version(), defaulting to "1"');
  }
  const d = {
    name: u,
    version: l,
    chainId: i.id,
    verifyingContract: s
  }, f = {
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  }, h = {
    owner: n,
    spender: r,
    value: a,
    nonce: c,
    deadline: o
  };
  return await ku(e, i.id), console.log("Requesting permit signature..."), { signature: await e.signTypedData({
    account: e.account,
    domain: d,
    types: f,
    primaryType: "Permit",
    message: h
  }), deadline: o };
}
const cV = "0.1.1";
function lV() {
  return cV;
}
class zl extends Error {
  constructor(e, n = {}) {
    const r = (() => {
      var c;
      if (n.cause instanceof zl) {
        if (n.cause.details)
          return n.cause.details;
        if (n.cause.shortMessage)
          return n.cause.shortMessage;
      }
      return n.cause && "details" in n.cause && typeof n.cause.details == "string" ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), s = n.cause instanceof zl && n.cause.docsPath || n.docsPath, i = `https://oxlib.sh${s ?? ""}`, o = [
      e || "An error occurred.",
      ...n.metaMessages ? ["", ...n.metaMessages] : [],
      ...r || s ? [
        "",
        r ? `Details: ${r}` : void 0,
        s ? `See: ${i}` : void 0
      ] : []
    ].filter((c) => typeof c == "string").join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: `ox@${lV()}`
    }), this.cause = n.cause, this.details = r, this.docs = i, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return y8(this, e);
  }
}
function y8(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? y8(t.cause, e) : e ? null : t;
}
function uV(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0)
    return t;
  const s = t.replace("0x", "");
  if (s.length > r * 2)
    throw new pV({
      size: Math.ceil(s.length / 2),
      targetSize: r,
      type: "Hex"
    });
  return `0x${s[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function _r(t, e = {}) {
  const { signed: n, size: r } = e, s = BigInt(t);
  let a;
  r ? n ? a = (1n << BigInt(r) * 8n - 1n) - 1n : a = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof a == "bigint" && n ? -a - 1n : 0;
  if (a && s > a || s < i) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new fV({
      max: a ? `${a}${u}` : void 0,
      min: `${i}${u}`,
      signed: n,
      size: r,
      value: `${t}${u}`
    });
  }
  const c = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? dV(c, r) : c;
}
function dV(t, e) {
  return uV(t, { dir: "left", size: e });
}
class fV extends zl {
  constructor({ max: e, min: n, signed: r, size: s, value: a }) {
    super(`Number \`${a}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${r ? " signed" : " unsigned"} integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class pV extends zl {
  constructor({ size: e, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}
const zh = "/docs/contract/decodeFunctionResult";
function g8(t) {
  const { abi: e, args: n, functionName: r, data: s } = t;
  let a = e[0];
  if (r) {
    const o = Ry({ abi: e, args: n, name: r });
    if (!o)
      throw new uf(r, { docsPath: zh });
    a = o;
  }
  if (a.type !== "function")
    throw new uf(void 0, { docsPath: zh });
  if (!a.outputs)
    throw new _M(a.name, { docsPath: zh });
  const i = Nv(a.outputs, s);
  if (i && i.length > 1)
    return i;
  if (i && i.length === 1)
    return i[0];
}
const Vw = "/docs/contract/encodeFunctionData";
function hV(t) {
  const { abi: e, args: n, functionName: r } = t;
  let s = e[0];
  if (r) {
    const a = Ry({
      abi: e,
      args: n,
      name: r
    });
    if (!a)
      throw new uf(r, { docsPath: Vw });
    s = a;
  }
  if (s.type !== "function")
    throw new uf(void 0, { docsPath: Vw });
  return {
    abi: [s],
    functionName: Py(bc(s))
  };
}
function Tu(t) {
  const { args: e } = t, { abi: n, functionName: r } = (() => {
    var o;
    return t.abi.length === 1 && ((o = t.functionName) != null && o.startsWith("0x")) ? t : hV(t);
  })(), s = n[0], a = r, i = "inputs" in s && s.inputs ? Ws(s.inputs, e ?? []) : void 0;
  return Rn([a, i ?? "0x"]);
}
const mV = 3;
function bV(t, { abi: e, address: n, args: r, docsPath: s, functionName: a, sender: i }) {
  const o = t instanceof _v ? t : t instanceof D ? t.walk((y) => "data" in y) || t.walk() : {}, { code: c, data: u, details: l, message: d, shortMessage: f } = o, h = t instanceof By ? new $v({ functionName: a }) : [mV, pp.code].includes(c) && (u || l || d || f) ? new Hv({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: a,
    message: o instanceof Gv ? l : f ?? d
  }) : t;
  return new Lv(h, {
    abi: e,
    args: r,
    contractAddress: n,
    docsPath: s,
    functionName: a,
    sender: i
  });
}
function Fe(t, e, n) {
  const r = t[e.name];
  if (typeof r == "function")
    return r;
  const s = t[n];
  return typeof s == "function" ? s : (a) => e(t, a);
}
function yV(t) {
  return {
    address: t.address,
    amount: _r(t.amount),
    index: _r(t.index),
    validatorIndex: _r(t.validatorIndex)
  };
}
function gV(t) {
  return {
    ...typeof t.baseFeePerGas == "bigint" && {
      baseFeePerGas: _r(t.baseFeePerGas)
    },
    ...typeof t.blobBaseFee == "bigint" && {
      blobBaseFee: _r(t.blobBaseFee)
    },
    ...typeof t.feeRecipient == "string" && {
      feeRecipient: t.feeRecipient
    },
    ...typeof t.gasLimit == "bigint" && {
      gasLimit: _r(t.gasLimit)
    },
    ...typeof t.number == "bigint" && {
      number: _r(t.number)
    },
    ...typeof t.prevRandao == "bigint" && {
      prevRandao: _r(t.prevRandao)
    },
    ...typeof t.time == "bigint" && {
      time: _r(t.time)
    },
    ...t.withdrawals && {
      withdrawals: t.withdrawals.map(yV)
    }
  };
}
const jw = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], $Z = [
  {
    name: "query",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "tuple[]",
        name: "queries",
        components: [
          {
            type: "address",
            name: "sender"
          },
          {
            type: "string[]",
            name: "urls"
          },
          {
            type: "bytes",
            name: "data"
          }
        ]
      }
    ],
    outputs: [
      {
        type: "bool[]",
        name: "failures"
      },
      {
        type: "bytes[]",
        name: "responses"
      }
    ]
  },
  {
    name: "HttpError",
    type: "error",
    inputs: [
      {
        type: "uint16",
        name: "status"
      },
      {
        type: "string",
        name: "message"
      }
    ]
  }
], wV = "0x82ad56cb", EV = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", xV = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", Vh = "/docs/contract/encodeDeployData";
function w8(t) {
  const { abi: e, args: n, bytecode: r } = t;
  if (!n || n.length === 0)
    return r;
  const s = e.find((i) => "type" in i && i.type === "constructor");
  if (!s)
    throw new MM({ docsPath: Vh });
  if (!("inputs" in s))
    throw new Pw({ docsPath: Vh });
  if (!s.inputs || s.inputs.length === 0)
    throw new Pw({ docsPath: Vh });
  const a = Ws(s.inputs, n);
  return Rn([r, a]);
}
function E8() {
  let t = () => {
  }, e = () => {
  };
  return { promise: new Promise((r, s) => {
    t = r, e = s;
  }), resolve: t, reject: e };
}
const jh = /* @__PURE__ */ new Map();
function AV({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: s }) {
  const a = async () => {
    const l = c();
    i();
    const d = l.map(({ args: f }) => f);
    d.length !== 0 && t(d).then((f) => {
      s && Array.isArray(f) && f.sort(s);
      for (let h = 0; h < l.length; h++) {
        const { resolve: y } = l[h];
        y == null || y([f[h], f]);
      }
    }).catch((f) => {
      for (let h = 0; h < l.length; h++) {
        const { reject: y } = l[h];
        y == null || y(f);
      }
    });
  }, i = () => jh.delete(e), o = () => c().map(({ args: l }) => l), c = () => jh.get(e) || [], u = (l) => jh.set(e, [...c(), l]);
  return {
    flush: i,
    async schedule(l) {
      const { promise: d, resolve: f, reject: h } = E8();
      return (n == null ? void 0 : n([...o(), l])) && a(), c().length > 0 ? (u({ args: l, resolve: f, reject: h }), d) : (u({ args: l, resolve: f, reject: h }), setTimeout(a, r), d);
    }
  };
}
function Kw(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new kw({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new kw({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return e[n] = r, e;
    }, {});
}
function vV(t) {
  const { balance: e, nonce: n, state: r, stateDiff: s, code: a } = t, i = {};
  if (a !== void 0 && (i.code = a), e !== void 0 && (i.balance = W(e)), n !== void 0 && (i.nonce = W(n)), r !== void 0 && (i.state = Kw(r)), s !== void 0) {
    if (i.state)
      throw new wD();
    i.stateDiff = Kw(s);
  }
  return i;
}
function $y(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: n, ...r } of t) {
    if (!He(n, { strict: !1 }))
      throw new Je({ address: n });
    if (e[n])
      throw new gD({ address: n });
    e[n] = vV(r);
  }
  return e;
}
async function x8(t, e) {
  var $, _, R, M;
  const { account: n = t.account, authorizationList: r, batch: s = !!(($ = t.batch) != null && $.multicall), blockNumber: a, blockTag: i = "latest", accessList: o, blobs: c, blockOverrides: u, code: l, data: d, factory: f, factoryData: h, gas: y, gasPrice: b, maxFeePerBlobGas: g, maxFeePerGas: w, maxPriorityFeePerGas: v, nonce: A, to: P, value: x, stateOverride: O, ...I } = e, T = n ? ht(n) : void 0;
  if (l && (f || h))
    throw new D("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (l && P)
    throw new D("Cannot provide both `code` & `to` as parameters.");
  const C = l && d, N = f && h && P && d, U = C || N, L = C ? TV({
    code: l,
    data: d
  }) : N ? SV({
    data: d,
    factory: f,
    factoryData: h,
    to: P
  }) : d;
  try {
    Au(e);
    const G = (typeof a == "bigint" ? W(a) : void 0) || i, Z = u ? gV(u) : void 0, Y = $y(O), X = (M = (R = (_ = t.chain) == null ? void 0 : _.formatters) == null ? void 0 : R.transactionRequest) == null ? void 0 : M.format, J = (X || wu)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...bp(I, { format: X }),
      from: T == null ? void 0 : T.address,
      accessList: o,
      authorizationList: r,
      blobs: c,
      data: L,
      gas: y,
      gasPrice: b,
      maxFeePerBlobGas: g,
      maxFeePerGas: w,
      maxPriorityFeePerGas: v,
      nonce: A,
      to: U ? void 0 : P,
      value: x
    });
    if (s && kV({ request: J }) && !Y && !Z)
      try {
        return await CV(t, {
          ...J,
          blockNumber: a,
          blockTag: i
        });
      } catch (ae) {
        if (!(ae instanceof bv) && !(ae instanceof x0))
          throw ae;
      }
    const ce = (() => {
      const ae = [
        J,
        G
      ];
      return Y && Z ? [...ae, Y, Z] : Y ? [...ae, Y] : Z ? [...ae, {}, Z] : ae;
    })(), te = await t.request({
      method: "eth_call",
      params: ce
    });
    return te === "0x" ? { data: void 0 } : { data: te };
  } catch (j) {
    const G = OV(j), { offchainLookup: Z, offchainLookupSignature: Y } = await import("./ccip-CR-ZXKzK.js");
    if (t.ccipRead !== !1 && (G == null ? void 0 : G.slice(0, 10)) === Y && P)
      return { data: await Z(t, { data: G, to: P }) };
    throw U && (G == null ? void 0 : G.slice(0, 10)) === "0x101bb98d" ? new vD({ factory: f }) : jv(j, {
      ...e,
      account: T,
      chain: t.chain
    });
  }
}
function kV({ request: t }) {
  const { data: e, to: n, ...r } = t;
  return !(!e || e.startsWith(wV) || !n || Object.values(r).filter((s) => typeof s < "u").length > 0);
}
async function CV(t, e) {
  var b;
  const { batchSize: n = 1024, wait: r = 0 } = typeof ((b = t.batch) == null ? void 0 : b.multicall) == "object" ? t.batch.multicall : {}, { blockNumber: s, blockTag: a = "latest", data: i, multicallAddress: o, to: c } = e;
  let u = o;
  if (!u) {
    if (!t.chain)
      throw new bv();
    u = NN({
      blockNumber: s,
      chain: t.chain,
      contract: "multicall3"
    });
  }
  const d = (typeof s == "bigint" ? W(s) : void 0) || a, { schedule: f } = AV({
    id: `${t.uid}.${d}`,
    wait: r,
    shouldSplitBatch(g) {
      return g.reduce((v, { data: A }) => v + (A.length - 2), 0) > n * 2;
    },
    fn: async (g) => {
      const w = g.map((P) => ({
        allowFailure: !0,
        callData: P.data,
        target: P.to
      })), v = Tu({
        abi: jw,
        args: [w],
        functionName: "aggregate3"
      }), A = await t.request({
        method: "eth_call",
        params: [
          {
            data: v,
            to: u
          },
          d
        ]
      });
      return g8({
        abi: jw,
        args: [w],
        functionName: "aggregate3",
        data: A || "0x"
      });
    }
  }), [{ returnData: h, success: y }] = await f({ data: i, to: c });
  if (!y)
    throw new _v({ data: h });
  return h === "0x" ? { data: void 0 } : { data: h };
}
function TV(t) {
  const { code: e, data: n } = t;
  return w8({
    abi: _f(["constructor(bytes, bytes)"]),
    bytecode: EV,
    args: [e, n]
  });
}
function SV(t) {
  const { data: e, factory: n, factoryData: r, to: s } = t;
  return w8({
    abi: _f(["constructor(address, bytes, address, bytes)"]),
    bytecode: xV,
    args: [s, e, n, r]
  });
}
function OV(t) {
  var n;
  if (!(t instanceof D))
    return;
  const e = t.walk();
  return typeof (e == null ? void 0 : e.data) == "object" ? (n = e.data) == null ? void 0 : n.data : e.data;
}
async function A8(t, e) {
  const { abi: n, address: r, args: s, functionName: a, ...i } = e, o = Tu({
    abi: n,
    args: s,
    functionName: a
  });
  try {
    const { data: c } = await Fe(t, x8, "call")({
      ...i,
      data: o,
      to: r
    });
    return g8({
      abi: n,
      args: s,
      functionName: a,
      data: c || "0x"
    });
  } catch (c) {
    throw bV(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/readContract",
      functionName: a
    });
  }
}
const qw = [
  {
    inputs: [
      { name: "success", type: "bool" },
      { name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" },
      { name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "factory",
        type: "address"
      },
      {
        indexed: !1,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: !1, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !0,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      { indexed: !1, name: "success", type: "bool" },
      {
        indexed: !1,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: !0,
        name: "sender",
        type: "address"
      },
      {
        indexed: !1,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: !1,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: !1,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint256" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint256" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "gasFees", type: "bytes32" },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
function v8(t) {
  const { authorization: e, factory: n, factoryData: r } = t;
  if (n === "0x7702" || n === "0x7702000000000000000000000000000000000000") {
    if (!e)
      return "0x7702000000000000000000000000000000000000";
    const s = e.address;
    return Ct([s, r ?? "0x"]);
  }
  return n ? Ct([n, r ?? "0x"]) : "0x";
}
async function Ww(t) {
  return new Promise((e) => setTimeout(e, t));
}
function BV(t, e) {
  if (!He(t, { strict: !1 }))
    throw new Je({ address: t });
  if (!He(e, { strict: !1 }))
    throw new Je({ address: e });
  return t.toLowerCase() === e.toLowerCase();
}
async function PV({ hash: t, signature: e }) {
  const n = sa(t) ? t : Se(t), { secp256k1: r } = await Promise.resolve().then(() => hS);
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: u, s: l, v: d, yParity: f } = e, h = Number(f ?? d), y = Qw(h);
      return new r.Signature(Te(u), Te(l)).addRecoveryBit(y);
    }
    const i = sa(e) ? e : Se(e);
    if (je(i) !== 65)
      throw new Error("invalid signature length");
    const o = er(`0x${i.slice(130)}`), c = Qw(o);
    return r.Signature.fromCompact(i.substring(2, 130)).addRecoveryBit(c);
  })().recoverPublicKey(n.substring(2)).toHex(!1)}`;
}
function Qw(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function IV({ hash: t, signature: e }) {
  return r8(await PV({ hash: t, signature: e }));
}
async function k8(t) {
  const { authorization: e, signature: n } = t;
  return IV({
    hash: s8(e),
    signature: n ?? e
  });
}
class UV extends D {
  constructor(e, { account: n, docsPath: r, chain: s, data: a, gas: i, gasPrice: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, to: d, value: f }) {
    var y;
    const h = Ac({
      from: n == null ? void 0 : n.address,
      to: d,
      value: typeof f < "u" && `${xy(f)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || "ETH"}`,
      data: a,
      gas: i,
      gasPrice: typeof o < "u" && `${Tt(o)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Tt(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Tt(u)} gwei`,
      nonce: l
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        h
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
function NV(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = Fy(t, n);
    return s instanceof up ? t : s;
  })();
  return new UV(r, {
    docsPath: e,
    ...n
  });
}
function C8(t, { docsPath: e, ...n }) {
  const r = (() => {
    const s = Fy(t, n);
    return s instanceof up ? t : s;
  })();
  return new wI(r, {
    docsPath: e,
    ...n
  });
}
const RV = "0x6492649264926492649264926492649264926492649264926492649264926492";
function Kh(t) {
  const { address: e, data: n, signature: r, to: s = "hex" } = t, a = Rn([
    Ws([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [e, n, r]),
    RV
  ]);
  return s === "hex" ? a : tn(a);
}
function T8(t) {
  const { callGasLimit: e, callData: n, maxPriorityFeePerGas: r, maxFeePerGas: s, paymaster: a, paymasterData: i, paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, sender: u, signature: l = "0x", verificationGasLimit: d } = t, f = Ct([
    At(W(d || 0n), { size: 16 }),
    At(W(e || 0n), { size: 16 })
  ]), h = v8(t), y = Ct([
    At(W(r || 0n), { size: 16 }),
    At(W(s || 0n), { size: 16 })
  ]), b = t.nonce ?? 0n, g = a ? Ct([
    a,
    At(W(c || 0n), {
      size: 16
    }),
    At(W(o || 0n), {
      size: 16
    }),
    i || "0x"
  ]) : "0x", w = t.preVerificationGas ?? 0n;
  return {
    accountGasLimits: f,
    callData: n,
    initCode: h,
    gasFees: y,
    nonce: b,
    paymasterAndData: g,
    preVerificationGas: w,
    sender: u,
    signature: l
  };
}
const FV = {
  PackedUserOperation: [
    { type: "address", name: "sender" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "bytes32", name: "accountGasLimits" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "bytes32", name: "gasFees" },
    { type: "bytes", name: "paymasterAndData" }
  ]
};
function MV(t) {
  const { chainId: e, entryPointAddress: n, userOperation: r } = t, s = T8(r);
  return {
    types: FV,
    primaryType: "PackedUserOperation",
    domain: {
      name: "ERC4337",
      version: "1",
      chainId: e,
      verifyingContract: n
    },
    message: s
  };
}
function DV(t) {
  const { chainId: e, entryPointAddress: n, entryPointVersion: r } = t, s = t.userOperation, { authorization: a, callData: i = "0x", callGasLimit: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymasterAndData: d = "0x", preVerificationGas: f, sender: h, verificationGasLimit: y } = s;
  if (r === "0.8")
    return o8(MV({
      chainId: e,
      entryPointAddress: n,
      userOperation: s
    }));
  const b = (() => {
    var g, w;
    if (r === "0.6") {
      const v = (g = s.initCode) == null ? void 0 : g.slice(0, 42), A = (w = s.initCode) == null ? void 0 : w.slice(42), P = v8({
        authorization: a,
        factory: v,
        factoryData: A
      });
      return Ws([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        h,
        l,
        qe(P),
        qe(i),
        o,
        y,
        f,
        c,
        u,
        qe(d)
      ]);
    }
    if (r === "0.7") {
      const v = T8(s);
      return Ws([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        v.sender,
        v.nonce,
        qe(v.initCode),
        qe(v.callData),
        v.accountGasLimits,
        v.preVerificationGas,
        v.gasFees,
        qe(v.paymasterAndData)
      ]);
    }
    throw new Error(`entryPointVersion "${r}" not supported.`);
  })();
  return qe(Ws([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [qe(b), n, BigInt(e)]));
}
async function LV(t, { address: e, blockNumber: n, blockTag: r = "latest" }) {
  const s = n !== void 0 ? W(n) : void 0, a = await t.request({
    method: "eth_getCode",
    params: [e, s || r]
  }, { dedupe: !!s });
  if (a !== "0x")
    return a;
}
async function HV(t) {
  const { extend: e, nonceKeyManager: n = nV({
    source: {
      get() {
        return Date.now();
      },
      set() {
      }
    }
  }), ...r } = t;
  let s = !1;
  const a = await t.getAddress();
  return {
    ...e,
    ...r,
    address: a,
    async getFactoryArgs() {
      return "isDeployed" in this && await this.isDeployed() ? { factory: void 0, factoryData: void 0 } : t.getFactoryArgs();
    },
    async getNonce(i) {
      const o = (i == null ? void 0 : i.key) ?? BigInt(await n.consume({
        address: a,
        chainId: t.client.chain.id,
        client: t.client
      }));
      return t.getNonce ? await t.getNonce({ ...i, key: o }) : await A8(t.client, {
        abi: _f([
          "function getNonce(address, uint192) pure returns (uint256)"
        ]),
        address: t.entryPoint.address,
        functionName: "getNonce",
        args: [a, o]
      });
    },
    async isDeployed() {
      return s ? !0 : (s = !!await Fe(t.client, LV, "getCode")({
        address: a
      }), s);
    },
    ...t.sign ? {
      async sign(i) {
        const [{ factory: o, factoryData: c }, u] = await Promise.all([
          this.getFactoryArgs(),
          t.sign(i)
        ]);
        return o && c ? Kh({
          address: o,
          data: c,
          signature: u
        }) : u;
      }
    } : {},
    async signMessage(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signMessage(i)
      ]);
      return o && c && o !== "0x7702" ? Kh({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    async signTypedData(i) {
      const [{ factory: o, factoryData: c }, u] = await Promise.all([
        this.getFactoryArgs(),
        t.signTypedData(i)
      ]);
      return o && c && o !== "0x7702" ? Kh({
        address: o,
        data: c,
        signature: u
      }) : u;
    },
    type: "smart"
  };
}
async function $V(t, { account: e = t.account, message: n }) {
  if (!e)
    throw new ca({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const r = ht(e);
  if (r.signMessage)
    return r.signMessage({ message: n });
  const s = typeof n == "string" ? $l(n) : n.raw instanceof Uint8Array ? Se(n.raw) : n.raw;
  return t.request({
    method: "personal_sign",
    params: [s, r.address]
  }, { retryCount: 0 });
}
async function _V(t, e) {
  const { account: n = t.account, domain: r, message: s, primaryType: a } = e;
  if (!n)
    throw new ca({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const i = ht(n), o = {
    EIP712Domain: i8({ domain: r }),
    ...e.types
  };
  if (a8({ domain: r, message: s, primaryType: a, types: o }), i.signTypedData)
    return i.signTypedData({ domain: r, message: s, primaryType: a, types: o });
  const c = Jz({ domain: r, message: s, primaryType: a, types: o });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [i.address, c]
  }, { retryCount: 0 });
}
class F0 extends D {
  constructor({ cause: e }) {
    super("Smart Account is not deployed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.",
        "- An incorrect `sender` address is provided."
      ],
      name: "AccountNotDeployedError"
    });
  }
}
Object.defineProperty(F0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa20/
});
class yc extends D {
  constructor({ cause: e, data: n, message: r } = {}) {
    var a;
    const s = (a = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : a.replace("execution reverted", "");
    super(`Execution reverted ${s ? `with reason: ${s}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n;
  }
}
Object.defineProperty(yc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32521
});
Object.defineProperty(yc, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class M0 extends D {
  constructor({ cause: e }) {
    super("Failed to send funds to beneficiary.", {
      cause: e,
      name: "FailedToSendToBeneficiaryError"
    });
  }
}
Object.defineProperty(M0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa91/
});
class D0 extends D {
  constructor({ cause: e }) {
    super("Gas value overflowed.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- one of the gas values exceeded 2**120 (uint120)"
      ].filter(Boolean),
      name: "GasValuesOverflowError"
    });
  }
}
Object.defineProperty(D0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa94/
});
class L0 extends D {
  constructor({ cause: e }) {
    super("The `handleOps` function was called by the Bundler with a gas limit too low.", {
      cause: e,
      name: "HandleOpsOutOfGasError"
    });
  }
}
Object.defineProperty(L0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa95/
});
class H0 extends D {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Failed to simulate deployment for Smart Account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- Invalid `factory`/`factoryData` or `initCode` properties are present",
        "- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)",
        `- Smart Account deployment execution reverted with an error
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeFailedError"
    });
  }
}
Object.defineProperty(H0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa13/
});
class $0 extends D {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account initialization implementation did not create an account.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- `factory`/`factoryData` or `initCode` properties are invalid",
        `- Smart Account initialization implementation is incorrect
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`
      ].filter(Boolean),
      name: "InitCodeMustCreateSenderError"
    });
  }
}
Object.defineProperty($0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa15/
});
class _0 extends D {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s, sender: a }) {
    super("Smart Account initialization implementation does not return the expected sender.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        `Smart Account initialization implementation does not return a sender address
`,
        n && `factory: ${n}`,
        r && `factoryData: ${r}`,
        s && `initCode: ${s}`,
        a && `sender: ${a}`
      ].filter(Boolean),
      name: "InitCodeMustReturnSenderError"
    });
  }
}
Object.defineProperty(_0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa14/
});
class G0 extends D {
  constructor({ cause: e }) {
    super("Smart Account does not have sufficient funds to execute the User Operation.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Smart Account does not have sufficient funds to cover the required prefund, or",
        "- a Paymaster was not provided"
      ].filter(Boolean),
      name: "InsufficientPrefundError"
    });
  }
}
Object.defineProperty(G0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa21/
});
class z0 extends D {
  constructor({ cause: e }) {
    super("Bundler attempted to call an invalid function on the EntryPoint.", {
      cause: e,
      name: "InternalCallOnlyError"
    });
  }
}
Object.defineProperty(z0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa92/
});
class V0 extends D {
  constructor({ cause: e }) {
    super("Bundler used an invalid aggregator for handling aggregated User Operations.", {
      cause: e,
      name: "InvalidAggregatorError"
    });
  }
}
Object.defineProperty(V0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa96/
});
class j0 extends D {
  constructor({ cause: e, nonce: n }) {
    super("Invalid Smart Account nonce used for User Operation.", {
      cause: e,
      metaMessages: [n && `nonce: ${n}`].filter(Boolean),
      name: "InvalidAccountNonceError"
    });
  }
}
Object.defineProperty(j0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa25/
});
class K0 extends D {
  constructor({ cause: e }) {
    super("Bundler has not set a beneficiary address.", {
      cause: e,
      name: "InvalidBeneficiaryError"
    });
  }
}
Object.defineProperty(K0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa90/
});
class ff extends D {
  constructor({ cause: e }) {
    super("Invalid fields set on User Operation.", {
      cause: e,
      name: "InvalidFieldsError"
    });
  }
}
Object.defineProperty(ff, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class q0 extends D {
  constructor({ cause: e, paymasterAndData: n }) {
    super("Paymaster properties provided are invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `paymasterAndData` property is of an incorrect length\n",
        n && `paymasterAndData: ${n}`
      ].filter(Boolean),
      name: "InvalidPaymasterAndDataError"
    });
  }
}
Object.defineProperty(q0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa93/
});
class ka extends D {
  constructor({ cause: e }) {
    super("Paymaster deposit for the User Operation is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the Paymaster has deposited less than the expected amount via the `deposit` function"
      ].filter(Boolean),
      name: "PaymasterDepositTooLowError"
    });
  }
}
Object.defineProperty(ka, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32508
});
Object.defineProperty(ka, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa31/
});
class W0 extends D {
  constructor({ cause: e }) {
    super("The `validatePaymasterUserOp` function on the Paymaster reverted.", {
      cause: e,
      name: "PaymasterFunctionRevertedError"
    });
  }
}
Object.defineProperty(W0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa33/
});
class Q0 extends D {
  constructor({ cause: e }) {
    super("The Paymaster contract has not been deployed.", {
      cause: e,
      name: "PaymasterNotDeployedError"
    });
  }
}
Object.defineProperty(Q0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa30/
});
class pf extends D {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterRateLimitError"
    });
  }
}
Object.defineProperty(pf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32504
});
class hf extends D {
  constructor({ cause: e }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: e,
      name: "PaymasterStakeTooLowError"
    });
  }
}
Object.defineProperty(hf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32505
});
class J0 extends D {
  constructor({ cause: e }) {
    super("Paymaster `postOp` function reverted.", {
      cause: e,
      name: "PaymasterPostOpFunctionRevertedError"
    });
  }
}
Object.defineProperty(J0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa50/
});
class Z0 extends D {
  constructor({ cause: e, factory: n, factoryData: r, initCode: s }) {
    super("Smart Account has already been deployed.", {
      cause: e,
      metaMessages: [
        "Remove the following properties and try again:",
        n && "`factory`",
        r && "`factoryData`",
        s && "`initCode`"
      ].filter(Boolean),
      name: "SenderAlreadyConstructedError"
    });
  }
}
Object.defineProperty(Z0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa10/
});
class mf extends D {
  constructor({ cause: e }) {
    super("UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).", {
      cause: e,
      name: "SignatureCheckFailedError"
    });
  }
}
Object.defineProperty(mf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32507
});
class X0 extends D {
  constructor({ cause: e }) {
    super("The `validateUserOp` function on the Smart Account reverted.", {
      cause: e,
      name: "SmartAccountFunctionRevertedError"
    });
  }
}
Object.defineProperty(X0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa23/
});
class bf extends D {
  constructor({ cause: e }) {
    super("UserOperation rejected because account specified unsupported signature aggregator.", {
      cause: e,
      name: "UnsupportedSignatureAggregatorError"
    });
  }
}
Object.defineProperty(bf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32506
});
class Y0 extends D {
  constructor({ cause: e }) {
    super("User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied"
      ].filter(Boolean),
      name: "UserOperationExpiredError"
    });
  }
}
Object.defineProperty(Y0, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa22/
});
class eb extends D {
  constructor({ cause: e }) {
    super("Paymaster for User Operation expired.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied"
      ].filter(Boolean),
      name: "UserOperationPaymasterExpiredError"
    });
  }
}
Object.defineProperty(eb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa32/
});
class tb extends D {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account"
      ].filter(Boolean),
      name: "UserOperationSignatureError"
    });
  }
}
Object.defineProperty(tb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa24/
});
class nb extends D {
  constructor({ cause: e }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster"
      ].filter(Boolean),
      name: "UserOperationPaymasterSignatureError"
    });
  }
}
Object.defineProperty(nb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa34/
});
class yf extends D {
  constructor({ cause: e }) {
    super("User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.", {
      cause: e,
      name: "UserOperationRejectedByEntryPointError"
    });
  }
}
Object.defineProperty(yf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32500
});
class gf extends D {
  constructor({ cause: e }) {
    super("User Operation rejected by Paymaster's `validatePaymasterUserOp`.", {
      cause: e,
      name: "UserOperationRejectedByPaymasterError"
    });
  }
}
Object.defineProperty(gf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32501
});
class wf extends D {
  constructor({ cause: e }) {
    super("User Operation rejected with op code validation error.", {
      cause: e,
      name: "UserOperationRejectedByOpCodeError"
    });
  }
}
Object.defineProperty(wf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32502
});
class Ef extends D {
  constructor({ cause: e }) {
    super("UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).", {
      cause: e,
      name: "UserOperationOutOfTimeRangeError"
    });
  }
}
Object.defineProperty(Ef, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32503
});
class GV extends D {
  constructor({ cause: e }) {
    super(`An error occurred while executing user operation: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownBundlerError"
    });
  }
}
class rb extends D {
  constructor({ cause: e }) {
    super("User Operation verification gas limit exceeded.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the gas used for verification exceeded the `verificationGasLimit`"
      ].filter(Boolean),
      name: "VerificationGasLimitExceededError"
    });
  }
}
Object.defineProperty(rb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa40/
});
class sb extends D {
  constructor({ cause: e }) {
    super("User Operation verification gas limit is too low.", {
      cause: e,
      metaMessages: [
        "This could arise when:",
        "- the `verificationGasLimit` is too low to verify the User Operation"
      ].filter(Boolean),
      name: "VerificationGasLimitTooLowError"
    });
  }
}
Object.defineProperty(sb, "message", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /aa41/
});
class zV extends D {
  constructor(e, { callData: n, callGasLimit: r, docsPath: s, factory: a, factoryData: i, initCode: o, maxFeePerGas: c, maxPriorityFeePerGas: u, nonce: l, paymaster: d, paymasterAndData: f, paymasterData: h, paymasterPostOpGasLimit: y, paymasterVerificationGasLimit: b, preVerificationGas: g, sender: w, signature: v, verificationGasLimit: A }) {
    const P = Ac({
      callData: n,
      callGasLimit: r,
      factory: a,
      factoryData: i,
      initCode: o,
      maxFeePerGas: typeof c < "u" && `${Tt(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${Tt(u)} gwei`,
      nonce: l,
      paymaster: d,
      paymasterAndData: f,
      paymasterData: h,
      paymasterPostOpGasLimit: y,
      paymasterVerificationGasLimit: b,
      preVerificationGas: g,
      sender: w,
      signature: v,
      verificationGasLimit: A
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        P
      ].filter(Boolean),
      name: "UserOperationExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class VV extends D {
  constructor({ hash: e }) {
    super(`User Operation receipt with hash "${e}" could not be found. The User Operation may not have been processed yet.`, { name: "UserOperationReceiptNotFoundError" });
  }
}
class jV extends D {
  constructor({ hash: e }) {
    super(`User Operation with hash "${e}" could not be found.`, {
      name: "UserOperationNotFoundError"
    });
  }
}
class Jw extends D {
  constructor({ hash: e }) {
    super(`Timed out while waiting for User Operation with hash "${e}" to be confirmed.`, { name: "WaitForUserOperationReceiptTimeoutError" });
  }
}
const KV = [
  yc,
  ff,
  ka,
  pf,
  hf,
  mf,
  bf,
  Ef,
  yf,
  gf,
  wf
];
function qV(t, e) {
  const n = (t.details || "").toLowerCase();
  if (F0.message.test(n))
    return new F0({
      cause: t
    });
  if (M0.message.test(n))
    return new M0({
      cause: t
    });
  if (D0.message.test(n))
    return new D0({
      cause: t
    });
  if (L0.message.test(n))
    return new L0({
      cause: t
    });
  if (H0.message.test(n))
    return new H0({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if ($0.message.test(n))
    return new $0({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (_0.message.test(n))
    return new _0({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode,
      sender: e.sender
    });
  if (G0.message.test(n))
    return new G0({
      cause: t
    });
  if (z0.message.test(n))
    return new z0({
      cause: t
    });
  if (j0.message.test(n))
    return new j0({
      cause: t,
      nonce: e.nonce
    });
  if (V0.message.test(n))
    return new V0({
      cause: t
    });
  if (K0.message.test(n))
    return new K0({
      cause: t
    });
  if (q0.message.test(n))
    return new q0({
      cause: t
    });
  if (ka.message.test(n))
    return new ka({
      cause: t
    });
  if (W0.message.test(n))
    return new W0({
      cause: t
    });
  if (Q0.message.test(n))
    return new Q0({
      cause: t
    });
  if (J0.message.test(n))
    return new J0({
      cause: t
    });
  if (X0.message.test(n))
    return new X0({
      cause: t
    });
  if (Z0.message.test(n))
    return new Z0({
      cause: t,
      factory: e.factory,
      factoryData: e.factoryData,
      initCode: e.initCode
    });
  if (Y0.message.test(n))
    return new Y0({
      cause: t
    });
  if (eb.message.test(n))
    return new eb({
      cause: t
    });
  if (nb.message.test(n))
    return new nb({
      cause: t
    });
  if (tb.message.test(n))
    return new tb({
      cause: t
    });
  if (rb.message.test(n))
    return new rb({
      cause: t
    });
  if (sb.message.test(n))
    return new sb({
      cause: t
    });
  const r = t.walk((s) => KV.some((a) => a.code === s.code));
  if (r) {
    if (r.code === yc.code)
      return new yc({
        cause: t,
        data: r.data,
        message: r.details
      });
    if (r.code === ff.code)
      return new ff({
        cause: t
      });
    if (r.code === ka.code)
      return new ka({
        cause: t
      });
    if (r.code === pf.code)
      return new pf({
        cause: t
      });
    if (r.code === hf.code)
      return new hf({
        cause: t
      });
    if (r.code === mf.code)
      return new mf({
        cause: t
      });
    if (r.code === bf.code)
      return new bf({
        cause: t
      });
    if (r.code === Ef.code)
      return new Ef({
        cause: t
      });
    if (r.code === yf.code)
      return new yf({
        cause: t
      });
    if (r.code === gf.code)
      return new gf({
        cause: t
      });
    if (r.code === wf.code)
      return new wf({
        cause: t
      });
  }
  return new GV({
    cause: t
  });
}
function S8(t, { calls: e, docsPath: n, ...r }) {
  const s = (() => {
    const a = qV(t, r);
    if (e && a instanceof yc) {
      const i = WV(a), o = e == null ? void 0 : e.filter((c) => c.abi);
      if (i && o.length > 0)
        return QV({ calls: o, revertData: i });
    }
    return a;
  })();
  return new zV(s, {
    docsPath: n,
    ...r
  });
}
function WV(t) {
  let e;
  return t.walk((n) => {
    var s, a, i, o;
    const r = n;
    if (typeof r.data == "string" || typeof ((s = r.data) == null ? void 0 : s.revertData) == "string" || !(r instanceof D) && typeof r.message == "string") {
      const c = (o = (i = ((a = r.data) == null ? void 0 : a.revertData) || r.data || r.message).match) == null ? void 0 : o.call(i, /(0x[A-Za-z0-9]*)/);
      if (c)
        return e = c[1], !0;
    }
    return !1;
  }), e;
}
function QV(t) {
  const { calls: e, revertData: n } = t, { abi: r, functionName: s, args: a, to: i } = (() => {
    const c = e == null ? void 0 : e.filter((l) => !!l.abi);
    if (c.length === 1)
      return c[0];
    const u = c.filter((l) => {
      try {
        return !!Rv({
          abi: l.abi,
          data: n
        });
      } catch {
        return !1;
      }
    });
    return u.length === 1 ? u[0] : {
      abi: [],
      functionName: c.reduce((l, d) => `${l ? `${l} | ` : ""}${d.functionName}`, ""),
      args: void 0,
      to: void 0
    };
  })(), o = n === "0x" ? new $v({ functionName: s }) : new Hv({
    abi: r,
    data: n,
    functionName: s
  });
  return new Lv(o, {
    abi: r,
    args: a,
    contractAddress: i,
    functionName: s
  });
}
function JV(t) {
  const e = {};
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), e;
}
function yp(t) {
  const e = {};
  return typeof t.callData < "u" && (e.callData = t.callData), typeof t.callGasLimit < "u" && (e.callGasLimit = W(t.callGasLimit)), typeof t.factory < "u" && (e.factory = t.factory), typeof t.factoryData < "u" && (e.factoryData = t.factoryData), typeof t.initCode < "u" && (e.initCode = t.initCode), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = W(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = W(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = W(t.nonce)), typeof t.paymaster < "u" && (e.paymaster = t.paymaster), typeof t.paymasterAndData < "u" && (e.paymasterAndData = t.paymasterAndData || "0x"), typeof t.paymasterData < "u" && (e.paymasterData = t.paymasterData), typeof t.paymasterPostOpGasLimit < "u" && (e.paymasterPostOpGasLimit = W(t.paymasterPostOpGasLimit)), typeof t.paymasterVerificationGasLimit < "u" && (e.paymasterVerificationGasLimit = W(t.paymasterVerificationGasLimit)), typeof t.preVerificationGas < "u" && (e.preVerificationGas = W(t.preVerificationGas)), typeof t.sender < "u" && (e.sender = t.sender), typeof t.signature < "u" && (e.signature = t.signature), typeof t.verificationGasLimit < "u" && (e.verificationGasLimit = W(t.verificationGasLimit)), typeof t.authorization < "u" && (e.eip7702Auth = ZV(t.authorization)), e;
}
function ZV(t) {
  return {
    address: t.address,
    chainId: W(t.chainId),
    nonce: W(t.nonce),
    r: t.r ? W(BigInt(t.r), { size: 32 }) : At("0x", { size: 32 }),
    s: t.s ? W(BigInt(t.s), { size: 32 }) : At("0x", { size: 32 }),
    yParity: t.yParity ? W(t.yParity, { size: 1 }) : At("0x", { size: 32 })
  };
}
async function Tc(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return er(e);
}
class XV extends D {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class _y extends D {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class YV extends D {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Tt(e)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class ej extends D {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = "Block";
    e && (r = `Block at hash "${e}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
async function xf(t, { blockHash: e, blockNumber: n, blockTag: r, includeTransactions: s } = {}) {
  var l, d, f;
  const a = r ?? "latest", i = s ?? !1, o = n !== void 0 ? W(n) : void 0;
  let c = null;
  if (e ? c = await t.request({
    method: "eth_getBlockByHash",
    params: [e, i]
  }, { dedupe: !0 }) : c = await t.request({
    method: "eth_getBlockByNumber",
    params: [o || a, i]
  }, { dedupe: !!o }), !c)
    throw new ej({ blockHash: e, blockNumber: n });
  return (((f = (d = (l = t.chain) == null ? void 0 : l.formatters) == null ? void 0 : d.block) == null ? void 0 : f.format) || ev)(c);
}
async function O8(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function tj(t, e) {
  var a, i;
  const { block: n, chain: r = t.chain, request: s } = e || {};
  try {
    const o = ((a = r == null ? void 0 : r.fees) == null ? void 0 : a.maxPriorityFeePerGas) ?? ((i = r == null ? void 0 : r.fees) == null ? void 0 : i.defaultPriorityFee);
    if (typeof o == "function") {
      const u = n || await Fe(t, xf, "getBlock")({}), l = await o({
        block: u,
        client: t,
        request: s
      });
      if (l === null)
        throw new Error();
      return l;
    }
    if (typeof o < "u")
      return o;
    const c = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Te(c);
  } catch {
    const [o, c] = await Promise.all([
      n ? Promise.resolve(n) : Fe(t, xf, "getBlock")({}),
      Fe(t, O8, "getGasPrice")({})
    ]);
    if (typeof o.baseFeePerGas != "bigint")
      throw new _y();
    const u = c - o.baseFeePerGas;
    return u < 0n ? 0n : u;
  }
}
async function nj(t, e) {
  return ab(t, e);
}
async function ab(t, e) {
  var f, h;
  const { block: n, chain: r = t.chain, request: s, type: a = "eip1559" } = e || {}, i = await (async () => {
    var y, b;
    return typeof ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: t,
      request: s
    }) : ((b = r == null ? void 0 : r.fees) == null ? void 0 : b.baseFeeMultiplier) ?? 1.2;
  })();
  if (i < 1)
    throw new XV();
  const c = 10 ** (((f = i.toString().split(".")[1]) == null ? void 0 : f.length) ?? 0), u = (y) => y * BigInt(Math.ceil(i * c)) / BigInt(c), l = n || await Fe(t, xf, "getBlock")({});
  if (typeof ((h = r == null ? void 0 : r.fees) == null ? void 0 : h.estimateFeesPerGas) == "function") {
    const y = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: u,
      request: s,
      type: a
    });
    if (y !== null)
      return y;
  }
  if (a === "eip1559") {
    if (typeof l.baseFeePerGas != "bigint")
      throw new _y();
    const y = typeof (s == null ? void 0 : s.maxPriorityFeePerGas) == "bigint" ? s.maxPriorityFeePerGas : await tj(t, {
      block: l,
      chain: r,
      request: s
    }), b = u(l.baseFeePerGas);
    return {
      maxFeePerGas: (s == null ? void 0 : s.maxFeePerGas) ?? b + y,
      maxPriorityFeePerGas: y
    };
  }
  return {
    gasPrice: (s == null ? void 0 : s.gasPrice) ?? u(await Fe(t, O8, "getGasPrice")({}))
  };
}
async function rj(t, { address: e, blockNumber: n, blockTag: r = "latest" }) {
  const s = typeof n == "bigint" ? W(n) : void 0, a = await t.request({
    method: "eth_getBalance",
    params: [e, s || r]
  });
  return BigInt(a);
}
async function sj(t, e) {
  var s, a, i;
  const { account: n = t.account } = e, r = n ? ht(n) : void 0;
  try {
    let _ = function(M) {
      const { block: j, request: G, rpcStateOverride: Z } = M;
      return t.request({
        method: "eth_estimateGas",
        params: Z ? [G, j ?? "latest", Z] : j ? [G, j] : [G]
      });
    };
    const { accessList: o, authorizationList: c, blobs: u, blobVersionedHashes: l, blockNumber: d, blockTag: f, data: h, gas: y, gasPrice: b, maxFeePerBlobGas: g, maxFeePerGas: w, maxPriorityFeePerGas: v, nonce: A, value: P, stateOverride: x, ...O } = await P8(t, {
      ...e,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (r == null ? void 0 : r.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), T = (typeof d == "bigint" ? W(d) : void 0) || f, C = $y(x), N = await (async () => {
      if (O.to)
        return O.to;
      if (c && c.length > 0)
        return await k8({
          authorization: c[0]
        }).catch(() => {
          throw new D("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    Au(e);
    const U = (i = (a = (s = t.chain) == null ? void 0 : s.formatters) == null ? void 0 : a.transactionRequest) == null ? void 0 : i.format, $ = (U || wu)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...bp(O, { format: U }),
      from: r == null ? void 0 : r.address,
      accessList: o,
      authorizationList: c,
      blobs: u,
      blobVersionedHashes: l,
      data: h,
      gas: y,
      gasPrice: b,
      maxFeePerBlobGas: g,
      maxFeePerGas: w,
      maxPriorityFeePerGas: v,
      nonce: A,
      to: N,
      value: P
    });
    let R = BigInt(await _({ block: T, request: $, rpcStateOverride: C }));
    if (c) {
      const M = await rj(t, { address: $.from }), j = await Promise.all(c.map(async (G) => {
        const { address: Z } = G, Y = await _({
          block: T,
          request: {
            authorizationList: void 0,
            data: h,
            from: r == null ? void 0 : r.address,
            to: Z,
            value: W(M)
          },
          rpcStateOverride: C
        }).catch(() => 100000n);
        return 2n * BigInt(Y);
      }));
      R += j.reduce((G, Z) => G + Z, 0n);
    }
    return R;
  } catch (o) {
    throw NV(o, {
      ...e,
      account: r,
      chain: t.chain
    });
  }
}
const B8 = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
], Zw = /* @__PURE__ */ new Map();
async function P8(t, e) {
  const { account: n = t.account, blobs: r, chain: s, gas: a, kzg: i, nonce: o, nonceManager: c, parameters: u = B8, type: l } = e, d = n && ht(n), f = { ...e, ...d ? { from: d == null ? void 0 : d.address } : {} };
  let h;
  async function y() {
    return h || (h = await Fe(t, xf, "getBlock")({ blockTag: "latest" }), h);
  }
  let b;
  async function g() {
    return b || (s ? s.id : typeof e.chainId < "u" ? e.chainId : (b = await Fe(t, Tc, "getChainId")({}), b));
  }
  if (u.includes("nonce") && typeof o > "u" && d)
    if (c) {
      const w = await g();
      f.nonce = await c.consume({
        address: d.address,
        chainId: w,
        client: t
      });
    } else
      f.nonce = await Fe(t, f8, "getTransactionCount")({
        address: d.address,
        blockTag: "pending"
      });
  if ((u.includes("blobVersionedHashes") || u.includes("sidecars")) && r && i) {
    const w = Ay({ blobs: r, kzg: i });
    if (u.includes("blobVersionedHashes")) {
      const v = uv({
        commitments: w,
        to: "hex"
      });
      f.blobVersionedHashes = v;
    }
    if (u.includes("sidecars")) {
      const v = vy({ blobs: r, commitments: w, kzg: i }), A = mv({
        blobs: r,
        commitments: w,
        proofs: v,
        to: "hex"
      });
      f.sidecars = A;
    }
  }
  if (u.includes("chainId") && (f.chainId = await g()), (u.includes("fees") || u.includes("type")) && typeof l > "u")
    try {
      f.type = Ev(f);
    } catch {
      let w = Zw.get(t.uid);
      if (typeof w > "u") {
        const v = await y();
        w = typeof (v == null ? void 0 : v.baseFeePerGas) == "bigint", Zw.set(t.uid, w);
      }
      f.type = w ? "eip1559" : "legacy";
    }
  if (u.includes("fees"))
    if (f.type !== "legacy" && f.type !== "eip2930") {
      if (typeof f.maxFeePerGas > "u" || typeof f.maxPriorityFeePerGas > "u") {
        const w = await y(), { maxFeePerGas: v, maxPriorityFeePerGas: A } = await ab(t, {
          block: w,
          chain: s,
          request: f
        });
        if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < A)
          throw new YV({
            maxPriorityFeePerGas: A
          });
        f.maxPriorityFeePerGas = A, f.maxFeePerGas = v;
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new _y();
      if (typeof e.gasPrice > "u") {
        const w = await y(), { gasPrice: v } = await ab(t, {
          block: w,
          chain: s,
          request: f,
          type: "legacy"
        });
        f.gasPrice = v;
      }
    }
  return u.includes("gas") && typeof a > "u" && (f.gas = await Fe(t, sj, "estimateGas")({
    ...f,
    account: d && { address: d.address, type: "json-rpc" }
  })), Au(f), delete f.parameters, f;
}
async function aj(t, { serializedTransaction: e }) {
  return t.request({
    method: "eth_sendRawTransaction",
    params: [e]
  }, { retryCount: 0 });
}
const qh = new dp(128);
async function ij(t, e) {
  var v, A, P, x;
  const { account: n = t.account, chain: r = t.chain, accessList: s, authorizationList: a, blobs: i, data: o, gas: c, gasPrice: u, maxFeePerBlobGas: l, maxFeePerGas: d, maxPriorityFeePerGas: f, nonce: h, type: y, value: b, ...g } = e;
  if (typeof n > "u")
    throw new ca({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const w = n ? ht(n) : null;
  try {
    Au(e);
    const O = await (async () => {
      if (e.to)
        return e.to;
      if (e.to !== null && a && a.length > 0)
        return await k8({
          authorization: a[0]
        }).catch(() => {
          throw new D("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((w == null ? void 0 : w.type) === "json-rpc" || w === null) {
      let I;
      r !== null && (I = await Fe(t, Tc, "getChainId")({}), UN({
        currentChainId: I,
        chain: r
      }));
      const T = (P = (A = (v = t.chain) == null ? void 0 : v.formatters) == null ? void 0 : A.transactionRequest) == null ? void 0 : P.format, N = (T || wu)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...bp(g, { format: T }),
        accessList: s,
        authorizationList: a,
        blobs: i,
        chainId: I,
        data: o,
        from: w == null ? void 0 : w.address,
        gas: c,
        gasPrice: u,
        maxFeePerBlobGas: l,
        maxFeePerGas: d,
        maxPriorityFeePerGas: f,
        nonce: h,
        to: O,
        type: y,
        value: b
      }), U = qh.get(t.uid), L = U ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({
          method: L,
          params: [N]
        }, { retryCount: 0 });
      } catch ($) {
        if (U === !1)
          throw $;
        const _ = $;
        if (_.name === "InvalidInputRpcError" || _.name === "InvalidParamsRpcError" || _.name === "MethodNotFoundRpcError" || _.name === "MethodNotSupportedRpcError")
          return await t.request({
            method: "wallet_sendTransaction",
            params: [N]
          }, { retryCount: 0 }).then((R) => (qh.set(t.uid, !0), R)).catch((R) => {
            const M = R;
            throw M.name === "MethodNotFoundRpcError" || M.name === "MethodNotSupportedRpcError" ? (qh.set(t.uid, !1), _) : M;
          });
        throw _;
      }
    }
    if ((w == null ? void 0 : w.type) === "local") {
      const I = await Fe(t, P8, "prepareTransactionRequest")({
        account: w,
        accessList: s,
        authorizationList: a,
        blobs: i,
        chain: r,
        data: o,
        gas: c,
        gasPrice: u,
        maxFeePerBlobGas: l,
        maxFeePerGas: d,
        maxPriorityFeePerGas: f,
        nonce: h,
        nonceManager: w.nonceManager,
        parameters: [...B8, "sidecars"],
        type: y,
        value: b,
        ...g,
        to: O
      }), T = (x = r == null ? void 0 : r.serializers) == null ? void 0 : x.transaction, C = await w.signTransaction(I, {
        serializer: T
      });
      return await Fe(t, aj, "sendRawTransaction")({
        serializedTransaction: C
      });
    }
    throw (w == null ? void 0 : w.type) === "smart" ? new Dh({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new Dh({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: w == null ? void 0 : w.type
    });
  } catch (O) {
    throw O instanceof Dh ? O : C8(O, {
      ...e,
      account: w,
      chain: e.chain || void 0
    });
  }
}
const Wh = /* @__PURE__ */ new Map(), Xw = /* @__PURE__ */ new Map();
let oj = 0;
function I8(t, e, n) {
  const r = ++oj, s = () => Wh.get(t) || [], a = () => {
    const l = s();
    Wh.set(t, l.filter((d) => d.id !== r));
  }, i = () => {
    const l = s();
    if (!l.some((f) => f.id === r))
      return;
    const d = Xw.get(t);
    if (l.length === 1 && d) {
      const f = d();
      f instanceof Promise && f.catch(() => {
      });
    }
    a();
  }, o = s();
  if (Wh.set(t, [
    ...o,
    { id: r, fns: e }
  ]), o && o.length > 0)
    return i;
  const c = {};
  for (const l in e)
    c[l] = (...d) => {
      var h, y;
      const f = s();
      if (f.length !== 0)
        for (const b of f)
          (y = (h = b.fns)[l]) == null || y.call(h, ...d);
    };
  const u = n(c);
  return typeof u == "function" && Xw.set(t, u), i;
}
function U8(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let s = !0;
  const a = () => s = !1;
  return (async () => {
    let o;
    o = await t({ unpoll: a });
    const c = await (n == null ? void 0 : n(o)) ?? r;
    await Ww(c);
    const u = async () => {
      s && (await t({ unpoll: a }), await Ww(r), u());
    };
    u();
  })(), a;
}
async function cj(t, e = {}) {
  const { account: n = t.account, chainId: r } = e, s = n ? ht(n) : void 0, a = r ? [s == null ? void 0 : s.address, [W(r)]] : [s == null ? void 0 : s.address], i = await t.request({
    method: "wallet_getCapabilities",
    params: a
  }), o = {};
  for (const [c, u] of Object.entries(i)) {
    o[Number(c)] = {};
    for (let [l, d] of Object.entries(u))
      l === "addSubAccount" && (l = "unstable_addSubAccount"), o[Number(c)][l] = d;
  }
  return typeof r == "number" ? o[r] : o;
}
const N8 = "0x5792579257925792579257925792579257925792579257925792579257925792", R8 = W(0, {
  size: 32
});
async function F8(t, e) {
  const { account: n = t.account, capabilities: r, chain: s = t.chain, experimental_fallback: a, experimental_fallbackDelay: i = 32, forceAtomic: o = !1, id: c, version: u = "2.0.0" } = e, l = n ? ht(n) : null, d = e.calls.map((f) => {
    const h = f, y = h.abi ? Tu({
      abi: h.abi,
      functionName: h.functionName,
      args: h.args
    }) : h.data;
    return {
      data: h.dataSuffix && y ? Ct([y, h.dataSuffix]) : y,
      to: h.to,
      value: h.value ? W(h.value) : void 0
    };
  });
  try {
    const f = await t.request({
      method: "wallet_sendCalls",
      params: [
        {
          atomicRequired: o,
          calls: d,
          capabilities: r,
          chainId: W(s.id),
          from: l == null ? void 0 : l.address,
          id: c,
          version: u
        }
      ]
    }, { retryCount: 0 });
    return typeof f == "string" ? { id: f } : f;
  } catch (f) {
    const h = f;
    if (a && (h.name === "MethodNotFoundRpcError" || h.name === "MethodNotSupportedRpcError" || h.name === "UnknownRpcError" || h.details.toLowerCase().includes("does not exist / is not available") || h.details.toLowerCase().includes("missing or invalid. request()") || h.details.toLowerCase().includes("did not match any variant of untagged enum") || h.details.toLowerCase().includes("account upgraded to unsupported contract") || h.details.toLowerCase().includes("eip-7702 not supported") || h.details.toLowerCase().includes("unsupported wc_ method"))) {
      if (r && Object.values(r).some((v) => !v.optional)) {
        const v = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
        throw new hp(new D(v, {
          details: v
        }));
      }
      if (o && d.length > 1) {
        const w = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
        throw new mp(new D(w, {
          details: w
        }));
      }
      const y = [];
      for (const w of d) {
        const v = ij(t, {
          account: l,
          chain: s,
          data: w.data,
          to: w.to,
          value: w.value ? Te(w.value) : void 0
        });
        y.push(v), i > 0 && await new Promise((A) => setTimeout(A, i));
      }
      const b = await Promise.allSettled(y);
      if (b.every((w) => w.status === "rejected"))
        throw b[0].reason;
      const g = b.map((w) => w.status === "fulfilled" ? w.value : R8);
      return {
        id: Ct([
          ...g,
          W(s.id, { size: 32 }),
          N8
        ])
      };
    }
    throw C8(f, {
      ...e,
      account: l,
      chain: e.chain
    });
  }
}
async function M8(t, e) {
  async function n(l) {
    if (l.endsWith(N8.slice(2))) {
      const f = Sr(P0(l, -64, -32)), h = P0(l, 0, -64).slice(2).match(/.{1,64}/g), y = await Promise.all(h.map((g) => R8.slice(2) !== g ? t.request({
        method: "eth_getTransactionReceipt",
        params: [`0x${g}`]
      }, { dedupe: !0 }) : void 0)), b = y.some((g) => g === null) ? 100 : y.every((g) => (g == null ? void 0 : g.status) === "0x1") ? 200 : y.every((g) => (g == null ? void 0 : g.status) === "0x0") ? 500 : 600;
      return {
        atomic: !1,
        chainId: er(f),
        receipts: y.filter(Boolean),
        status: b,
        version: "2.0.0"
      };
    }
    return t.request({
      method: "wallet_getCallsStatus",
      params: [l]
    });
  }
  const { atomic: r = !1, chainId: s, receipts: a, version: i = "2.0.0", ...o } = await n(e.id), [c, u] = (() => {
    const l = o.status;
    return l >= 100 && l < 200 ? ["pending", l] : l >= 200 && l < 300 ? ["success", l] : l >= 300 && l < 700 ? ["failure", l] : l === "CONFIRMED" ? ["success", 200] : l === "PENDING" ? ["pending", 100] : [void 0, l];
  })();
  return {
    ...o,
    atomic: r,
    // @ts-expect-error: for backwards compatibility
    chainId: s ? er(s) : void 0,
    receipts: (a == null ? void 0 : a.map((l) => ({
      ...l,
      blockNumber: Te(l.blockNumber),
      gasUsed: Te(l.gasUsed),
      status: tv[l.status]
    }))) ?? [],
    statusCode: u,
    status: c,
    version: i
  };
}
async function lj(t, e) {
  const { id: n } = e;
  await t.request({
    method: "wallet_showCallsStatus",
    params: [n]
  });
}
async function uj(t, e) {
  const { id: n, pollingInterval: r = t.pollingInterval, status: s = ({ statusCode: f }) => f >= 200, timeout: a = 6e4 } = e, i = Pi(["waitForCallsStatus", t.uid, n]), { promise: o, resolve: c, reject: u } = E8();
  let l;
  const d = I8(i, { resolve: c, reject: u }, (f) => {
    const h = U8(async () => {
      const y = (b) => {
        clearTimeout(l), h(), b(), d();
      };
      try {
        const b = await M8(t, { id: n });
        if (!s(b))
          return;
        y(() => f.resolve(b));
      } catch (b) {
        y(() => f.reject(b));
      }
    }, {
      interval: r,
      emitOnBegin: !0
    });
    return h;
  });
  return l = a ? setTimeout(() => {
    d(), clearTimeout(l), u(new dj({ id: n }));
  }, a) : void 0, await o;
}
class dj extends D {
  constructor({ id: e }) {
    super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
  }
}
async function fj(t, e) {
  var c;
  const { account: n = t.account, chainId: r, nonce: s } = e;
  if (!n)
    throw new ca({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const a = ht(n), i = (() => {
    if (e.executor)
      return e.executor === "self" ? e.executor : ht(e.executor);
  })(), o = {
    address: e.contractAddress ?? e.address,
    chainId: r,
    nonce: s
  };
  return typeof o.chainId > "u" && (o.chainId = ((c = t.chain) == null ? void 0 : c.id) ?? await Fe(t, Tc, "getChainId")({})), typeof o.nonce > "u" && (o.nonce = await Fe(t, f8, "getTransactionCount")({
    address: a.address,
    blockTag: "pending"
  }), (i === "self" || i != null && i.address && BV(i.address, a.address)) && (o.nonce += 1)), o;
}
async function D8(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = yp(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      W(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Te(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Te(c)
    }
  };
}
async function L8(t, e) {
  const { chainId: n, entryPointAddress: r, context: s, ...a } = e, i = yp(a), { paymasterPostOpGasLimit: o, paymasterVerificationGasLimit: c, ...u } = await t.request({
    method: "pm_getPaymasterStubData",
    params: [
      {
        ...i,
        callGasLimit: i.callGasLimit ?? "0x0",
        verificationGasLimit: i.verificationGasLimit ?? "0x0",
        preVerificationGas: i.preVerificationGas ?? "0x0"
      },
      r,
      W(n),
      s
    ]
  });
  return {
    ...u,
    ...o && {
      paymasterPostOpGasLimit: Te(o)
    },
    ...c && {
      paymasterVerificationGasLimit: Te(c)
    }
  };
}
const pj = [
  "factory",
  "fees",
  "gas",
  "paymaster",
  "nonce",
  "signature",
  "authorization"
];
async function eo(t, e) {
  var O;
  const n = e, { account: r = t.account, parameters: s = pj, stateOverride: a } = n;
  if (!r)
    throw new ca();
  const i = ht(r), o = t, c = n.paymaster ?? (o == null ? void 0 : o.paymaster), u = typeof c == "string" ? c : void 0, { getPaymasterStubData: l, getPaymasterData: d } = (() => {
    if (c === !0)
      return {
        getPaymasterStubData: (I) => Fe(o, L8, "getPaymasterStubData")(I),
        getPaymasterData: (I) => Fe(o, D8, "getPaymasterData")(I)
      };
    if (typeof c == "object") {
      const { getPaymasterStubData: I, getPaymasterData: T } = c;
      return {
        getPaymasterStubData: T && I ? I : T,
        getPaymasterData: T && I ? T : void 0
      };
    }
    return {
      getPaymasterStubData: void 0,
      getPaymasterData: void 0
    };
  })(), f = n.paymasterContext ? n.paymasterContext : o == null ? void 0 : o.paymasterContext;
  let h = {
    ...n,
    paymaster: u,
    sender: i.address
  };
  const [y, b, g, w, v] = await Promise.all([
    (async () => n.calls ? i.encodeCalls(n.calls.map((I) => {
      const T = I;
      return T.abi ? {
        data: Tu(T),
        to: T.to,
        value: T.value
      } : T;
    })) : n.callData)(),
    (async () => {
      if (!s.includes("factory"))
        return;
      if (n.initCode)
        return { initCode: n.initCode };
      if (n.factory && n.factoryData)
        return {
          factory: n.factory,
          factoryData: n.factoryData
        };
      const { factory: I, factoryData: T } = await i.getFactoryArgs();
      return i.entryPoint.version === "0.6" ? {
        initCode: I && T ? Ct([I, T]) : void 0
      } : {
        factory: I,
        factoryData: T
      };
    })(),
    (async () => {
      var I;
      if (s.includes("fees")) {
        if (typeof n.maxFeePerGas == "bigint" && typeof n.maxPriorityFeePerGas == "bigint")
          return h;
        if ((I = o == null ? void 0 : o.userOperation) != null && I.estimateFeesPerGas) {
          const T = await o.userOperation.estimateFeesPerGas({
            account: i,
            bundlerClient: o,
            userOperation: h
          });
          return {
            ...h,
            ...T
          };
        }
        try {
          const T = o.client ?? t, C = await Fe(T, nj, "estimateFeesPerGas")({
            chain: T.chain,
            type: "eip1559"
          });
          return {
            maxFeePerGas: typeof n.maxFeePerGas == "bigint" ? n.maxFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxFeePerGas
            ),
            maxPriorityFeePerGas: typeof n.maxPriorityFeePerGas == "bigint" ? n.maxPriorityFeePerGas : BigInt(
              // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
              2n * C.maxPriorityFeePerGas
            )
          };
        } catch {
          return;
        }
      }
    })(),
    (async () => {
      if (s.includes("nonce"))
        return typeof n.nonce == "bigint" ? n.nonce : i.getNonce();
    })(),
    (async () => {
      if (s.includes("authorization")) {
        if (typeof n.authorization == "object")
          return n.authorization;
        if (i.authorization && !await i.isDeployed())
          return {
            ...await fj(i.client, i.authorization),
            r: "0xfffffffffffffffffffffffffffffff000000000000000000000000000000000",
            s: "0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            yParity: 1
          };
      }
    })()
  ]);
  typeof y < "u" && (h.callData = y), typeof b < "u" && (h = { ...h, ...b }), typeof g < "u" && (h = { ...h, ...g }), typeof w < "u" && (h.nonce = w), typeof v < "u" && (h.authorization = v), s.includes("signature") && (typeof n.signature < "u" ? h.signature = n.signature : h.signature = await i.getStubSignature(h)), i.entryPoint.version === "0.6" && !h.initCode && (h.initCode = "0x");
  let A;
  async function P() {
    return A || (t.chain ? t.chain.id : (A = await Fe(t, Tc, "getChainId")({}), A));
  }
  let x = !1;
  if (s.includes("paymaster") && l && !u && !n.paymasterAndData) {
    const { isFinal: I = !1, sponsor: T, ...C } = await l({
      chainId: await P(),
      entryPointAddress: i.entryPoint.address,
      context: f,
      ...h
    });
    x = I, h = {
      ...h,
      ...C
    };
  }
  if (i.entryPoint.version === "0.6" && !h.paymasterAndData && (h.paymasterAndData = "0x"), s.includes("gas")) {
    if ((O = i.userOperation) != null && O.estimateGas) {
      const I = await i.userOperation.estimateGas(h);
      h = {
        ...h,
        ...I
      };
    }
    if (typeof h.callGasLimit > "u" || typeof h.preVerificationGas > "u" || typeof h.verificationGasLimit > "u" || h.paymaster && typeof h.paymasterPostOpGasLimit > "u" || h.paymaster && typeof h.paymasterVerificationGasLimit > "u") {
      const I = await Fe(o, H8, "estimateUserOperationGas")({
        account: i,
        // Some Bundlers fail if nullish gas values are provided for gas estimation :') 
        // so we will need to set a default zeroish value.
        callGasLimit: 0n,
        preVerificationGas: 0n,
        verificationGasLimit: 0n,
        stateOverride: a,
        ...h.paymaster ? {
          paymasterPostOpGasLimit: 0n,
          paymasterVerificationGasLimit: 0n
        } : {},
        ...h
      });
      h = {
        ...h,
        callGasLimit: h.callGasLimit ?? I.callGasLimit,
        preVerificationGas: h.preVerificationGas ?? I.preVerificationGas,
        verificationGasLimit: h.verificationGasLimit ?? I.verificationGasLimit,
        paymasterPostOpGasLimit: h.paymasterPostOpGasLimit ?? I.paymasterPostOpGasLimit,
        paymasterVerificationGasLimit: h.paymasterVerificationGasLimit ?? I.paymasterVerificationGasLimit
      };
    }
  }
  if (s.includes("paymaster") && d && !u && !n.paymasterAndData && !x) {
    const I = await d({
      chainId: await P(),
      entryPointAddress: i.entryPoint.address,
      context: f,
      ...h
    });
    h = {
      ...h,
      ...I
    };
  }
  return delete h.calls, delete h.parameters, delete h.paymasterContext, typeof h.paymaster != "string" && delete h.paymaster, h;
}
async function H8(t, e) {
  var c;
  const { account: n = t.account, entryPointAddress: r, stateOverride: s } = e;
  if (!n && !e.sender)
    throw new ca();
  const a = n ? ht(n) : void 0, i = $y(s), o = a ? await Fe(t, eo, "prepareUserOperation")({
    ...e,
    parameters: [
      "authorization",
      "factory",
      "nonce",
      "paymaster",
      "signature"
    ]
  }) : e;
  try {
    const u = [
      yp(o),
      r ?? ((c = a == null ? void 0 : a.entryPoint) == null ? void 0 : c.address)
    ], l = await t.request({
      method: "eth_estimateUserOperationGas",
      params: i ? [...u, i] : [...u]
    });
    return JV(l);
  } catch (u) {
    const l = e.calls;
    throw S8(u, {
      ...o,
      ...l ? { calls: l } : {}
    });
  }
}
function hj(t) {
  return t.request({ method: "eth_supportedEntryPoints" });
}
function mj(t) {
  const e = { ...t };
  return t.callGasLimit && (e.callGasLimit = BigInt(t.callGasLimit)), t.maxFeePerGas && (e.maxFeePerGas = BigInt(t.maxFeePerGas)), t.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = BigInt(t.maxPriorityFeePerGas)), t.nonce && (e.nonce = BigInt(t.nonce)), t.paymasterPostOpGasLimit && (e.paymasterPostOpGasLimit = BigInt(t.paymasterPostOpGasLimit)), t.paymasterVerificationGasLimit && (e.paymasterVerificationGasLimit = BigInt(t.paymasterVerificationGasLimit)), t.preVerificationGas && (e.preVerificationGas = BigInt(t.preVerificationGas)), t.verificationGasLimit && (e.verificationGasLimit = BigInt(t.verificationGasLimit)), e;
}
async function bj(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationByHash",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new jV({ hash: e });
  const { blockHash: r, blockNumber: s, entryPoint: a, transactionHash: i, userOperation: o } = n;
  return {
    blockHash: r,
    blockNumber: BigInt(s),
    entryPoint: a,
    transactionHash: i,
    userOperation: mj(o)
  };
}
function yj(t) {
  const e = { ...t };
  return t.actualGasCost && (e.actualGasCost = BigInt(t.actualGasCost)), t.actualGasUsed && (e.actualGasUsed = BigInt(t.actualGasUsed)), t.logs && (e.logs = t.logs.map((n) => gy(n))), t.receipt && (e.receipt = nv(e.receipt)), e;
}
async function $8(t, { hash: e }) {
  const n = await t.request({
    method: "eth_getUserOperationReceipt",
    params: [e]
  }, { dedupe: !0 });
  if (!n)
    throw new VV({ hash: e });
  return yj(n);
}
async function gj(t, e) {
  var c, u;
  const { account: n = t.account, entryPointAddress: r } = e;
  if (!n && !e.sender)
    throw new ca();
  const s = n ? ht(n) : void 0, a = s ? await Fe(t, eo, "prepareUserOperation")(e) : e, i = e.signature || await ((c = s == null ? void 0 : s.signUserOperation) == null ? void 0 : c.call(s, a)), o = yp({
    ...a,
    signature: i
  });
  try {
    return await t.request({
      method: "eth_sendUserOperation",
      params: [
        o,
        r ?? ((u = s == null ? void 0 : s.entryPoint) == null ? void 0 : u.address)
      ]
    }, { retryCount: 0 });
  } catch (l) {
    const d = e.calls;
    throw S8(l, {
      ...a,
      ...d ? { calls: d } : {},
      signature: i
    });
  }
}
function wj(t, e) {
  const { hash: n, pollingInterval: r = t.pollingInterval, retryCount: s, timeout: a = 12e4 } = e;
  let i = 0;
  const o = Pi([
    "waitForUserOperationReceipt",
    t.uid,
    n
  ]);
  return new Promise((c, u) => {
    const l = I8(o, { resolve: c, reject: u }, (d) => {
      const f = (y) => {
        h(), y(), l();
      }, h = U8(async () => {
        s && i >= s && f(() => d.reject(new Jw({ hash: n })));
        try {
          const y = await Fe(t, $8, "getUserOperationReceipt")({ hash: n });
          f(() => d.resolve(y));
        } catch (y) {
          const b = y;
          b.name !== "UserOperationReceiptNotFoundError" && f(() => d.reject(b));
        }
        i++;
      }, {
        emitOnBegin: !0,
        interval: r
      });
      return a && setTimeout(() => f(() => d.reject(new Jw({ hash: n }))), a), h;
    });
  });
}
function Ej(t) {
  return {
    estimateUserOperationGas: (e) => H8(t, e),
    getChainId: () => Tc(t),
    getSupportedEntryPoints: () => hj(t),
    getUserOperation: (e) => bj(t, e),
    getUserOperationReceipt: (e) => $8(t, e),
    prepareUserOperation: (e) => eo(t, e),
    sendUserOperation: (e) => gj(t, e),
    waitForUserOperationReceipt: (e) => wj(t, e)
  };
}
function xj(t) {
  return {
    getPaymasterData: (e) => D8(t, e),
    getPaymasterStubData: (e) => L8(t, e)
  };
}
const ib = 256;
let Ed = ib, xd;
function Aj(t = 11) {
  if (!xd || Ed + t > ib * 2) {
    xd = "", Ed = 0;
    for (let e = 0; e < ib; e++)
      xd += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return xd.substring(Ed, Ed++ + t);
}
function _8(t) {
  const { batch: e, chain: n, ccipRead: r, key: s = "base", name: a = "Base Client", type: i = "base" } = t, o = (n == null ? void 0 : n.blockTime) ?? 12e3, c = Math.min(Math.max(Math.floor(o / 2), 500), 4e3), u = t.pollingInterval ?? c, l = t.cacheTime ?? u, d = t.account ? ht(t.account) : void 0, { config: f, request: h, value: y } = t.transport({
    chain: n,
    pollingInterval: u
  }), b = { ...f, ...y }, g = {
    account: d,
    batch: e,
    cacheTime: l,
    ccipRead: r,
    chain: n,
    key: s,
    name: a,
    pollingInterval: u,
    request: h,
    transport: b,
    type: i,
    uid: Aj()
  };
  function w(v) {
    return (A) => {
      const P = A(v);
      for (const O in g)
        delete P[O];
      const x = { ...v, ...P };
      return Object.assign(x, { extend: w(x) });
    };
  }
  return Object.assign(g, { extend: w(g) });
}
function Yw(t) {
  const { client: e, key: n = "bundler", name: r = "Bundler Client", paymaster: s, paymasterContext: a, transport: i, userOperation: o } = t;
  return Object.assign(_8({
    ...t,
    chain: t.chain ?? (e == null ? void 0 : e.chain),
    key: n,
    name: r,
    transport: i,
    type: "bundlerClient"
  }), { client: e, paymaster: s, paymasterContext: a, userOperation: o }).extend(Ej);
}
function vj(t) {
  const { key: e = "bundler", name: n = "Bundler Client", transport: r } = t;
  return _8({
    ...t,
    key: e,
    name: n,
    transport: r,
    type: "PaymasterClient"
  }).extend(xj);
}
const kj = "0x0000000071727De22E5E9d8BAf0edAc6f37da032", Cj = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      }
    ],
    name: "executeUserOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "gasFees",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "address payable",
        name: "beneficiary",
        type: "address"
      }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], eE = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";
async function Tj({
  userOp: t,
  relayerPrivateKey: e,
  chain: n
}) {
  console.log("userOp", t);
  const r = df(e), s = Df({
    chain: n,
    transport: Zt(),
    account: r
  }), a = uu({
    chain: n,
    transport: Zt()
  }), i = G8(t), o = await Ij({
    userOperation: i,
    entryPointAddress: eE,
    chainId: n.id
  });
  console.log("opHash", o), console.log("packedOp", i), console.log("relayerAccount", r);
  const c = Uj({
    userOps: [t],
    beneficiary: r.address
  });
  console.log("handleOpsData", c);
  const u = await s.sendTransaction({
    to: eE,
    data: c,
    value: BigInt(0),
    gasLimit: 1e6,
    chain: n
  });
  console.log("Sent handleOps tx:", u);
  const l = await a.waitForTransactionReceipt({ hash: u });
  return console.log("Confirmed handleOps tx:", l.transactionHash), l.transactionHash;
}
function Sj(t) {
  if (!t.verificationGasLimit)
    throw new Error("verificationGasLimit is required");
  if (!t.callGasLimit)
    throw new Error("callGasLimit is required");
  return du([
    pi(Ys(t.verificationGasLimit), { size: 16 }),
    pi(Ys(t.callGasLimit), { size: 16 })
  ]);
}
function Oj(t) {
  if (!t.maxPriorityFeePerGas)
    throw new Error("maxPriorityFeePerGas is required");
  if (!t.maxFeePerGas)
    throw new Error("maxFeePerGas is required");
  return du([
    pi(Ys(t.maxPriorityFeePerGas), { size: 16 }),
    pi(Ys(t.maxFeePerGas), { size: 16 })
  ]);
}
function Bj(t) {
  return t.factory ? du([
    t.factory === "0x7702" ? pi(t.factory, { dir: "right", size: 20 }) : t.factory,
    t.factoryData || "0x"
  ]) : "0x";
}
function Pj(t) {
  if (!t.paymaster) return "0x";
  if (!t.paymasterVerificationGasLimit)
    throw new Error("paymasterVerificationGasLimit is required");
  if (!t.paymasterPostOpGasLimit)
    throw new Error("paymasterPostOpGasLimit is required");
  return du([
    t.paymaster,
    pi(Ys(t.paymasterVerificationGasLimit || 0n), { size: 16 }),
    pi(Ys(t.paymasterPostOpGasLimit || 0n), { size: 16 }),
    t.paymasterData || "0x"
  ]);
}
function G8(t) {
  return {
    sender: t.sender,
    nonce: t.nonce,
    initCode: Bj(t),
    callData: t.callData,
    accountGasLimits: Sj(t),
    preVerificationGas: t.preVerificationGas,
    gasFees: Oj(t),
    paymasterAndData: Pj(t),
    signature: t.signature
  };
}
const Ij = ({
  userOperation: t,
  entryPointAddress: e,
  chainId: n
}) => {
  const r = Uc(
    Fg(
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        t.sender,
        t.nonce,
        Uc(t.initCode),
        Uc(t.callData),
        t.accountGasLimits,
        t.preVerificationGas,
        t.gasFees,
        Uc(t.paymasterAndData)
      ]
    )
  );
  return Uc(
    Fg(
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [r, e, BigInt(n)]
    )
  );
}, Uj = ({
  userOps: t,
  beneficiary: e
}) => {
  const n = Nj(t);
  return console.log("encodeHandleOpsCalldata packedUserOps", n), Xs({
    abi: Cj,
    functionName: "handleOps",
    args: [n, e]
  });
}, Nj = (t) => t.map(
  (n) => G8(n)
), Rj = async (t, e = BigInt(0)) => {
  if (!t) throw new Error("Owner account not found");
  return Xs({
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "salt",
            type: "uint256"
          }
        ],
        name: "createAccount",
        outputs: [
          {
            internalType: "contract SimpleAccount",
            name: "ret",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    functionName: "createAccount",
    args: [t, e]
  });
}, Fj = (t) => t || "0x91E60e0613810449d098b0b5Ec8b51A0FE8c8985";
async function Mj(t) {
  const {
    client: e,
    owner: n,
    factoryAddress: r,
    index: s = BigInt(0),
    address: a,
    nonceKey: i
    // accountLogicAddress = "0xe6Cae83BdE06E4c305530e199D7217f42808555B",
  } = t, o = await _j({ owner: n }), c = t.entryPoint ? {
    address: t.entryPoint.address,
    abi: qw,
    version: "0.7"
  } : {
    address: kj,
    abi: qw,
    version: "0.7"
  }, u = Fj(r);
  let l;
  const d = async () => l || (l = e.chain ? e.chain.id : await Fe(e, Tc, "getChainId")({}), l), f = () => async () => ({
    factory: u,
    factoryData: await Rj(o.address, s)
  }), { accountAddress: h, getFactoryArgs: y } = await (async () => {
    const b = f();
    if (a)
      return { accountAddress: a, getFactoryArgs: b };
    const { factory: g, factoryData: w } = await b();
    return { accountAddress: await $j(e, {
      factory: g,
      factoryData: w,
      entryPointAddress: c.address
    }), getFactoryArgs: b };
  })();
  return HV({
    client: e,
    entryPoint: c,
    getFactoryArgs: y,
    async getAddress() {
      return h;
    },
    async encodeCalls(b) {
      if (b.length > 1)
        return Xs({
          abi: nE,
          functionName: "executeBatch",
          args: [
            b.map((w) => w.to),
            b.map((w) => w.value ?? 0n),
            b.map((w) => w.data ?? "0x")
          ]
        });
      const g = b.length === 0 ? void 0 : b[0];
      if (!g)
        throw new Error("No calls to encode");
      return Xs({
        abi: tE,
        functionName: "execute",
        args: [g.to, g.value ?? 0n, g.data ?? "0x"]
      });
    },
    decodeCalls: async (b) => {
      try {
        const g = [], w = rm({
          abi: nE,
          data: b
        }), v = w.args[0], A = w.args[1], P = w.args[2];
        for (let x = 0; x < v.length; x++)
          g.push({
            to: v[x],
            data: P[x],
            value: A[x]
          });
        return g;
      } catch {
        const w = rm({
          abi: tE,
          data: b
        });
        return [
          {
            to: w.args[0],
            value: w.args[1],
            data: w.args[2]
          }
        ];
      }
    },
    async getNonce(b) {
      return Dj(e, {
        address: await this.getAddress(),
        entryPointAddress: c.address,
        key: i ?? (b == null ? void 0 : b.key)
      });
    },
    async getStubSignature() {
      return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    },
    async sign({ hash: b }) {
      return this.signMessage({ message: b });
    },
    signMessage: async (b) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    signTypedData: async (b) => {
      throw new Error("Simple account isn't 1271 compliant");
    },
    async signUserOperation(b) {
      const { chainId: g = await d(), ...w } = b;
      return $V(e, {
        account: o,
        message: {
          raw: DV({
            userOperation: {
              ...w,
              sender: w.sender ?? await this.getAddress(),
              signature: "0x"
            },
            entryPointAddress: c.address,
            entryPointVersion: c.version,
            chainId: g
          })
        }
      });
    }
  });
}
const tE = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dest",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "func",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], nE = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "dest",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "value",
        type: "uint256[]"
      },
      {
        internalType: "bytes[]",
        name: "func",
        type: "bytes[]"
      }
    ],
    name: "executeBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Dj = async (t, e) => {
  const { address: n, entryPointAddress: r, key: s = BigInt(0) } = e;
  return await Fe(
    t,
    A8,
    "readContract"
  )({
    address: r,
    abi: [
      {
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "getNonce",
    args: [n, s]
  });
}, Lj = "0x60806040526102a28038038091610015826100ae565b6080396040816080019112610093576080516001600160a01b03811681036100935760a0516001600160401b0381116100935782609f82011215610093578060800151610061816100fc565b9361006f60405195866100d9565b81855260a082840101116100935761008e9160a0602086019101610117565b610196565b600080fd5b634e487b7160e01b600052604160045260246000fd5b6080601f91909101601f19168101906001600160401b038211908210176100d457604052565b610098565b601f909101601f19168101906001600160401b038211908210176100d457604052565b6001600160401b0381116100d457601f01601f191660200190565b60005b83811061012a5750506000910152565b818101518382015260200161011a565b6040916020825261015a8151809281602086015260208686019101610117565b601f01601f1916010190565b3d15610191573d90610177826100fc565b9161018560405193846100d9565b82523d6000602084013e565b606090565b600091908291826040516101cd816101bf6020820195639b249f6960e01b87526024830161013a565b03601f1981018352826100d9565b51925af16101d9610166565b906102485760048151116000146101f7576024015160005260206000f35b60405162461bcd60e51b8152602060048201526024808201527f67657453656e64657241646472657373206661696c656420776974686f7574206044820152636461746160e01b6064820152608490fd5b60405162461bcd60e51b815260206004820152602b60248201527f67657453656e6465724164647265737320646964206e6f74207265766572742060448201526a185cc8195e1c1958dd195960aa1b6064820152608490fdfe", Hj = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_entryPoint",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "initCode",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "constructor"
  }
], $j = async (t, e) => {
  const { initCode: n, entryPointAddress: r, factory: s, factoryData: a } = e;
  if (!n && !s && !a)
    throw new Error(
      "Either `initCode` or `factory` and `factoryData` must be provided"
    );
  const i = n || du([s, a]), { data: o } = await Fe(
    t,
    x8,
    "call"
  )({
    data: Q3({
      abi: Hj,
      bytecode: Lj,
      args: [r, i]
    })
  });
  if (!o)
    throw new Error("Failed to get sender address");
  return J3([{ type: "address" }], o)[0];
};
async function _j({
  owner: t,
  address: e
}) {
  if ("type" in t && t.type === "local")
    return t;
  let n;
  if ("request" in t) {
    if (!e)
      try {
        [e] = await t.request({
          method: "eth_requestAccounts"
        });
      } catch {
        [e] = await t.request({
          method: "eth_accounts"
        });
      }
    if (!e)
      throw new Error("address is required");
    n = Df({
      account: e,
      transport: Zc(t)
    });
  }
  return n || (n = t), n8({
    address: n.account.address,
    async signMessage({ message: r }) {
      return n.signMessage({ message: r });
    },
    async signTypedData(r) {
      return Fe(
        n,
        _V,
        "signTypedData"
      )(r);
    },
    async signTransaction(r) {
      throw new Error("Smart account signer doesn't need to sign transactions");
    }
  });
}
const Gj = "0x0000000071727de22e5e9d8baf0edac6f37da032";
async function zj(t, e, n, r, s, a) {
  try {
    const i = uu({
      chain: e,
      transport: Zt()
    });
    if (!t.account)
      throw new Error("No account found");
    const o = t.account.address, c = t8(), u = df(c);
    console.log("Delegator account:", u.address), console.log("Creating smart account...");
    const l = await Mj({
      client: i,
      entryPoint: {
        address: Gj,
        version: "0.7"
      },
      owner: df(c)
    });
    console.log("Smart account address:", l.address), console.log("Transfer amount:", r.toString());
    const { signature: d, deadline: f } = await b8(
      i,
      t,
      o,
      l.address,
      n,
      r,
      e
    );
    console.log("Received signature:", d);
    const h = p8(
      o,
      l.address,
      r,
      f,
      d
    );
    console.log("delegatorSmartAccount.address", l.address);
    const y = h8(
      o,
      l.address,
      r
    ), b = m8(s, r);
    console.log("Estimating gas fees...");
    const g = await i.estimateFeesPerGas(), w = Z3("1"), v = g.maxFeePerGas + w, A = [
      { to: Ye, data: "0x" },
      { to: n, data: h },
      { to: n, data: y },
      { to: n, data: b }
    ];
    if (a)
      if (a.includes("alchemy")) {
        const P = Yw({
          chain: e,
          transport: Zt(a)
        });
        console.log("preparing user op");
        const x = await eo(i, {
          account: l,
          calls: A,
          maxFeePerGas: v,
          maxPriorityFeePerGas: w,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        }), O = await l.signUserOperation(x);
        x.signature = O, console.log("Signed user operation:", O), console.log("Sending user operation...");
        const I = await P.sendUserOperation(x);
        console.log("User operation sent! Hash:", I);
        const T = await P.waitForUserOperationReceipt({
          hash: I
        });
        return console.log("User operation receipt:", T), T.receipt.transactionHash;
      } else {
        const P = vj({
          transport: Zt(a)
        }), x = Yw({
          chain: e,
          paymaster: P,
          transport: Zt(a)
        });
        console.log("preparing user op");
        let O = await eo(i, {
          account: l,
          calls: A,
          maxFeePerGas: v,
          maxPriorityFeePerGas: w,
          callGasLimit: 500000n,
          verificationGasLimit: 500000n,
          preVerificationGas: 500000n
        });
        O = await x.prepareUserOperation({
          ...O
        }), console.log("preparedUserOp", O);
        const I = await l.signUserOperation(O);
        O.signature = I, console.log("Signed user operation:", I), console.log("Sending user operation...");
        const T = await x.sendUserOperation(O);
        console.log("User operation sent! Hash:", T);
        const C = await x.waitForUserOperationReceipt({
          hash: T
        });
        return console.log("User operation receipt:", C), C.receipt.transactionHash;
      }
    else {
      const P = "";
      console.log("preparing user op");
      const x = await eo(i, {
        account: l,
        calls: A,
        maxFeePerGas: v,
        maxPriorityFeePerGas: w,
        callGasLimit: 500000n,
        verificationGasLimit: 500000n,
        preVerificationGas: 500000n,
        paymasterAndData: "0x"
      });
      console.log("preparedUserOp", x);
      const O = Vj(x);
      console.log("Required prefund:", O);
      const I = await i.getBalance({
        address: l.address
      });
      console.log("Balance:", I);
      const T = await l.signUserOperation(x);
      x.signature = T, console.log("Signed user operation:", T);
      const C = await Tj({
        userOp: x,
        relayerPrivateKey: P,
        chain: e
      });
      return console.log("User operation submitted! Hash:", C), C;
    }
  } catch (i) {
    throw console.error("Gasless flow error:", i), i;
  }
}
const Vj = (t) => {
  const e = t;
  return (e.verificationGasLimit + e.callGasLimit + (e.paymasterVerificationGasLimit || 0n) + (e.paymasterPostOpGasLimit || 0n) + e.preVerificationGas) * e.maxFeePerGas;
};
function _Z() {
  const [t, e] = Lf(
    typeof window < "u" ? new URLSearchParams(window.location.search) : new URLSearchParams()
  );
  return Ob(() => {
    const i = () => {
      e(new URLSearchParams(window.location.search));
    };
    window.addEventListener("popstate", i);
    const o = window.history.pushState, c = window.history.replaceState;
    return window.history.pushState = function() {
      o.apply(this, arguments), i();
    }, window.history.replaceState = function() {
      c.apply(this, arguments), i();
    }, () => {
      window.removeEventListener("popstate", i), window.history.pushState = o, window.history.replaceState = c;
    };
  }, []), {
    queryParams: t,
    getParam: (i) => t.get(i),
    hasParam: (i, o) => o ? t.get(i) === o : t.has(i),
    setParam: (i, o) => {
      const c = new URLSearchParams(t);
      c.set(i, o);
      const u = new URL(window.location.href);
      u.search = c.toString(), window.history.pushState({}, "", u.toString()), e(c);
    },
    removeParam: (i) => {
      const o = new URLSearchParams(t);
      o.delete(i);
      const c = new URL(window.location.href);
      c.search = o.toString(), window.history.pushState({}, "", c.toString()), e(o);
    }
  };
}
function jj(t) {
  return typeof window > "u" ? null : new URLSearchParams(window.location.search).get(t);
}
var me;
(function(t) {
  t[t.Verbose = 4] = "Verbose", t[t.Info = 3] = "Info", t[t.Warn = 2] = "Warn", t[t.Error = 1] = "Error", t[t.None = 0] = "None";
})(me || (me = {}));
const ob = (t, e, n) => {
  if (n >= e) {
    const r = t.reduce((s, a, i) => ((i + 1) % 2 && s.push(`
`), s.push(a), s), []);
    switch (e) {
      case me.Info:
        console.info(...r);
        break;
      case me.Error:
        console.error(...r);
        break;
      case me.Warn:
        console.warn(...r);
        break;
      default:
        console.log(...r);
        break;
    }
  }
};
function z8(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: Kj } = Object.prototype, { getPrototypeOf: Gy } = Object, { iterator: gp, toStringTag: V8 } = Symbol, wp = /* @__PURE__ */ ((t) => (e) => {
  const n = Kj.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), rr = (t) => (t = t.toLowerCase(), (e) => wp(e) === t), Ep = (t) => (e) => typeof e === t, { isArray: Sc } = Array, Vl = Ep("undefined");
function qj(t) {
  return t !== null && !Vl(t) && t.constructor !== null && !Vl(t.constructor) && nn(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const j8 = rr("ArrayBuffer");
function Wj(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && j8(t.buffer), e;
}
const Qj = Ep("string"), nn = Ep("function"), K8 = Ep("number"), xp = (t) => t !== null && typeof t == "object", Jj = (t) => t === !0 || t === !1, Fd = (t) => {
  if (wp(t) !== "object")
    return !1;
  const e = Gy(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(V8 in t) && !(gp in t);
}, Zj = rr("Date"), Xj = rr("File"), Yj = rr("Blob"), eK = rr("FileList"), tK = (t) => xp(t) && nn(t.pipe), nK = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || nn(t.append) && ((e = wp(t)) === "formdata" || // detect form-data instance
  e === "object" && nn(t.toString) && t.toString() === "[object FormData]"));
}, rK = rr("URLSearchParams"), [sK, aK, iK, oK] = ["ReadableStream", "Request", "Response", "Headers"].map(rr), cK = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Su(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, s;
  if (typeof t != "object" && (t = [t]), Sc(t))
    for (r = 0, s = t.length; r < s; r++)
      e.call(null, t[r], r, t);
  else {
    const a = n ? Object.getOwnPropertyNames(t) : Object.keys(t), i = a.length;
    let o;
    for (r = 0; r < i; r++)
      o = a[r], e.call(null, t[o], o, t);
  }
}
function q8(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, s;
  for (; r-- > 0; )
    if (s = n[r], e === s.toLowerCase())
      return s;
  return null;
}
const Ca = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, W8 = (t) => !Vl(t) && t !== Ca;
function cb() {
  const { caseless: t } = W8(this) && this || {}, e = {}, n = (r, s) => {
    const a = t && q8(e, s) || s;
    Fd(e[a]) && Fd(r) ? e[a] = cb(e[a], r) : Fd(r) ? e[a] = cb({}, r) : Sc(r) ? e[a] = r.slice() : e[a] = r;
  };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && Su(arguments[r], n);
  return e;
}
const lK = (t, e, n, { allOwnKeys: r } = {}) => (Su(e, (s, a) => {
  n && nn(s) ? t[a] = z8(s, n) : t[a] = s;
}, { allOwnKeys: r }), t), uK = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), dK = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, fK = (t, e, n, r) => {
  let s, a, i;
  const o = {};
  if (e = e || {}, t == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(t), a = s.length; a-- > 0; )
      i = s[a], (!r || r(i, t, e)) && !o[i] && (e[i] = t[i], o[i] = !0);
    t = n !== !1 && Gy(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, pK = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, hK = (t) => {
  if (!t) return null;
  if (Sc(t)) return t;
  let e = t.length;
  if (!K8(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, mK = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Gy(Uint8Array)), bK = (t, e) => {
  const r = (t && t[gp]).call(t);
  let s;
  for (; (s = r.next()) && !s.done; ) {
    const a = s.value;
    e.call(t, a[0], a[1]);
  }
}, yK = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, gK = rr("HTMLFormElement"), wK = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, s) {
    return r.toUpperCase() + s;
  }
), rE = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), EK = rr("RegExp"), Q8 = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  Su(n, (s, a) => {
    let i;
    (i = e(s, a, t)) !== !1 && (r[a] = i || s);
  }), Object.defineProperties(t, r);
}, xK = (t) => {
  Q8(t, (e, n) => {
    if (nn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (nn(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, AK = (t, e) => {
  const n = {}, r = (s) => {
    s.forEach((a) => {
      n[a] = !0;
    });
  };
  return Sc(t) ? r(t) : r(String(t).split(e)), n;
}, vK = () => {
}, kK = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
function CK(t) {
  return !!(t && nn(t.append) && t[V8] === "FormData" && t[gp]);
}
const TK = (t) => {
  const e = new Array(10), n = (r, s) => {
    if (xp(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[s] = r;
        const a = Sc(r) ? [] : {};
        return Su(r, (i, o) => {
          const c = n(i, s + 1);
          !Vl(c) && (a[o] = c);
        }), e[s] = void 0, a;
      }
    }
    return r;
  };
  return n(t, 0);
}, SK = rr("AsyncFunction"), OK = (t) => t && (xp(t) || nn(t)) && nn(t.then) && nn(t.catch), J8 = ((t, e) => t ? setImmediate : e ? ((n, r) => (Ca.addEventListener("message", ({ source: s, data: a }) => {
  s === Ca && a === n && r.length && r.shift()();
}, !1), (s) => {
  r.push(s), Ca.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  nn(Ca.postMessage)
), BK = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ca) : typeof process < "u" && process.nextTick || J8, PK = (t) => t != null && nn(t[gp]), H = {
  isArray: Sc,
  isArrayBuffer: j8,
  isBuffer: qj,
  isFormData: nK,
  isArrayBufferView: Wj,
  isString: Qj,
  isNumber: K8,
  isBoolean: Jj,
  isObject: xp,
  isPlainObject: Fd,
  isReadableStream: sK,
  isRequest: aK,
  isResponse: iK,
  isHeaders: oK,
  isUndefined: Vl,
  isDate: Zj,
  isFile: Xj,
  isBlob: Yj,
  isRegExp: EK,
  isFunction: nn,
  isStream: tK,
  isURLSearchParams: rK,
  isTypedArray: mK,
  isFileList: eK,
  forEach: Su,
  merge: cb,
  extend: lK,
  trim: cK,
  stripBOM: uK,
  inherits: dK,
  toFlatObject: fK,
  kindOf: wp,
  kindOfTest: rr,
  endsWith: pK,
  toArray: hK,
  forEachEntry: bK,
  matchAll: yK,
  isHTMLForm: gK,
  hasOwnProperty: rE,
  hasOwnProp: rE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Q8,
  freezeMethods: xK,
  toObjectSet: AK,
  toCamelCase: wK,
  noop: vK,
  toFiniteNumber: kK,
  findKey: q8,
  global: Ca,
  isContextDefined: W8,
  isSpecCompliantForm: CK,
  toJSONObject: TK,
  isAsyncFn: SK,
  isThenable: OK,
  setImmediate: J8,
  asap: BK,
  isIterable: PK
};
function fe(t, e, n, r, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null);
}
H.inherits(fe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: H.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Z8 = fe.prototype, X8 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  X8[t] = { value: t };
});
Object.defineProperties(fe, X8);
Object.defineProperty(Z8, "isAxiosError", { value: !0 });
fe.from = (t, e, n, r, s, a) => {
  const i = Object.create(Z8);
  return H.toFlatObject(t, i, function(c) {
    return c !== Error.prototype;
  }, (o) => o !== "isAxiosError"), fe.call(i, t.message, e, n, r, s), i.cause = t, i.name = t.name, a && Object.assign(i, a), i;
};
const IK = null;
function lb(t) {
  return H.isPlainObject(t) || H.isArray(t);
}
function Y8(t) {
  return H.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function sE(t, e, n) {
  return t ? t.concat(e).map(function(s, a) {
    return s = Y8(s), !n && a ? "[" + s + "]" : s;
  }).join(n ? "." : "") : e;
}
function UK(t) {
  return H.isArray(t) && !t.some(lb);
}
const NK = H.toFlatObject(H, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Ap(t, e, n) {
  if (!H.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = H.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(b, g) {
    return !H.isUndefined(g[b]);
  });
  const r = n.metaTokens, s = n.visitor || l, a = n.dots, i = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && H.isSpecCompliantForm(e);
  if (!H.isFunction(s))
    throw new TypeError("visitor must be a function");
  function u(y) {
    if (y === null) return "";
    if (H.isDate(y))
      return y.toISOString();
    if (H.isBoolean(y))
      return y.toString();
    if (!c && H.isBlob(y))
      throw new fe("Blob is not supported. Use a Buffer instead.");
    return H.isArrayBuffer(y) || H.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function l(y, b, g) {
    let w = y;
    if (y && !g && typeof y == "object") {
      if (H.endsWith(b, "{}"))
        b = r ? b : b.slice(0, -2), y = JSON.stringify(y);
      else if (H.isArray(y) && UK(y) || (H.isFileList(y) || H.endsWith(b, "[]")) && (w = H.toArray(y)))
        return b = Y8(b), w.forEach(function(A, P) {
          !(H.isUndefined(A) || A === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? sE([b], P, a) : i === null ? b : b + "[]",
            u(A)
          );
        }), !1;
    }
    return lb(y) ? !0 : (e.append(sE(g, b, a), u(y)), !1);
  }
  const d = [], f = Object.assign(NK, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: lb
  });
  function h(y, b) {
    if (!H.isUndefined(y)) {
      if (d.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      d.push(y), H.forEach(y, function(w, v) {
        (!(H.isUndefined(w) || w === null) && s.call(
          e,
          w,
          H.isString(v) ? v.trim() : v,
          b,
          f
        )) === !0 && h(w, b ? b.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!H.isObject(t))
    throw new TypeError("data must be an object");
  return h(t), e;
}
function aE(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function zy(t, e) {
  this._pairs = [], t && Ap(t, this, e);
}
const ek = zy.prototype;
ek.append = function(e, n) {
  this._pairs.push([e, n]);
};
ek.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, aE);
  } : aE;
  return this._pairs.map(function(s) {
    return n(s[0]) + "=" + n(s[1]);
  }, "").join("&");
};
function RK(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function tk(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || RK;
  H.isFunction(n) && (n = {
    serialize: n
  });
  const s = n && n.serialize;
  let a;
  if (s ? a = s(e, n) : a = H.isURLSearchParams(e) ? e.toString() : new zy(e, n).toString(r), a) {
    const i = t.indexOf("#");
    i !== -1 && (t = t.slice(0, i)), t += (t.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return t;
}
class iE {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    H.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const nk = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, FK = typeof URLSearchParams < "u" ? URLSearchParams : zy, MK = typeof FormData < "u" ? FormData : null, DK = typeof Blob < "u" ? Blob : null, LK = {
  isBrowser: !0,
  classes: {
    URLSearchParams: FK,
    FormData: MK,
    Blob: DK
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Vy = typeof window < "u" && typeof document < "u", ub = typeof navigator == "object" && navigator || void 0, HK = Vy && (!ub || ["ReactNative", "NativeScript", "NS"].indexOf(ub.product) < 0), $K = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", _K = Vy && window.location.href || "http://localhost", GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Vy,
  hasStandardBrowserEnv: HK,
  hasStandardBrowserWebWorkerEnv: $K,
  navigator: ub,
  origin: _K
}, Symbol.toStringTag, { value: "Module" })), vt = {
  ...GK,
  ...LK
};
function zK(t, e) {
  return Ap(t, new vt.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, s, a) {
      return vt.isNode && H.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function VK(t) {
  return H.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function jK(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const s = n.length;
  let a;
  for (r = 0; r < s; r++)
    a = n[r], e[a] = t[a];
  return e;
}
function rk(t) {
  function e(n, r, s, a) {
    let i = n[a++];
    if (i === "__proto__") return !0;
    const o = Number.isFinite(+i), c = a >= n.length;
    return i = !i && H.isArray(s) ? s.length : i, c ? (H.hasOwnProp(s, i) ? s[i] = [s[i], r] : s[i] = r, !o) : ((!s[i] || !H.isObject(s[i])) && (s[i] = []), e(n, r, s[i], a) && H.isArray(s[i]) && (s[i] = jK(s[i])), !o);
  }
  if (H.isFormData(t) && H.isFunction(t.entries)) {
    const n = {};
    return H.forEachEntry(t, (r, s) => {
      e(VK(r), s, n, 0);
    }), n;
  }
  return null;
}
function KK(t, e, n) {
  if (H.isString(t))
    try {
      return (e || JSON.parse)(t), H.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const Ou = {
  transitional: nk,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", s = r.indexOf("application/json") > -1, a = H.isObject(e);
    if (a && H.isHTMLForm(e) && (e = new FormData(e)), H.isFormData(e))
      return s ? JSON.stringify(rk(e)) : e;
    if (H.isArrayBuffer(e) || H.isBuffer(e) || H.isStream(e) || H.isFile(e) || H.isBlob(e) || H.isReadableStream(e))
      return e;
    if (H.isArrayBufferView(e))
      return e.buffer;
    if (H.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return zK(e, this.formSerializer).toString();
      if ((o = H.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ap(
          o ? { "files[]": e } : e,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || s ? (n.setContentType("application/json", !1), KK(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || Ou.transitional, r = n && n.forcedJSONParsing, s = this.responseType === "json";
    if (H.isResponse(e) || H.isReadableStream(e))
      return e;
    if (e && H.isString(e) && (r && !this.responseType || s)) {
      const i = !(n && n.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (i)
          throw o.name === "SyntaxError" ? fe.from(o, fe.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: vt.classes.FormData,
    Blob: vt.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
H.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  Ou.headers[t] = {};
});
const qK = H.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), WK = (t) => {
  const e = {};
  let n, r, s;
  return t && t.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), n = i.substring(0, s).trim().toLowerCase(), r = i.substring(s + 1).trim(), !(!n || e[n] && qK[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, oE = Symbol("internals");
function Qc(t) {
  return t && String(t).trim().toLowerCase();
}
function Md(t) {
  return t === !1 || t == null ? t : H.isArray(t) ? t.map(Md) : String(t);
}
function QK(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const JK = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Qh(t, e, n, r, s) {
  if (H.isFunction(r))
    return r.call(this, e, n);
  if (s && (e = n), !!H.isString(e)) {
    if (H.isString(r))
      return e.indexOf(r) !== -1;
    if (H.isRegExp(r))
      return r.test(e);
  }
}
function ZK(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function XK(t, e) {
  const n = H.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(s, a, i) {
        return this[r].call(this, e, s, a, i);
      },
      configurable: !0
    });
  });
}
let rn = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const s = this;
    function a(o, c, u) {
      const l = Qc(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = H.findKey(s, l);
      (!d || s[d] === void 0 || u === !0 || u === void 0 && s[d] !== !1) && (s[d || c] = Md(o));
    }
    const i = (o, c) => H.forEach(o, (u, l) => a(u, l, c));
    if (H.isPlainObject(e) || e instanceof this.constructor)
      i(e, n);
    else if (H.isString(e) && (e = e.trim()) && !JK(e))
      i(WK(e), n);
    else if (H.isObject(e) && H.isIterable(e)) {
      let o = {}, c, u;
      for (const l of e) {
        if (!H.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        o[u = l[0]] = (c = o[u]) ? H.isArray(c) ? [...c, l[1]] : [c, l[1]] : l[1];
      }
      i(o, n);
    } else
      e != null && a(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = Qc(e), e) {
      const r = H.findKey(this, e);
      if (r) {
        const s = this[r];
        if (!n)
          return s;
        if (n === !0)
          return QK(s);
        if (H.isFunction(n))
          return n.call(this, s, r);
        if (H.isRegExp(n))
          return n.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = Qc(e), e) {
      const r = H.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || Qh(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let s = !1;
    function a(i) {
      if (i = Qc(i), i) {
        const o = H.findKey(r, i);
        o && (!n || Qh(r, r[o], o, n)) && (delete r[o], s = !0);
      }
    }
    return H.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, s = !1;
    for (; r--; ) {
      const a = n[r];
      (!e || Qh(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const n = this, r = {};
    return H.forEach(this, (s, a) => {
      const i = H.findKey(r, a);
      if (i) {
        n[i] = Md(s), delete n[a];
        return;
      }
      const o = e ? ZK(a) : String(a).trim();
      o !== a && delete n[a], n[o] = Md(s), r[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return H.forEach(this, (r, s) => {
      r != null && r !== !1 && (n[s] = e && H.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((s) => r.set(s)), r;
  }
  static accessor(e) {
    const r = (this[oE] = this[oE] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(i) {
      const o = Qc(i);
      r[o] || (XK(s, i), r[o] = !0);
    }
    return H.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
rn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
H.reduceDescriptors(rn.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
H.freezeMethods(rn);
function Jh(t, e) {
  const n = this || Ou, r = e || n, s = rn.from(r.headers);
  let a = r.data;
  return H.forEach(t, function(o) {
    a = o.call(n, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function sk(t) {
  return !!(t && t.__CANCEL__);
}
function Oc(t, e, n) {
  fe.call(this, t ?? "canceled", fe.ERR_CANCELED, e, n), this.name = "CanceledError";
}
H.inherits(Oc, fe, {
  __CANCEL__: !0
});
function ak(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new fe(
    "Request failed with status code " + n.status,
    [fe.ERR_BAD_REQUEST, fe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function YK(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function eq(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let s = 0, a = 0, i;
  return e = e !== void 0 ? e : 1e3, function(c) {
    const u = Date.now(), l = r[a];
    i || (i = u), n[s] = c, r[s] = u;
    let d = a, f = 0;
    for (; d !== s; )
      f += n[d++], d = d % t;
    if (s = (s + 1) % t, s === a && (a = (a + 1) % t), u - i < e)
      return;
    const h = l && u - l;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function tq(t, e) {
  let n = 0, r = 1e3 / e, s, a;
  const i = (u, l = Date.now()) => {
    n = l, s = null, a && (clearTimeout(a), a = null), t.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), d = l - n;
    d >= r ? i(u, l) : (s = u, a || (a = setTimeout(() => {
      a = null, i(s);
    }, r - d)));
  }, () => s && i(s)];
}
const Af = (t, e, n = 3) => {
  let r = 0;
  const s = eq(50, 250);
  return tq((a) => {
    const i = a.loaded, o = a.lengthComputable ? a.total : void 0, c = i - r, u = s(c), l = i <= o;
    r = i;
    const d = {
      loaded: i,
      total: o,
      progress: o ? i / o : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && o && l ? (o - i) / u : void 0,
      event: a,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    t(d);
  }, n);
}, cE = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, lE = (t) => (...e) => H.asap(() => t(...e)), nq = vt.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, vt.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(
  new URL(vt.origin),
  vt.navigator && /(msie|trident)/i.test(vt.navigator.userAgent)
) : () => !0, rq = vt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, s, a) {
      const i = [t + "=" + encodeURIComponent(e)];
      H.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()), H.isString(r) && i.push("path=" + r), H.isString(s) && i.push("domain=" + s), a === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function sq(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function aq(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function ik(t, e, n) {
  let r = !sq(e);
  return t && (r || n == !1) ? aq(t, e) : e;
}
const uE = (t) => t instanceof rn ? { ...t } : t;
function Ci(t, e) {
  e = e || {};
  const n = {};
  function r(u, l, d, f) {
    return H.isPlainObject(u) && H.isPlainObject(l) ? H.merge.call({ caseless: f }, u, l) : H.isPlainObject(l) ? H.merge({}, l) : H.isArray(l) ? l.slice() : l;
  }
  function s(u, l, d, f) {
    if (H.isUndefined(l)) {
      if (!H.isUndefined(u))
        return r(void 0, u, d, f);
    } else return r(u, l, d, f);
  }
  function a(u, l) {
    if (!H.isUndefined(l))
      return r(void 0, l);
  }
  function i(u, l) {
    if (H.isUndefined(l)) {
      if (!H.isUndefined(u))
        return r(void 0, u);
    } else return r(void 0, l);
  }
  function o(u, l, d) {
    if (d in e)
      return r(u, l);
    if (d in t)
      return r(void 0, u);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: o,
    headers: (u, l, d) => s(uE(u), uE(l), d, !0)
  };
  return H.forEach(Object.keys(Object.assign({}, t, e)), function(l) {
    const d = c[l] || s, f = d(t[l], e[l], l);
    H.isUndefined(f) && d !== o || (n[l] = f);
  }), n;
}
const ok = (t) => {
  const e = Ci({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: a, headers: i, auth: o } = e;
  e.headers = i = rn.from(i), e.url = tk(ik(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), o && i.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let c;
  if (H.isFormData(n)) {
    if (vt.hasStandardBrowserEnv || vt.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((c = i.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      i.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (vt.hasStandardBrowserEnv && (r && H.isFunction(r) && (r = r(e)), r || r !== !1 && nq(e.url))) {
    const u = s && a && rq.read(a);
    u && i.set(s, u);
  }
  return e;
}, iq = typeof XMLHttpRequest < "u", oq = iq && function(t) {
  return new Promise(function(n, r) {
    const s = ok(t);
    let a = s.data;
    const i = rn.from(s.headers).normalize();
    let { responseType: o, onUploadProgress: c, onDownloadProgress: u } = s, l, d, f, h, y;
    function b() {
      h && h(), y && y(), s.cancelToken && s.cancelToken.unsubscribe(l), s.signal && s.signal.removeEventListener("abort", l);
    }
    let g = new XMLHttpRequest();
    g.open(s.method.toUpperCase(), s.url, !0), g.timeout = s.timeout;
    function w() {
      if (!g)
        return;
      const A = rn.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), x = {
        data: !o || o === "text" || o === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: A,
        config: t,
        request: g
      };
      ak(function(I) {
        n(I), b();
      }, function(I) {
        r(I), b();
      }, x), g = null;
    }
    "onloadend" in g ? g.onloadend = w : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, g.onabort = function() {
      g && (r(new fe("Request aborted", fe.ECONNABORTED, t, g)), g = null);
    }, g.onerror = function() {
      r(new fe("Network Error", fe.ERR_NETWORK, t, g)), g = null;
    }, g.ontimeout = function() {
      let P = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const x = s.transitional || nk;
      s.timeoutErrorMessage && (P = s.timeoutErrorMessage), r(new fe(
        P,
        x.clarifyTimeoutError ? fe.ETIMEDOUT : fe.ECONNABORTED,
        t,
        g
      )), g = null;
    }, a === void 0 && i.setContentType(null), "setRequestHeader" in g && H.forEach(i.toJSON(), function(P, x) {
      g.setRequestHeader(x, P);
    }), H.isUndefined(s.withCredentials) || (g.withCredentials = !!s.withCredentials), o && o !== "json" && (g.responseType = s.responseType), u && ([f, y] = Af(u, !0), g.addEventListener("progress", f)), c && g.upload && ([d, h] = Af(c), g.upload.addEventListener("progress", d), g.upload.addEventListener("loadend", h)), (s.cancelToken || s.signal) && (l = (A) => {
      g && (r(!A || A.type ? new Oc(null, t, g) : A), g.abort(), g = null);
    }, s.cancelToken && s.cancelToken.subscribe(l), s.signal && (s.signal.aborted ? l() : s.signal.addEventListener("abort", l)));
    const v = YK(s.url);
    if (v && vt.protocols.indexOf(v) === -1) {
      r(new fe("Unsupported protocol " + v + ":", fe.ERR_BAD_REQUEST, t));
      return;
    }
    g.send(a || null);
  });
}, cq = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), s;
    const a = function(u) {
      if (!s) {
        s = !0, o();
        const l = u instanceof Error ? u : this.reason;
        r.abort(l instanceof fe ? l : new Oc(l instanceof Error ? l.message : l));
      }
    };
    let i = e && setTimeout(() => {
      i = null, a(new fe(`timeout ${e} of ms exceeded`, fe.ETIMEDOUT));
    }, e);
    const o = () => {
      t && (i && clearTimeout(i), i = null, t.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(a) : u.removeEventListener("abort", a);
      }), t = null);
    };
    t.forEach((u) => u.addEventListener("abort", a));
    const { signal: c } = r;
    return c.unsubscribe = () => H.asap(o), c;
  }
}, lq = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, s;
  for (; r < n; )
    s = r + e, yield t.slice(r, s), r = s;
}, uq = async function* (t, e) {
  for await (const n of dq(t))
    yield* lq(n, e);
}, dq = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, dE = (t, e, n, r) => {
  const s = uq(t, e);
  let a = 0, i, o = (c) => {
    i || (i = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await s.next();
        if (u) {
          o(), c.close();
          return;
        }
        let d = l.byteLength;
        if (n) {
          let f = a += d;
          n(f);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw o(u), u;
      }
    },
    cancel(c) {
      return o(c), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, vp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", ck = vp && typeof ReadableStream == "function", fq = vp && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), lk = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, pq = ck && lk(() => {
  let t = !1;
  const e = new Request(vt.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), fE = 64 * 1024, db = ck && lk(() => H.isReadableStream(new Response("").body)), vf = {
  stream: db && ((t) => t.body)
};
vp && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !vf[e] && (vf[e] = H.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new fe(`Response type '${e}' is not supported`, fe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const hq = async (t) => {
  if (t == null)
    return 0;
  if (H.isBlob(t))
    return t.size;
  if (H.isSpecCompliantForm(t))
    return (await new Request(vt.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (H.isArrayBufferView(t) || H.isArrayBuffer(t))
    return t.byteLength;
  if (H.isURLSearchParams(t) && (t = t + ""), H.isString(t))
    return (await fq(t)).byteLength;
}, mq = async (t, e) => {
  const n = H.toFiniteNumber(t.getContentLength());
  return n ?? hq(e);
}, bq = vp && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: s,
    cancelToken: a,
    timeout: i,
    onDownloadProgress: o,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = ok(t);
  u = u ? (u + "").toLowerCase() : "text";
  let h = cq([s, a && a.toAbortSignal()], i), y;
  const b = h && h.unsubscribe && (() => {
    h.unsubscribe();
  });
  let g;
  try {
    if (c && pq && n !== "get" && n !== "head" && (g = await mq(l, r)) !== 0) {
      let x = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), O;
      if (H.isFormData(r) && (O = x.headers.get("content-type")) && l.setContentType(O), x.body) {
        const [I, T] = cE(
          g,
          Af(lE(c))
        );
        r = dE(x.body, fE, I, T);
      }
    }
    H.isString(d) || (d = d ? "include" : "omit");
    const w = "credentials" in Request.prototype;
    y = new Request(e, {
      ...f,
      signal: h,
      method: n.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: w ? d : void 0
    });
    let v = await fetch(y, f);
    const A = db && (u === "stream" || u === "response");
    if (db && (o || A && b)) {
      const x = {};
      ["status", "statusText", "headers"].forEach((C) => {
        x[C] = v[C];
      });
      const O = H.toFiniteNumber(v.headers.get("content-length")), [I, T] = o && cE(
        O,
        Af(lE(o), !0)
      ) || [];
      v = new Response(
        dE(v.body, fE, I, () => {
          T && T(), b && b();
        }),
        x
      );
    }
    u = u || "text";
    let P = await vf[H.findKey(vf, u) || "text"](v, t);
    return !A && b && b(), await new Promise((x, O) => {
      ak(x, O, {
        data: P,
        headers: rn.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: t,
        request: y
      });
    });
  } catch (w) {
    throw b && b(), w && w.name === "TypeError" && /Load failed|fetch/i.test(w.message) ? Object.assign(
      new fe("Network Error", fe.ERR_NETWORK, t, y),
      {
        cause: w.cause || w
      }
    ) : fe.from(w, w && w.code, t, y);
  }
}), fb = {
  http: IK,
  xhr: oq,
  fetch: bq
};
H.forEach(fb, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const pE = (t) => `- ${t}`, yq = (t) => H.isFunction(t) || t === null || t === !1, uk = {
  getAdapter: (t) => {
    t = H.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const s = {};
    for (let a = 0; a < e; a++) {
      n = t[a];
      let i;
      if (r = n, !yq(n) && (r = fb[(i = String(n)).toLowerCase()], r === void 0))
        throw new fe(`Unknown adapter '${i}'`);
      if (r)
        break;
      s[i || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(s).map(
        ([o, c]) => `adapter ${o} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = e ? a.length > 1 ? `since :
` + a.map(pE).join(`
`) : " " + pE(a[0]) : "as no adapter specified";
      throw new fe(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: fb
};
function Zh(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Oc(null, t);
}
function hE(t) {
  return Zh(t), t.headers = rn.from(t.headers), t.data = Jh.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), uk.getAdapter(t.adapter || Ou.adapter)(t).then(function(r) {
    return Zh(t), r.data = Jh.call(
      t,
      t.transformResponse,
      r
    ), r.headers = rn.from(r.headers), r;
  }, function(r) {
    return sk(r) || (Zh(t), r && r.response && (r.response.data = Jh.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = rn.from(r.response.headers))), Promise.reject(r);
  });
}
const dk = "1.10.0", kp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  kp[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const mE = {};
kp.transitional = function(e, n, r) {
  function s(a, i) {
    return "[Axios v" + dk + "] Transitional option '" + a + "'" + i + (r ? ". " + r : "");
  }
  return (a, i, o) => {
    if (e === !1)
      throw new fe(
        s(i, " has been removed" + (n ? " in " + n : "")),
        fe.ERR_DEPRECATED
      );
    return n && !mE[i] && (mE[i] = !0, console.warn(
      s(
        i,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(a, i, o) : !0;
  };
};
kp.spelling = function(e) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function gq(t, e, n) {
  if (typeof t != "object")
    throw new fe("options must be an object", fe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let s = r.length;
  for (; s-- > 0; ) {
    const a = r[s], i = e[a];
    if (i) {
      const o = t[a], c = o === void 0 || i(o, a, t);
      if (c !== !0)
        throw new fe("option " + a + " must be " + c, fe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new fe("Unknown option " + a, fe.ERR_BAD_OPTION);
  }
}
const Dd = {
  assertOptions: gq,
  validators: kp
}, cr = Dd.validators;
let li = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new iE(),
      response: new iE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Ci(this.defaults, n);
    const { transitional: r, paramsSerializer: s, headers: a } = n;
    r !== void 0 && Dd.assertOptions(r, {
      silentJSONParsing: cr.transitional(cr.boolean),
      forcedJSONParsing: cr.transitional(cr.boolean),
      clarifyTimeoutError: cr.transitional(cr.boolean)
    }, !1), s != null && (H.isFunction(s) ? n.paramsSerializer = {
      serialize: s
    } : Dd.assertOptions(s, {
      encode: cr.function,
      serialize: cr.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Dd.assertOptions(n, {
      baseUrl: cr.spelling("baseURL"),
      withXsrfToken: cr.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let i = a && H.merge(
      a.common,
      a[n.method]
    );
    a && H.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete a[y];
      }
    ), n.headers = rn.concat(i, a);
    const o = [];
    let c = !0;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(n) === !1 || (c = c && b.synchronous, o.unshift(b.fulfilled, b.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(b) {
      u.push(b.fulfilled, b.rejected);
    });
    let l, d = 0, f;
    if (!c) {
      const y = [hE.bind(this), void 0];
      for (y.unshift.apply(y, o), y.push.apply(y, u), f = y.length, l = Promise.resolve(n); d < f; )
        l = l.then(y[d++], y[d++]);
      return l;
    }
    f = o.length;
    let h = n;
    for (d = 0; d < f; ) {
      const y = o[d++], b = o[d++];
      try {
        h = y(h);
      } catch (g) {
        b.call(this, g);
        break;
      }
    }
    try {
      l = hE.call(this, h);
    } catch (y) {
      return Promise.reject(y);
    }
    for (d = 0, f = u.length; d < f; )
      l = l.then(u[d++], u[d++]);
    return l;
  }
  getUri(e) {
    e = Ci(this.defaults, e);
    const n = ik(e.baseURL, e.url, e.allowAbsoluteUrls);
    return tk(n, e.params, e.paramsSerializer);
  }
};
H.forEach(["delete", "get", "head", "options"], function(e) {
  li.prototype[e] = function(n, r) {
    return this.request(Ci(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
H.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(a, i, o) {
      return this.request(Ci(o || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: i
      }));
    };
  }
  li.prototype[e] = n(), li.prototype[e + "Form"] = n(!0);
});
let wq = class fk {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((s) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](s);
      r._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const i = new Promise((o) => {
        r.subscribe(o), a = o;
      }).then(s);
      return i.cancel = function() {
        r.unsubscribe(a);
      }, i;
    }, e(function(a, i, o) {
      r.reason || (r.reason = new Oc(a, i, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new fk(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function Eq(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function xq(t) {
  return H.isObject(t) && t.isAxiosError === !0;
}
const pb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(pb).forEach(([t, e]) => {
  pb[e] = t;
});
function pk(t) {
  const e = new li(t), n = z8(li.prototype.request, e);
  return H.extend(n, li.prototype, e, { allOwnKeys: !0 }), H.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(s) {
    return pk(Ci(t, s));
  }, n;
}
const Ze = pk(Ou);
Ze.Axios = li;
Ze.CanceledError = Oc;
Ze.CancelToken = wq;
Ze.isCancel = sk;
Ze.VERSION = dk;
Ze.toFormData = Ap;
Ze.AxiosError = fe;
Ze.Cancel = Ze.CanceledError;
Ze.all = function(e) {
  return Promise.all(e);
};
Ze.spread = Eq;
Ze.isAxiosError = xq;
Ze.mergeConfig = Ci;
Ze.AxiosHeaders = rn;
Ze.formToJSON = (t) => rk(H.isHTMLForm(t) ? new FormData(t) : t);
Ze.getAdapter = uk.getAdapter;
Ze.HttpStatusCode = pb;
Ze.default = Ze;
const {
  Axios: VZ,
  AxiosError: jZ,
  CanceledError: KZ,
  isCancel: qZ,
  CancelToken: WZ,
  VERSION: QZ,
  all: JZ,
  Cancel: ZZ,
  isAxiosError: XZ,
  spread: YZ,
  toFormData: eX,
  AxiosHeaders: tX,
  HttpStatusCode: nX,
  formToJSON: rX,
  getAdapter: sX,
  mergeConfig: aX
} = Ze;
function Aq(t = {}) {
  return It.request(t);
}
function vq(t) {
  return t && t.cause === "APIError";
}
class Bc extends Error {
  constructor(e = "Unknown Reason", n, r, s = "APIError", a = {}) {
    super(e, { ...a, cause: "APIError" }), Object.defineProperty(this, "type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "statusCode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "rawError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "endpoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "APIError", this.type = s, this.statusCode = n, this.endpoint = r == null ? void 0 : r.endpoint, this.rawError = r;
  }
}
const It = Ze.create();
It.interceptors.response.use((t) => (t.headers.Deprecation === "true" && console.warn(`Warning: API ${t.config.url} is deprecated. Stability and performance may be affected.`), t), (t) => {
  var e, n, r, s, a, i;
  return Promise.reject(new Bc((n = (e = t.response) == null ? void 0 : e.data) == null ? void 0 : n.message, ((s = (r = t.response) == null ? void 0 : r.data) == null ? void 0 : s.statusCode) || 500, {
    ...(a = t.response) == null ? void 0 : a.data,
    endpoint: (i = t.config) == null ? void 0 : i.url
  }));
});
async function jy(t, e, n = 15, r = 0) {
  if (r >= n)
    throw `Failed to get data after ${r} attempt(s), aborting`;
  async function s() {
    return (await It.request(t)).data;
  }
  const a = await s();
  if (e(a))
    return a;
  await new Promise((o) => setTimeout(o, 5e3)), r++, await jy(t, e, n, r);
}
async function Ky(t, e, n = 15, r = 0, s = 5e3) {
  if (r >= n)
    throw `Failed to get an ok response after ${r} attempt(s), aborting`;
  const a = await It.request(t);
  if (e || (e = (i) => i.status === 200), e(a))
    return !0;
  await new Promise((i) => setTimeout(i, s)), r++, await Ky(t, e, n, r, s);
}
class kq extends Error {
  constructor(e, n) {
    super(`Failed to receive a successful response for solver status check with hash '${e}' after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "SolverStatusTimeoutError", this.txHash = e;
  }
}
class Cq extends Error {
  constructor(e, n) {
    super(`Deposit transaction with hash '${e}' is pending after ${n} attempt(s).`), Object.defineProperty(this, "txHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "DepositTransactionTimeoutError", this.txHash = e;
  }
}
class Tq extends Error {
  constructor(e, n, r) {
    super(e), Object.defineProperty(this, "receipt", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tenderlyError", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TransactionConfirmationError", this.receipt = n, this.tenderlyError = r ?? void 0;
  }
}
async function qy(t, e = 15, n = 0, r = 5e3) {
  if (n >= e)
    throw `Failed to get an ok response after ${n} attempt(s), aborting`;
  if (await t())
    return !0;
  await new Promise((a) => setTimeout(a, r)), n++, await qy(t, e, n, r);
}
const Sq = (t) => new Promise((e) => {
  It.get(`https://api.tenderly.co/api/v1/explorer/${t}`, {
    timeout: 5e3
  }).then((n) => {
    n && n.data && n.data.error_info && e(n.data.error_info), e(null);
  }).catch((n) => {
    console.warn(`Tenderly api failed: ${n}`), e(null);
  });
});
async function Oq(t, e, n, r, s, a, i, o, c, u, l, d, f) {
  var U, L, $, _, R, M, j, G, Z, Y, X, le;
  const h = Re();
  try {
    await qy(async () => await r.getChainId() === t, 10, void 0, 250);
  } catch {
    throw `Current chain id: ${await r.getChainId()} does not match expected chain id: ${t} `;
  }
  let y, b = !1, g = !1;
  const w = h.pollingInterval ?? 5e3, v = h.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / w;
  let A = !0, P = 0, x;
  const O = !!(Array.isArray(e) && e.length > 1 && r.handleBatchTransactionStep);
  if (O ? x = await ((U = r.handleBatchTransactionStep) == null ? void 0 : U.call(r, t, e)) : x = await r.handleSendTransactionStep(t, Array.isArray(e) ? e[0] : e, n), x === "null")
    throw "User rejected the request";
  const I = Array.isArray(e) ? (L = e.find((J) => J.check)) == null ? void 0 : L.check : e.check;
  if (yE({
    txHash: x,
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: h.source
  }), x && !O && !Array.isArray(e) && t === ((_ = ($ = l == null ? void 0 : l.currencyOut) == null ? void 0 : $.currency) == null ? void 0 : _.chainId) && bE({
    calldata: JSON.stringify({ ...e.data, txHash: x }),
    chainId: t,
    step: n,
    request: i,
    headers: o,
    source: h.source
  }), !x)
    throw Error("Transaction hash not returned from handleSendTransactionStep method");
  s([
    { txHash: x, chainId: t, isBatchTx: O }
  ]);
  const T = (J) => {
    var ce, te, ae, he, Oe, De, ze;
    if ((ce = Re()) == null || ce.log(["Execute Steps: Polling for confirmation", J], me.Verbose), f == null || f((te = J.data) == null ? void 0 : te.status), J.status === 200 && J.data && J.data.status === "failure")
      throw Error("Transaction failed");
    if (J.status === 200 && J.data && J.data.status === "fallback")
      throw Error("Transaction failed: Refunded");
    if (J.status === 200 && J.data && J.data.status === "success") {
      if (x)
        a([
          { txHash: x, chainId: t, isBatchTx: O }
        ]);
      else if ((ae = J == null ? void 0 : J.data) != null && ae.inTxHashes) {
        const mn = (Oe = (he = J.data) == null ? void 0 : he.inTxHashes) == null ? void 0 : Oe.map((bt) => {
          var Ur;
          return {
            txHash: bt,
            chainId: ((Ur = J == null ? void 0 : J.data) == null ? void 0 : Ur.originChainId) ?? t,
            isBatchTx: O
          };
        });
        a(mn);
      }
      const at = (ze = (De = J.data) == null ? void 0 : De.txHashes) == null ? void 0 : ze.map((mn) => {
        var bt;
        return {
          txHash: mn,
          chainId: ((bt = J == null ? void 0 : J.data) == null ? void 0 : bt.destinationChainId) ?? c
        };
      });
      return s(at), !0;
    }
    return !1;
  }, C = async (J) => {
    var ce, te, ae;
    for (u == null || u(); A && P < v && !b && !g; ) {
      let he;
      if (I != null && I.endpoint && !((ce = i == null ? void 0 : i.data) != null && ce.useExternalLiquidity)) {
        let Oe = I == null ? void 0 : I.endpoint;
        h.source && !Oe.includes("referrer") && (I == null ? void 0 : I.method) === "GET" && (Oe = Oe.includes("?") ? `${Oe}&referrer=${h.source}` : `${Oe}?referrer=${h.source}`);
        try {
          he = await It.request({
            url: `${i.baseURL}${Oe}`,
            method: I == null ? void 0 : I.method,
            headers: o
          });
        } catch (De) {
          (te = Re()) == null || te.log(["Execute Steps: Polling for confirmation api error", De], me.Verbose), he = {
            data: {},
            status: 200,
            statusText: "OK",
            headers: {},
            config: {
              headers: {}
            }
          };
        }
      }
      ((ae = he == null ? void 0 : he.data) == null ? void 0 : ae.status) === "pending" && A && (J == null || J.abort()), !he || T(he) ? A = !1 : he && (he.data.status !== "pending" && (u == null || u(he), P++), await new Promise((Oe) => setTimeout(Oe, w)));
    }
    if (P >= v)
      throw y ? new kq(x, P) : new Cq(x, P);
    if (b)
      throw Error("Transaction was cancelled");
    return !0;
  }, N = () => {
    const J = new AbortController(), ce = J.signal;
    return {
      promise: r.handleConfirmTransactionStep(x, t, (te) => {
        var ae, he, Oe;
        ce.aborted || (s([{ txHash: te, chainId: t }]), x = te, P = 0, (ae = Re()) == null || ae.log(["Transaction replaced", te], me.Verbose), yE({
          txHash: te,
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: h.source
        }), !O && !Array.isArray(e) && t === ((Oe = (he = l == null ? void 0 : l.currencyOut) == null ? void 0 : he.currency) == null ? void 0 : Oe.chainId) && bE({
          calldata: JSON.stringify({ ...e.data, replacementTxHash: te }),
          chainId: t,
          step: n,
          request: i,
          headers: o,
          source: h.source
        }));
      }, () => {
        var te;
        ce.aborted || (b = !0, (te = Re()) == null || te.log(["Transaction cancelled"], me.Verbose));
      }).then((te) => {
        var ae;
        if (!ce.aborted) {
          if (y = te, d == null || d(y), y && typeof y == "object" && "status" in y && y.status === "reverted")
            throw "Transaction Reverted";
          (ae = Re()) == null || ae.log(["Transaction Receipt obtained", y], me.Verbose);
        }
      }).catch(async (te) => {
        var he;
        if (ce.aborted)
          return;
        let ae = null;
        if (y && y.transactionHash && (ae = await Sq(y.transactionHash)), (he = Re()) == null || he.log(["Error in handleConfirmTransactionStep", te], me.Error), te.message === "Transaction cancelled")
          b = !0;
        else
          throw g = !0, new Tq(te, y, ae);
      }),
      controller: J
    };
  };
  if (t === 8253038)
    return !0;
  if (O)
    await C();
  else if (
    //Sequence internal functions
    // We want synchronous execution in the following cases:
    // - Approval Signature step required first
    // - Bitcoin is the destination
    // - Canonical route used
    n.id === "approve" || ((M = (R = l == null ? void 0 : l.currencyOut) == null ? void 0 : R.currency) == null ? void 0 : M.chainId) === 8253038 || (j = i == null ? void 0 : i.data) != null && j.useExternalLiquidity
  )
    await N().promise, ((Z = (G = l == null ? void 0 : l.currencyOut) == null ? void 0 : G.currency) == null ? void 0 : Z.chainId) !== 8253038 && !((Y = i == null ? void 0 : i.data) != null && Y.useExternalLiquidity) && await C();
  else {
    const { promise: J, controller: ce } = N(), te = C(ce);
    await Promise.race([J, te]);
    const ae = ((le = (X = l == null ? void 0 : l.currencyOut) == null ? void 0 : X.currency) == null ? void 0 : le.chainId) === t;
    A && (ae ? A = !1 : await te), y || (I ? ce.abort() : await J);
  }
  return !0;
}
const bE = async ({ calldata: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (t && s.requestId && e) {
    (i = Re()) == null || i.log(["Posting same chain transaction to notify the solver"], me.Verbose);
    try {
      const c = {
        tx: t,
        chainId: e.toString(),
        requestId: s.requestId,
        referrer: a
      };
      It.request({
        url: `${n.baseURL}/transactions/single`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Re()) == null || u.log(["Same chain transaction notified to the solver"], me.Verbose);
      });
    } catch (c) {
      (o = Re()) == null || o.log(["Failed to post same chain transaction to solver", c], me.Warn);
    }
  }
}, yE = async ({ txHash: t, chainId: e, request: n, headers: r, step: s, source: a }) => {
  var i, o;
  if (s.id === "deposit" && t) {
    (i = Re()) == null || i.log(["Posting transaction to notify the solver"], me.Verbose);
    try {
      const c = {
        txHash: t,
        chainId: e.toString(),
        referrer: a
      };
      It.request({
        url: `${n.baseURL}/transactions/index`,
        method: "POST",
        headers: r,
        data: c
      }).then(() => {
        var u;
        (u = Re()) == null || u.log(["Transaction notified to the solver"], me.Verbose);
      });
    } catch (c) {
      (o = Re()) == null || o.log(["Failed to post transaction to solver", c], me.Warn);
    }
  }
};
function Bq(t) {
  var a, i;
  const e = t[0], n = t[1], r = (a = e == null ? void 0 : e.items) == null ? void 0 : a.some((o) => o.status === "incomplete"), s = (i = n == null ? void 0 : n.items) == null ? void 0 : i.some((o) => o.status === "incomplete");
  return (e == null ? void 0 : e.id) === "approve" && ((n == null ? void 0 : n.id) === "deposit" || (n == null ? void 0 : n.id) === "swap") && r && s;
}
function Pq(t) {
  var r;
  const e = (r = t[1]) == null ? void 0 : r.id;
  return {
    id: `approve-and-${e}`,
    action: "Confirm transaction in your wallet",
    description: `Batching approval and ${e} transactions`,
    kind: "transaction",
    items: [
      ...t[0].items || [],
      ...(t[1].items || []).map((s) => (s.status = "complete", s.progressState = "complete", s))
    ],
    requestId: t[1].requestId ?? t[0].requestId
  };
}
async function Cp(t, e = {}, n, r, s, a) {
  var f, h;
  const i = Re();
  i != null && i.baseApiUrl && (e.baseURL = i.baseApiUrl);
  const o = i.pollingInterval ?? 5e3, c = i.maxPollingAttemptsBeforeTimeout ?? 2.5 * 60 * 1e3 / o, u = i.chains.find((y) => y.id === t);
  if (!u)
    throw `Unable to find chain: Chain id ${t}`;
  let l = s, d = !1;
  try {
    if (!l) {
      i.log(["Execute Steps: Fetching Steps", e], me.Verbose);
      const x = await It.request(e);
      if (l = x.data, x.status !== 200)
        throw l;
      i.log(["Execute Steps: Steps retrieved", l], me.Verbose);
    }
    if (l.error || !l.steps)
      throw l;
    if (Bq(l.steps) && (d = !!(n != null && n.supportsAtomicBatch && await (n == null ? void 0 : n.supportsAtomicBatch(t))), d)) {
      const x = Pq(l.steps);
      l.steps = [x];
    }
    r({
      steps: [...l == null ? void 0 : l.steps],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details
    });
    let y = -1, b = -1;
    if (l.steps.find((x, O) => {
      if (!x.items)
        return !1;
      if (b = x.items.findIndex((I) => I.status == "incomplete"), b !== -1)
        return y = O, !0;
    }), y === -1)
      return i.log(["Execute Steps: all steps complete"], me.Verbose), l;
    const g = l.steps[y];
    if (a && a[g.id]) {
      const x = a[g.id];
      (f = g.items) == null || f.forEach((O) => {
        x.gasLimit && (O.data.gas = x.gasLimit);
      });
    }
    let w = l.steps[y].items;
    if (!w)
      return i.log(["Execute Steps: skipping step, no items in step"], me.Verbose), l;
    let { kind: v } = g, A = w[b];
    if (!A.data) {
      if (i.log(["Execute Steps: step item data is missing, begin polling"], me.Verbose), l = await jy(e, (O) => {
        var T, C, N, U;
        i.log(["Execute Steps: step item data is missing, polling", O], me.Verbose);
        const I = O;
        return !!((C = (T = I == null ? void 0 : I.steps) == null ? void 0 : T[y].items) != null && C[b].data || ((U = (N = I == null ? void 0 : I.steps) == null ? void 0 : N[y].items) == null ? void 0 : U[b].status) === "complete");
      }), !l.steps || !l.steps[y].items)
        throw l;
      const x = l.steps[y].items;
      if (!x || !x[b] || !x[b].data)
        throw l;
      w = x, A = x[b], r({
        steps: [...l == null ? void 0 : l.steps],
        fees: { ...l == null ? void 0 : l.fees },
        breakdown: l == null ? void 0 : l.breakdown,
        details: l == null ? void 0 : l.details
      });
    }
    i.log([`Execute Steps: Begin processing step items for: ${g.action}`], me.Verbose);
    const P = w.filter((x) => x.status === "incomplete").map((x) => new Promise(async (O, I) => {
      var T, C;
      try {
        const N = x.data;
        if (!l)
          return;
        switch (v) {
          case "transaction": {
            try {
              i.log([
                "Execute Steps: Begin transaction step for, sending transaction"
              ], me.Verbose);
              const U = ((T = x == null ? void 0 : x.data) == null ? void 0 : T.chainId) ?? t, L = t;
              x.progressState = "confirming", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              }), await Oq(U, d && b === 0 ? w : x, g, n, (_) => {
                i.log([
                  "Execute Steps: Transaction step, got transactions",
                  _
                ], me.Verbose), x.txHashes = _, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (_) => {
                x.internalTxHashes = _, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, e, void 0, L, (_) => {
                _ && _.data.status === "delayed" ? x.progressState = "validating_delayed" : x.progressState = "validating", l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, l == null ? void 0 : l.details, (_) => {
                x.receipt = _, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              }, (_) => {
                _ != x.checkStatus && (x.checkStatus = _, l && r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }));
              });
            } catch (U) {
              throw U;
            }
            break;
          }
          case "signature": {
            let U;
            const L = N.sign, $ = N.post;
            if (i.log(["Execute Steps: Begin signature step"], me.Verbose), L && (x.progressState = "signing", r({
              steps: [...l.steps],
              fees: { ...l == null ? void 0 : l.fees },
              breakdown: l == null ? void 0 : l.breakdown,
              details: l == null ? void 0 : l.details
            }), U = await n.handleSignMessageStep(x, g), U && (e.params = {
              ...e.params,
              signature: U
            })), $) {
              i.log(["Execute Steps: Posting order"], me.Verbose), x.progressState = "posting", r({
                steps: [...l.steps],
                fees: { ...l == null ? void 0 : l.fees },
                breakdown: l == null ? void 0 : l.breakdown,
                details: l == null ? void 0 : l.details
              });
              const _ = new URL(`${e.baseURL}${$.endpoint}`), R = {
                "Content-Type": "application/json"
              };
              $.body && !$.body.referrer && ($.body.referrer = i.source);
              try {
                const j = await async function() {
                  return await It.request({
                    url: _.href,
                    data: $.body ? JSON.stringify($.body) : void 0,
                    method: $.method,
                    params: e.params,
                    headers: R
                  });
                }();
                if (j.data && j.data.steps && Array.isArray(j.data.steps)) {
                  l.steps = [...l.steps, ...j.data.steps], r({
                    steps: [...l.steps, ...j.data.steps],
                    fees: { ...l.fees },
                    breakdown: l.breakdown,
                    details: l.details
                  }), i.log([
                    `Execute Steps: New steps appended from ${$.endpoint}`,
                    j.data.steps
                  ], me.Verbose);
                  break;
                }
                if (x != null && x.check && (x.progressState = "validating", r({
                  steps: [...l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }), x.isValidatingSignature = !0, r({
                  steps: [...l == null ? void 0 : l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                }), await Ky({
                  url: `${e.baseURL}${x == null ? void 0 : x.check.endpoint}`,
                  method: x == null ? void 0 : x.check.method,
                  headers: R
                }, (G) => {
                  var Z, Y, X, le, J, ce, te, ae, he, Oe;
                  if (i.log([
                    "Execute Steps: Polling execute status to check if indexed",
                    G
                  ], me.Verbose), ((Z = G == null ? void 0 : G.data) == null ? void 0 : Z.status) === "success" && ((Y = G == null ? void 0 : G.data) != null && Y.txHashes)) {
                    const De = (le = (X = G.data) == null ? void 0 : X.txHashes) == null ? void 0 : le.map((ze) => ({
                      txHash: ze,
                      chainId: G.data.destinationChainId ?? (u == null ? void 0 : u.id)
                    }));
                    if ((J = G == null ? void 0 : G.data) != null && J.inTxHashes) {
                      const ze = (te = (ce = G.data) == null ? void 0 : ce.inTxHashes) == null ? void 0 : te.map((at) => ({
                        txHash: at,
                        chainId: (u == null ? void 0 : u.id) ?? G.data.originChainId
                      }));
                      x.internalTxHashes = ze;
                    }
                    return x.txHashes = De, !0;
                  } else {
                    if (((ae = G == null ? void 0 : G.data) == null ? void 0 : ae.status) === "failure")
                      throw Error(((he = G == null ? void 0 : G.data) == null ? void 0 : he.details) || "Transaction failed");
                    ((Oe = G == null ? void 0 : G.data) == null ? void 0 : Oe.status) === "delayed" && (x.progressState = "validating_delayed");
                  }
                  return !1;
                }, c, 0, o)), j.status > 299 || j.status < 200)
                  throw j.data;
                j.data.results ? x.orderData = j.data.results : j.data && j.data.orderId && (x.orderData = [
                  {
                    orderId: j.data.orderId,
                    crossPostingOrderId: j.data.crossPostingOrderId,
                    orderIndex: j.data.orderIndex || 0
                  }
                ]), r({
                  steps: [...l == null ? void 0 : l.steps],
                  fees: { ...l == null ? void 0 : l.fees },
                  breakdown: l == null ? void 0 : l.breakdown,
                  details: l == null ? void 0 : l.details
                });
              } catch (M) {
                throw M;
              }
            }
            break;
          }
          default:
            break;
        }
        x.status = "complete", x.progressState = "complete", x.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        }), O(x);
      } catch (N) {
        const U = N, L = U ? U.message : "Error: something went wrong";
        U && (l != null && l.steps) && (l.steps[y].error = L, x.error = L, x.errorData = ((C = N == null ? void 0 : N.response) == null ? void 0 : C.data) || N, x.isValidatingSignature = !1, r({
          steps: [...l == null ? void 0 : l.steps],
          fees: { ...l == null ? void 0 : l.fees },
          breakdown: l == null ? void 0 : l.breakdown,
          details: l == null ? void 0 : l.details
        })), I(U);
      }
    }));
    return await Promise.all(P), await Cp(t, e, n, r, l, a);
  } catch (y) {
    i.log(["Execute Steps: An error occurred", y], me.Error);
    const b = y && ((h = y == null ? void 0 : y.response) != null && h.data) ? y.response.data : y;
    let g = !1;
    throw b && b.message ? g = b.message.includes("Refunded") : b && b.includes && (g = b.includes("Refunded")), l ? (l.error = b, r({
      steps: l.steps ? [...l.steps] : [{}],
      fees: { ...l == null ? void 0 : l.fees },
      breakdown: l == null ? void 0 : l.breakdown,
      details: l == null ? void 0 : l.details,
      refunded: g,
      error: b
    })) : (l = {
      error: b,
      steps: [],
      refunded: g
    }, r(l)), y;
  }
}
function Iq(t, e) {
  Object.keys(e).map((n) => {
    var s;
    let r = e[n];
    return r !== void 0 && (Array.isArray(r) ? r.forEach((a) => {
      t.searchParams.append(n, a);
    }) : t.searchParams.append(n, (s = e[n]) == null ? void 0 : s.toString())), t;
  });
}
function Wy(t) {
  var a;
  const { abi: e, functionName: n, args: r } = t, s = Xs({ abi: e, functionName: n, args: r });
  return {
    to: t.address,
    value: ((a = t == null ? void 0 : t.value) == null ? void 0 : a.toString()) ?? "0",
    data: s
  };
}
async function Uq(t, e) {
  const r = e.contracts.map((s) => {
    const { address: a, abi: i, functionName: o, args: c, value: u } = s;
    return {
      data: Tu({
        abi: i,
        functionName: o,
        args: c
      }),
      to: a,
      value: u
    };
  });
  return Fe(t, F8, "sendCalls")({ ...e, calls: r });
}
function gE() {
  return (t) => ({
    getCallsStatus: (e) => M8(t, e),
    getCapabilities: (e) => cj(t, e),
    sendCalls: (e) => F8(t, e),
    showCallsStatus: (e) => lj(t, e),
    waitForCallsStatus: (e) => uj(t, e),
    writeContracts: (e) => Uq(t, e)
  });
}
function Qy(t) {
  return t.extend !== void 0 && t.getPermissions !== void 0;
}
const Tp = (t) => ({
  vmType: "evm",
  getChainId: async () => t.getChainId(),
  transport: Zc(t.transport),
  address: async () => {
    var n;
    let e = (n = t.account) == null ? void 0 : n.address;
    return e || ([e] = await t.getAddresses()), e;
  },
  handleSignMessageStep: async (e) => {
    var a;
    const n = Re(), r = (a = e.data) == null ? void 0 : a.sign;
    let s;
    return r && (r.signatureKind === "eip191" ? (n.log(["Execute Steps: Signing with eip191"], me.Verbose), r.message.match(/0x[0-9a-fA-F]{64}/) ? s = await t.signMessage({
      account: t.account,
      message: {
        raw: r.message
      }
    }) : s = await t.signMessage({
      account: t.account,
      message: r.message
    })) : r.signatureKind === "eip712" && (n.log(["Execute Steps: Signing with eip712"], me.Verbose), s = await t.signTypedData({
      account: t.account,
      domain: r.domain,
      types: r.types,
      primaryType: r.primaryType,
      message: r.value
    }))), s;
  },
  handleSendTransactionStep: async (e, n) => {
    var o;
    const r = n.data, s = Re(), a = (o = Re().chains.find((c) => c.id === e)) == null ? void 0 : o.viemChain;
    if (!a)
      throw "Chain not found when sending transaction";
    return await Df({
      account: t.account ?? r.from,
      chain: a,
      transport: Zc(t.transport, { retryCount: 10, retryDelay: 200 })
    }).sendTransaction({
      chain: a,
      data: r.data,
      account: t.account ?? r.from,
      // use signer.account if it's defined
      to: r.to,
      value: us(r.value || 0),
      ...r.maxFeePerGas && s.useGasFeeEstimations && {
        maxFeePerGas: us(r.maxFeePerGas)
      },
      ...r.maxPriorityFeePerGas && s.useGasFeeEstimations && {
        maxPriorityFeePerGas: us(r.maxPriorityFeePerGas)
      },
      ...r.gas && s.useGasFeeEstimations && {
        gas: us(r.gas)
      }
    });
  },
  handleConfirmTransactionStep: async (e, n, r, s) => {
    const a = Re(), i = a.chains.find((l) => l.id === n), o = i == null ? void 0 : i.httpRpcUrl;
    return await uu({
      chain: i == null ? void 0 : i.viemChain,
      transport: t.transport ? Mg(o ? [Zt(o), Zc(t.transport), Zt()] : [Zc(t.transport), Zt()]) : Mg([Zt(o), Zt()]),
      pollingInterval: a.confirmationPollingInterval
    }).waitForTransactionReceipt({
      hash: e,
      onReplaced: (l) => {
        if (l.reason === "cancelled")
          throw s(), Error("Transaction cancelled");
        r(l.transaction.hash);
      }
    });
  },
  switchChain: async (e) => {
    var n;
    try {
      await t.switchChain({
        id: e
      });
      return;
    } catch (r) {
      if (r && (r != null && r.message)) {
        if (r.message.includes("does not support the requested chain"))
          throw new Error("Wallet does not support chain");
        if (r.message.includes("rejected"))
          throw r;
        if (r.message.includes("already pending"))
          return;
      }
      const a = Re().chains.find((i) => i.id === e);
      if (!a)
        throw "Chain missing from Relay Client";
      try {
        await t.addChain({
          chain: a == null ? void 0 : a.viemChain
        });
      } catch (i) {
        if (i instanceof Error && i.name && i.name === "InternalRpcError" && i.message.includes("is not a function")) {
          (n = Re()) == null || n.log([
            "Execute Steps: Detected internal RPC Error when adding a chain to the wallet",
            i
          ], me.Verbose);
          return;
        } else
          throw i;
      }
      return;
    }
  },
  supportsAtomicBatch: async (e) => {
    var n, r;
    if (!t.account)
      return !1;
    try {
      const s = t.extend(gE());
      return (r = (n = (await s.getCapabilities({
        account: s.account
      }))[e]) == null ? void 0 : n.atomicBatch) == null ? void 0 : r.supported;
    } catch {
      return !1;
    }
  },
  handleBatchTransactionStep: async (e, n) => {
    var c;
    const r = n.map((u) => ({
      to: u.data.to,
      data: u.data.data,
      value: us(u.data.value || 0),
      ...u.data.maxFeePerGas && {
        maxFeePerGas: us(u.data.maxFeePerGas)
      },
      ...u.data.maxPriorityFeePerGas && {
        maxPriorityFeePerGas: us(u.data.maxPriorityFeePerGas)
      },
      ...u.data.gas && {
        gas: us(u.data.gas)
      }
    })), s = t.extend(gE()), i = (c = Re().chains.find((u) => u.id === e)) == null ? void 0 : c.viemChain;
    if (!i)
      throw "Chain not found when sending transaction";
    return await s.sendCalls({
      chain: i,
      account: t.account,
      calls: r
    });
  }
}), hk = "https://api.relay.link", zs = "https://assets.relay.link", Nq = Object.values(vu).reduce((t, e) => (t[e.id] = e, t), {}), mk = (t) => {
  let e;
  const r = [999].includes(t.id) ? void 0 : Nq[t.id];
  return r ? e = r : e = {
    id: t.id,
    name: t.displayName,
    nativeCurrency: {
      name: t.currency.name ?? "Ethereum",
      decimals: t.currency.decimals ?? 18,
      symbol: t.currency.symbol ?? "ETH"
    },
    rpcUrls: {
      default: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      },
      public: {
        http: [t.httpRpcUrl],
        webSocket: [t.wsRpcUrl]
      }
    },
    blockExplorers: {
      etherscan: {
        name: t.explorerName,
        url: t.explorerUrl
      },
      default: {
        name: t.explorerName,
        url: t.explorerUrl
      }
    }
  }, {
    ...t,
    viemChain: e,
    icon: {
      dark: `${zs}/icons/${t.id}/dark.png`,
      light: t.iconUrl ?? `${zs}/icons/${t.id}/light.png`,
      squaredDark: `${zs}/icons/square/${t.id}/dark.png`,
      squaredLight: `${zs}/icons/square/${t.id}/light.png`
    }
  };
}, Sp = (t) => {
  var e;
  return {
    id: t.id,
    name: t.name.replace(" ", "-"),
    displayName: t.name,
    httpRpcUrl: t.rpcUrls.default && t.rpcUrls.default && t.rpcUrls.default ? t.rpcUrls.default.http[0] ?? "" : "",
    wsRpcUrl: t.rpcUrls && t.rpcUrls.default.webSocket ? t.rpcUrls.default.webSocket[0] ?? "" : "",
    icon: {
      dark: `${zs}/icons/${t.id}/dark.png`,
      light: `${zs}/icons/${t.id}/light.png`,
      squaredDark: `${zs}/icons/square/${t.id}/dark.png`,
      squaredLight: `${zs}/icons/square/${t.id}/light.png`
    },
    currency: {
      address: Ye,
      ...t.nativeCurrency
    },
    explorerUrl: ((e = t.blockExplorers) == null ? void 0 : e.default.url) ?? "",
    vmType: "evm",
    depositEnabled: !0,
    viemChain: t
  };
}, Rq = async (t, e) => {
  let n = "";
  if (e) {
    const s = new URLSearchParams();
    s.set("referrer", e), n = `?${s.toString()}`;
  }
  const r = await It.get(`${t}/chains${n}`);
  if (r.data && r.data.chains)
    return r.data.chains.map((s) => mk(s));
  throw "No Chain Data";
}, bk = (t) => {
  let e = null, n, r = [];
  for (const s of t) {
    for (const a of s.items || [])
      if (a.txHashes && a.txHashes.length > 0 && (r = a.txHashes.concat([...r])), a.internalTxHashes && a.internalTxHashes.length > 0 && (r = a.internalTxHashes.concat([...r])), a.status === "incomplete") {
        e = s, n = a;
        break;
      }
    if (e && n)
      break;
  }
  return { currentStep: e, currentStepItem: n, txHashes: r };
};
function Jy(t) {
  return t.abi !== void 0;
}
function Zy(t) {
  return typeof structuredClone == "function" ? structuredClone(t) : JSON.parse(JSON.stringify(t));
}
const Fq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APIError: Bc,
  get LogLevel() {
    return me;
  },
  adaptViemWallet: Tp,
  axios: It,
  configureViemChain: mk,
  convertViemChainToRelayChain: Sp,
  executeSteps: Cp,
  fetchChainConfigs: Rq,
  getCurrentStepData: bk,
  isAPIError: vq,
  isSimulateContractRequest: Jy,
  log: ob,
  pollUntilHasData: jy,
  pollUntilOk: Ky,
  prepareCallTransaction: Wy,
  repeatUntilOk: qy,
  request: Aq,
  safeStructuredClone: Zy,
  setParams: Iq
}, Symbol.toStringTag, { value: "Module" })), Mq = "2.1.3";
let ol;
const Dq = [
  ml,
  hl,
  qv,
  bl,
  pl,
  Cv
].map((t) => Sp(t)), Lq = [Kv, Tv].map((t) => Sp(t));
class Hq {
  log(e, n = me.Info) {
    return ob(e, n, this.logLevel);
  }
  constructor(e) {
    var n;
    if (Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uiVersion", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "baseApiUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "source", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "logLevel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "confirmationPollingInterval", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxPollingAttemptsBeforeTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "useGasFeeEstimations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chains", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utils", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { ...Fq }
    }), Object.defineProperty(this, "actions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: sC
    }), this.version = Mq, this.uiVersion = e.uiVersion, this.baseApiUrl = e.baseApiUrl ?? hk, this.logLevel = e.logLevel !== void 0 ? e.logLevel : me.None, this.pollingInterval = e.pollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations ?? !0, e.chains ? this.chains = e.chains : (n = e.baseApiUrl) != null && n.includes("testnets") ? this.chains = Lq : this.chains = Dq, e.source)
      this.source = e.source;
    else if (typeof window < "u") {
      let r = location.hostname;
      r.indexOf("www.") === 0 && (r = r.replace("www.", "")), this.source = r, console.warn("RelaySDK automatically generated a source based on the url, we recommend providing a source when initializing the sdk. Refer to our docs for steps on how to do this: https://docs.relay.link/references/sdk/getting-started#configuration");
    }
  }
  configure(e) {
    this.baseApiUrl = e.baseApiUrl ? e.baseApiUrl : this.baseApiUrl, this.source = e.source ? e.source : this.source, this.logLevel = e.logLevel !== void 0 ? e.logLevel : me.None, this.pollingInterval = e.pollingInterval ? e.pollingInterval : this.pollingInterval, this.confirmationPollingInterval = e.confirmationPollingInterval ? e.confirmationPollingInterval : this.confirmationPollingInterval, this.maxPollingAttemptsBeforeTimeout = e.maxPollingAttemptsBeforeTimeout ? e.maxPollingAttemptsBeforeTimeout : this.maxPollingAttemptsBeforeTimeout, this.useGasFeeEstimations = e.useGasFeeEstimations !== void 0 ? e.useGasFeeEstimations : this.useGasFeeEstimations, e.logger ? this.log = e.logger : this.log = (n, r = me.Info) => {
      ob(n, r, this.logLevel);
    }, e.chains && (this.chains = e.chains);
  }
}
function Re() {
  return ol;
}
function $q(t) {
  return ol ? ol.configure(t) : ol = new Hq({ ...t }), ol;
}
const yk = "0x000000000000000000000000000000000000dead", gk = "CbKGgVKLJFb8bBrf58DnAkdryX6ubewVytn7X957YwNr", wk = "CrfbABN2sSvmoZLu9eDDfXpaC2nHg42R7AXbHs9eg4S9", Ek = "bc1q4vxn43l44h30nkluqfxd9eckf45vr2awz38lwa", _q = "THa7BwoPfacfiELa63pbmm3g5PGKYmtJyt", Gq = "0x00000000000000000000000000000000000dead0", xk = "0x000000000000000000000000000000000000000000000000000000000000dead", zq = 9286185, Vq = 543210, hb = (t, e) => t === "svm" ? e === zq ? wk : gk : t === "bvm" ? Ek : e === Vq ? Gq : t === "tvm" ? _q : t === "suivm" ? xk : yk, wE = (t) => t ? t === wk || t === gk || t === Ek || t === yk || t === xk : !1;
function jq(t) {
  var o, c, u, l, d;
  const { quote: e, wallet: n, depositGasLimit: r, onProgress: s } = t, a = Re();
  if (!a.baseApiUrl || !a.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let i;
  n && (i = Qy(n) ? Tp(n) : n);
  try {
    if (!i)
      throw new Error("AdaptedWallet is required to execute steps");
    const f = new AbortController(), h = (u = (c = (o = e.details) == null ? void 0 : o.currencyIn) == null ? void 0 : c.currency) == null ? void 0 : u.chainId;
    if (h === void 0)
      throw new Error("Missing chainId from quote");
    if (wE((l = e == null ? void 0 : e.details) == null ? void 0 : l.recipient))
      throw new Error("Recipient should never be burn address");
    if (wE((d = e == null ? void 0 : e.details) == null ? void 0 : d.sender))
      throw new Error("Sender should never be burn address");
    const { request: y, ...b } = e, g = Zy(b), w = new Promise((v, A) => {
      Cp(h, y, i, ({ steps: P, fees: x, breakdown: O, details: I, refunded: T, error: C }) => {
        if (f.signal.aborted) {
          console.log("Relay SDK: Execution aborted, skipping progress callback");
          return;
        }
        const { currentStep: N, currentStepItem: U, txHashes: L } = bk(P);
        s == null || s({
          steps: P,
          fees: x,
          breakdown: O,
          details: I,
          currentStep: N,
          currentStepItem: U,
          txHashes: L,
          refunded: T,
          error: C
        });
      }, g, r ? {
        deposit: {
          gasLimit: r
        }
      } : void 0).then((P) => {
        v({ data: P, abortController: f });
      }).catch(A);
    });
    return w.abortController = f, w;
  } catch (f) {
    throw console.error(f), f;
  }
}
const Kq = async (t, e, n, r, s) => {
  const a = t.chains.find((l) => l.id === n), i = t.chains.find((l) => l.id === e), o = a ? hb(a.vmType, a.id) : void 0, c = i ? hb(i.vmType, i.id) : void 0;
  let u;
  return s && (u = await s.address()), {
    user: u || o || Ye,
    recipient: r || u || c || Ye
  };
};
async function qq(t, e) {
  var P;
  const { toChainId: n, toCurrency: r, wallet: s, chainId: a, currency: i, tradeType: o, amount: c = "0", recipient: u, options: l, txs: d, user: f } = t, h = Re();
  if (!h.baseApiUrl || !h.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let y;
  s && (y = Qy(s) ? Tp(s) : s);
  let b;
  d && d.length > 0 && (b = d.map((x) => Jy(x) ? Wy(x) : x));
  let g;
  if (e && (g = await Kq(h, n, a, u, y)), !f && !(g != null && g.user))
    throw new Error("User is required");
  if (!u && !(g != null && g.recipient))
    throw new Error("Recipient is required");
  const w = {
    user: e ? g == null ? void 0 : g.user : f,
    destinationCurrency: r,
    destinationChainId: n,
    originCurrency: i,
    originChainId: a,
    amount: c,
    recipient: e ? g == null ? void 0 : g.recipient : u,
    tradeType: o,
    referrer: h.source || void 0,
    txs: b,
    ...l
  }, v = {
    url: `${h.baseApiUrl}/quote`,
    method: "post",
    data: w
  }, A = await It.request(v);
  if (A.status !== 200)
    throw new Bc((P = A == null ? void 0 : A.data) == null ? void 0 : P.message, A.status, A.data);
  return { ...A.data, request: v };
}
async function Wq(t) {
  var v;
  const { destinationChainId: e, destinationCurrency: n, originChainId: r, originCurrency: s, tradeType: a, amount: i = "0", user: o, recipient: c, options: u, txs: l } = t, d = Re();
  if (!d.baseApiUrl || !d.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let f;
  l && l.length > 0 && (f = l.map((A) => Jy(A) ? Wy(A) : A));
  const h = d.chains.find((A) => A.id === r), y = hb(h == null ? void 0 : h.vmType, h == null ? void 0 : h.id), b = {
    user: o ?? y,
    destinationCurrency: n,
    destinationChainId: e,
    originCurrency: s,
    originChainId: r,
    amount: i,
    recipient: c || (o ?? y),
    tradeType: a,
    referrer: d.source || void 0,
    txs: f,
    ...u
  }, g = {
    url: `${d.baseApiUrl}/price`,
    method: "post",
    data: b
  }, w = await It.request(g);
  if (w.status !== 200)
    throw new Bc((v = w == null ? void 0 : w.data) == null ? void 0 : v.message, w.status, w.data);
  return { ...w.data, request: g };
}
async function Qq(t, e = It) {
  const n = Re();
  if (!n)
    throw new Error("Client not initialized");
  t.user = t.user || Ye, t.currency = t.currency;
  const r = await e.get(`${n.baseApiUrl}/config/v2`, { params: t });
  if (r.data)
    return r.data;
  throw "No solver capacity data";
}
async function Jq(t) {
  var a;
  const { wallet: e } = t, n = Re();
  if (!n.baseApiUrl || !n.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  const r = {
    url: `${n.baseApiUrl}/app-fees/${e}/balances`,
    method: "get"
  }, s = await It.request(r);
  if (s.status !== 200)
    throw new Bc((a = s == null ? void 0 : s.data) == null ? void 0 : a.message, s.status, s.data);
  return s.data.balances || [];
}
async function Zq(t) {
  var d;
  const { wallet: e, chainId: n, currency: r, recipient: s, onProgress: a } = t, i = Re();
  if (!i.baseApiUrl || !i.baseApiUrl.length)
    throw new ReferenceError("RelayClient missing api url configuration");
  let o;
  if (e && (o = Qy(e) ? Tp(e) : e), !o)
    throw new Error("AdaptedWallet is required to execute claim steps");
  const c = await o.address(), u = new AbortController(), l = {
    url: `${i.baseApiUrl}/app-fees/${c}/claim`,
    method: "post",
    data: { chainId: n, currency: r, recipient: s || c },
    signal: u.signal
  };
  try {
    const f = await i.utils.axios.request(l);
    if (f.status !== 200)
      throw new Bc((d = f == null ? void 0 : f.data) == null ? void 0 : d.message, f.status, f.data);
    const h = f.data.steps || [], y = Zy({
      steps: h
    });
    return { data: await Cp(n, l, o, (g) => {
      u.signal.aborted || a == null || a(g);
    }, y), abortController: u };
  } catch (f) {
    throw console.error(f), f;
  }
}
$q({
  baseApiUrl: hk,
  source: "AnyPay",
  chains: Object.values(vu).map(
    (t) => Sp(t)
  )
});
async function Xq(t) {
  try {
    const e = Re();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("getRelaySDKQuote", t), await e.actions.getQuote({
      wallet: t.wallet,
      chainId: t.chainId,
      toChainId: t.toChainId || t.chainId,
      amount: t.amount,
      currency: t.currency,
      toCurrency: t.toCurrency || t.currency,
      tradeType: t.tradeType || "EXACT_OUTPUT",
      txs: t.txs,
      user: t.wallet.account.address,
      recipient: t.recipient || t.wallet.account.address
    });
  } catch (e) {
    throw console.error("Error getting relay quote:", e), e;
  }
}
async function Yq(t) {
  try {
    const e = Re();
    if (!e)
      throw new Error("Relay client not available");
    return console.log("relaysdkclient", e.chains, t.quote), await e.actions.execute({
      quote: t.quote,
      wallet: t.wallet,
      onProgress: t.onProgress || ((r) => {
        console.log("Relay progress:", r);
      })
    });
  } catch (e) {
    throw console.error("Error executing relay transaction:", e), e;
  }
}
async function eW(t, e, n) {
  return await Yq({
    quote: t,
    wallet: e,
    onProgress: n
  });
}
function tW(t) {
  var e, n, r, s, a, i, o, c;
  return (c = (o = (i = (a = (s = (r = (e = t == null ? void 0 : t.data) == null ? void 0 : e.steps) == null ? void 0 : r[((n = t == null ? void 0 : t.data) == null ? void 0 : n.steps.length) - 1]) == null ? void 0 : s.items) == null ? void 0 : a[0]) == null ? void 0 : i.txHashes) == null ? void 0 : o[0]) == null ? void 0 : c.txHash;
}
const nW = [{
  type: "function",
  name: "isValidSignature",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }, {
    type: "bytes"
  }],
  outputs: [{
    type: "bytes4"
  }],
  payable: !1,
  stateMutability: "view"
}], rW = {
  isValidSignatureBytes32: "0x1626ba7e"
};
var sW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: nW,
  returns: rW
});
const aW = [{
  type: "function",
  name: "deploy",
  constant: !1,
  inputs: [{
    type: "address"
  }, {
    type: "bytes32"
  }],
  outputs: [],
  payable: !0,
  stateMutability: "payable"
}];
var iW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: aW
});
const oW = [{
  type: "function",
  name: "nonce",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "readNonce",
  constant: !0,
  inputs: [{
    type: "uint256"
  }],
  outputs: [{
    type: "uint256"
  }],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "updateImplementation",
  constant: !1,
  inputs: [{
    type: "address"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "selfExecute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "execute",
  constant: !1,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }, {
    type: "uint256"
  }, {
    type: "bytes"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "createContract",
  inputs: [{
    type: "bytes"
  }],
  payable: !0,
  stateMutability: "payable"
}, {
  type: "function",
  name: "setExtraImageHash",
  constant: !1,
  inputs: [{
    type: "bytes32",
    name: "imageHash"
  }, {
    type: "uint256",
    name: "expiration"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "nonpayable"
}];
var cW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: oW
});
const lW = [{
  type: "function",
  name: "updateImageHash",
  constant: !0,
  inputs: [{
    type: "bytes32"
  }],
  outputs: [],
  payable: !1,
  stateMutability: "view"
}, {
  type: "function",
  name: "imageHash",
  constant: !0,
  inputs: [],
  outputs: [{
    type: "bytes32"
  }],
  payable: !1,
  stateMutability: "view"
}];
var uW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: lW
});
const dW = [{
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookAlreadyExists",
  type: "error"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "HookDoesNotExist",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "_sender",
    type: "address"
  }, {
    internalType: "address",
    name: "_self",
    type: "address"
  }],
  name: "OnlySelfAuth",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
    indexed: !1,
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    indexed: !1,
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "DefinedHook",
  type: "event"
}, {
  stateMutability: "payable",
  type: "fallback"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }, {
    internalType: "address",
    name: "_implementation",
    type: "address"
  }],
  name: "addHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155BatchReceived",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC1155Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "address",
    name: "",
    type: "address"
  }, {
    internalType: "uint256",
    name: "",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "",
    type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
    internalType: "bytes4",
    name: "",
    type: "bytes4"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "readHook",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_signature",
    type: "bytes4"
  }],
  name: "removeHook",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  stateMutability: "payable",
  type: "receive"
}];
var fW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: dW
});
const pW = [{
  type: "function",
  name: "PROXY_getImplementation",
  inputs: [],
  outputs: [{
    name: "",
    type: "address",
    internalType: "address"
  }],
  stateMutability: "view"
}];
var hW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: pW
});
const St = {
  erc1271: sW,
  factory: iW,
  mainModule: cW,
  mainModuleUpgradable: uW,
  moduleHooks: fW,
  walletProxyHook: hW
};
function ft() {
  return ft = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, ft.apply(null, arguments);
}
function Bu(t) {
  return oi(["bytes", "uint256", "address", "bytes32"], ["0x1901", t.chainId, t.address, t.digest]);
}
function Ak(t) {
  return t.digest !== void 0 && t.chainId !== void 0 && t.address !== void 0;
}
var mW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  subdigestOf: Bu,
  isSignedPayload: Ak
});
const bW = "0x1626ba7e", yW = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }, {
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}];
async function vk(t, e, n, r) {
  return await new vr(t, yW, r).isValidSignature(e, n) === bW;
}
var gW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isValidEIP1271Signature: vk
});
let Qs = /* @__PURE__ */ function(t) {
  return t[t.EIP712 = 1] = "EIP712", t[t.ETH_SIGN = 2] = "ETH_SIGN", t[t.WALLET_BYTES32 = 3] = "WALLET_BYTES32", t;
}({});
function wW(t) {
  const e = Q(t), n = e[e.length - 1];
  return n === Qs.EIP712 || n === Qs.ETH_SIGN;
}
function Pu(t, e) {
  const n = Q(e), r = Q(t), s = n[n.length - 1], a = V(n.slice(0, 32)), i = V(n.slice(32, 64)), o = Number(V(n.slice(64, 65))), c = {
    r: a,
    s: i,
    v: o
  };
  if (s === Qs.EIP712)
    return Zm(r, c);
  if (s === Qs.ETH_SIGN)
    return Zm(uA(r), c);
  throw new Error(`Unsupported signature type: ${s}`);
}
function Xy(t, e, n, r) {
  const s = Q(n), a = s[s.length - 1];
  if (a === Qs.EIP712 || a === Qs.ETH_SIGN)
    return t === Pu(e, n);
  if (a === Qs.WALLET_BYTES32)
    return vk(t, V(e), s.slice(0, -1), r);
  throw new Error(`Unsupported signature type: ${a}`);
}
function EW(t, e) {
  const n = Q(e);
  if (n.length === 66)
    try {
      return Pu(t, n);
    } catch {
    }
}
var xW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigType: Qs,
  canRecover: wW,
  recoverSigner: Pu,
  isValidSignature: Xy,
  tryRecoverSigner: EW
});
let ui = /* @__PURE__ */ function(t) {
  return t[t.EOASignature = 0] = "EOASignature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t;
}({});
function Yy(t) {
  return t.address !== void 0 && !kk(t);
}
function kk(t) {
  return t.signature !== void 0 && t.weight !== void 0 && t.isDynamic !== void 0;
}
function Ck(t) {
  return t.threshold !== void 0 && t.signers !== void 0;
}
function Tk(t) {
  const e = Q(t), n = e[0] << 8 | e[1], r = [];
  for (let s = 2; s < e.length; ) {
    const a = e[s++], i = e[s++];
    switch (a) {
      case ui.EOASignature:
        r.push({
          unrecovered: !0,
          weight: i,
          signature: V(e.slice(s, s + 66)),
          isDynamic: !1
        }), s += 66;
        break;
      case ui.Address:
        r.push({
          weight: i,
          address: ue(V(e.slice(s, s + 20)))
        }), s += 20;
        break;
      case ui.DynamicSignature:
        const o = ue(V(e.slice(s, s + 20)));
        s += 20;
        const c = e[s] << 8 | e[s + 1];
        s += 2, r.push({
          unrecovered: !0,
          weight: i,
          signature: V(e.slice(s, s + c)),
          address: o,
          isDynamic: !0
        }), s += c;
        break;
      default:
        throw new Error(`Unknown signature part type: ${a}`);
    }
  }
  return {
    version: 1,
    threshold: n,
    signers: r
  };
}
function eg(t) {
  if (Ei(t))
    return V(t);
  const {
    signers: e,
    threshold: n
  } = Ck(t) ? t : t.config, r = e.map((s) => {
    if (Yy(s))
      return Ee(["uint8", "uint8", "address"], [ui.Address, s.weight, s.address]);
    if (s.isDynamic) {
      const a = Q(s.signature);
      return Ee(["uint8", "uint8", "address", "uint16", "bytes"], [ui.DynamicSignature, s.weight, s.address, a.length, a]);
    }
    return Ee(["uint8", "uint8", "bytes"], [ui.EOASignature, s.weight, s.signature]);
  });
  return Ee(["uint16", ...new Array(r.length).fill("bytes")], [n, ...r]);
}
async function Sk(t, e, n) {
  const r = Bu(e), s = await Promise.all(t.signers.map(async (a) => {
    if (Yy(a))
      return a;
    if (a.isDynamic) {
      if (!a.address) throw new Error("Dynamic signature part must have address");
      if (!Xy(a.address, r, a.signature, n))
        throw new Error(`Invalid dynamic signature part ${a.address}`);
      return {
        address: a.address,
        weight: a.weight,
        signature: a.signature
      };
    } else
      return {
        address: Pu(r, a.signature),
        weight: a.weight,
        signature: a.signature
      };
  }));
  return {
    version: 1,
    payload: e,
    subdigest: r,
    config: {
      version: 1,
      threshold: t.threshold,
      signers: s
    }
  };
}
function yl(t, e, n, r) {
  if (n.length !== 0)
    throw new Error("Explicit subdigests not supported on v1");
  let s = 0n;
  const a = t.signers.map((o) => {
    if (!e.has(o.address))
      return o;
    const c = e.get(o.address), u = Q(c.signature);
    return s += BigInt(o.weight), c.isDynamic || u.length !== 66 ? ft({}, o, {
      isDynamic: !0,
      signature: c.signature,
      address: o.address
    }) : ft({}, o, {
      isDynamic: !1,
      signature: c.signature
    });
  });
  return {
    encoded: eg({
      version: 1,
      threshold: t.threshold,
      signers: a
    }),
    weight: s
  };
}
const tg = {
  decode: (t) => Tk(t),
  encode: (t) => eg(t),
  trim: async (t) => t,
  supportsNoChainId: !0,
  recover: (t, e, n) => Sk(t, e, n),
  encodeSigners: (t, e, n, r) => yl(t, e, n),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = tg.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    throw new Error("Signature chaining not supported on v1");
  },
  hashSetImageHash: function(t) {
    throw new Error("Image hash not supported on v1");
  },
  signaturesOf(t) {
    return t.signers.filter((e) => e.signature !== void 0).map((e) => ({
      address: e.address,
      signature: e.signature
    }));
  },
  signaturesOfDecoded: function(t) {
    return t.signers.map((e) => e.signature).filter((e) => e !== void 0);
  }
};
var AW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignaturePartType: ui,
  isAddressMember: Yy,
  isUnrecoveredSignatureMember: kk,
  isUnrecoveredSignature: Ck,
  decodeSignature: Tk,
  encodeSignature: eg,
  recoverSignature: Sk,
  encodeSigners: yl,
  SignatureCoder: tg
});
const ng = {
  isWalletConfig: (t) => t.version === 1 && t.threshold !== void 0 && t.signers !== void 0,
  imageHashOf: (t) => t.signers.reduce((e, n) => xe(Ot.defaultAbiCoder().encode(["bytes32", "uint8", "address"], [e, n.weight, n.address])), Ee(["uint256"], [t.threshold])),
  hasSubdigest: (t, e) => !1,
  isComplete: (t) => !0,
  checkpointOf: (t) => 0n,
  signersOf: (t) => t.signers.map((e) => ({
    address: e.address,
    weight: Number(e.weight)
  })),
  fromSimple: (t) => {
    if (BigInt(t.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (t.subdigests && t.subdigests.length > 0)
      throw new Error("v1 wallet config does not support subdigests");
    return {
      version: 1,
      threshold: t.threshold,
      signers: t.signers
    };
  },
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Bt([...St.mainModule.abi, ...St.mainModuleUpgradable.abi]), a = [];
      return (!r || r === "first") && a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImplementation"), [n.mainModuleUpgradable]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), a.push({
        to: t,
        data: s.encodeFunctionData(s.getFunction("updateImageHash"), [ng.imageHashOf(e)]),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }), {
        entrypoint: t,
        transactions: a
      };
    },
    decodeTransaction: function(t) {
      throw new Error("Function not implemented.");
    }
  },
  toJSON: function(t) {
    const e = t.signers.map((n) => ({
      weight: BigInt(n.weight).toString(),
      address: n.address
    }));
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      signers: e
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t), n = e.signers.map((r) => ({
      weight: BigInt(r.weight),
      address: r.address
    }));
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      signers: n
    };
  },
  editConfig: function(t, e) {
    var n;
    const r = t.signers.slice();
    if (e.checkpoint && BigInt(e.checkpoint) !== 0n)
      throw new Error("v1 wallet config does not support checkpoint");
    if (e.add)
      for (const s of e.add)
        r.find((a) => a.address === s.address) || r.push({
          weight: s.weight,
          address: s.address
        });
    if (e.remove)
      for (const s of e.remove) {
        const a = r.findIndex((i) => i.address === s);
        a >= 0 && r.splice(a, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      signers: r
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = yl(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = t.signers;
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => Number(a) - Number(i))) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = yl(t, n, []);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return yl(t, n, []).encoded;
  }
};
var vW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigCoder: ng
}), kW = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const Ok = 1, Bk = {
  version: Ok,
  factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
  guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
  mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
  mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var ha = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: vW,
  context: kW,
  signature: AW,
  version: Ok,
  DeployedWalletContext: Bk
});
const rg = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function Pk(t) {
  return xe(Ik(t));
}
function Ik(t) {
  return Ee(["bytes32", "bytes32"], [rg, t]);
}
function Uk(t) {
  const e = Q(t);
  if (e.length === 64 && V(e.slice(0, 32)) === rg)
    return V(e.slice(32, 64));
}
function CW(t) {
  return Uk(t) !== void 0;
}
var TW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SetImageHashPrefix: rg,
  hashSetImageHash: Pk,
  messageSetImageHash: Ik,
  decodeMessageSetImageHash: Uk,
  isMessageSetImageHash: CW
});
let rt = /* @__PURE__ */ function(t) {
  return t[t.Legacy = 0] = "Legacy", t[t.Dynamic = 1] = "Dynamic", t[t.NoChainIdDynamic = 2] = "NoChainIdDynamic", t[t.Chained = 3] = "Chained", t;
}({}), Ve = /* @__PURE__ */ function(t) {
  return t[t.Signature = 0] = "Signature", t[t.Address = 1] = "Address", t[t.DynamicSignature = 2] = "DynamicSignature", t[t.Node = 3] = "Node", t[t.Branch = 4] = "Branch", t[t.Subdigest = 5] = "Subdigest", t[t.Nested = 6] = "Nested", t;
}({});
const kf = 66;
function Ti(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function Pc(t) {
  return t.tree !== void 0;
}
function Iu(t) {
  return t.unrecovered && t.signature !== void 0 && t.isDynamic !== void 0;
}
function Cf(t) {
  let e = Q(t), n;
  const r = (s, a) => s ? s.right ? {
    left: s,
    right: a
  } : {
    left: s.left,
    right: a
  } : {
    left: a
  };
  for (; e.length > 0; ) {
    const s = e[0];
    switch (e = e.slice(1), s) {
      case Ve.Signature:
        {
          const a = e[0], i = V(e.slice(1, kf + 1));
          n = r(n, {
            signature: i,
            weight: a,
            unrecovered: !0,
            isDynamic: !1
          }), e = e.slice(kf + 1);
        }
        break;
      case Ve.Address:
        {
          const a = e[0], i = ue(V(e.slice(1, 21)));
          n = r(n, {
            address: i,
            weight: a
          }), e = e.slice(21);
        }
        break;
      case Ve.DynamicSignature:
        {
          const a = e[0], i = ue(V(e.slice(1, 21))), o = e[21] << 16 | e[22] << 8 | e[23], c = V(e.slice(24, 24 + o));
          n = r(n, {
            address: i,
            signature: c,
            weight: a,
            unrecovered: !0,
            isDynamic: !0
          }), e = e.slice(24 + o);
        }
        break;
      case Ve.Node:
        {
          const a = V(e.slice(0, 32));
          n = r(n, {
            nodeHash: a
          }), e = e.slice(32);
        }
        break;
      case Ve.Branch:
        {
          const a = e[0] << 16 | e[1] << 8 | e[2], i = Cf(e.slice(3, 3 + a));
          n = r(n, i), e = e.slice(3 + a);
        }
        break;
      case Ve.Subdigest:
        {
          const a = V(e.slice(0, 32));
          n = r(n, {
            subdigest: a
          }), e = e.slice(32);
        }
        break;
      case Ve.Nested:
        {
          const a = e[0], i = e[1] << 8 | e[2], o = e[3] << 16 | e[4] << 8 | e[5], c = Cf(e.slice(6, 6 + o));
          n = r(n, {
            weight: a,
            threshold: i,
            tree: c
          }), e = e.slice(6 + o);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${s}: ${V(e)}`);
    }
  }
  if (!n)
    throw new Error("Empty signature tree");
  return n.right ? n : n.left;
}
class Nk extends Error {
  constructor(e) {
    super(`Invalid signature leaf: ${JSON.stringify(e)}`), this.leaf = e;
  }
}
async function di(t, e, n) {
  if (Ti(t)) {
    const [r, s] = await Promise.all([di(t.left, e, n), di(t.right, e, n)]);
    return {
      left: r,
      right: s
    };
  }
  if (Pc(t))
    return {
      weight: t.weight,
      threshold: t.threshold,
      tree: await di(t.tree, e, n)
    };
  if (Iu(t))
    if (t.isDynamic) {
      if (!t.address)
        throw new Error("Dynamic signature leaf without address");
      if (!await Xy(t.address, e, t.signature, n))
        throw new Nk(t);
      return {
        weight: t.weight,
        address: t.address,
        signature: t.signature,
        subdigest: e
      };
    } else
      return {
        weight: t.weight,
        address: Pu(e, t.signature),
        signature: t.signature,
        subdigest: e
      };
  return t;
}
const yt = {
  concat: (t, e) => Ee(["bytes", "bytes"], [t, e]),
  node: (t) => Ee(["uint8", "bytes32"], [Ve.Node, t]),
  branch: (t) => {
    const e = Q(t);
    return Ee(["uint8", "uint24", "bytes"], [Ve.Branch, e.length, e]);
  },
  nested: (t, e, n) => {
    const r = Q(n);
    return Ee(["uint8", "uint8", "uint16", "uint24", "bytes"], [Ve.Nested, t, e, r.length, r]);
  },
  subdigest: (t) => Ee(["uint8", "bytes32"], [Ve.Subdigest, t]),
  signature: (t, e) => Ee(["uint8", "uint8", "bytes"], [Ve.Signature, t, e]),
  dynamicSignature: (t, e, n) => {
    const r = Q(n);
    return Ee(["uint8", "uint8", "address", "uint24", "bytes"], [Ve.DynamicSignature, t, e, r.length, r]);
  },
  address: (t, e) => Ee(["uint8", "uint8", "address"], [Ve.Address, t, e])
};
function gl(t, e, n, r, s = {}) {
  const a = wl(t.tree, e, n, s);
  return BigInt(r) === 0n ? {
    encoded: Ee(["uint8", "uint16", "uint32", "bytes"], [rt.NoChainIdDynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : BigInt(t.threshold) > 255n ? {
    encoded: Ee(["uint8", "uint16", "uint32", "bytes"], [rt.Dynamic, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  } : {
    encoded: Ee(["uint8", "uint8", "uint32", "bytes"], [rt.Legacy, t.threshold, t.checkpoint, a.encoded]),
    weight: a.weight
  };
}
function wl(t, e, n, r = {}) {
  const s = !r.disableTrim;
  if (tr(t)) {
    const a = wl(t.left, e, n), i = wl(t.right, e, n), o = jt(t.left), c = jt(t.right);
    return s && a.weight === 0n && i.weight === 0n && !o && !c ? {
      // We don't need to include anything for this node
      // just the hash will be enough
      encoded: yt.node(Un(t)),
      weight: 0n
    } : s && i.weight === 0n && !c ? {
      // The right node doesn't have any weight
      // but we still need to include the left node encoded
      encoded: yt.concat(a.encoded, yt.node(Un(t.right))),
      weight: a.weight
    } : s && a.weight === 0n && !o ? {
      // The left node doesn't have any weight
      // we can just append its hash, but for the right node
      // we need to create a new "branch"
      encoded: yt.concat(yt.node(Un(t.left)), yt.branch(i.encoded)),
      weight: i.weight
    } : {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: yt.concat(a.encoded, yt.branch(i.encoded)),
      weight: a.weight + i.weight
    };
  }
  if (cs(t)) {
    const a = wl(t.tree, e, n);
    return s && a.weight === 0n ? {
      encoded: yt.node(Un(t)),
      weight: 0n
    } : {
      encoded: yt.nested(t.weight, t.threshold, a.encoded),
      weight: a.weight
    };
  }
  if (ls(t))
    return {
      encoded: yt.node(Un(t)),
      weight: 0n
    };
  if (os(t)) {
    const a = n.includes(t.subdigest);
    return {
      encoded: yt.subdigest(t.subdigest),
      weight: a ? F9 : 0n
    };
  }
  if (jt(t))
    if (e.has(t.address)) {
      const i = e.get(t.address), o = i.signature;
      return r.forceDynamicEncoding || i.isDynamic ? {
        encoded: yt.dynamicSignature(t.weight, t.address, o),
        weight: BigInt(t.weight)
      } : {
        encoded: yt.signature(t.weight, o),
        weight: BigInt(t.weight)
      };
    } else
      return {
        encoded: yt.address(t.weight, t.address),
        weight: 0n
      };
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(t)}`);
}
function sg(t) {
  return ig(t) ? sg(t.suffix[t.suffix.length - 1]) : t.config;
}
function ag(t) {
  return t.type !== void 0 && t.decoded !== void 0 && t.version !== void 0 && t.version === 2;
}
function Uu(t) {
  return t.suffix !== void 0 && Array.isArray(t.suffix) && t.suffix.every(ag);
}
function Rk(t) {
  return t.type !== void 0 && t.config !== void 0 && t.digest !== void 0 && t.version !== void 0 && t.version === 2;
}
function ig(t) {
  return t.chain !== void 0 && Array.isArray(t.chain) && t.chain.every(Rk);
}
function Op(t) {
  const e = Q(t), n = e[0];
  switch (n) {
    case rt.Legacy:
      return {
        version: 2,
        type: rt.Legacy,
        decoded: Ld(e)
      };
    case rt.Dynamic:
      return {
        version: 2,
        type: rt.Dynamic,
        decoded: Ld(e.slice(1))
      };
    case rt.NoChainIdDynamic:
      return {
        version: 2,
        type: rt.NoChainIdDynamic,
        decoded: Ld(e.slice(1))
      };
    case rt.Chained:
      return Fk(e);
    default:
      throw new Error(`Invalid signature type: ${n}`);
  }
}
function Ld(t) {
  const e = Q(t), n = e[0] << 8 | e[1], r = e[2] << 24 | e[3] << 16 | e[4] << 8 | e[5], s = Cf(e.slice(6));
  return {
    threshold: n,
    checkpoint: r,
    tree: s
  };
}
function Fk(t) {
  const e = Q(t), n = e[0];
  if (n !== rt.Chained)
    throw new Error(`Expected chained signature type: ${n}`);
  const r = [];
  let s = 1;
  for (; s < e.length; ) {
    const o = e[s] << 16 | e[s + 1] << 8 | e[s + 2];
    s += 3;
    const c = Op(e.slice(s, s + o));
    r.push(c), s += o;
  }
  const a = r[0];
  if (Uu(a))
    throw new Error("Expected first link of chained signature to be a simple signature (not chained)");
  const i = r.slice(1);
  return ft({}, a, {
    suffix: i
  });
}
function Mk(t) {
  return Ee(["bytes32", "bytes32"], [oi(["string"], ["SetImageHash(bytes32 imageHash)"]), t]);
}
async function og(t, e, n) {
  const r = e.subdigest === void 0 ? e : void 0;
  t.type === rt.NoChainIdDynamic && r && (r.chainId = 0);
  const a = r ? Bu(r) : e.subdigest;
  if (!Uu(t)) {
    const l = await di(t.decoded.tree, a, n);
    return {
      version: 2,
      type: t.type,
      subdigest: a,
      config: ft({
        version: 2
      }, t.decoded, {
        tree: l
      })
    };
  }
  if (!Ak(r))
    throw new Error("Chained signature recovery requires detailed signed payload, subdigest is not enough");
  const i = [];
  let o = r;
  for (const l of [ft({}, t, {
    suffix: void 0
  }), ...t.suffix]) {
    const d = await og(l, o, n);
    i.unshift(d);
    const f = Mk(lg(sg(d)));
    o = ft({}, o, {
      message: f,
      digest: xe(f)
    });
  }
  const c = i[0], u = i.slice(1);
  return ft({}, c, {
    suffix: u
  });
}
function Bp(t, e) {
  const r = [t, ...e || []].map((a) => Q(Js(a))), s = Ee(r.map(() => ["uint24", "bytes"]).flat(), r.map((a) => [a.length, a]).flat());
  return Ee(["uint8", "bytes"], [rt.Chained, s]);
}
function Js(t) {
  if (Ei(t)) return V(t);
  if (Uu(t) || ig(t))
    return Bp(Js(t), (t.suffix || []).map(Js));
  const e = ag(t) ? t.decoded : t.config;
  switch (t.type) {
    case rt.Legacy:
      if (BigInt(e.threshold) > 255n)
        throw new Error(`Legacy signature threshold is too large: ${e.threshold} (max 255)`);
      return mb(e);
    case rt.NoChainIdDynamic:
    case rt.Dynamic:
      return Ee(["uint8", "bytes"], [t.type, mb(e)]);
    case rt.Chained:
      throw new Error("Unreachable code: Chained signature should be handled above");
    default:
      throw new Error(`Invalid signature type: ${t.type}`);
  }
}
function mb(t) {
  return Ee(["uint16", "uint32", "bytes"], [t.threshold, t.checkpoint, El(t.tree)]);
}
function El(t) {
  if (tr(t) || Ti(t)) {
    const e = Q(El(t.right)), n = Q(El(t.left));
    return tr(t.right) || Ti(t.right) ? Ee(["bytes", "uint8", "uint24", "bytes"], [n, Ve.Branch, e.length, e]) : Ee(["bytes", "bytes"], [n, e]);
  }
  if (cs(t) || Pc(t)) {
    const e = Q(El(t.tree));
    return Ee(["uint8", "uint8", "uint16", "uint24", "bytes"], [Ve.Nested, t.weight, t.threshold, e.length, e]);
  }
  if (Iu(t) || jt(t) && t.signature !== void 0) {
    const e = Q(t.signature);
    if (t.isDynamic || e.length !== kf) {
      if (!t.address) throw new Error("Dynamic signature leaf must have address");
      return Ee(["uint8", "uint8", "address", "uint24", "bytes"], [Ve.DynamicSignature, t.weight, t.address, e.length, e]);
    } else
      return Ee(["uint8", "uint8", "bytes"], [Ve.Signature, t.weight, e]);
  }
  if (jt(t))
    return Ee(["uint8", "uint8", "address"], [Ve.Address, t.weight, t.address]);
  if (ls(t))
    return Ee(["uint8", "bytes32"], [Ve.Node, t.nodeHash]);
  if (os(t))
    return Ee(["uint8", "bytes32"], [Ve.Subdigest, t.subdigest]);
  throw new Error(`Unknown signature tree type: ${t}`);
}
function xl(t) {
  return tr(t) ? [...xl(t.left), ...xl(t.right)] : cs(t) ? xl(t.tree) : jt(t) && t.signature ? [{
    address: t.address,
    signature: t.signature
  }] : [];
}
function Al(t) {
  return Ti(t) ? [...Al(t.left), ...Al(t.right)] : Pc(t) ? Al(t.tree) : Iu(t) ? [t.signature] : [];
}
function Hd(t) {
  return Ti(t) ? [...Hd(t.left), ...Hd(t.right)] : Pc(t) ? Hd(t.tree) : os(t) ? [t.subdigest] : [];
}
async function Tf(t) {
  const e = typeof t == "string" ? Op(t) : t;
  if (Uu(e)) {
    const r = await Promise.all([Tf(ft({}, e, {
      suffix: void 0
    })), ...e.suffix.map((s) => Tf(s))]);
    return Bp(r[0], r.slice(1));
  }
  const {
    trimmed: n
  } = await vl(e.decoded.tree);
  return Js(ft({}, e, {
    decoded: ft({}, e.decoded, {
      tree: n
    })
  }));
}
async function vl(t, e = !0) {
  if (Ti(t)) {
    const [n, r] = await Promise.all([vl(t.left), vl(t.right)]);
    if (n.weight === 0 && r.weight === 0)
      try {
        const s = await di(t, Xd, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: Un(s)
          }
        };
      } catch {
      }
    else
      return {
        weight: n.weight + r.weight,
        trimmed: {
          left: n.trimmed,
          right: r.trimmed
        }
      };
  }
  if (Pc(t)) {
    const n = await vl(t.tree);
    if (n.weight === 0)
      try {
        const r = await di(t, Xd, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: Un(r)
          }
        };
      } catch {
      }
    return {
      weight: n.weight,
      trimmed: {
        weight: t.weight,
        threshold: t.threshold,
        tree: n.trimmed
      }
    };
  }
  return ls(t) && Hk(t.nodeHash) ? {
    weight: 0,
    trimmed: ft({}, Lk(t.nodeHash))
  } : Iu(t) || jt(t) && t.signature !== void 0 ? {
    weight: Number(t.weight),
    trimmed: t
  } : !e && os(t) ? {
    weight: 1 / 0,
    trimmed: t
  } : {
    weight: 0,
    trimmed: t
  };
}
const Pp = {
  decode: (t) => Op(t),
  encode: (t) => Js(t),
  trim: (t) => Tf(t),
  supportsNoChainId: !0,
  recover: (t, e, n) => og(t, e, n),
  encodeSigners: (t, e, n, r) => gl(t, e, n, r),
  hasEnoughSigningPower: (t, e) => {
    const {
      weight: n
    } = Pp.encodeSigners(t, e, [], 0);
    return n >= BigInt(t.threshold);
  },
  chainSignatures: (t, e) => {
    const n = e.reverse(), r = Ei(t) ? t : Js(t), s = n.map((a) => Ei(a) ? a : Js(a));
    return Bp(r, s);
  },
  hashSetImageHash: function(t) {
    return Pk(t);
  },
  signaturesOf(t) {
    return xl(t.tree);
  },
  signaturesOfDecoded: function(t) {
    return Al(t.decoded.tree);
  }
};
var SW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignatureType: rt,
  SignaturePartType: Ve,
  SignaturePartTypeLength: kf,
  isUnrecoveredNode: Ti,
  isUnrecoveredNestedLeaf: Pc,
  isUnrecoveredSignatureLeaf: Iu,
  decodeSignatureTree: Cf,
  InvalidSignatureLeafError: Nk,
  recoverTopology: di,
  partEncoder: yt,
  encodeSigners: gl,
  encodeTree: wl,
  deepestConfigOfSignature: sg,
  isUnrecoveredSignature: ag,
  isUnrecoveredChainedSignature: Uu,
  isSignature: Rk,
  isChainedSignature: ig,
  decodeSignature: Op,
  decodeSignatureBody: Ld,
  decodeChainedSignature: Fk,
  setImageHashStruct: Mk,
  recoverSignature: og,
  encodeChain: Bp,
  encodeSignature: Js,
  encodeSignatureBody: mb,
  encodeSignatureTree: El,
  signaturesOf: xl,
  signaturesOfDecoded: Al,
  subdigestsOfDecoded: Hd,
  trimSignature: Tf,
  trimUnrecoveredTree: vl,
  SignatureCoder: Pp
});
function jt(t) {
  return t.address !== void 0 && t.weight !== void 0;
}
function os(t) {
  return t.subdigest !== void 0 && t.address === void 0;
}
function kl(t) {
  return tr(t) ? JSON.stringify({
    left: kl(t.left),
    right: kl(t.right)
  }) : cs(t) ? JSON.stringify({
    weight: BigInt(t.weight).toString(),
    threshold: BigInt(t.threshold).toString(),
    tree: kl(t.tree)
  }) : jt(t) ? JSON.stringify({
    address: t.address,
    weight: BigInt(t.weight).toString()
  }) : JSON.stringify(t);
}
function Cl(t) {
  const e = typeof t == "string" ? JSON.parse(t) : t;
  return e.left !== void 0 && e.right !== void 0 ? {
    left: Cl(e.left),
    right: Cl(e.right)
  } : e.weight !== void 0 && e.threshold !== void 0 && e.tree !== void 0 ? {
    weight: BigInt(e.weight),
    threshold: BigInt(e.threshold),
    tree: Cl(e.tree)
  } : e.address !== void 0 && e.weight !== void 0 ? {
    address: e.address,
    weight: BigInt(e.weight)
  } : e;
}
function cs(t) {
  return t.tree !== void 0 && t.weight !== void 0 && t.threshold !== void 0;
}
function ls(t) {
  return t.nodeHash !== void 0;
}
function cg(t) {
  return jt(t) || os(t) || cs(t) || ls(t);
}
function tr(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function OW(t) {
  return tr(t) || cg(t);
}
function Dk(t) {
  return Ee(["uint96", "address"], [t.weight, t.address]);
}
function Lk(t) {
  const e = Q(t);
  if (e.length !== 32)
    throw new Error("Invalid encoded string length");
  const n = BigInt(V(e.slice(0, 12))), r = ue(V(e.slice(12)));
  return {
    weight: n,
    address: r
  };
}
function Hk(t) {
  const e = Q(t);
  return e.length !== 32 ? !1 : e.slice(0, 11).every((r) => r === 0);
}
function Un(t) {
  if (jt(t))
    return Dk(t);
  if (os(t))
    return oi(["string", "bytes32"], [`Sequence static digest:
`, t.subdigest]);
  if (cs(t)) {
    const e = Un(t.tree);
    return oi(["string", "bytes32", "uint256", "uint256"], [`Sequence nested config:
`, e, t.threshold, t.weight]);
  }
  return ls(t) ? t.nodeHash : oi(["bytes32", "bytes32"], [Un(t.left), Un(t.right)]);
}
function BW(t) {
  const e = [];
  let n = t;
  for (; !cg(n); )
    e.unshift(n.right), n = n.left;
  return e.unshift(n), e;
}
function PW(t) {
  return t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && t.version !== void 0 && t.version === 2;
}
function lg(t) {
  return oi(["bytes32", "uint256"], [oi(["bytes32", "uint256"], [Un(t.tree), t.threshold]), t.checkpoint]);
}
function $k(t) {
  return t.threshold !== void 0 && t.weight !== void 0 && t.members !== void 0;
}
function to(t) {
  return jt(t) || os(t) ? [t] : cs(t) ? [{
    threshold: t.threshold,
    weight: t.weight,
    members: to(t.tree)
  }] : ls(t) ? [] : [...to(t.left), ...to(t.right)];
}
function bb(t) {
  return ls(t) ? !0 : tr(t) ? bb(t.left) || bb(t.right) : !1;
}
function IW(t) {
  return {
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    members: to(t.tree)
  };
}
const _k = (t, e) => t.map((n) => $k(n) ? {
  tree: e(n.members),
  threshold: n.threshold,
  weight: n.weight
} : n);
function ug(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  return _k(t, ug).reduce((n, r) => ({
    left: n,
    right: r
  }));
}
function dg(t) {
  if (t.length === 0)
    throw new Error("Empty members array");
  const e = _k(t, dg);
  for (let n = e.length; n > 1; n = n / 2)
    for (let r = 0; r < n / 2; r++) {
      const s = r * 2, a = s + 1;
      a >= n ? e[r] = e[s] : e[r] = {
        left: e[s],
        right: e[a]
      };
    }
  return e[0];
}
function fg(t) {
  return t.length > 8 ? dg(t) : ug(t);
}
function Gk(t, e = fg) {
  return {
    version: 2,
    threshold: t.threshold,
    checkpoint: t.checkpoint,
    tree: e(t.members)
  };
}
function Sf(t, e) {
  return os(t) ? t.subdigest === e : tr(t) ? Sf(t.left, e) || Sf(t.right, e) : !1;
}
function yb(t) {
  const e = [t], n = /* @__PURE__ */ new Set();
  for (; e.length > 0; ) {
    const r = e.pop();
    cs(r) ? e.push(r.tree) : tr(r) ? (e.push(r.left), e.push(r.right)) : jt(r) && n.add({
      address: r.address,
      weight: Number(r.weight)
    });
  }
  return Array.from(n);
}
function Of(t) {
  return tr(t) ? Of(t.left) && Of(t.right) : !ls(t);
}
const Ip = {
  isWalletConfig: (t) => t.version === 2 && t.threshold !== void 0 && t.tree !== void 0,
  imageHashOf: (t) => lg(t),
  hasSubdigest: (t, e) => Sf(t.tree, e),
  checkpointOf: (t) => BigInt(t.checkpoint),
  signersOf: (t) => yb(t.tree),
  fromSimple: (t) => {
    var e;
    return Gk(ft({}, t, {
      members: [...t.signers, ...((e = t.subdigests) != null ? e : []).map((n) => ({
        subdigest: n
      }))]
    }));
  },
  isComplete: (t) => Of(t.tree),
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: !0,
    buildTransaction: (t, e, n, r) => {
      const s = new Bt(St.mainModuleUpgradable.abi);
      return {
        entrypoint: t,
        transactions: [{
          to: t,
          data: s.encodeFunctionData(s.getFunction("updateImageHash"), [Ip.imageHashOf(e)]),
          gasLimit: 0,
          delegateCall: !1,
          revertOnError: !0,
          value: 0
        }]
      };
    },
    decodeTransaction: function(t) {
      var e, n, r, s;
      const a = new Bt(St.mainModuleUpgradable.abi);
      if (t.transactions.length !== 1)
        throw new Error("Invalid transaction bundle, expected 1 transaction");
      const i = t.transactions[0].data;
      if (!i)
        throw new Error("Invalid transaction bundle, expected data");
      const o = a.decodeFunctionData(a.getFunction("updateImageHash"), i);
      if (!o)
        throw new Error("Invalid transaction bundle, expected valid data");
      if (t.transactions[0].to !== t.entrypoint)
        throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
      if (t.transactions[0].delegateCall)
        throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
      if (!t.transactions[0].revertOnError)
        throw new Error("Invalid transaction bundle, expected revertOnError");
      if (BigInt((e = (n = t.transactions[0]) == null ? void 0 : n.value) != null ? e : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      if (BigInt((r = (s = t.transactions[0]) == null ? void 0 : s.gasLimit) != null ? r : 0) !== 0n)
        throw new Error("Invalid transaction bundle, expected value to be 0");
      return {
        address: t.entrypoint,
        newImageHash: o[0],
        kind: void 0
      };
    }
  },
  toJSON: function(t) {
    return JSON.stringify({
      version: t.version,
      threshold: BigInt(t.threshold).toString(),
      checkpoint: BigInt(t.checkpoint).toString(),
      tree: kl(t.tree)
    });
  },
  fromJSON: function(t) {
    const e = JSON.parse(t);
    return {
      version: e.version,
      threshold: BigInt(e.threshold),
      checkpoint: BigInt(e.checkpoint),
      tree: Cl(e.tree)
    };
  },
  editConfig: function(t, e) {
    var n, r;
    const s = to(t.tree);
    if (e.add)
      for (const a of e.add)
        s.find((i) => jt(i) && i.address === a.address) || s.push({
          address: a.address,
          weight: a.weight
        });
    if (e.remove)
      for (const a of e.remove) {
        const i = s.findIndex((o) => jt(o) && o.address === a);
        i >= 0 && s.splice(i, 1);
      }
    return {
      version: t.version,
      threshold: (n = e.threshold) != null ? n : t.threshold,
      checkpoint: (r = e.checkpoint) != null ? r : t.checkpoint,
      tree: fg(s)
    };
  },
  buildStubSignature: function(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const [s, a] of e.entries()) {
      n.set(s, {
        signature: a,
        isDynamic: !0
      });
      const {
        encoded: i,
        weight: o
      } = gl(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    const r = yb(t.tree);
    for (const {
      address: s
    } of r.sort(({
      weight: a
    }, {
      weight: i
    }) => a - i)) {
      n.set(s, {
        signature: "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02",
        isDynamic: !1
      });
      const {
        encoded: i,
        weight: o
      } = gl(t, n, [], 0);
      if (o >= BigInt(t.threshold))
        return i;
    }
    return gl(t, n, [], 0).encoded;
  }
};
var UW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSignerLeaf: jt,
  isSubdigestLeaf: os,
  topologyToJSON: kl,
  topologyFromJSON: Cl,
  isNestedLeaf: cs,
  isNodeLeaf: ls,
  isLeaf: cg,
  isNode: tr,
  isTopology: OW,
  encodeSignerLeaf: Dk,
  decodeSignerLeaf: Lk,
  isEncodedSignerLeaf: Hk,
  hashNode: Un,
  leftFace: BW,
  isWalletConfig: PW,
  imageHash: lg,
  isSimpleNestedMember: $k,
  topologyToMembers: to,
  hasUnknownNodes: bb,
  toSimpleWalletConfig: IW,
  legacyTopologyBuilder: ug,
  merkleTopologyBuilder: dg,
  optimized2SignersTopologyBuilder: fg,
  toWalletConfig: Gk,
  hasSubdigest: Sf,
  signersOf: yb,
  isComplete: Of,
  ConfigCoder: Ip
}), NW = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const RW = {
  config: Ip,
  signature: Pp
}, zk = 2, Vk = {
  version: zk,
  factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
  guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
  mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
  mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3",
  proxyImplementationHook: "0x1f56dbAD5e8319F0DE9a323E24A31b5077dEB1a4"
};
var de = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: UW,
  signature: SW,
  context: NW,
  chained: TW,
  coders: RW,
  version: zk,
  DeployedWalletContext: Vk
}), FW = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function gb(t, e) {
  const n = xe(Ee(["bytes", "bytes32"], [t.walletCreationCode, fn(t.mainModule, 32)])), r = xe(Ee(["bytes1", "address", "bytes32", "bytes32"], ["0xff", t.factory, e, n]));
  return ue(_e(r, 12));
}
async function MW(t, e, n, r, s, a) {
  return (await Promise.all(sQ.map(async (o) => {
    try {
      const c = o.signature.SignatureCoder.decode(V(n)), u = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: V(e),
        chainId: r
      }, s), l = o.config.ConfigCoder.imageHashOf(u.config);
      if (gb(a[o.version], l).toLowerCase() === t.toLowerCase())
        return !0;
      const f = await o.signature.SignatureCoder.recover(c, {
        address: t,
        digest: V(e),
        chainId: r
      }, s), h = o.config.ConfigCoder.imageHashOf(f.config);
      return gb(a[o.version], h).toLowerCase() === t.toLowerCase();
    } catch {
    }
    return !1;
  }))).some((o) => o);
}
function DW(t) {
  const e = Object.keys(t).length;
  for (let n = 1; n <= e; n++) {
    const r = t[n];
    if (!r || r.version !== n)
      return !1;
  }
  return !0;
}
function LW(t) {
  const e = Object.keys(t).length;
  return t[e];
}
const HW = {
  1: Bk,
  2: Vk
};
var $W = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addressOf: gb,
  isValidCounterfactual: MW,
  isValidVersionedContext: DW,
  latestContext: LW,
  defaultContexts: HW
});
const Up = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function _W(t, e, n, r) {
  return ft({}, t, {
    chainId: n,
    intent: {
      id: r,
      wallet: e
    }
  });
}
function GW(t) {
  return xe(Ot.defaultAbiCoder().encode(["address", "uint256", "bytes32"], [t.intent.wallet, t.chainId, t.intent.id]));
}
function zW(t) {
  const e = Ot.defaultAbiCoder().decode(["uint256", Up], t);
  if (e.length !== 2 || !e[0] || !e[1]) throw new Error("Invalid meta transaction data");
  return [e[0], e[1]];
}
function jk(t, e) {
  return Ot.defaultAbiCoder().encode(["uint256", Up], [t, jl(e)]);
}
function Kk(t, e) {
  return xe(jk(t, e));
}
function VW(t, e, n, r) {
  return Bu({
    address: t,
    chainId: e,
    digest: Kk(n, r)
  });
}
function jW(t, e, n) {
  return Bu({
    address: t,
    chainId: e,
    digest: xe(Ot.defaultAbiCoder().encode(["string", Up], ["guest:", jl(n)]))
  });
}
function qk(t, e) {
  return e.map((n) => pg(t, n));
}
function pg(t, e) {
  if (e.to && e.to !== ra)
    return {
      nonce: Tl(e.nonce) ? void 0 : BigInt(e.nonce),
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: Tl(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise
        // Keeping this as is for now so we don't have to change everything to async
        to: e.to,
        value: BigInt(e.value || 0),
        data: e.data || "0x"
      }
    };
  {
    const n = new Bt(St.mainModule.abi), r = n.encodeFunctionData(n.getFunction("createContract"), [e.data]);
    return {
      nonce: typeof e.nonce == "number" ? BigInt(e.nonce) : void 0,
      transaction: {
        delegateCall: !1,
        revertOnError: !1,
        gasLimit: Tl(e.gasLimit) ? void 0 : BigInt(e.gasLimit),
        to: t,
        value: BigInt(e.value || 0),
        data: r
      }
    };
  }
}
function Np(t) {
  return t.delegateCall !== void 0 || t.revertOnError !== void 0;
}
function Wk(t) {
  return t.every(Np);
}
function jl(t) {
  return t.map((e) => {
    var n;
    return {
      delegateCall: e.delegateCall === !0,
      revertOnError: e.revertOnError === !0,
      gasLimit: Tl(e.gasLimit) ? 0n : BigInt(e.gasLimit),
      target: (n = e.to) != null ? n : ra,
      value: Tl(e.value) ? 0n : e.value,
      data: e.data || "0x"
    };
  });
}
function KW(t) {
  return t.map((e) => ({
    delegateCall: e.delegateCall,
    revertOnError: e.revertOnError,
    gasLimit: e.gasLimit,
    to: e.target,
    value: e.value,
    data: e.data
  }));
}
function qW(t, e) {
  const n = BigInt(t), r = BigInt(e), s = 2n ** 96n;
  if (r / s !== 0n)
    throw new Error("Space already encoded");
  return r + n * s;
}
function WW(t) {
  const e = BigInt(t), n = 2n ** 96n;
  return [e / n, e % n];
}
function QW(t, e) {
  return Array.isArray(e) ? Wk(e) ? e : qk(t, e).map((r) => r.transaction) : Np(e) ? [e] : [pg(t, e).transaction];
}
function Qk(t) {
  return t !== void 0 && t.entrypoint !== void 0 && t.chainId !== void 0 && t.transactions !== void 0 && t.nonce !== void 0 && t.intent !== void 0 && t.intent.id !== void 0 && t.intent.wallet !== void 0 && Array.isArray(t.transactions) && t.transactions.reduce((e, n) => e && Np(n), !0);
}
function Jk(t) {
  return t !== void 0 && t.signature !== void 0 && t.signature !== "" && Qk(t);
}
function JW(t) {
  const e = new Bt(St.mainModule.abi);
  return e.encodeFunctionData(e.getFunction("execute"), Jk(t) ? [
    // Signed transaction bundle has all 3 parameters
    jl(t.transactions),
    t.nonce,
    t.signature
  ] : [
    // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
    jl(t.transactions),
    0,
    new Uint8Array([])
  ]);
}
const Zk = "0x61c2926c", Xk = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`, wb = (t, e) => {
  const n = [], r = new Bt(St.mainModule.abi);
  for (const s of e) {
    const a = Q(s.data || "0x");
    if (s.to === t && V(a.slice(0, 4)) === Zk) {
      const i = a.slice(4), o = Ot.defaultAbiCoder().decode([Xk], i)[0];
      n.push(...wb(s.to, o.map((c) => ft({}, c, {
        to: c.target
      }))));
    } else
      try {
        const i = r.decodeFunctionData("execute", a)[0], o = wb(t, i.map((c) => ft({}, c.toObject(), {
          to: c.target
        })));
        n.push(...o);
      } catch {
        n.push(s);
      }
  }
  return n;
}, Tl = (t) => t == null;
var ZW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MetaTransactionsType: Up,
  intendTransactionBundle: _W,
  intendedTransactionID: GW,
  unpackMetaTransactionsData: zW,
  packMetaTransactionsData: jk,
  digestOfTransactions: Kk,
  subdigestOfTransactions: VW,
  subdigestOfGuestModuleTransactions: jW,
  toSequenceTransactions: qk,
  toSequenceTransaction: pg,
  isSequenceTransaction: Np,
  hasSequenceTransactions: Wk,
  sequenceTxAbiEncode: jl,
  fromTxAbiEncode: KW,
  encodeNonce: qW,
  decodeNonce: WW,
  fromTransactionish: QW,
  isTransactionBundle: Qk,
  isSignedTransactionBundle: Jk,
  encodeBundleExecData: JW,
  selfExecuteSelector: Zk,
  selfExecuteAbi: Xk,
  unwind: wb
});
const Yk = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033", XW = "0x6492649264926492649264926492649264926492649264926492649264926492";
async function e3(t, e, n, r) {
  try {
    return await t.call({
      data: Le([Yk, Ot.defaultAbiCoder().encode(["address", "bytes32", "bytes"], [e, n, r])])
    }) === "0x01";
  } catch {
    return !1;
  }
}
var YW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE: Yk,
  EIP_6492_SUFFIX: XW,
  validateEIP6492Offchain: e3
});
class eQ {
  constructor(e) {
    this.provider = e, this.isDeployedCache = /* @__PURE__ */ new Set();
  }
  module(e) {
    return new vr(e, [...St.mainModuleUpgradable.abi, ...St.mainModule.abi, ...St.erc1271.abi], this.provider);
  }
  async isDeployed(e) {
    if (this.isDeployedCache.has(e))
      return !0;
    const r = (await this.provider.getCode(e).then((s) => Q(s))).length !== 0;
    return r && this.isDeployedCache.add(e), r;
  }
  async implementation(e) {
    const n = Ot.defaultAbiCoder().encode(["address"], [e]), r = await this.provider.getStorage(e, n).then((s) => Q(s));
    if (r.length === 20)
      return ue(V(r));
    if (r.length === 32)
      return Ot.defaultAbiCoder().decode(["address"], r)[0];
  }
  async imageHash(e) {
    try {
      return await this.module(e).imageHash();
    } catch {
    }
  }
  async nonce(e, n = 0) {
    try {
      return await this.module(e).readNonce(n);
    } catch (r) {
      if (!await this.isDeployed(e))
        return 0;
      throw r;
    }
  }
  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(e, n, r) {
    return e3(this.provider, e, n, r);
  }
}
var tQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  OnChainReader: eQ
});
function nQ(t) {
  return t && t.address && t.digest && t.chainId !== void 0 && t.config;
}
var re = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: FW,
  signature: mW,
  context: $W,
  signer: xW,
  EIP1271: gW,
  transaction: ZW,
  reader: tQ,
  EIP6492: YW,
  isWalletSignRequestMetadata: nQ
});
const Eb = [{
  config: ng,
  signature: tg
}, {
  config: Ip,
  signature: Pp
}];
function t3(t) {
  const e = t - 1;
  if (e < 0 || e >= Eb.length)
    throw new Error(`No coder for version: ${t}`);
  return Eb[e];
}
function rQ(t) {
  return t3(t);
}
var Ht = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALL_CODERS: Eb,
  coderFor: t3,
  genericCoderFor: rQ
});
const sQ = [ha, de];
function aQ(t, e, n) {
  for (let r = 0; r < n.length; r++)
    if (re.context.addressOf(n[r], e) === t)
      return n[r].version;
  throw new Error("Could not find version for counterfactual address");
}
var iQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  counterfactualVersion: aQ
});
class oQ {
  constructor() {
    this.version = 2, this.configCoder = de.config.ConfigCoder, this.signatureCoder = de.signature.SignatureCoder;
  }
  buildTransaction(e, n, r) {
    if (!de.config.ConfigCoder.isWalletConfig(r)) {
      const c = de.config.toWalletConfig({
        threshold: r.threshold,
        members: r.signers,
        checkpoint: 0
      });
      return this.buildTransaction(e, n, c);
    }
    const s = n[2], a = new Bt(St.mainModule.abi), i = de.config.ConfigCoder.update.buildTransaction(e, r, s, "first");
    return {
      tx: {
        entrypoint: e,
        nonce: re.transaction.encodeNonce(xb, 0),
        transactions: [{
          to: e,
          value: 0,
          gasLimit: 0,
          revertOnError: !0,
          delegateCall: !1,
          data: a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable])
        }, ...i.transactions]
      },
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: r
    };
  }
  decodeTransaction(e, n) {
    const r = e.entrypoint;
    if (e.transactions.length < 2)
      throw new Error("Invalid transaction bundle size");
    if (!e.nonce || re.transaction.encodeNonce(xb, 0) !== BigInt(e.nonce))
      throw new Error("Invalid transaction bundle nonce");
    if (e.transactions[0].to !== r || e.transactions[1].to !== r || e.transactions[0].delegateCall || e.transactions[1].delegateCall || !e.transactions[0].revertOnError || !e.transactions[1].revertOnError || e.transactions[0].value && BigInt(e.transactions[0].value) !== 0n || e.transactions[1].value && BigInt(e.transactions[1].value) !== 0n || e.transactions[0].gasLimit && BigInt(e.transactions[0].gasLimit) !== 0n || e.transactions[1].gasLimit && BigInt(e.transactions[1].gasLimit) !== 0n)
      throw new Error("Invalid transaction bundle format");
    const s = n[2], a = new Bt(St.mainModule.abi), i = V(e.transactions[0].data || new Uint8Array()), o = V(a.encodeFunctionData(a.getFunction("updateImplementation"), [s.mainModuleUpgradable]));
    if (i !== o)
      throw new Error("Invalid new implementation on transaction");
    const c = de.config.ConfigCoder.update.decodeTransaction({
      entrypoint: r,
      transactions: [e.transactions[1]]
    });
    if (c.address !== r)
      throw new Error("Invalid transaction bundle address");
    return c;
  }
}
const xb = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb", n3 = new oQ();
var cQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE: xb,
  v1v2: n3
});
function Ab() {
  return Ab = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Ab.apply(null, arguments);
}
function lQ(t) {
  for (const [e, n] of Object.entries(t))
    if (e !== String(n.version - 1))
      throw new Error(`Migration with key ${e} has version ${n.version}, expected version to be key + 1`);
}
class uQ {
  constructor(e, n, r) {
    this.tracker = e, this.migrations = n, this.contexts = r, lQ(n);
  }
  lastMigration() {
    let e;
    for (const n of Object.values(this.migrations))
      (e === void 0 || n.version > e.version) && (e = n);
    if (e === void 0)
      throw new Error("No migrations");
    return e;
  }
  async getAllMigratePresignedTransaction(e) {
    const {
      address: n,
      fromImageHash: r,
      fromVersion: s,
      chainId: a
    } = e;
    let i = r, o = s;
    const c = Object.values(this.contexts), u = [];
    for (let l = 1; l < c.length; l++) {
      const d = await this.tracker.getMigration(n, i, o, a);
      if (!d) return {
        signedMigrations: u,
        missing: !0,
        lastImageHash: i,
        lastVersion: o
      };
      u.push(d);
      const f = this.migrations[o];
      if (!f)
        throw new Error(`No migration found for version ${o}`);
      const h = f.decodeTransaction(d.tx, this.contexts);
      if (h.address !== n)
        throw new Error("Migration transaction address does not match expected address");
      i = h.newImageHash, o += 1;
    }
    return {
      signedMigrations: u,
      missing: !1,
      lastImageHash: i,
      lastVersion: o
    };
  }
  async signNextMigration(e, n, r, s) {
    const a = this.migrations[n];
    if (!a)
      return;
    const i = a.buildTransaction(e, this.contexts, s), o = await r.signTransactionBundle(i.tx);
    return Ab({}, i, {
      tx: o
    });
  }
}
var EE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Migrator: uQ
});
const dQ = {
  1: n3
};
var xE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultMigrations: dQ
});
function no() {
  return no = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, no.apply(null, arguments);
}
const hg = "Webrpc", r3 = "webrpc@v0.24.0;gen-typescript@v0.16.3;sequence-relayer@v0.4.1", fQ = "v1", pQ = "v0.4.1", hQ = "fdce30970483936652aaeabaf9339a302ac52d32";
function mQ(t) {
  const e = t.get(hg);
  return e ? bQ(e) : {
    webrpcGenVersion: "",
    codeGenName: "",
    codeGenVersion: "",
    schemaName: "",
    schemaVersion: ""
  };
}
function bQ(t) {
  const e = t.split(";");
  if (e.length < 3)
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: ""
    };
  const [n, r] = e[0].split("@"), [s, a] = e[1].split("@"), [i, o] = e[2].split("@");
  return {
    webrpcGenVersion: r ?? "",
    codeGenName: s ?? "",
    codeGenVersion: a ?? "",
    schemaName: i ?? "",
    schemaVersion: o ?? ""
  };
}
let Vs = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.DROPPED = "DROPPED", t.QUEUED = "QUEUED", t.SENT = "SENT", t.SUCCEEDED = "SUCCEEDED", t.PARTIALLY_FAILED = "PARTIALLY_FAILED", t.FAILED = "FAILED", t;
}({}), yQ = /* @__PURE__ */ function(t) {
  return t.SEND = "SEND", t.RECEIVE = "RECEIVE", t.BRIDGE_DEPOSIT = "BRIDGE_DEPOSIT", t.BRIDGE_WITHDRAW = "BRIDGE_WITHDRAW", t.BURN = "BURN", t.UNKNOWN = "UNKNOWN", t;
}({}), gQ = /* @__PURE__ */ function(t) {
  return t.UNKNOWN = "UNKNOWN", t.ERC20_TOKEN = "ERC20_TOKEN", t.ERC1155_TOKEN = "ERC1155_TOKEN", t;
}({}), wQ = /* @__PURE__ */ function(t) {
  return t.DESC = "DESC", t.ASC = "ASC", t;
}({});
class s3 {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Relayer/", this.ping = (r, s) => this.fetch(this.url("Ping"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.version = (r, s) => this.fetch(this.url("Version"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      version: i.version
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.runtimeStatus = (r, s) => this.fetch(this.url("RuntimeStatus"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      status: i.status
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getSequenceContext = (r, s) => this.fetch(this.url("GetSequenceContext"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      data: i.data
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.getChainID = (r, s) => this.fetch(this.url("GetChainID"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      chainID: i.chainID
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.sendMetaTxn = (r, s, a) => this.fetch(this.url("SendMetaTxn"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      txnHash: o.txnHash
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNonce = (r, s, a) => this.fetch(this.url("GetMetaTxnNonce"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnReceipt = (r, s, a) => this.fetch(this.url("GetMetaTxnReceipt"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      receipt: o.receipt
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.simulate = (r, s, a) => this.fetch(this.url("Simulate"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      results: o.results
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateMetaTxnGasLimits = (r, s, a) => this.fetch(this.url("UpdateMetaTxnGasLimits"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      payload: o.payload
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.feeTokens = (r, s) => this.fetch(this.url("FeeTokens"), Pe({}, r, s)).then((a) => Ie(a).then((i) => ({
      isFeeRequired: i.isFeeRequired,
      tokens: i.tokens
    })), (a) => {
      throw Ce.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.feeOptions = (r, s, a) => this.fetch(this.url("FeeOptions"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      options: o.options,
      sponsored: o.sponsored,
      quote: o.quote
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTxnNetworkFeeOptions = (r, s, a) => this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      options: o.options
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getMetaTransactions = (r, s, a) => this.fetch(this.url("GetMetaTransactions"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getTransactionCost = (r, s, a) => this.fetch(this.url("GetTransactionCost"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      cost: o.cost
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.sentTransactions = (r, s, a) => this.fetch(this.url("SentTransactions"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.pendingTransactions = (r, s, a) => this.fetch(this.url("PendingTransactions"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      transactions: o.transactions
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTank = (r, s, a) => this.fetch(this.url("GetGasTank"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      gasTank: o.gasTank
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasTank = (r, s, a) => this.fetch(this.url("AddGasTank"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasTank = (r, s, a) => this.fetch(this.url("UpdateGasTank"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasTank: o.gasTank
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.nextGasTankBalanceAdjustmentNonce = (r, s, a) => this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      nonce: o.nonce
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustGasTankBalance = (r, s, a) => this.fetch(this.url("AdjustGasTankBalance"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      adjustment: o.adjustment
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasTankBalanceAdjustment = (r, s, a) => this.fetch(this.url("GetGasTankBalanceAdjustment"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      adjustment: o.adjustment
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasTankBalanceAdjustments = (r, s, a) => this.fetch(this.url("ListGasTankBalanceAdjustments"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      adjustments: o.adjustments
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.listGasSponsors = (r, s, a) => this.fetch(this.url("ListGasSponsors"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getGasSponsor = (r, s, a) => this.fetch(this.url("GetGasSponsor"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addGasSponsor = (r, s, a) => this.fetch(this.url("AddGasSponsor"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.updateGasSponsor = (r, s, a) => this.fetch(this.url("UpdateGasSponsor"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status,
      gasSponsor: o.gasSponsor
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.removeGasSponsor = (r, s, a) => this.fetch(this.url("RemoveGasSponsor"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      status: o.status
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.addressGasSponsors = (r, s, a) => this.fetch(this.url("AddressGasSponsors"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      page: o.page,
      gasSponsors: o.gasSponsors
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.getProjectBalance = (r, s, a) => this.fetch(this.url("GetProjectBalance"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.adjustProjectBalance = (r, s, a) => this.fetch(this.url("AdjustProjectBalance"), Pe(r, s, a)).then((i) => Ie(i).then((o) => ({
      balance: o.balance
    })), (i) => {
      throw Ce.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const Pe = (t = {}, e = {}, n = null) => {
  const r = no({}, e, {
    "Content-Type": "application/json"
  });
  return r[hg] = r3, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, Ie = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), mg.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (P3[r] || be).new(n);
  }
  return n;
});
let be = class a3 extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, a3.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}, i3 = class o3 extends be {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, o3.prototype);
  }
}, Ce = class c3 extends be {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, c3.prototype);
  }
}, l3 = class u3 extends be {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, u3.prototype);
  }
}, d3 = class f3 extends be {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, f3.prototype);
  }
}, p3 = class h3 extends be {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, h3.prototype);
  }
}, mg = class m3 extends be {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, m3.prototype);
  }
}, b3 = class y3 extends be {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, y3.prototype);
  }
}, g3 = class w3 extends be {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, w3.prototype);
  }
}, E3 = class x3 extends be {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, x3.prototype);
  }
}, A3 = class v3 extends be {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, v3.prototype);
  }
}, k3 = class C3 extends be {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, C3.prototype);
  }
};
class Rp extends be {
  constructor(e = "Unauthorized", n = 1e3, r = "Unauthorized access", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Rp.prototype);
  }
}
class Fp extends be {
  constructor(e = "PermissionDenied", n = 1001, r = "Permission denied", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Fp.prototype);
  }
}
class Mp extends be {
  constructor(e = "SessionExpired", n = 1002, r = "Session expired", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Mp.prototype);
  }
}
class Dp extends be {
  constructor(e = "MethodNotFound", n = 1003, r = "Method not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Dp.prototype);
  }
}
class Lp extends be {
  constructor(e = "RequestConflict", n = 1004, r = "Conflict with target resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Lp.prototype);
  }
}
class Hp extends be {
  constructor(e = "Aborted", n = 1005, r = "Request aborted", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Hp.prototype);
  }
}
class $p extends be {
  constructor(e = "Geoblocked", n = 1006, r = "Geoblocked region", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, $p.prototype);
  }
}
class _p extends be {
  constructor(e = "RateLimited", n = 1007, r = "Rate-limited. Please slow down.", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, _p.prototype);
  }
}
class Gp extends be {
  constructor(e = "ProjectNotFound", n = 1008, r = "Project not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Gp.prototype);
  }
}
class zp extends be {
  constructor(e = "AccessKeyNotFound", n = 1101, r = "Access key not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, zp.prototype);
  }
}
class Vp extends be {
  constructor(e = "AccessKeyMismatch", n = 1102, r = "Access key mismatch", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Vp.prototype);
  }
}
class jp extends be {
  constructor(e = "InvalidOrigin", n = 1103, r = "Invalid origin for Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, jp.prototype);
  }
}
class Kp extends be {
  constructor(e = "InvalidService", n = 1104, r = "Service not enabled for Access key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Kp.prototype);
  }
}
class qp extends be {
  constructor(e = "UnauthorizedUser", n = 1105, r = "Unauthorized user", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, qp.prototype);
  }
}
class Wp extends be {
  constructor(e = "QuotaExceeded", n = 1200, r = "Quota request exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Wp.prototype);
  }
}
class Qp extends be {
  constructor(e = "QuotaRateLimit", n = 1201, r = "Quota rate limit exceeded", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Qp.prototype);
  }
}
class Jp extends be {
  constructor(e = "NoDefaultKey", n = 1300, r = "No default access key found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Jp.prototype);
  }
}
class Zp extends be {
  constructor(e = "MaxAccessKeys", n = 1301, r = "Access keys limit reached", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Zp.prototype);
  }
}
class Xp extends be {
  constructor(e = "AtLeastOneKey", n = 1302, r = "You need at least one Access Key", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Xp.prototype);
  }
}
class Yp extends be {
  constructor(e = "Timeout", n = 1900, r = "Request timed out", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Yp.prototype);
  }
}
let T3 = class S3 extends be {
  constructor(e = "InvalidArgument", n = 2001, r = "Invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, S3.prototype);
  }
};
class eh extends be {
  constructor(e = "Unavailable", n = 2002, r = "Unavailable resource", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, eh.prototype);
  }
}
class th extends be {
  constructor(e = "QueryFailed", n = 2003, r = "Query failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, th.prototype);
  }
}
let O3 = class B3 extends be {
  constructor(e = "NotFound", n = 3e3, r = "Resource not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, B3.prototype);
  }
};
class nh extends be {
  constructor(e = "InsufficientFee", n = 3004, r = "Insufficient fee", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, nh.prototype);
  }
}
class rh extends be {
  constructor(e = "NotEnoughBalance", n = 3005, r = "Not enough balance", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, rh.prototype);
  }
}
let EQ = /* @__PURE__ */ function(t) {
  return t.WebrpcEndpoint = "WebrpcEndpoint", t.WebrpcRequestFailed = "WebrpcRequestFailed", t.WebrpcBadRoute = "WebrpcBadRoute", t.WebrpcBadMethod = "WebrpcBadMethod", t.WebrpcBadRequest = "WebrpcBadRequest", t.WebrpcBadResponse = "WebrpcBadResponse", t.WebrpcServerPanic = "WebrpcServerPanic", t.WebrpcInternalError = "WebrpcInternalError", t.WebrpcClientDisconnected = "WebrpcClientDisconnected", t.WebrpcStreamLost = "WebrpcStreamLost", t.WebrpcStreamFinished = "WebrpcStreamFinished", t.Unauthorized = "Unauthorized", t.PermissionDenied = "PermissionDenied", t.SessionExpired = "SessionExpired", t.MethodNotFound = "MethodNotFound", t.RequestConflict = "RequestConflict", t.Aborted = "Aborted", t.Geoblocked = "Geoblocked", t.RateLimited = "RateLimited", t.ProjectNotFound = "ProjectNotFound", t.AccessKeyNotFound = "AccessKeyNotFound", t.AccessKeyMismatch = "AccessKeyMismatch", t.InvalidOrigin = "InvalidOrigin", t.InvalidService = "InvalidService", t.UnauthorizedUser = "UnauthorizedUser", t.QuotaExceeded = "QuotaExceeded", t.QuotaRateLimit = "QuotaRateLimit", t.NoDefaultKey = "NoDefaultKey", t.MaxAccessKeys = "MaxAccessKeys", t.AtLeastOneKey = "AtLeastOneKey", t.Timeout = "Timeout", t.InvalidArgument = "InvalidArgument", t.Unavailable = "Unavailable", t.QueryFailed = "QueryFailed", t.NotFound = "NotFound", t.InsufficientFee = "InsufficientFee", t.NotEnoughBalance = "NotEnoughBalance", t;
}({}), xQ = /* @__PURE__ */ function(t) {
  return t[t.WebrpcEndpoint = 0] = "WebrpcEndpoint", t[t.WebrpcRequestFailed = -1] = "WebrpcRequestFailed", t[t.WebrpcBadRoute = -2] = "WebrpcBadRoute", t[t.WebrpcBadMethod = -3] = "WebrpcBadMethod", t[t.WebrpcBadRequest = -4] = "WebrpcBadRequest", t[t.WebrpcBadResponse = -5] = "WebrpcBadResponse", t[t.WebrpcServerPanic = -6] = "WebrpcServerPanic", t[t.WebrpcInternalError = -7] = "WebrpcInternalError", t[t.WebrpcClientDisconnected = -8] = "WebrpcClientDisconnected", t[t.WebrpcStreamLost = -9] = "WebrpcStreamLost", t[t.WebrpcStreamFinished = -10] = "WebrpcStreamFinished", t[t.Unauthorized = 1e3] = "Unauthorized", t[t.PermissionDenied = 1001] = "PermissionDenied", t[t.SessionExpired = 1002] = "SessionExpired", t[t.MethodNotFound = 1003] = "MethodNotFound", t[t.RequestConflict = 1004] = "RequestConflict", t[t.Aborted = 1005] = "Aborted", t[t.Geoblocked = 1006] = "Geoblocked", t[t.RateLimited = 1007] = "RateLimited", t[t.ProjectNotFound = 1008] = "ProjectNotFound", t[t.AccessKeyNotFound = 1101] = "AccessKeyNotFound", t[t.AccessKeyMismatch = 1102] = "AccessKeyMismatch", t[t.InvalidOrigin = 1103] = "InvalidOrigin", t[t.InvalidService = 1104] = "InvalidService", t[t.UnauthorizedUser = 1105] = "UnauthorizedUser", t[t.QuotaExceeded = 1200] = "QuotaExceeded", t[t.QuotaRateLimit = 1201] = "QuotaRateLimit", t[t.NoDefaultKey = 1300] = "NoDefaultKey", t[t.MaxAccessKeys = 1301] = "MaxAccessKeys", t[t.AtLeastOneKey = 1302] = "AtLeastOneKey", t[t.Timeout = 1900] = "Timeout", t[t.InvalidArgument = 2001] = "InvalidArgument", t[t.Unavailable = 2002] = "Unavailable", t[t.QueryFailed = 2003] = "QueryFailed", t[t.NotFound = 3e3] = "NotFound", t[t.InsufficientFee = 3004] = "InsufficientFee", t[t.NotEnoughBalance = 3005] = "NotEnoughBalance", t;
}({});
const P3 = {
  0: i3,
  [-1]: Ce,
  [-2]: l3,
  [-3]: d3,
  [-4]: p3,
  [-5]: mg,
  [-6]: b3,
  [-7]: g3,
  [-8]: E3,
  [-9]: A3,
  [-10]: k3,
  1e3: Rp,
  1001: Fp,
  1002: Mp,
  1003: Dp,
  1004: Lp,
  1005: Hp,
  1006: $p,
  1007: _p,
  1008: Gp,
  1101: zp,
  1102: Vp,
  1103: jp,
  1104: Kp,
  1105: qp,
  1200: Wp,
  1201: Qp,
  1300: Jp,
  1301: Zp,
  1302: Xp,
  1900: Yp,
  2001: T3,
  2002: eh,
  2003: th,
  3e3: O3,
  3004: nh,
  3005: rh
};
var Bf = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WebrpcHeader: hg,
  WebrpcHeaderValue: r3,
  WebRPCVersion: fQ,
  WebRPCSchemaVersion: pQ,
  WebRPCSchemaHash: hQ,
  VersionFromHeader: mQ,
  ETHTxnStatus: Vs,
  TransferType: yQ,
  FeeTokenType: gQ,
  SortOrder: wQ,
  Relayer: s3,
  WebrpcError: be,
  WebrpcEndpointError: i3,
  WebrpcRequestFailedError: Ce,
  WebrpcBadRouteError: l3,
  WebrpcBadMethodError: d3,
  WebrpcBadRequestError: p3,
  WebrpcBadResponseError: mg,
  WebrpcServerPanicError: b3,
  WebrpcInternalErrorError: g3,
  WebrpcClientDisconnectedError: E3,
  WebrpcStreamLostError: A3,
  WebrpcStreamFinishedError: k3,
  UnauthorizedError: Rp,
  PermissionDeniedError: Fp,
  SessionExpiredError: Mp,
  MethodNotFoundError: Dp,
  RequestConflictError: Lp,
  AbortedError: Hp,
  GeoblockedError: $p,
  RateLimitedError: _p,
  ProjectNotFoundError: Gp,
  AccessKeyNotFoundError: zp,
  AccessKeyMismatchError: Vp,
  InvalidOriginError: jp,
  InvalidServiceError: Kp,
  UnauthorizedUserError: qp,
  QuotaExceededError: Wp,
  QuotaRateLimitError: Qp,
  NoDefaultKeyError: Jp,
  MaxAccessKeysError: Zp,
  AtLeastOneKeyError: Xp,
  TimeoutError: Yp,
  InvalidArgumentError: T3,
  UnavailableError: eh,
  QueryFailedError: th,
  NotFoundError: O3,
  InsufficientFeeError: nh,
  NotEnoughBalanceError: rh,
  errors: EQ,
  WebrpcErrorCodes: xQ,
  webrpcErrorByCode: P3
});
const AQ = [Vs.DROPPED, Vs.SUCCEEDED, Vs.PARTIALLY_FAILED, Vs.FAILED], vQ = [Vs.DROPPED, Vs.PARTIALLY_FAILED, Vs.FAILED];
class kQ {
  constructor(e) {
    if (this.options = e, this.service = void 0, this.provider = void 0, this._fetch = (n, r) => {
      const s = {}, {
        jwtAuth: a,
        projectAccessKey: i
      } = this.options;
      return a && a.length > 0 && (s.Authorization = `BEARER ${a}`), i && i.length > 0 && (s["X-Access-Key"] = i), r.headers = no({}, s, r.headers), fetch(n, r);
    }, this.service = new s3(e.url, this._fetch), TQ(e.provider))
      this.provider = e.provider;
    else {
      const {
        jwtAuth: n,
        projectAccessKey: r
      } = this.options, s = VA(e.provider.url, r, n);
      this.provider = new hy(s, void 0, {
        staticNetwork: !0
      });
    }
  }
  async waitReceipt(e, n = 1e3, r = 5, s) {
    typeof e != "string" && (e = re.transaction.intendedTransactionID(e)), Fn.info(`[rpc-relayer/waitReceipt] waiting for ${e}`);
    let a = 0;
    for (; s === void 0 || !s(); ) {
      try {
        const {
          receipt: i
        } = await this.service.getMetaTxnReceipt({
          metaTxID: e
        });
        if (i && i.txnReceipt && i.txnReceipt !== "null" && AQ.includes(i.status))
          return {
            receipt: i
          };
      } catch (i) {
        if (a++, a === r)
          throw i;
      }
      (s === void 0 || !s()) && await new Promise((i) => setTimeout(i, n));
    }
    throw new Error(`Cancelled waiting for transaction receipt ${e}`);
  }
  async simulate(e, ...n) {
    const s = Ot.defaultAbiCoder().encode([re.transaction.MetaTransactionsType], [re.transaction.sequenceTxAbiEncode(n)]);
    return (await this.service.simulate({
      wallet: e,
      transactions: s
    })).results;
  }
  async getFeeOptions(e, ...n) {
    const r = await this.service.feeTokens();
    if (r.isFeeRequired) {
      const s = r.tokens.map((c) => c.symbol).join(", ");
      Fn.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${s}`);
      const a = await this.getNonce(e);
      if (!this.provider)
        throw Fn.warn("[rpc-relayer/getFeeOptions] provider not set, needed for stub signature"), new Error("provider is not set");
      const {
        options: i,
        quote: o
      } = await this.service.feeOptions({
        wallet: e,
        to: e,
        data: re.transaction.encodeBundleExecData({
          entrypoint: e,
          transactions: n,
          nonce: a
        })
      });
      return Fn.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(i, al)}`), {
        options: i,
        quote: {
          _tag: "FeeQuote",
          _quote: o
        }
      };
    } else
      return Fn.info("[rpc-relayer/getFeeOptions] relayer fees are not required"), {
        options: []
      };
  }
  async getFeeOptionsRaw(e, n, r) {
    const {
      options: s,
      quote: a
    } = await this.service.feeOptions({
      wallet: e,
      to: e,
      data: V(n),
      simulate: r == null ? void 0 : r.simulate
    }, no({}, r != null && r.projectAccessKey ? {
      "X-Access-Key": r.projectAccessKey
    } : void 0));
    return {
      options: s,
      quote: {
        _tag: "FeeQuote",
        _quote: a
      }
    };
  }
  async gasRefundOptions(e, ...n) {
    const {
      options: r
    } = await this.getFeeOptions(e, ...n);
    return r;
  }
  async getNonce(e, n) {
    Fn.info(`[rpc-relayer/getNonce] get nonce for wallet ${e} space: ${n}`);
    const r = n !== void 0 ? w0(BigInt(n)) : void 0, s = await this.service.getMetaTxnNonce({
      walletContractAddress: e,
      space: r
    }), a = BigInt(s.nonce), [i, o] = re.transaction.decodeNonce(a);
    return Fn.info(`[rpc-relayer/getNonce] got next nonce for wallet ${e} ${o} space: ${i}`), a;
  }
  async relay(e, n, r = !0, s) {
    var a = this;
    Fn.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(e, al)} with quote ${JSON.stringify(n, al)}`);
    let i;
    if (n !== void 0 && (typeof n._quote == "string" ? i = n._quote : Fn.warn("[rpc-relayer/relay] ignoring invalid fee quote")), !this.provider)
      throw Fn.warn("[rpc-relayer/relay] provider not set, failed relay"), new Error("provider is not set");
    const o = re.transaction.encodeBundleExecData(e), c = await this.service.sendMetaTxn({
      call: {
        walletAddress: e.intent.wallet,
        contract: e.entrypoint,
        input: o
      },
      quote: i
    }, no({}, s ? {
      "X-Access-Key": s
    } : void 0));
    if (Fn.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(c, al)}`), r)
      return this.wait(e.intent.id);
    {
      const u = {
        hash: e.intent.id,
        confirmations: 0,
        from: e.intent.wallet,
        wait: (d) => Promise.reject(new Error("impossible"))
      }, l = async function(f) {
        var h;
        if (!a.provider)
          throw new Error("cannot wait for receipt, relayer has no provider set");
        const y = await a.wait(e.intent.id), b = (h = y.receipt) == null ? void 0 : h.transactionHash;
        if (!b)
          throw new Error("cannot wait for receipt, unknown native transaction hash");
        return Object.assign(u, y), a.provider.waitForTransaction(b, f);
      };
      return u.wait = l, u;
    }
  }
  async wait(e, n, r = 1e3, s = 5) {
    var a = this;
    let i = !1;
    const {
      receipt: o
    } = await (n !== void 0 ? Promise.race([this.waitReceipt(e, r, s, () => i), new Promise((u, l) => setTimeout(() => {
      i = !0, l(`Timeout waiting for transaction receipt ${e}`);
    }, n))]) : this.waitReceipt(e, r, s));
    if (!o.txnReceipt || vQ.includes(o.status))
      throw new CQ(o);
    const c = JSON.parse(o.txnReceipt);
    return {
      blockHash: c.blockHash,
      blockNumber: Number(c.blockNumber),
      confirmations: 1,
      from: typeof e == "string" ? void 0 : e.intent.wallet,
      hash: c.transactionHash,
      raw: o.txnReceipt,
      receipt: c,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function(u) {
        return a.provider.waitForTransaction(c.transactionHash, u);
      }
    };
  }
  async getMetaTransactions(e, n) {
    return this.service.getMetaTransactions({
      projectId: e,
      page: n
    });
  }
  async getTransactionCost(e, n, r) {
    return this.service.getTransactionCost({
      projectId: e,
      from: n,
      to: r
    });
  }
  async listGasSponsors(e) {
    return this.service.listGasSponsors(e);
  }
  async addGasSponsor(e) {
    return this.service.addGasSponsor(e);
  }
  async updateGasSponsor(e) {
    return this.service.updateGasSponsor(e);
  }
  async removeGasSponsor(e) {
    return this.service.removeGasSponsor(e);
  }
}
class CQ {
  constructor(e) {
    this.receipt = e;
  }
}
function TQ(t) {
  return t && typeof t == "object" && typeof t.getNetwork == "function" && typeof t.getBlockNumber == "function";
}
function SQ(t) {
  return typeof t == "object" && typeof t.simulate == "function" && typeof t.getFeeOptions == "function" && typeof t.gasRefundOptions == "function" && typeof t.getNonce == "function" && typeof t.relay == "function" && typeof t.wait == "function";
}
function OQ(t) {
  return t.getAddress !== void 0 && t.buildDeployTransaction !== void 0 && t.predecorateSignedTransactions !== void 0 && t.decorateTransactions !== void 0 && t.sign !== void 0 && t.notifyStatusChange !== void 0;
}
class BQ {
  constructor(e, n = !0) {
    this.signer = e, this.eoa = n;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(e) {
  }
  async predecorateSignedTransactions(e) {
    return [];
  }
  async decorateTransactions(e, n) {
    return e;
  }
  sign(e) {
    return this.signer.signMessage(e);
  }
  notifyStatusChange(e, n, r) {
  }
  suffix() {
    return new Uint8Array([2]);
  }
}
let Ta = /* @__PURE__ */ function(t) {
  return t[t.INITIAL = 0] = "INITIAL", t[t.SIGNING = 1] = "SIGNING", t[t.SIGNED = 2] = "SIGNED", t[t.ERROR = 3] = "ERROR", t;
}({});
function PQ(t) {
  return t === void 0 || t.state === Ta.INITIAL || t.state === Ta.SIGNING;
}
class sh {
  constructor(e, n = sh.randomTag()) {
    this.tag = n, this.observers = [], this.signers = [], this.count = 0, this.setSigners(e);
  }
  static randomTag() {
    return `default-${V(na(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(e) {
    this.signers = e.map((n) => OQ(n) ? n : new BQ(n));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function(e) {
      return e.getAddress();
    }));
  }
  subscribe(e) {
    return this.observers.push(e), () => {
      this.observers = this.observers.filter((n) => n !== e);
    };
  }
  async notifyObservers(e, n, r) {
    await Promise.all([...this.signers.map(async function(s) {
      return s.notifyStatusChange(e, n, r);
    }), ...this.observers.map(async function(s) {
      return s(n, r);
    })]);
  }
  async buildDeployTransaction(e) {
    let n;
    for (const r of this.signers) {
      const s = await r.buildDeployTransaction(e);
      n === void 0 ? n = s : s != null && s.transactions && (n.transactions = s.transactions.concat(n.transactions));
    }
    return n;
  }
  async predecorateSignedTransactions(e) {
    const n = [];
    for (const r of this.signers)
      n.push(...await r.predecorateSignedTransactions(e ?? {}));
    return n;
  }
  async decorateTransactions(e, n) {
    for (const r of this.signers)
      e = await r.decorateTransactions(e, n ?? {});
    return e;
  }
  signMessage(e) {
    var n = this;
    const r = this.pullId();
    return new Promise(async function(s) {
      const {
        message: a,
        metadata: i,
        callback: o,
        candidates: c
      } = e, u = {
        ended: !1,
        message: a,
        signers: {}
      };
      let l = i ?? {};
      const d = (b) => {
        l = b, n.notifyObservers(r, u, l);
      }, f = () => {
        try {
          n.notifyObservers(r, u, l);
          const b = Object.entries(u.signers).filter(([g, w]) => PQ(w));
          if (o && o(u, d) || b.length === 0) {
            u.ended = !0, s(u), n.notifyObservers(r, u, l);
            return;
          }
        } catch (b) {
          console.error("Error while notifying observers", b);
        }
      };
      let h = n.signers;
      if (c) {
        const b = await Promise.all(n.signers.map(async function(g) {
          return g.getAddress();
        }));
        h = n.signers.filter((g, w) => c.includes(b[w]));
      }
      const y = await Promise.allSettled(h.map(async function(b) {
        const g = await b.getAddress();
        u.signers[g] = {
          state: Ta.SIGNING,
          request: b.sign(a, i ?? {}).then((w) => {
            const v = b.suffix();
            return u.signers[g] = {
              state: Ta.SIGNED,
              signature: w,
              suffix: v
            }, f(), w;
          }).catch((w) => {
            throw u.signers[g] = {
              state: Ta.ERROR,
              error: w
            }, f(), w;
          })
        };
      }));
      for (let b = 0; b < y.length; b++) {
        const g = n.signers[b], w = y[b];
        if (w.status === "rejected") {
          const v = await g.getAddress();
          console.warn(`signer ${v} rejected the request: ${w.reason}`), u.signers[v] = {
            state: Ta.ERROR,
            error: new Error(`signer ${v} rejected the request: ${w.reason}`)
          };
        }
      }
      f();
    });
  }
}
function ws() {
  return ws = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, ws.apply(null, arguments);
}
async function AE(t) {
  return Array.isArray(t) ? Promise.all(t.map((e) => ot(e))) : ot(t);
}
const vE = (t) => {
  const e = /* @__PURE__ */ new Map();
  for (const n of Object.keys(t.signers)) {
    const r = t.signers[n];
    if (r.state === Ta.SIGNED) {
      const s = Q(r.suffix), a = Ee(["bytes", "bytes"], [r.signature, s]);
      e.set(n, {
        signature: a,
        isDynamic: s.length !== 1 || s[0] !== 2
      });
    }
  }
  return e;
};
class ro extends _A {
  constructor(e) {
    var n;
    const r = BigInt(e.chainId);
    if (r === 0n && !e.coders.signature.supportsNoChainId)
      throw new Error(`Sequence version ${e.config.version} doesn't support chainId 0`);
    super((n = e.provider) != null ? n : null), this.context = void 0, this.config = void 0, this.address = void 0, this.chainId = void 0, this.relayer = void 0, this.coders = void 0, this.orchestrator = void 0, this._reader = void 0, this.context = e.context, this.config = e.config, this.orchestrator = e.orchestrator, this.coders = e.coders, this.address = e.address, this.chainId = r, this.relayer = e.relayer, this._reader = e.reader;
  }
  static newWallet(e) {
    const n = re.context.addressOf(e.context, e.coders.config.imageHashOf(e.config));
    return new ro(ws({}, e, {
      address: n
    }));
  }
  reader() {
    if (this._reader) return this._reader;
    if (!this.provider) throw new Error("Wallet status provider requires a provider");
    return new re.reader.OnChainReader(this.provider);
  }
  setConfig(e) {
    this.config = e;
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setAddress(e) {
    this.address = e;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(e) {
    const n = await this.orchestrator.decorateTransactions(e);
    if (await this.reader().isDeployed(this.address))
      return n;
    const r = [{
      to: n.entrypoint,
      data: re.transaction.encodeBundleExecData(n),
      revertOnError: !0
    }], s = await this.buildDeployTransaction();
    return s && r.unshift(...s.transactions), {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: n.intent,
      transactions: r
    };
  }
  async buildDeployTransaction(e) {
    if (e != null && e.ignoreDeployed && await this.reader().isDeployed(this.address))
      return;
    const n = this.coders.config.imageHashOf(this.config);
    if (re.context.addressOf(this.context, n) !== this.address)
      throw new Error(`First address of config ${n} doesn't match wallet address ${this.address}`);
    let r;
    switch (this.chainId) {
      case BigInt(k.SKALE_NEBULA):
        r = 10000000n;
        break;
      case BigInt(k.SOMNIA_TESTNET):
        r = 10000000n;
        break;
    }
    const s = ro.buildDeployTransaction(this.context, n, r);
    if (e != null && e.includeChildren) {
      const a = await this.orchestrator.buildDeployTransaction(e);
      a && (s.transactions = a.transactions.concat(s.transactions));
    }
    return s;
  }
  async deploy(e) {
    const n = await this.buildDeployTransaction(e);
    if (n !== void 0) {
      if (!this.relayer) throw new Error("Wallet deploy requires a relayer");
      return this.relayer.relay(ws({}, n, {
        chainId: this.chainId,
        intent: {
          id: V(na(32)),
          wallet: this.address
        }
      }));
    }
  }
  static buildDeployTransaction(e, n, r = 100000n) {
    const s = new Bt(St.factory.abi);
    return {
      entrypoint: e.guestModule,
      transactions: [{
        to: e.factory,
        data: s.encodeFunctionData(s.getFunction("deploy"), [e.mainModule, n]),
        gasLimit: r,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(e) {
    if (this.coders.config.update.isKindUsed) {
      const n = await this.reader().implementation(this.address), r = n && n === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, e, this.context, r ? "later" : "first");
    }
    return this.coders.config.update.buildTransaction(this.address, e, this.context);
  }
  async getNonce(e = 0) {
    const n = await this.reader().nonce(this.address, e);
    if (n === void 0) throw new Error("Unable to determine nonce");
    return Number(n);
  }
  async signDigest(e, n) {
    const r = vw(this.address, this.chainId, e);
    if (this.coders.config.hasSubdigest(this.config, r))
      return this.coders.signature.encodeSigners(this.config, /* @__PURE__ */ new Map(), [r], this.chainId).encoded;
    const s = ws({}, n, {
      // Keep other metadata fields
      digest: e,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    }), a = Q(r), i = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map((c) => c.address),
      message: a,
      metadata: s,
      callback: (c, u) => {
        const l = vE(c), d = ws({}, s, {
          parts: l
        });
        return u(d), this.coders.signature.hasEnoughSigningPower(this.config, l);
      }
    }), o = vE(i);
    return this.coders.signature.encodeSigners(this.config, o, [], this.chainId).encoded;
  }
  signMessage(e) {
    return this.signDigest(xe(e), {
      message: e
    });
  }
  // XXX This method is not implemented in the original code but required by the AbstractSigner interface
  signTypedData(e, n, r) {
    const s = jA({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(s);
  }
  signTransactionBundle(e) {
    if (e.entrypoint !== this.address)
      throw new Error(`Invalid entrypoint: ${e.entrypoint} !== ${this.address}`);
    return this.signTransactions(e.transactions, e.nonce);
  }
  async fetchNonceOrSpace(e) {
    let n;
    if (e && e.space !== void 0)
      n = BigInt(e.space);
    else {
      if (e === void 0)
        return this.randomNonce();
      if (e && e.serial === !0)
        n = 0;
      else
        return e;
    }
    const r = await this.reader().nonce(this.address, n);
    if (r === void 0) throw new Error("Unable to determine nonce");
    return re.transaction.encodeNonce(n, r);
  }
  // Generate nonce with random space
  randomNonce() {
    const e = BigInt(V(na(12)));
    return re.transaction.encodeNonce(e, 0);
  }
  async signTransactions(e, n, r) {
    const s = await AE(e), a = re.transaction.fromTransactionish(this.address, s);
    a.length === 0 && a.push({
      to: this.address,
      data: "0x",
      value: 0,
      gasLimit: 0,
      delegateCall: !1,
      revertOnError: !0
    });
    const i = await this.fetchNonceOrSpace(n), o = re.transaction.digestOfTransactions(i, a), c = ws({
      digest: o,
      transactions: a
    }, r), u = await this.signDigest(o, c);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: vw(this.address, this.chainId, o),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions: a,
      entrypoint: this.address,
      nonce: i,
      signature: u
    };
  }
  async sendSignedTransaction(e, n) {
    if (!this.relayer) throw new Error("Wallet sendTransaction requires a relayer");
    return this.relayer.relay(e, n);
  }
  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(e, n) {
    let r;
    (n == null ? void 0 : n.nonce) !== void 0 ? r = n.nonce : n != null && n.serial ? r = {
      serial: !0
    } : r = this.randomNonce();
    const s = await this.signTransactions(e, r), a = await this.decorateTransactions(s);
    return this.sendSignedTransaction(a, n == null ? void 0 : n.quote);
  }
  async fillGasLimits(e) {
    const n = await AE(e), r = re.transaction.fromTransactionish(this.address, n), s = this.relayer;
    if (!s) throw new Error("Wallet fillGasLimits requires a relayer");
    const a = await s.simulate(this.address, ...r);
    return r.map((i, o) => {
      const c = i.gasLimit ? Number(i.gasLimit) : a[o].gasLimit;
      return ws({}, i, a[o], {
        gasLimit: c
      });
    });
  }
  connect(e, n) {
    return new ro({
      // Sequence version configurator
      coders: this.coders,
      context: this.context,
      config: this.config,
      chainId: this.chainId,
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this._reader,
      provider: e,
      relayer: n ?? this.relayer
    });
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
}
function ur() {
  return ur = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, ur.apply(null, arguments);
}
function IQ(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case Bf.FeeTokenType.UNKNOWN:
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.to,
        value: w0(e),
        data: "0x"
      }];
    case Bf.FeeTokenType.ERC20_TOKEN:
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      return [{
        delegateCall: !1,
        revertOnError: !0,
        gasLimit: t.gasLimit,
        to: t.token.contractAddress,
        value: 0,
        data: new Bt([{
          constant: !1,
          inputs: [{
            type: "address"
          }, {
            type: "uint256"
          }],
          name: "transfer",
          outputs: [],
          type: "function"
        }]).encodeFunctionData("transfer", [t.to, w0(e)])
      }];
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
class UQ {
  constructor(e, n, r) {
    this.account = e, this.chainId = n, this.options = r;
  }
  get provider() {
    return this.account.providerFor(this.chainId);
  }
  async getAddress() {
    return this.account.address;
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. The message is already being prefixed with the EIP-191 prefix.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @returns A Promise that resolves to the signature as a hexadecimal string
   *
   * @example
   * ```typescript
   * const signer = account.getSigner(chainId)
   *
   * const message = "Hello, Sequence!";
   * const signature = await signer.signMessage(message);
   * console.log(signature);
   * // => "0x123abc..." (hexadecimal signature)
   */
  signMessage(e) {
    var n, r;
    return this.account.signMessage(e, this.chainId, (n = (r = this.options) == null ? void 0 : r.cantValidateBehavior) != null ? n : "throw");
  }
  signTypedData(e, n, r) {
    var s, a;
    return this.account.signTypedData(e, n, r, this.chainId, (s = (a = this.options) == null ? void 0 : a.cantValidateBehavior) != null ? s : "throw");
  }
  async defaultSelectFee(e, n) {
    if (n.length === 0) return;
    const r = [{
      constant: !0,
      inputs: [{
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        type: "uint256"
      }],
      type: "function"
    }];
    for (const s of n)
      if (s.token.type === Bf.FeeTokenType.UNKNOWN) {
        if (await this.getBalance() >= BigInt(s.value))
          return s;
      } else if (s.token.contractAddress && s.token.type === Bf.FeeTokenType.ERC20_TOKEN && await new vr(s.token.contractAddress, r, this.provider).balanceOf(this.account.address) >= BigInt(s.value))
        return s;
    throw new Error("No fee option available - not enough balance");
  }
  async sendTransaction(e, n) {
    var r, s, a, i, o;
    const c = await this.account.prepareTransactions({
      txs: e,
      chainId: this.chainId,
      stubSignatureOverrides: (r = (s = this.options) == null ? void 0 : s.stubSignatureOverrides) != null ? r : /* @__PURE__ */ new Map(),
      simulateForFeeOptions: n == null ? void 0 : n.simulateForFeeOptions
    }), l = await ((a = (i = this.options) == null ? void 0 : i.selectFee) != null ? a : this.defaultSelectFee.bind(this))(e, c.feeOptions), d = [...c.transactions, ...IQ(l)];
    return this.account.sendTransaction(d, this.chainId, c.feeQuote, void 0, void 0, ((o = this.options) == null ? void 0 : o.nonceSpace) !== void 0 ? {
      nonceSpace: this.options.nonceSpace
    } : void 0);
  }
  getBalance(e) {
    return this.provider.getBalance(this.account.address, e);
  }
  call(e, n) {
    return this.provider.call(ur({}, e, {
      blockTag: n
    }));
  }
  async resolveName(e) {
    const n = await this.provider.resolveName(e);
    if (!n) throw new Error(`Could not resolve name ${e}`);
    return n;
  }
  connect(e) {
    throw new Error("Method not implemented.");
  }
  signTransaction(e) {
    throw new Error("Method not implemented.");
  }
  getTransactionCount(e) {
    throw new Error("Method not implemented.");
  }
  estimateGas(e) {
    throw new Error("Method not implemented.");
  }
  getChainId() {
    return Promise.resolve(Number(this.chainId));
  }
  getGasPrice() {
    throw new Error("Method not implemented.");
  }
  getFeeData() {
    throw new Error("Method not implemented.");
  }
  getNonce(e) {
    throw new Error("Method not implemented.");
  }
  populateCall(e) {
    throw new Error("Method not implemented.");
  }
  checkTransaction(e) {
    throw new Error("Method not implemented.");
  }
  async populateTransaction(e) {
    throw new Error("Method not implemented.");
  }
  _checkProvider(e) {
    throw new Error("Method not implemented.");
  }
}
class NQ {
  async isDeployed(e) {
    return !1;
  }
  async implementation(e) {
  }
  async imageHash(e) {
  }
  async nonce(e, n) {
    return 0n;
  }
  async isValidSignature(e, n, r) {
    throw new Error("Method not supported.");
  }
}
class ah {
  constructor(e) {
    this.address = void 0, this.networks = void 0, this.tracker = void 0, this.contexts = void 0, this.migrator = void 0, this.migrations = void 0, this.orchestrator = void 0, this.jwt = void 0, this.projectAccessKey = void 0, this.address = ue(e.address), this.contexts = e.contexts, this.tracker = e.tracker, this.networks = e.networks, this.orchestrator = e.orchestrator, this.jwt = e.jwt, this.projectAccessKey = e.projectAccessKey, this.migrations = e.migrations || xE.DefaultMigrations, this.migrator = new EE.Migrator(e.tracker, this.migrations, this.contexts);
  }
  getSigner(e, n) {
    return new UQ(this, e, n);
  }
  static async new(e) {
    var n;
    const s = new EE.Migrator(e.tracker, (n = e.migrations) != null ? n : xE.DefaultMigrations, e.contexts).lastMigration(), a = s.configCoder, i = a.fromSimple(e.config), o = a.imageHashOf(i), c = e.contexts[s.version], u = re.context.addressOf(c, o);
    return await e.tracker.saveCounterfactualWallet({
      config: i,
      context: Object.values(e.contexts)
    }), new ah({
      address: u,
      tracker: e.tracker,
      contexts: e.contexts,
      networks: e.networks,
      orchestrator: e.orchestrator,
      migrations: e.migrations,
      projectAccessKey: e.projectAccessKey
    });
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  get version() {
    return this.migrator.lastMigration().version;
  }
  get coders() {
    const e = this.migrator.lastMigration();
    return {
      signature: e.signatureCoder,
      config: e.configCoder
    };
  }
  network(e) {
    const n = BigInt(e), r = this.networks.find((s) => n === BigInt(s.chainId));
    if (!r) throw new Error(`Network not found for chainId ${e}`);
    return r;
  }
  providerFor(e) {
    const n = this.network(e);
    if (!n.provider && !n.rpcUrl)
      throw new Error(`Provider not found for chainId ${e}`);
    const r = new Jn(n.name, n.chainId);
    return n.provider || new hy(VA(n.rpcUrl, this.projectAccessKey, this.jwt), r, {
      staticNetwork: r
    });
  }
  reader(e) {
    return BigInt(e) === 0n ? new NQ() : new re.reader.OnChainReader(this.providerFor(e));
  }
  relayer(e) {
    const n = this.network(e);
    if (!n.relayer) throw new Error(`Relayer not found for chainId ${e}`);
    return SQ(n.relayer) ? n.relayer : new kQ(ur({}, n.relayer, {
      projectAccessKey: this.projectAccessKey,
      jwtAuth: this.jwt
    }));
  }
  setOrchestrator(e) {
    this.orchestrator = e;
  }
  setJwt(e) {
    this.jwt = e;
  }
  contextFor(e) {
    const n = this.contexts[e];
    if (!n) throw new Error(`Context not found for version ${e}`);
    return n;
  }
  walletForStatus(e, n) {
    const r = Ht.coderFor(n.version);
    return this.walletFor(e, this.contextFor(n.version), n.config, r);
  }
  walletFor(e, n, r, s) {
    const a = BigInt(e) === 0n;
    return new ro({
      config: r,
      context: n,
      chainId: e,
      coders: s,
      relayer: a ? void 0 : this.relayer(e),
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this.reader(e)
    });
  }
  // Get the status of the account on a given network
  // this does the following process:
  // 1. Get the current on-chain status of the wallet (version + imageHash)
  // 2. Get any pending migrations that have been signed by the wallet
  // 3. Get any pending configuration updates that have been signed by the wallet
  // 4. Fetch reverse lookups for both on-chain and pending configurations
  async status(e, n = !1) {
    var r = this;
    const s = this.reader(e).isDeployed(this.address), a = this.tracker.imageHashOfCounterfactualWallet({
      wallet: this.address
    }).then((x) => {
      if (!x) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
      return x;
    }), i = a.then((x) => iQ.counterfactualVersion(this.address, x.imageHash, Object.values(this.contexts))), o = async function() {
      if (!await s) return i;
      const O = await r.reader(e).implementation(r.address);
      if (!O) throw new Error(`Implementation not found for wallet ${r.address}`);
      const I = Object.values(r.contexts);
      for (let T = 0; T < I.length; T++)
        if (I[T].mainModule === O || I[T].mainModuleUpgradable === O)
          return I[T].version;
      throw new Error(`Version not found for implementation ${O}`);
    }(), c = async function() {
      const x = await r.reader(e).imageHash(r.address);
      if (x) return x;
      const O = await a;
      if (O) return O.imageHash;
      throw new Error(`On-chain imageHash not found for wallet ${r.address}`);
    }(), u = async function() {
      const x = await c, O = await r.tracker.configOfImageHash({
        imageHash: x
      });
      if (O) return O;
      throw new Error(`On-chain config not found for imageHash ${x}`);
    }(), l = await o, d = await c;
    let f = d, h = l, y = [];
    if (l !== this.version) {
      const x = await this.migrator.getAllMigratePresignedTransaction({
        address: this.address,
        fromImageHash: d,
        fromVersion: l,
        chainId: e
      });
      f = x.lastImageHash, h = x.lastVersion, y = x.signedMigrations;
    }
    const b = await this.tracker.loadPresignedConfiguration({
      wallet: this.address,
      fromImageHash: f,
      longestPath: n
    }), g = b && b.length > 0 ? b[b.length - 1].nextImageHash : f, w = await this.tracker.configOfImageHash({
      imageHash: g
    });
    if (!w)
      throw new Error(`Config not found for imageHash ${g}`);
    const v = await s, A = await a, P = Ht.coderFor(h).config.checkpointOf(w);
    return {
      original: ur({}, A, {
        version: await i
      }),
      onChain: {
        imageHash: d,
        config: await u,
        version: l,
        deployed: v
      },
      fullyMigrated: h === this.version,
      signedMigrations: y,
      version: h,
      presignedConfigurations: b,
      imageHash: g,
      config: w,
      checkpoint: P,
      canOnchainValidate: l === this.version && v
    };
  }
  mustBeFullyMigrated(e) {
    if (!e.fullyMigrated)
      throw new Error(`Wallet ${this.address} is not fully migrated`);
  }
  async predecorateSignedTransactions(e, n) {
    const r = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), s = await this.predecorateTransactions([], e, n);
    return re.transaction.fromTransactionish(this.address, s).length > 0 && r.push(await this.signTransactions(s, n)), r;
  }
  async predecorateTransactions(e, n, r) {
    if (e = Array.isArray(e) ? e : [e], n.onChain.imageHash !== n.imageHash) {
      const i = await this.walletForStatus(r, n).buildUpdateConfigurationTransaction(n.config);
      e = [...e, ...i.transactions];
    }
    const {
      proxyImplementationHook: s
    } = this.contexts[n.config.version];
    if (s && (r === k.IMMUTABLE_ZKEVM || r === k.IMMUTABLE_ZKEVM_TESTNET)) {
      const a = this.providerFor(r);
      if (a) {
        const i = new vr(this.address, St.walletProxyHook.abi, a);
        let o;
        try {
          o = await i.PROXY_getImplementation();
        } catch (c) {
          console.log("Error getting implementation address", c);
        }
        if (!o || o === ra) {
          console.log("Adding wallet proxy hook");
          const c = new Bt(St.moduleHooks.abi);
          e = [{
            to: this.address,
            data: c.encodeFunctionData(c.getFunction("addHook"), ["0x90611127", s]),
            gasLimit: 5e4,
            // Expected ~28k gas. Buffer added
            delegateCall: !1,
            revertOnError: !1,
            value: 0
          }, ...e];
        }
      }
    }
    return e;
  }
  async decorateTransactions(e, n, r) {
    var s, a;
    if (!Array.isArray(e))
      return this.decorateTransactions([e], n, r);
    r = (s = r) != null ? s : e[0].chainId;
    const i = await this.buildBootstrapTransactions(n, r), o = i.transactions.length > 0;
    if (!o && e.length === 1)
      return e[0];
    const {
      entrypoint: c
    } = o ? i : e[0], u = {
      entrypoint: c,
      chainId: r,
      // Intent of the first bundle is used
      intent: (a = e[0]) == null ? void 0 : a.intent,
      transactions: [...i.transactions, ...e.map((l) => ({
        to: l.entrypoint,
        data: re.transaction.encodeBundleExecData(l),
        gasLimit: 0,
        delegateCall: !1,
        revertOnError: !0,
        value: 0
      }))]
    };
    if (!n.onChain.deployed) {
      const l = re.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, r, u.transactions);
      u.intent === void 0 ? u.intent = {
        id: l,
        wallet: this.address
      } : u.intent.id = l;
    }
    return u;
  }
  async decorateSignature(e, n) {
    if (!n.presignedConfigurations || n.presignedConfigurations.length === 0)
      return e;
    const r = this.coders.signature, s = n.presignedConfigurations.map((i) => i.signature), a = r.chainSignatures(e, s);
    return r.trim(a);
  }
  async publishWitnessFor(e, n = 0) {
    const r = Tr(`This is a Sequence account woo! ${Date.now()}`), s = await this.status(n), a = this.coders.config.fromSimple({
      threshold: e.length,
      checkpoint: 0,
      signers: e.map((l) => ({
        address: l,
        weight: 1
      }))
    }), o = await this.walletFor(n, s.original.context, a, this.coders).signDigest(r), c = this.coders.signature.decode(o), u = this.coders.signature.signaturesOfDecoded(c);
    if (u.length === 0)
      throw new Error("No signatures found");
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: r,
      chainId: n,
      signatures: u
    });
  }
  async publishWitness() {
    const e = Tr(`This is a Sequence account woo! ${Date.now()}`), n = await this.signDigest(e, 0, !1), r = this.coders.signature.decode(n), s = this.coders.signature.signaturesOfDecoded(r);
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: e,
      chainId: 0,
      signatures: s
    });
  }
  async signDigest(e, n, r = !0, s = "ignore", a) {
    const i = BigInt(n) === 0n ? this.networks[0].chainId : n, o = await this.status(i);
    if (this.mustBeFullyMigrated(o), !o.canOnchainValidate && s === "throw")
      throw new Error("Wallet cannot validate onchain");
    const u = await this.walletForStatus(n, o).signDigest(e, a), l = r ? this.decorateSignature(u, o) : u;
    if (!o.canOnchainValidate)
      switch (s) {
        case "ignore":
          return l;
        case "eip6492":
          return this.buildEIP6492Signature(await l, o, n);
      }
    return l;
  }
  buildOnChainSignature(e) {
    const n = re.signature.subdigestOf({
      digest: V(e),
      chainId: 0,
      address: this.address
    }), r = V(n), s = this.coders.config.fromSimple({
      // Threshold *only* needs to be > 0, this is not a magic number
      // we only use 2 ** 15 because it may lead to lower gas costs in some chains
      threshold: 32768,
      checkpoint: 0,
      signers: [],
      subdigests: [r]
    }), a = new Bt(St.mainModule.abi), i = {
      entrypoint: this.address,
      transactions: [{
        to: this.address,
        data: a.encodeFunctionData(
          // *NEVER* use updateImageHash here, as it would effectively destroy the wallet
          // setExtraImageHash sets an additional imageHash, without changing the current one
          "setExtraImageHash",
          [
            this.coders.config.imageHashOf(s),
            // 2 ** 255 instead of max uint256, to have more zeros in the calldata
            "57896044618658097711785492504343953926634992332820282019728792003956564819968"
          ]
        ),
        // Conservative gas limit, used because the current relayer
        // has trouble estimating gas for this transaction
        gasLimit: 25e4
      }]
    };
    this.tracker.saveWalletConfig({
      config: s
    });
    const o = this.coders.signature.encodeSigners(s, /* @__PURE__ */ new Map(), [r], 0).encoded;
    return {
      bundle: i,
      signature: o
    };
  }
  async buildEIP6492Signature(e, n, r) {
    const s = await this.buildBootstrapTransactions(n, r);
    if (s.transactions.length === 0)
      throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
    const a = Ot.defaultAbiCoder().encode(["address", "bytes", "bytes"], [s.entrypoint, re.transaction.encodeBundleExecData(s), e]);
    return Ee(["bytes", "bytes32"], [a, re.EIP6492.EIP_6492_SUFFIX]);
  }
  async editConfig(e) {
    const n = await this.status(0).then((s) => s.config), r = this.coders.config.editConfig(n, ur({}, e, {
      checkpoint: this.coders.config.checkpointOf(n) + 1n
    }));
    return this.updateConfig(r);
  }
  async updateConfig(e) {
    if (!this.coders.config.isWalletConfig(e))
      throw new Error(`Invalid config for wallet ${this.address}`);
    const n = this.coders.config.imageHashOf(e), r = this.coders.signature.hashSetImageHash(n), s = await this.signDigest(r, 0, !1);
    await this.tracker.savePresignedConfiguration({
      wallet: this.address,
      nextConfig: e,
      signature: s,
      referenceChainId: 1
    });
    const a = await this.tracker.configOfImageHash({
      imageHash: n,
      noCache: !0
    });
    if (!a || this.coders.config.imageHashOf(a) !== n)
      throw Error(`Reverse lookup failed for imageHash ${n}`);
  }
  /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */
  async buildBootstrapTransactions(e, n) {
    var r;
    const s = await this.orchestrator.buildDeployTransaction({
      chainId: n
    }), a = (r = s == null ? void 0 : s.transactions) != null ? r : [];
    if (!e.onChain.deployed) {
      let c;
      switch (BigInt(n)) {
        case BigInt(k.SKALE_NEBULA):
          c = 10000000n;
          break;
        case BigInt(k.SOMNIA_TESTNET):
          c = 10000000n;
          break;
      }
      const u = ro.buildDeployTransaction(e.original.context, e.original.imageHash, c);
      a.push(...u.transactions);
    }
    a.push(...e.signedMigrations.map((c) => ({
      to: c.tx.entrypoint,
      data: re.transaction.encodeBundleExecData(c.tx),
      value: 0,
      gasLimit: 0,
      revertOnError: !0,
      delegateCall: !1
    })));
    const i = e.signedMigrations.length > 0 ? e.signedMigrations[0].tx.intent.id : re.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, n, a), {
      guestModule: o
    } = this.contextFor(e.version);
    return {
      entrypoint: o,
      transactions: a,
      chainId: n,
      intent: {
        id: i,
        wallet: this.address
      }
    };
  }
  async bootstrapTransactions(e, n) {
    const r = n || await this.status(e);
    return this.buildBootstrapTransactions(r, e);
  }
  async doBootstrap(e, n, r) {
    const s = await this.bootstrapTransactions(e, r);
    return this.relayer(e).relay(ur({}, s, {
      chainId: e
    }), n);
  }
  /**
   * Signs a message.
   *
   * This method will sign the message using the account associated with this signer
   * and the specified chain ID. If the message is already prefixed with the EIP-191
   * prefix, it will be hashed directly. Otherwise, it will be prefixed before hashing.
   *
   * @param message - The message to sign. Can be a string or BytesLike.
   * @param chainId - The chain ID to use for signing
   * @param cantValidateBehavior - Behavior when the wallet cannot validate on-chain
   * @returns A Promise that resolves to the signature as a hexadecimal string
   */
  signMessage(e, n, r = "ignore") {
    const s = V(e), a = V(Yt(D6));
    let i;
    return s.substring(2).startsWith(a.substring(2)) ? i = xe(e) : i = uA(e), this.signDigest(i, n, !0, r);
  }
  async signTransactions(e, n, r, s) {
    const a = r || await this.status(n);
    this.mustBeFullyMigrated(a);
    const i = this.walletForStatus(n, a), o = {
      address: this.address,
      digest: "",
      // Set in wallet.signTransactions
      chainId: n,
      config: {
        version: this.version
      },
      decorate: !0,
      cantValidateBehavior: "ignore"
    }, c = s != null && s.serial ? {
      serial: !0
    } : (s == null ? void 0 : s.nonceSpace) !== void 0 ? {
      space: s.nonceSpace
    } : void 0, u = await i.signTransactions(e, c, o);
    return ur({}, u, {
      signature: await this.decorateSignature(u.signature, a)
    });
  }
  async signMigrations(e, n) {
    const r = await this.status(e);
    if (r.fullyMigrated) return !1;
    const s = this.walletForStatus(e, r), a = n(s.config), i = await this.migrator.signNextMigration(this.address, r.version, s, a);
    if (!i) return !1;
    await this.tracker.saveWalletConfig({
      config: a
    });
    const o = Ht.coderFor(a.version).config, c = o.imageHashOf(a), u = await this.tracker.configOfImageHash({
      imageHash: c,
      noCache: !0
    });
    if (!u || o.imageHashOf(u) !== c)
      throw Error(`Reverse lookup failed for imageHash ${c}`);
    return await this.tracker.saveMigration(this.address, i, this.contexts), !0;
  }
  async signAllMigrations(e) {
    var n = this;
    const r = [];
    return {
      signedMigrations: (await Promise.all(this.networks.map(async function(i) {
        try {
          return await n.signMigrations(i.chainId, e);
        } catch (o) {
          return console.warn(`Failed to sign migrations for chain ${i.chainId}`, o), r.push(i.chainId), null;
        }
      }))).filter((i) => i !== null),
      failedChains: r
    };
  }
  async isMigratedAllChains() {
    var e = this;
    const n = [];
    return {
      migratedAllChains: (await Promise.all(this.networks.map(async function(a) {
        try {
          return await e.status(a.chainId);
        } catch (i) {
          return n.push(a.chainId), console.warn(`Failed to get status for chain ${a.chainId}`, i), {
            fullyMigrated: !0
          };
        }
      }))).every((a) => a.fullyMigrated),
      failedChains: n
    };
  }
  async sendSignedTransactions(e, n, r, s, a, i) {
    if (!Array.isArray(e))
      return this.sendSignedTransactions([e], n, r, s, a, i);
    const o = s || await this.status(n);
    this.mustBeFullyMigrated(o);
    const c = await this.decorateTransactions(e, o, n);
    return a == null || a(c), this.relayer(n).relay(c, r, void 0, i);
  }
  async fillGasLimits(e, n, r) {
    return this.walletForStatus(n, r || await this.status(n)).fillGasLimits(e);
  }
  async gasRefundQuotes(e, n, r, s, a) {
    const i = s || await this.status(n), o = this.walletForStatus(n, i), c = await this.predecorateTransactions(e, i, n), u = re.transaction.fromTransactionish(this.address, c), l = o.coders.config.buildStubSignature(o.config, r), d = V(na(32)), f = {
      chainId: n,
      intent: {
        id: d,
        wallet: this.address
      },
      signature: l,
      transactions: u,
      entrypoint: this.address,
      nonce: 0
      // The relayer also ignored the nonce
    }, h = await this.decorateTransactions(f, i), y = re.transaction.encodeBundleExecData(h), b = await this.relayer(n).getFeeOptionsRaw(h.entrypoint, y, a);
    return ur({}, b, {
      decorated: h
    });
  }
  async prepareTransactions(e) {
    const n = await this.status(e.chainId), r = await this.fillGasLimits(e.txs, e.chainId, n), s = await this.gasRefundQuotes(r, e.chainId, e.stubSignatureOverrides, n, {
      simulate: e.simulateForFeeOptions,
      projectAccessKey: e.projectAccessKey
    }), a = re.transaction.unwind(this.address, s.decorated.transactions);
    return {
      transactions: r,
      flatDecorated: a,
      feeOptions: s.options,
      feeQuote: s.quote
    };
  }
  async sendTransaction(e, n, r, s = !1, a, i) {
    const o = await this.status(n), c = s ? e : await this.predecorateTransactions(e, o, n), l = re.transaction.fromTransactionish(this.address, c).length > 0 ? await this.signTransactions(c, n, void 0, i) : void 0, d = await this.orchestrator.predecorateSignedTransactions({
      chainId: n
    }), f = [];
    return l !== void 0 && l.transactions.length > 0 && f.push(l), f.push(...d.filter((h) => h.transactions.length > 0)), this.sendSignedTransactions(f, n, r, void 0, a, i == null ? void 0 : i.projectAccessKey);
  }
  async signTypedData(e, n, r, s, a = "ignore") {
    const i = jA({
      domain: e,
      types: n,
      message: r
    });
    return this.signDigest(i, s, !0, a);
  }
  async getSigners() {
    var e = this;
    const n = (r) => r.length ? r[r.length - 1] : void 0;
    return (await Promise.all(this.networks.map(async function({
      chainId: r,
      name: s
    }) {
      try {
        var a;
        const i = await e.status(r);
        let o = (a = n(i.presignedConfigurations)) == null ? void 0 : a.nextImageHash;
        if (!o && i.onChain.version !== i.version) {
          const d = n(i.signedMigrations);
          if (d) {
            const {
              toVersion: f,
              toConfig: h
            } = d;
            o = Ht.genericCoderFor(f).config.imageHashOf(h);
          }
        }
        o || (o = i.onChain.imageHash);
        const c = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!c)
          throw new Error(`unable to find config for image hash ${o}`);
        return Ht.genericCoderFor(c.version).config.signersOf(c).map((d) => ur({}, d, {
          network: r
        }));
      } catch (i) {
        return console.warn(`unable to get signers on network ${r} ${s}`, i), [];
      }
    }))).flat();
  }
  async getAllSigners() {
    var e = this;
    const n = [];
    return await Promise.all(this.networks.map(async function(r) {
      const s = r.chainId, a = await e.status(s, !0), i = [a.onChain.imageHash, ...a.onChain.version !== a.version ? a.signedMigrations.map((o) => Ht.coderFor(o.toVersion).config.imageHashOf(o.toConfig)) : [], ...a.presignedConfigurations.map((o) => o.nextImageHash)];
      return Promise.all(i.map(async function(o, c) {
        const u = c === i.length - 1, l = await e.tracker.configOfImageHash({
          imageHash: o
        });
        if (!l) {
          console.warn(`AllSigners may be incomplete, config not found for imageHash ${o}`);
          return;
        }
        Ht.genericCoderFor(l.version).config.signersOf(l).forEach((h) => {
          const y = n.find((b) => b.address === h.address && b.network === s);
          if (y && u && y.flaggedForRemoval) {
            y.flaggedForRemoval = !1;
            return;
          }
          y || n.push({
            address: h.address,
            weight: h.weight,
            network: s,
            flaggedForRemoval: !u
          });
        });
      }));
    })), n;
  }
}
function RQ(t, e) {
  const n = t.replace("ipfs://ipfs/", "").replace("ipfs://", "");
  return t.startsWith("ipfs://") ? `${e}${n}` : t;
}
function FQ(t) {
  return t.startsWith("ipfs://");
}
class I3 {
  constructor(e, n, r = 1e3) {
    this.provider = e, this.solver = n, this.window = r, this.pending = /* @__PURE__ */ new Map();
  }
  async runByEIP5719(e, n, r) {
    const s = `${e}-${n}-${r}`, a = Date.now();
    if (this.pending.has(s) && a - this.pending.get(s).timestamp < this.window)
      return this.pending.get(s).promise;
    const i = U3(e, this.provider, n, r, this.solver);
    return this.pending.set(s, {
      timestamp: a,
      promise: i
    }), i;
  }
}
function MQ(t, e) {
  const n = [{
    inputs: [{
      internalType: "bytes32",
      type: "bytes32"
    }],
    name: "getAlternativeSignature",
    outputs: [{
      internalType: "string",
      type: "string"
    }],
    stateMutability: "view",
    type: "function"
  }];
  return new vr(t, n, e);
}
async function DQ(t) {
  try {
    return await t;
  } catch {
    return;
  }
}
async function U3(t, e, n, r, s, a = 0) {
  if (a > 10) throw new Error("EIP5719 - Too many tries");
  if (re.signer.canRecover(r)) {
    const c = re.signer.recoverSigner(n, r);
    if (c && c.toLowerCase() === t.toLowerCase()) return r;
  }
  try {
    if (await re.signer.isValidSignature(t, n, r, e))
      return r;
  } catch {
  }
  const i = await DQ(MQ(t, e).getAlternativeSignature(n));
  if (!i || i === "") throw new Error("EIP5719 - Invalid signature and no alternative signature");
  const o = V(await (s || new LQ()).resolve(i));
  if (!o || o === "") throw new Error("EIP5719 - Empty alternative signature");
  if (o === V(r))
    throw new Error("EIP5719 - Alternative signature is invalid or the same");
  return U3(t, e, n, o, s, a + 1);
}
class LQ {
  constructor(e = "https://cloudflare-ipfs.com/ipfs/") {
    var n = this;
    this.gateway = e, this.uri = (r) => FQ(r) ? RQ(r, this.gateway) : r, this.resolve = async function(r) {
      const s = n.uri(r), a = await fetch(s);
      if (!a.ok) throw new Error(`URISolverIPFS - Failed to fetch ${s}`);
      return await a.text();
    };
  }
}
const HQ = (t, e) => e.some((n) => t instanceof n);
let kE, CE;
function $Q() {
  return kE || (kE = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function _Q() {
  return CE || (CE = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const N3 = /* @__PURE__ */ new WeakMap(), vb = /* @__PURE__ */ new WeakMap(), R3 = /* @__PURE__ */ new WeakMap(), Xh = /* @__PURE__ */ new WeakMap(), bg = /* @__PURE__ */ new WeakMap();
function GQ(t) {
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("success", a), t.removeEventListener("error", i);
    }, a = () => {
      n(Zs(t.result)), s();
    }, i = () => {
      r(t.error), s();
    };
    t.addEventListener("success", a), t.addEventListener("error", i);
  });
  return e.then((n) => {
    n instanceof IDBCursor && N3.set(n, t);
  }).catch(() => {
  }), bg.set(e, t), e;
}
function zQ(t) {
  if (vb.has(t))
    return;
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("complete", a), t.removeEventListener("error", i), t.removeEventListener("abort", i);
    }, a = () => {
      n(), s();
    }, i = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), s();
    };
    t.addEventListener("complete", a), t.addEventListener("error", i), t.addEventListener("abort", i);
  });
  vb.set(t, e);
}
let kb = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return vb.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || R3.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Zs(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function VQ(t) {
  kb = t(kb);
}
function jQ(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(Yh(this), e, ...n);
    return R3.set(r, e.sort ? e.sort() : [e]), Zs(r);
  } : _Q().includes(t) ? function(...e) {
    return t.apply(Yh(this), e), Zs(N3.get(this));
  } : function(...e) {
    return Zs(t.apply(Yh(this), e));
  };
}
function KQ(t) {
  return typeof t == "function" ? jQ(t) : (t instanceof IDBTransaction && zQ(t), HQ(t, $Q()) ? new Proxy(t, kb) : t);
}
function Zs(t) {
  if (t instanceof IDBRequest)
    return GQ(t);
  if (Xh.has(t))
    return Xh.get(t);
  const e = KQ(t);
  return e !== t && (Xh.set(t, e), bg.set(e, t)), e;
}
const Yh = (t) => bg.get(t);
function qQ(t, e, { blocked: n, upgrade: r, blocking: s, terminated: a } = {}) {
  const i = indexedDB.open(t, e), o = Zs(i);
  return r && i.addEventListener("upgradeneeded", (c) => {
    r(Zs(i.result), c.oldVersion, c.newVersion, Zs(i.transaction), c);
  }), n && i.addEventListener("blocked", (c) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    c.oldVersion,
    c.newVersion,
    c
  )), o.then((c) => {
    a && c.addEventListener("close", () => a()), s && c.addEventListener("versionchange", (u) => s(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), o;
}
const WQ = ["get", "getKey", "getAll", "getAllKeys", "count"], QQ = ["put", "add", "delete", "clear"], em = /* @__PURE__ */ new Map();
function TE(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (em.get(e))
    return em.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, s = QQ.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(s || WQ.includes(n))
  )
    return;
  const a = async function(i, ...o) {
    const c = this.transaction(i, s ? "readwrite" : "readonly");
    let u = c.store;
    return r && (u = u.index(o.shift())), (await Promise.all([
      u[n](...o),
      s && c.done
    ]))[0];
  };
  return em.set(e, a), a;
}
VQ((t) => ({
  ...t,
  get: (e, n, r) => TE(e, n) || t.get(e, n, r),
  has: (e, n) => !!TE(e, n) || t.has(e, n)
}));
function Pr() {
  return Pr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Pr.apply(null, arguments);
}
const JQ = ["function execute((bool delegateCall, bool revertOnError, uint256 gasLimit, address target, uint256 value, bytes data)[] calldata transactions, uint256 nonce, bytes calldata signature)"], fi = {
  namespace: "Sequence-Sessions",
  owners: ["AZ6R2mG8zxW9q7--iZXGrBknjegHoPzmG5IG-nxvMaM"],
  arweaveUrl: "https://arweave.net",
  graphqlUrl: "https://arweave.net/graphql",
  eip5719Provider: void 0,
  rateLimitRetryDelayMs: 5 * 60 * 1e3
};
class ZQ {
  constructor(e = fi) {
    this.options = e, this.configs = /* @__PURE__ */ new Map(), this.eip5719 = void 0, e.eip5719Provider && (this.eip5719 = new I3(e.eip5719Provider));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = ue(e.wallet), s = await this.configOfImageHash({
      imageHash: e.fromImageHash
    });
    if (!s)
      throw new Error(`unable to find from config ${e.fromImageHash}`);
    if (!de.config.isWalletConfig(s))
      throw new Error(`from config ${e.fromImageHash} is not v2`);
    const a = BigInt(s.checkpoint), i = Object.entries(await Jc({
      Type: "config update",
      Wallet: r
    }, this.options)).flatMap(([l, d]) => {
      try {
        const {
          Signer: f,
          Subdigest: h,
          Digest: y,
          "To-Config": b
        } = d;
        let g;
        switch (d["Signature-Type"]) {
          case "eip-712":
          case "eth_sign":
          case "erc-1271":
            g = d["Signature-Type"];
            break;
          default:
            throw new Error(`unknown signature type ${d["Signature-Type"]}`);
        }
        let w;
        try {
          w = BigInt(d["To-Checkpoint"]);
        } catch {
          throw new Error(`to checkpoint is not a number: ${d["To-Checkpoint"]}`);
        }
        if (w <= a)
          return [];
        if (!$1(f))
          throw new Error(`signer is not an address: ${f}`);
        if (!Ue(h, 32))
          throw new Error(`subdigest is not a hash: ${h}`);
        if (!Ue(y, 32))
          throw new Error(`digest is not a hash: ${y}`);
        let v;
        try {
          v = BigInt(d["Chain-ID"]);
        } catch {
          throw new Error(`chain id is not a number: ${d["Chain-ID"]}`);
        }
        if (!Ue(b, 32))
          throw new Error(`to config is not a hash: ${b}`);
        return [{
          id: l,
          signatureType: g,
          signer: f,
          subdigest: h,
          digest: y,
          chainId: v,
          toImageHash: b,
          toCheckpoint: w
        }];
      } catch (f) {
        return console.warn(`invalid wallet ${r} config update ${l}:`, f), [];
      }
    }), o = /* @__PURE__ */ new Map();
    let c = [];
    for (const l of i) {
      let d = o.get(l.toImageHash);
      d || (d = /* @__PURE__ */ new Map(), o.set(l.toImageHash, d), c.push(l)), d.set(l.signer, l);
    }
    e.longestPath ? c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? -1 : 1) : c.sort(({
      toCheckpoint: l
    }, {
      toCheckpoint: d
    }) => l === d ? 0 : l < d ? 1 : -1);
    const u = [];
    for (let l = s; c.length; ) {
      const d = de.config.imageHash(l);
      let f, h, y = [];
      for (const g of c) {
        h = o.get(g.toImageHash), y = Array.from(h.keys());
        const {
          weight: w
        } = de.signature.encodeSigners(l, new Map(y.map((v) => [v, {
          signature: "0x",
          isDynamic: !1
        }])), [], 0);
        if (w >= BigInt(l.threshold)) {
          f = g;
          break;
        }
      }
      if (!f) {
        console.warn(`unreachable configs with checkpoint > ${l.checkpoint} from config ${d}`);
        break;
      }
      const b = f.toImageHash;
      try {
        const g = await this.configOfImageHash({
          imageHash: b
        });
        if (!g)
          throw new Error(`unable to find config ${b}`);
        if (!de.config.isWalletConfig(g))
          throw new Error(`config ${b} is not v2`);
        const w = new Map((await Promise.all(y.map(async function(P) {
          const {
            id: x,
            subdigest: O,
            signatureType: I
          } = h.get(P);
          try {
            let T = await (await Ad(x, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).text();
            switch (I) {
              case "eip-712":
                T += "01";
                break;
              case "eth_sign":
                T += "02";
                break;
              case "erc-1271":
                T += "03";
                break;
            }
            if (n.eip5719)
              try {
                T = V(await n.eip5719.runByEIP5719(P, O, T));
              } catch {
                console.warn(`unable to run eip-5719 on config update ${x}`);
              }
            const C = re.signer.tryRecoverSigner(O, T);
            return [[P, {
              signature: T,
              isDynamic: C !== P
            }]];
          } catch (T) {
            return console.warn(`unable to fetch signer ${P} config update ${x}:`, T), [];
          }
        }))).flat()), {
          encoded: v,
          weight: A
        } = de.signature.encodeSigners(l, w, [], 0);
        if (A < BigInt(l.threshold))
          throw new Error(`insufficient signing power ${A.toString()} < ${l.threshold}`);
        u.push({
          wallet: r,
          signature: v,
          nextImageHash: b
        }), l = g, c = c.filter(({
          toCheckpoint: P
        }) => P > BigInt(l.checkpoint));
      } catch (g) {
        console.warn(`unable to reconstruct wallet ${r} update from config ${d} to config ${b}:`, g), c = c.filter(({
          toImageHash: w
        }) => w !== b);
      }
    }
    return u;
  }
  savePresignedConfiguration(e) {
    throw new Error("arweave backend does not support saving config updates");
  }
  saveWitnesses(e) {
    throw new Error("arweave backend does not support saving signatures");
  }
  async configOfImageHash(e) {
    var n = this;
    if (!e.noCache) {
      const s = this.configs.get(e.imageHash);
      if (s)
        try {
          return await s;
        } catch {
          const i = this.configs.get(e.imageHash);
          if (i)
            return i;
        }
    }
    const r = async function(s) {
      const a = Object.entries(await Jc({
        Type: "config",
        Config: s
      }, n.options)).flatMap(([i, o]) => {
        try {
          const c = Number(o.Version);
          if (!c)
            throw new Error(`invalid version: ${o.Version}`);
          return [{
            id: i,
            version: c
          }];
        } catch (c) {
          return console.warn(`config ${s} at ${i} invalid:`, c), [];
        }
      });
      switch (a.length) {
        case 0:
          n.configs.set(s, Promise.resolve(void 0));
          return;
        case 1:
          break;
        default:
          console.warn(`multiple configs ${s} at ${a.map(({
            id: i
          }) => i).join(", ")}`);
          break;
      }
      for (const {
        id: i,
        version: o
      } of a)
        try {
          const c = Pr({}, await (await Ad(i, n.options.rateLimitRetryDelayMs, n.options.arweaveUrl)).json(), {
            version: o
          });
          c.tree && (c.tree = Hi(c.tree));
          const u = Ht.coderFor(o).config.imageHashOf(c);
          if (u !== s)
            throw new Error(`image hash is ${u}, expected ${s}`);
          return n.configs.set(s, Promise.resolve(c)), c;
        } catch (c) {
          console.warn(`config at ${i} invalid:`, c);
        }
      n.configs.set(s, Promise.resolve(void 0));
    }(e.imageHash);
    return e.noCache || this.configs.set(e.imageHash, r), r;
  }
  saveWalletConfig(e) {
    throw new Error("arweave backend does not support saving configs");
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = ue(e.wallet), r = Object.entries(await Jc({
      Type: "wallet",
      Wallet: n
    }, this.options)).flatMap(([s, a]) => {
      try {
        const {
          "Deploy-Config": i
        } = a, o = Number(a["Deploy-Version"]);
        if (!o)
          throw new Error(`invalid version: ${a["Deploy-Version"]}`);
        if (!i)
          throw new Error("no deploy config");
        const c = re.context.defaultContexts[o];
        if (!c)
          throw new Error(`unknown version: ${o}`);
        if (re.context.addressOf(c, i) !== n)
          throw new Error(`incorrect v${o} deploy config: ${i}`);
        return [{
          id: s,
          imageHash: i,
          context: c
        }];
      } catch (i) {
        return console.warn(`wallet ${n} at ${s} invalid:`, i), [];
      }
    });
    switch (r.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple deploy configs for wallet ${n} at ${r.map(({
          id: s
        }) => s).join(", ")}, using first`);
        break;
    }
    return r[0];
  }
  saveCounterfactualWallet(e) {
    throw new Error("arweave backend does not support saving wallets");
  }
  async walletsOfSigner(e) {
    var n = this;
    const r = ue(e.signer), s = /* @__PURE__ */ new Map();
    for (const [a, i] of Object.entries(await Jc({
      Type: ["signature", "config update"],
      Signer: r,
      Witness: e.allSignatures ? void 0 : "true"
    }, this.options))) {
      const {
        Wallet: o,
        Subdigest: c,
        Digest: u,
        "Chain-ID": l
      } = i;
      try {
        if (s.has(o))
          continue;
        let d;
        switch (i["Signature-Type"]) {
          case "eip-712":
            d = "01";
            break;
          case "eth_sign":
            d = "02";
            break;
          case "erc-1271":
            d = "03";
            break;
          default:
            throw new Error(`unknown signature type ${i["Signature-Type"]}`);
        }
        if (c !== re.signature.subdigestOf({
          digest: u,
          chainId: l,
          address: o
        }))
          throw new Error("incorrect subdigest");
        const f = Ad(a, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then(async function(h) {
          const y = await h.text() + d;
          if (n.eip5719)
            try {
              return V(await n.eip5719.runByEIP5719(r, c, y));
            } catch {
              console.warn(`unable to run eip-5719 on signature ${a}`);
            }
          return y;
        });
        s.set(o, {
          digest: u,
          chainId: BigInt(l),
          signature: f
        });
      } catch (d) {
        console.warn(`signer ${r} signature ${a} of wallet ${o} invalid:`, d);
      }
    }
    return Promise.all([...s.entries()].map(async function([a, {
      digest: i,
      chainId: o,
      signature: c
    }]) {
      return {
        wallet: a,
        proof: {
          digest: i,
          chainId: o,
          signature: await c
        }
      };
    }));
  }
  async getMigration(e, n, r, s) {
    const a = ue(e), i = Object.entries(await Jc({
      Type: "migration",
      Migration: a,
      "Chain-ID": BigInt(s).toString(),
      "From-Version": `${r}`,
      "From-Config": n
    }, this.options)).flatMap(([A, P]) => {
      try {
        const {
          "To-Config": x,
          Executor: O
        } = P, I = Number(P["To-Version"]);
        if (!I)
          throw new Error(`invalid version: ${P["To-Version"]}`);
        if (!Ue(x, 32))
          throw new Error(`to config is not a hash: ${x}`);
        if (!$1(O))
          throw new Error(`executor is not an address: ${O}`);
        return {
          id: A,
          toVersion: I,
          toImageHash: x,
          executor: O
        };
      } catch (x) {
        return console.warn(`chain ${s} migration ${A} for v${r} wallet ${a} from config ${n} invalid:`, x), [];
      }
    });
    switch (i.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple chain ${s} migrations for v${r} wallet ${a} from config ${n} at ${i.map(({
          id: A
        }) => A).join(", ")}, using first`);
        break;
    }
    const {
      id: o,
      toVersion: c,
      toImageHash: u,
      executor: l
    } = i[0], [d, f] = await Promise.all([Ad(o, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then((A) => A.text()), this.configOfImageHash({
      imageHash: u
    })]);
    if (!f)
      throw new Error(`unable to find to config ${u} for migration`);
    const h = new Bt(JQ), [y, b, g] = h.decodeFunctionData("execute", d), w = re.transaction.fromTxAbiEncode(y), v = re.transaction.subdigestOfTransactions(a, s, b, w);
    return {
      tx: {
        entrypoint: l,
        transactions: w,
        nonce: b,
        chainId: s,
        intent: {
          id: v,
          wallet: a
        },
        signature: g
      },
      fromVersion: r,
      toVersion: Number(c),
      toConfig: f
    };
  }
  saveMigration(e, n, r) {
    throw new Error("arweave backend does not support saving migrations");
  }
}
async function Jc(t, e) {
  var n, r, s, a;
  const i = (n = e == null ? void 0 : e.namespace) != null ? n : fi.namespace, o = e == null ? void 0 : e.owners, c = (r = e == null ? void 0 : e.graphqlUrl) != null ? r : fi.graphqlUrl, u = (s = e == null ? void 0 : e.rateLimitRetryDelayMs) != null ? s : fi.rateLimitRetryDelayMs, l = (a = e == null ? void 0 : e.pageSize) != null ? a : 100, d = e == null ? void 0 : e.maxResults, f = Object.entries(t).flatMap(([y, b]) => b === void 0 ? [] : [`{ name: "${i ? `${i}-${y}` : y}", values: [${typeof b == "string" ? `"${b}"` : b.map((g) => `"${g}"`).join(", ")}] }`]), h = [];
  for (let y = !0; y && (d === void 0 || h.length < d); ) {
    const b = `
      query {
        transactions(sort: HEIGHT_DESC, ${h.length ? `first: ${l}, after: "${h[h.length - 1].cursor}"` : `first: ${l}`}, tags: [${f.join(", ")}]${o === void 0 ? "" : `, owners: [${o.map((v) => `"${v}"`).join(", ")}]`}) {
          pageInfo {
            hasNextPage
          }
          edges {
            cursor
            node {
              id
              tags {
                name
                value
              }
            }
          }
        }
      }
    `;
    let g;
    for (; g = await fetch(c, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: b
      }),
      redirect: "follow"
    }), g.status === 429; )
      console.warn(`rate limited by ${c}, trying again in ${u / 1e3} seconds at ${new Date(Date.now() + u).toLocaleTimeString()}`), await new Promise((v) => setTimeout(v, u));
    const {
      data: {
        transactions: w
      }
    } = await g.json();
    h.push(...w.edges), y = w.pageInfo.hasNextPage;
  }
  return Object.fromEntries(h.map(({
    node: {
      id: y,
      tags: b
    }
  }) => [y, Object.fromEntries(b.map(({
    name: g,
    value: w
  }) => [i && g.startsWith(`${i}-`) ? g.slice(i.length + 1) : g, w]))]));
}
async function Ad(t, e = fi.rateLimitRetryDelayMs, n = fi.arweaveUrl) {
  for (; ; ) {
    const r = await fetch(`${n}/${t}`, {
      redirect: "follow"
    });
    if (r.status !== 429)
      return r;
    console.warn(`rate limited by ${n}, trying again in ${e / 1e3} seconds at ${new Date(Date.now() + e).toLocaleTimeString()}`), await new Promise((s) => setTimeout(s, e));
  }
}
function Hi(t) {
  return typeof t == "string" ? {
    nodeHash: t
  } : typeof t == "object" && (t == null ? void 0 : t.node) !== void 0 ? {
    nodeHash: t.node
  } : t instanceof Array && t.length === 2 ? {
    left: Hi(t[0]),
    right: Hi(t[1])
  } : de.config.isNode(t) ? {
    left: Hi(t.left),
    right: Hi(t.right)
  } : de.config.isNestedLeaf(t) ? Pr({}, t, {
    tree: Hi(t.tree)
  }) : t;
}
var XQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaults: fi,
  ArweaveReader: ZQ
});
class YQ {
  constructor(e) {
    this.tracker = e;
  }
  async loadPresignedConfiguration(e) {
    return console.debug("? loadPresignedConfiguration"), Nt(e, "? "), Nt(await this.tracker.loadPresignedConfiguration(e), "! ");
  }
  savePresignedConfiguration(e) {
    return console.debug("? savePresignedConfiguration"), Nt(e, "? "), this.tracker.savePresignedConfiguration(e);
  }
  saveWitnesses(e) {
    return console.debug("? saveWitnesses"), Nt(e, "? "), this.tracker.saveWitnesses(e);
  }
  async configOfImageHash(e) {
    return console.debug("? configOfImageHash"), Nt(e, "? "), Nt(await this.tracker.configOfImageHash(e), "! ");
  }
  saveWalletConfig(e) {
    return console.debug("? saveWalletConfig"), Nt(e, "? "), this.tracker.saveWalletConfig(e);
  }
  async imageHashOfCounterfactualWallet(e) {
    return console.debug("? imageHashOfCounterfactualWallet"), Nt(e, "? "), Nt(await this.tracker.imageHashOfCounterfactualWallet(e), "! ");
  }
  saveCounterfactualWallet(e) {
    return console.debug("? saveCounterfactualWallet"), Nt(e, "? "), this.tracker.saveCounterfactualWallet(e);
  }
  async walletsOfSigner(e) {
    return console.debug("? walletsOfSigner"), Nt(e, "? "), Nt(await this.tracker.walletsOfSigner(e), "! ");
  }
  async getMigration(e, n, r, s) {
    return console.debug("? getMigration"), Nt({
      address: e,
      fromImageHash: n,
      fromVersion: r,
      chainId: s
    }, "? "), Nt(await this.tracker.getMigration(e, n, r, s), "! ");
  }
  saveMigration(e, n, r) {
    return console.debug("? saveMigration"), Nt({
      address: e,
      signed: n,
      contexts: r
    }, "? "), this.tracker.saveMigration(e, n, r);
  }
}
function Nt(t, e = "") {
  switch (t) {
    case void 0:
      console.debug(e + "undefined");
      break;
    default:
      JSON.stringify(t, al, 2).split(`
`).map((n) => e + n).forEach((n) => console.debug(n));
      break;
  }
  return t;
}
var eJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DebugConfigTracker: YQ
});
class F3 {
  constructor() {
    this.configs = {}, this.v2Nodes = {}, this.counterfactualWallets = {}, this.payloads = {}, this.signatures = {}, this.migrations = {}, this.loadConfig = (e) => Promise.resolve(this.configs[e]), this.saveConfig = (e, n) => (this.configs[e] = n, Promise.resolve()), this.loadV2Node = (e) => Promise.resolve(this.v2Nodes[e]), this.saveV2Node = (e, n) => (this.v2Nodes[e] = n, Promise.resolve()), this.loadCounterfactualWallet = (e) => Promise.resolve(this.counterfactualWallets[e]), this.saveCounterfactualWallet = (e, n, r) => (this.counterfactualWallets[e] = {
      imageHash: n,
      context: r
    }, Promise.resolve()), this.loadPayloadOfSubdigest = (e) => Promise.resolve(this.payloads[e]), this.savePayloadOfSubdigest = (e, n) => (this.payloads[e] = n, Promise.resolve()), this.loadSubdigestsOfSigner = (e) => Promise.resolve(Object.keys(this.signatures[e] || {})), this.loadSignatureOfSubdigest = (e, n) => {
      var r;
      return Promise.resolve((r = this.signatures[e]) == null ? void 0 : r[n]);
    }, this.saveSignatureOfSubdigest = (e, n, r) => (this.signatures[e] || (this.signatures[e] = {}), this.signatures[e][n] = r, Promise.resolve()), this.loadMigrationsSubdigest = (e, n, r) => {
      var s;
      return Promise.resolve(((s = this.migrations[e]) == null || (s = s[n]) == null ? void 0 : s[r]) || []);
    }, this.saveMigrationsSubdigest = (e, n, r, s, a) => (this.migrations[e] || (this.migrations[e] = {}), this.migrations[e][n] || (this.migrations[e][n] = {}), this.migrations[e][n][r] || (this.migrations[e][n][r] = []), this.migrations[e][n][r].push({
      subdigest: s,
      toImageHash: a
    }), Promise.resolve());
  }
}
function so(t) {
  if (t === void 0) return;
  const e = {};
  for (const n of Object.keys(t)) {
    const r = t[n];
    r._isBigNumber === !0 && r._hex !== void 0 && typeof r._hex == "string" && r._hex.length !== "" ? e[n] = BigInt(r._hex) : Array.isArray(r) ? e[n] = r.map((s) => so(s)) : typeof r == "object" && r !== null ? e[n] = so(r) : e[n] = r;
  }
  return e;
}
class tJ {
  constructor(e) {
    var n = this;
    this.dbName = e, this._lazyDb = void 0, this.loadConfig = async function(r) {
      return (await n.getDb()).get("configs", r).then((a) => so(a));
    }, this.saveConfig = async function(r, s) {
      await (await n.getDb()).put("configs", s, r);
    }, this.loadV2Node = async function(r) {
      return (await n.getDb()).get("v2Nodes", r).then((a) => so(a));
    }, this.saveV2Node = async function(r, s) {
      await (await n.getDb()).put("v2Nodes", s, r);
    }, this.loadCounterfactualWallet = async function(r) {
      return (await n.getDb()).get("counterfactualWallets", r);
    }, this.saveCounterfactualWallet = async function(r, s, a) {
      await (await n.getDb()).put("counterfactualWallets", {
        imageHash: s,
        context: a
      }, r);
    }, this.loadPayloadOfSubdigest = async function(r) {
      return (await n.getDb()).get("payloads", r).then((a) => so(a));
    }, this.savePayloadOfSubdigest = async function(r, s) {
      await (await n.getDb()).put("payloads", s, r);
    }, this.loadSubdigestsOfSigner = async function(r) {
      return (await (await n.getDb()).getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(r))).map((i) => i.split("-")[0]);
    }, this.loadSignatureOfSubdigest = async function(r, s) {
      const i = await (await n.getDb()).get("signatures", [s, r].join("-"));
      return i == null ? void 0 : i.signature;
    }, this.saveSignatureOfSubdigest = async function(r, s, a) {
      await (await n.getDb()).put("signatures", {
        signature: a,
        signer: r
      }, [s, r].join("-"));
    }, this.loadMigrationsSubdigest = async function(r, s, a) {
      return (await (await n.getDb()).getAllFromIndex("migrations", "jump", IDBKeyRange.only([r, s, a]))).map((c) => ({
        subdigest: c.subdigest,
        toImageHash: c.toImageHash
      }));
    }, this.saveMigrationsSubdigest = async function(r, s, a, i, o) {
      await (await n.getDb()).put("migrations", {
        wallet: r,
        fromVersion: s,
        toVersion: a,
        subdigest: i,
        toImageHash: o
      }, i);
    };
  }
  async getDb() {
    if (this._lazyDb) return this._lazyDb;
    const e = this.dbName;
    return this._lazyDb = await qQ(e, 1, {
      upgrade(n, r, s, a) {
        console.log(`upgrading ${e} from ${r} to ${s} - ${a}`), r === 0 && (n.createObjectStore("configs"), n.createObjectStore("v2Nodes"), n.createObjectStore("counterfactualWallets"), n.createObjectStore("payloads"), n.createObjectStore("signatures").createIndex("signer", "signer", {
          unique: !1
        }), n.createObjectStore("migrations").createIndex("jump", ["wallet", "fromVersion", "toVersion"]));
      }
    }), this._lazyDb;
  }
}
function M3(t) {
  return t.left !== void 0 && t.right !== void 0;
}
function D3(t) {
  return t.weight !== void 0 && t.threshold !== void 0 && t.tree !== void 0;
}
function Cb(t) {
  return t.version === 2 && t.threshold !== void 0 && t.checkpoint !== void 0 && t.tree !== void 0 && typeof t.tree == "string";
}
var nJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainNode: M3,
  isPlainNested: D3,
  isPlainV2Config: Cb,
  MemoryTrackerStore: F3,
  recreateBigNumbers: so,
  IndexedDBStore: tJ
});
class yg {
  constructor(e, n = new F3(), r = !1) {
    var s = this;
    this.provider = e, this.store = n, this.useEIP5719 = r, this.cachedEIP5719 = void 0, this.loadTopology = async function(a) {
      const i = await s.store.loadV2Node(a);
      if (!i) return {
        nodeHash: a
      };
      if (M3(i)) {
        const [o, c] = await Promise.all([s.loadTopology(i.left), s.loadTopology(i.right)]);
        return {
          left: o,
          right: c
        };
      }
      return D3(i) ? {
        weight: BigInt(i.weight),
        threshold: BigInt(i.threshold),
        tree: await s.loadTopology(i.tree)
      } : i;
    }, this.saveTopology = async function(a) {
      if (de.config.isNodeLeaf(a))
        return;
      const i = de.config.hashNode(a);
      if (de.config.isNode(a)) {
        const o = s.saveTopology(a.left), c = s.saveTopology(a.right), u = s.store.saveV2Node(i, {
          left: de.config.hashNode(a.left),
          right: de.config.hashNode(a.right)
        });
        await Promise.all([o, c, u]);
        return;
      }
      if (de.config.isNestedLeaf(a)) {
        const o = s.saveTopology(a.tree), c = s.store.saveV2Node(i, {
          weight: BigInt(a.weight).toString(),
          threshold: BigInt(a.threshold).toString(),
          tree: de.config.hashNode(a.tree)
        });
        await Promise.all([o, c]);
        return;
      }
      if (de.config.isSignerLeaf(a))
        return s.store.saveV2Node(i, {
          address: a.address,
          weight: a.weight
        });
      if (de.config.isSubdigestLeaf(a))
        return s.store.saveV2Node(i, {
          subdigest: a.subdigest
        });
      throw new Error(`Unknown topology type: ${a}`);
    }, this.saveWalletConfig = async function(a) {
      const {
        config: i
      } = a;
      if (ha.config.ConfigCoder.isWalletConfig(i)) {
        const o = ha.config.ConfigCoder.imageHashOf(i);
        return s.store.saveConfig(o, i);
      }
      if (de.config.ConfigCoder.isWalletConfig(i)) {
        const o = de.config.ConfigCoder.imageHashOf(i);
        if (de.config.isComplete(i.tree))
          return s.store.saveConfig(o, i);
      }
    }, this.configOfImageHashCache = {}, this.configOfImageHash = async function(a) {
      const {
        imageHash: i
      } = a;
      if (s.configOfImageHashCache[a.imageHash])
        return s.configOfImageHashCache[a.imageHash];
      const o = await s.store.loadConfig(i);
      if (o) {
        if (o.version === 1 || o.version === 2 && !Cb(o))
          return s.configOfImageHashCache[a.imageHash] = o, o;
        if (Cb(o)) {
          const c = {
            version: 2,
            threshold: BigInt(o.threshold),
            checkpoint: BigInt(o.checkpoint),
            tree: await s.loadTopology(o.tree)
          };
          return s.configOfImageHashCache[a.imageHash] = c, c;
        }
        throw new Error(`Unknown config type: ${o}`);
      }
    }, this.saveCounterfactualWallet = async function(a) {
      const {
        config: i,
        context: o
      } = a, c = Ht.genericCoderFor(i.version).config.imageHashOf(i);
      await Promise.all([s.saveWalletConfig({
        config: i
      }), ...o.map((u) => {
        const l = re.context.addressOf(u, c);
        return s.store.saveCounterfactualWallet(l, c, u);
      })]);
    }, this.imageHashOfCounterfactualWallet = async function(a) {
      const {
        wallet: i
      } = a, o = await s.store.loadCounterfactualWallet(i);
      if (o)
        return {
          imageHash: o.imageHash,
          context: o.context
        };
    }, this.savePayload = async function(a) {
      const {
        payload: i
      } = a, o = re.signature.subdigestOf(i);
      await s.store.savePayloadOfSubdigest(o, i);
    }, this.payloadOfSubdigestCache = {}, this.payloadOfSubdigest = async function(a) {
      if (s.payloadOfSubdigestCache[a.subdigest])
        return s.payloadOfSubdigestCache[a.subdigest];
      const {
        subdigest: i
      } = a, o = await s.store.loadPayloadOfSubdigest(i);
      return o && (s.payloadOfSubdigestCache[i] = o), o;
    }, this.savePresignedConfiguration = async function(a) {
      const i = de.signature.SignatureCoder.decode(a.signature), o = Ht.genericCoderFor(a.nextConfig.version).config.imageHashOf(a.nextConfig), c = de.chained.messageSetImageHash(o), u = xe(c), l = {
        message: c,
        address: a.wallet,
        chainId: 0,
        digest: u
      }, d = s.savePayload({
        payload: l
      }), f = s.saveWalletConfig({
        config: a.nextConfig
      }), h = await de.signature.SignatureCoder.recover(i, l, s.provider), y = de.signature.signaturesOf(h.config.tree);
      await Promise.all([d, f, s.saveWalletConfig({
        config: h.config
      }), ...y.map((b) => s.store.saveSignatureOfSubdigest(b.address, h.subdigest, b.signature))]);
    }, this.loadPresignedConfiguration = async function(a) {
      const {
        wallet: i,
        fromImageHash: o,
        longestPath: c
      } = a, u = await s.configOfImageHash({
        imageHash: o
      });
      if (!u || !de.config.ConfigCoder.isWalletConfig(u))
        return [];
      const l = de.config.signersOf(u.tree).map((A) => A.address), d = await Promise.all(l.map((A) => s.store.loadSubdigestsOfSigner(A))), f = [...new Set(d.flat())], y = (await Promise.all([...new Set(f)].map(async function(A) {
        return Pr({}, await s.payloadOfSubdigest({
          subdigest: A
        }), {
          subdigest: A
        });
      }))).filter((A) => (A == null ? void 0 : A.message) && (A == null ? void 0 : A.address) && A.address === i).map((A) => ({
        payload: A,
        nextImageHash: de.chained.decodeMessageSetImageHash(A.message)
      })).filter((A) => A == null ? void 0 : A.nextImageHash);
      let b;
      const w = (await Promise.all(y.map(async function({
        nextImageHash: A,
        payload: P
      }) {
        const x = await s.configOfImageHash({
          imageHash: A
        });
        if (!x || !de.config.isWalletConfig(x)) return;
        const O = BigInt(x.checkpoint);
        return {
          nextConfig: x,
          nextCheckpoint: O,
          nextImageHash: A,
          payload: P
        };
      }))).filter((A) => A !== void 0).filter((A) => A.nextCheckpoint > BigInt(u.checkpoint)).sort((A, P) => (
        // If we are looking for the longest path, sort by ascending checkpoint
        // because we want to find the smalles jump, and we should start with the
        // closest one. If we are not looking for the longest path, sort by
        // descending checkpoint, because we want to find the largest jump.
        //
        // We don't have a guarantee that all "next configs" will be valid
        // so worst case scenario we will need to try all of them.
        // But we can try to optimize for the most common case.
        A.nextCheckpoint > P.nextCheckpoint ? c ? 1 : -1 : c ? -1 : 1
      ));
      for (const A of w) {
        const {
          nextConfig: P,
          nextCheckpoint: x,
          nextImageHash: O,
          payload: I
        } = A;
        if (b) {
          const N = b.checkpoint;
          if (c) {
            if (x >= N) continue;
          } else if (x <= N) continue;
        }
        const T = new Map((await Promise.all(l.map(async function(N) {
          const U = await s.store.loadSignatureOfSubdigest(N, I.subdigest);
          if (!U)
            return [N, void 0];
          const L = V(s.useEIP5719 ? await s.cachedEIP5719.runByEIP5719(N, I.subdigest, U) : U), $ = re.signer.tryRecoverSigner(I.subdigest, L) !== N;
          return [N, {
            isDynamic: $,
            signature: L
          }];
        }))).filter((N) => !!N[1]));
        if (T.size === 0) continue;
        const C = de.signature.SignatureCoder.encodeSigners(u, T, [], 0);
        C.weight < BigInt(u.threshold) || (b = {
          nextImageHash: O,
          checkpoint: BigInt(P.checkpoint),
          signature: C.encoded
        });
      }
      if (!b)
        return [];
      const v = await s.loadPresignedConfiguration({
        wallet: i,
        fromImageHash: b.nextImageHash,
        longestPath: c
      });
      return [{
        wallet: i,
        nextImageHash: b.nextImageHash,
        signature: b.signature
      }, ...v];
    }, this.saveWitnesses = async function(a) {
      const i = {
        digest: a.digest,
        address: a.wallet,
        chainId: a.chainId
      }, o = re.signature.subdigestOf(i);
      await Promise.all([s.savePayload({
        payload: i
      }), ...a.signatures.filter((c) => re.signer.canRecover(c)).map((c) => {
        const u = re.signer.recoverSigner(o, c);
        return s.store.saveSignatureOfSubdigest(u, o, c);
      })]);
    }, this.walletsOfSigner = async function(a) {
      const i = await s.store.loadSubdigestsOfSigner(a.signer), o = await Promise.all(i.map((u) => s.payloadOfSubdigest({
        subdigest: u
      }))).then((u) => u.filter((l) => l !== void 0)), c = [];
      for (const u of o) {
        const l = u.address;
        if (c.find((h) => h.wallet === l)) continue;
        const d = re.signature.subdigestOf(u), f = await s.store.loadSignatureOfSubdigest(a.signer, d);
        f && c.push({
          wallet: l,
          proof: {
            digest: u.digest,
            chainId: BigInt(u.chainId),
            signature: V(f)
          }
        });
      }
      return c;
    }, this.cachedEIP5719 = new I3(e);
  }
  async saveMigration(e, n, r) {
    const s = n.fromVersion;
    if (s !== 1) throw new Error("Migration not supported");
    if (!de.config.isWalletConfig(n.toConfig)) throw new Error("Invalid to config");
    const {
      newImageHash: a,
      address: i
    } = cQ.v1v2.decodeTransaction(n.tx, r);
    if (i !== e) throw new Error("Invalid migration transaction - address");
    if (de.config.ConfigCoder.imageHashOf(n.toConfig) != a) throw new Error("Invalid migration transaction - config");
    const o = re.transaction.packMetaTransactionsData(n.tx.nonce, n.tx.transactions), c = xe(o), u = {
      chainId: n.tx.chainId,
      message: o,
      address: e,
      digest: c
    }, l = re.signature.subdigestOf(u), d = this.savePayload({
      payload: u
    }), f = this.saveWalletConfig({
      config: n.toConfig
    }), h = ha.signature.SignatureCoder.decode(n.tx.signature), y = await ha.signature.SignatureCoder.recover(h, u, this.provider), b = ha.signature.SignatureCoder.signaturesOf(y.config);
    await Promise.all([d, f, this.saveWalletConfig({
      config: y.config
    }), this.store.saveMigrationsSubdigest(e, s, s + 1, l, a), ...b.map((g) => this.store.saveSignatureOfSubdigest(g.address, y.subdigest, g.signature))]);
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const [i, o] = await Promise.all([this.configOfImageHash({
      imageHash: n
    }), this.store.loadMigrationsSubdigest(e, r, r + 1)]), c = Ht.coderFor(r);
    return !i || !c.config.isWalletConfig(i) ? void 0 : (await Promise.all(o.map(async function(l) {
      const {
        subdigest: d,
        toImageHash: f
      } = l, h = await a.payloadOfSubdigest({
        subdigest: d
      });
      if (!h || !h.message || BigInt(s) !== BigInt(h.chainId)) return;
      const y = c.config.signersOf(i).map((A) => A.address), b = new Map((await Promise.all(y.map(async function(A) {
        const P = await a.store.loadSignatureOfSubdigest(A, d);
        if (!P)
          return [A, void 0];
        const x = V(a.useEIP5719 ? await a.cachedEIP5719.runByEIP5719(A, d, P) : P), O = re.signer.tryRecoverSigner(d, x) !== A;
        return [A, {
          isDynamic: O,
          signature: x
        }];
      }))).filter((A) => !!A[1])), g = c.signature.encodeSigners(i, b, [], s);
      if (!g || g.weight < BigInt(i.threshold)) return;
      const [w, v] = re.transaction.unpackMetaTransactionsData(h.message);
      return {
        tx: {
          entrypoint: e,
          transactions: re.transaction.fromTxAbiEncode(v),
          chainId: s,
          nonce: w,
          signature: g.encoded,
          intent: {
            id: d,
            wallet: e
          }
        },
        toConfig: await a.configOfImageHash({
          imageHash: f
        }),
        fromVersion: r,
        toVersion: r + 1
      };
    })).then((l) => l.filter((d) => d !== void 0)))[0];
  }
  updateProvider(e) {
    this.provider = e;
  }
}
var rJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LocalConfigTracker: yg
});
const sJ = "Webrpc", aJ = "webrpc@v0.22.1;gen-typescript@v0.16.2;sessions@v0.0.1";
let tm = /* @__PURE__ */ function(t) {
  return t.EIP712 = "EIP712", t.EthSign = "EthSign", t.EIP1271 = "EIP1271", t;
}({});
class iJ {
  constructor(e, n) {
    this.hostname = void 0, this.fetch = void 0, this.path = "/rpc/Sessions/", this.ping = (r, s) => this.fetch(this.url("Ping"), gn({}, r, s)).then((a) => wn(a).then((i) => ({})), (a) => {
      throw Rt.new({
        cause: `fetch(): ${a.message || ""}`
      });
    }), this.config = (r, s, a) => this.fetch(this.url("Config"), gn(r, s, a)).then((i) => wn(i).then((o) => ({
      version: o.version,
      config: o.config
    })), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.wallets = (r, s, a) => this.fetch(this.url("Wallets"), gn(r, s, a)).then((i) => wn(i).then((o) => ({
      wallets: o.wallets,
      cursor: o.cursor
    })), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.deployHash = (r, s, a) => this.fetch(this.url("DeployHash"), gn(r, s, a)).then((i) => wn(i).then((o) => ({
      deployHash: o.deployHash,
      context: o.context
    })), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.configUpdates = (r, s, a) => this.fetch(this.url("ConfigUpdates"), gn(r, s, a)).then((i) => wn(i).then((o) => ({
      updates: o.updates
    })), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.migrations = (r, s, a) => this.fetch(this.url("Migrations"), gn(r, s, a)).then((i) => wn(i).then((o) => ({
      migrations: o.migrations
    })), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveConfig = (r, s, a) => this.fetch(this.url("SaveConfig"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveWallet = (r, s, a) => this.fetch(this.url("SaveWallet"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignature = (r, s, a) => this.fetch(this.url("SaveSignature"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures = (r, s, a) => this.fetch(this.url("SaveSignerSignatures"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveSignerSignatures2 = (r, s, a) => this.fetch(this.url("SaveSignerSignatures2"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.saveMigration = (r, s, a) => this.fetch(this.url("SaveMigration"), gn(r, s, a)).then((i) => wn(i).then((o) => ({})), (i) => {
      throw Rt.new({
        cause: `fetch(): ${i.message || ""}`
      });
    }), this.hostname = e.replace(/\/*$/, ""), this.fetch = (r, s) => n(r, s);
  }
  url(e) {
    return this.hostname + this.path + e;
  }
}
const gn = (t = {}, e = {}, n = null) => {
  const r = Pr({}, e, {
    "Content-Type": "application/json"
  });
  return r[sJ] = aJ, {
    method: "POST",
    headers: r,
    body: JSON.stringify(t || {}),
    signal: n
  };
}, wn = (t) => t.text().then((e) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    let s = "";
    throw r instanceof Error && (s = r.message), ih.new({
      status: t.status,
      cause: `JSON.parse(): ${s}: response text: ${e}`
    });
  }
  if (!t.ok) {
    const r = typeof n.code == "number" ? n.code : 0;
    throw (oJ[r] || Ut).new(n);
  }
  return n;
});
class Ut extends Error {
  constructor(e, n, r, s, a) {
    super(r), this.name = void 0, this.code = void 0, this.message = void 0, this.status = void 0, this.cause = void 0, this.msg = void 0, this.name = e || "WebrpcError", this.code = typeof n == "number" ? n : 0, this.message = r || `endpoint error ${this.code}`, this.msg = this.message, this.status = typeof s == "number" ? s : 0, this.cause = a, Object.setPrototypeOf(this, Ut.prototype);
  }
  static new(e) {
    return new this(e.error, e.code, e.message || e.msg, e.status, e.cause);
  }
}
class gg extends Ut {
  constructor(e = "WebrpcEndpoint", n = 0, r = "endpoint error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, gg.prototype);
  }
}
class Rt extends Ut {
  constructor(e = "WebrpcRequestFailed", n = -1, r = "request failed", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Rt.prototype);
  }
}
class wg extends Ut {
  constructor(e = "WebrpcBadRoute", n = -2, r = "bad route", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, wg.prototype);
  }
}
class Eg extends Ut {
  constructor(e = "WebrpcBadMethod", n = -3, r = "bad method", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Eg.prototype);
  }
}
class xg extends Ut {
  constructor(e = "WebrpcBadRequest", n = -4, r = "bad request", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, xg.prototype);
  }
}
class ih extends Ut {
  constructor(e = "WebrpcBadResponse", n = -5, r = "bad response", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, ih.prototype);
  }
}
class Ag extends Ut {
  constructor(e = "WebrpcServerPanic", n = -6, r = "server panic", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Ag.prototype);
  }
}
class vg extends Ut {
  constructor(e = "WebrpcInternalError", n = -7, r = "internal error", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, vg.prototype);
  }
}
class kg extends Ut {
  constructor(e = "WebrpcClientDisconnected", n = -8, r = "client disconnected", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, kg.prototype);
  }
}
class Cg extends Ut {
  constructor(e = "WebrpcStreamLost", n = -9, r = "stream lost", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Cg.prototype);
  }
}
class Tg extends Ut {
  constructor(e = "WebrpcStreamFinished", n = -10, r = "stream finished", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Tg.prototype);
  }
}
class Sg extends Ut {
  constructor(e = "InvalidArgument", n = 1, r = "invalid argument", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Sg.prototype);
  }
}
class Og extends Ut {
  constructor(e = "NotFound", n = 2, r = "not found", s = 0, a) {
    super(e, n, r, s, a), Object.setPrototypeOf(this, Og.prototype);
  }
}
const oJ = {
  0: gg,
  [-1]: Rt,
  [-2]: wg,
  [-3]: Eg,
  [-4]: xg,
  [-5]: ih,
  [-6]: Ag,
  [-7]: vg,
  [-8]: kg,
  [-9]: Cg,
  [-10]: Tg,
  1: Sg,
  2: Og
};
class cJ {
  constructor(e, n = !0) {
    this.onlyRecoverable = n, this.sessions = void 0, this.sessions = new iJ(e, fetch);
  }
  async loadPresignedConfiguration(e) {
    try {
      const {
        updates: n
      } = await this.sessions.configUpdates({
        wallet: e.wallet,
        fromImageHash: e.fromImageHash,
        allUpdates: e.longestPath
      });
      return n.map(({
        toImageHash: r,
        signature: s
      }) => ({
        wallet: e.wallet,
        nextImageHash: r,
        signature: s
      }));
    } catch (n) {
      if (nm(n))
        return [];
      throw n;
    }
  }
  async savePresignedConfiguration(e) {
    const n = e.nextConfig, r = Ht.genericCoderFor(n.version).config.imageHashOf(n), s = de.signature.setImageHashStruct(r), a = xe(s);
    await this.sessions.saveSignature({
      wallet: e.wallet,
      digest: a,
      chainID: "0",
      signature: e.signature,
      toConfig: vd(n),
      referenceChainID: e.referenceChainId !== void 0 ? BigInt(e.referenceChainId).toString() : void 0
    });
  }
  async saveWitnesses(e) {
    let n = e.signatures;
    this.onlyRecoverable && (n = n.filter((r) => re.signer.canRecover(r))), await this.sessions.saveSignerSignatures({
      wallet: e.wallet,
      digest: e.digest,
      chainID: Vi(e.chainId),
      signatures: n
    });
  }
  async configOfImageHash(e) {
    try {
      const {
        version: n,
        config: r
      } = await this.sessions.config(e);
      return lJ(n, r);
    } catch (n) {
      if (nm(n))
        return;
      throw n;
    }
  }
  async saveWalletConfig(e) {
    const n = vd(e.config);
    await this.sessions.saveConfig({
      version: e.config.version,
      config: n
    });
  }
  async imageHashOfCounterfactualWallet(e) {
    try {
      const {
        deployHash: n,
        context: r
      } = await this.sessions.deployHash(e);
      return {
        imageHash: n,
        context: r
      };
    } catch (n) {
      if (nm(n))
        return;
      throw n;
    }
  }
  async saveCounterfactualWallet(e) {
    const n = vd(e.config);
    await this.sessions.saveWallet({
      version: e.config.version,
      deployConfig: n
    });
  }
  async walletsOfSigner(e) {
    const {
      wallets: n
    } = await this.sessions.wallets(e);
    return Object.entries(n).map(([r, {
      digest: s,
      chainID: a,
      type: i,
      signature: o
    }]) => {
      switch (i) {
        case tm.EIP712:
          o += Zn(re.signer.SigType.EIP712).slice(2);
          break;
        case tm.EthSign:
          o += Zn(re.signer.SigType.ETH_SIGN).slice(2);
          break;
        case tm.EIP1271:
          o += Zn(re.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet: r,
        proof: {
          digest: s,
          signature: o,
          chainId: BigInt(a)
        }
      };
    });
  }
  async getMigration(e, n, r, s) {
    var a = this;
    const i = Vi(s), {
      migrations: o
    } = await this.sessions.migrations({
      wallet: e,
      fromVersion: r,
      fromImageHash: n,
      chainID: i
    }), c = async function(d) {
      const f = o[d];
      if (f) {
        const h = Object.keys(f).map(Number).sort((y, b) => b - y);
        for (const y of h)
          for (const [b, g] of Object.entries(f[y]))
            try {
              const w = await a.configOfImageHash({
                imageHash: b
              });
              if (w)
                return {
                  fromVersion: r,
                  toVersion: y,
                  toConfig: w,
                  tx: {
                    entrypoint: g.executor,
                    transactions: g.transactions,
                    nonce: g.nonce,
                    signature: g.signature,
                    chainId: d,
                    intent: {
                      id: re.transaction.subdigestOfTransactions(e, d, g.nonce, g.transactions),
                      wallet: e
                    }
                  }
                };
            } catch (w) {
              console.error(w);
            }
      }
    }, u = await c(i);
    if (u)
      return u;
    for (const l in o)
      if (l !== i) {
        const d = await c(l);
        if (d)
          return d;
      }
  }
  async saveMigration(e, n, r) {
    await this.sessions.saveMigration({
      wallet: e,
      fromVersion: n.fromVersion,
      toVersion: n.toVersion,
      toConfig: vd(n.toConfig),
      executor: n.tx.entrypoint,
      transactions: n.tx.transactions.map(uJ),
      nonce: Vi(n.tx.nonce),
      signature: n.tx.signature,
      chainID: Vi(n.tx.chainId)
    });
  }
}
function vd(t) {
  switch (t.version) {
    case 1:
      if (ha.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Sa(t.threshold),
          signers: t.signers.map(({
            weight: e,
            address: n
          }) => ({
            weight: Sa(e),
            address: n
          }))
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    case 2:
      if (de.config.ConfigCoder.isWalletConfig(t))
        return {
          threshold: Sa(t.threshold),
          checkpoint: Sa(t.checkpoint),
          tree: $d(t.tree)
        };
      throw new Error(`not a v${t.version} config: ${t}`);
    default:
      throw new Error(`unknown version ${t.version}`);
  }
}
function $d(t) {
  return de.config.isNode(t) ? {
    left: $d(t.left),
    right: $d(t.right)
  } : de.config.isSignerLeaf(t) ? {
    weight: Sa(t.weight),
    address: t.address
  } : de.config.isNestedLeaf(t) ? {
    weight: Sa(t.weight),
    threshold: Sa(t.threshold),
    tree: $d(t.tree)
  } : de.config.isNodeLeaf(t) ? {
    node: t.nodeHash
  } : Pr({}, t);
}
function lJ(t, e) {
  switch (t) {
    case 1:
      return Pr({}, e, {
        version: t
      });
    case 2:
      return Pr({}, e, {
        version: t,
        tree: _d(e.tree)
      });
    default:
      throw new Error(`unknown version ${t}`);
  }
}
function _d(t) {
  switch (typeof t) {
    case "object":
      const e = Pr({}, t);
      return e.left !== void 0 && (e.left = _d(e.left)), e.right !== void 0 && (e.right = _d(e.right)), e.tree !== void 0 && (e.tree = _d(e.tree)), e.node !== void 0 && (e.nodeHash = e.node, delete e.node), e;
    default:
      throw new Error(`v2 config tree ${t} is not an object`);
  }
}
function uJ(t) {
  return {
    to: t.to,
    value: t.value !== void 0 ? Vi(t.value) : void 0,
    data: t.data !== void 0 ? V(t.data) : void 0,
    gasLimit: t.gasLimit !== void 0 ? Vi(t.gasLimit) : void 0,
    delegateCall: t.delegateCall,
    revertOnError: t.revertOnError
  };
}
function Sa(t) {
  return Number(t);
}
function Vi(t) {
  return BigInt(t).toString();
}
function nm(t) {
  return typeof t == "object" && t.status === 404;
}
var dJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  RemoteConfigTracker: cJ
});
function Tb(t, e, n) {
  return new Promise((r) => {
    let s = 0;
    t.forEach((a) => a.then((i) => {
      n(i) ? r(i) : (s++, s === t.length && r(e));
    }).catch(() => {
      s++, s === t.length && r(e);
    }));
  });
}
async function cl(t, e) {
  return Promise.all(t.map((n) => n.catch(() => e)));
}
class fJ {
  constructor(e) {
    this.trackers = e;
  }
  async configOfImageHash(e) {
    const n = this.trackers.map(async function(o, c) {
      return {
        res: await o.configOfImageHash(e),
        i: c
      };
    }), r = await Tb(n, void 0, (o) => (o == null ? void 0 : o.res) === void 0 ? !1 : Ht.genericCoderFor(o.res.version).config.isComplete(o.res));
    if (r != null && r.res)
      return this.saveWalletConfig({
        config: r.res,
        skipTracker: r.i
      }), r.res;
    const s = new yg(void 0), a = await cl(n, void 0);
    for (const o of a)
      o != null && o.res && await s.saveWalletConfig({
        config: o.res
      });
    const i = await s.configOfImageHash(e);
    return i && this.saveWalletConfig({
      config: i
    }), i;
  }
  async saveWalletConfig(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveWalletConfig(e);
    }));
  }
  async imageHashOfCounterfactualWallet(e) {
    const n = await Tb(this.trackers.map((r) => r.imageHashOfCounterfactualWallet(e)), void 0, (r) => !!r);
    return n && this.configOfImageHash({
      imageHash: n.imageHash
    }).then((r) => {
      r && this.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }), n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all(this.trackers.map((n, r) => {
      if (r !== e.skipTracker)
        return n.saveCounterfactualWallet(e);
    }));
  }
  async walletsOfSigner(e) {
    const n = await cl(this.trackers.map((i) => i.walletsOfSigner(e)), []).then((i) => i.flat()), r = {};
    for (const i of n)
      r[i.wallet] = i.proof;
    const s = Object.keys(r).map((i) => ({
      wallet: i,
      proof: r[i]
    })), a = /* @__PURE__ */ new Map();
    return s.forEach(({
      wallet: i,
      proof: {
        digest: o,
        chainId: c,
        signature: u
      }
    }) => {
      const l = `${i}-${o}-${c}`;
      let d = a.get(l);
      d || (d = {
        wallet: i,
        digest: o,
        chainId: c,
        signatures: []
      }, a.set(l, d)), d.signatures.push(u);
    }), a.forEach((i) => this.saveWitnesses(i)), s;
  }
  async saveWitnesses(e) {
    await Promise.all(this.trackers.map((n) => n.saveWitnesses(e)));
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = await cl(this.trackers.map((c) => c.loadPresignedConfiguration(e)), []), a = (await cl(r.map(async function(c) {
      const u = c[c.length - 1], l = await n.configOfImageHash({
        imageHash: u.nextImageHash
      });
      if (l)
        return {
          checkpoint: Ht.genericCoderFor(l.version).config.checkpointOf(l),
          result: c
        };
    }), void 0)).reduce((c, u) => u && (!c || u.checkpoint > c.checkpoint) ? u : c);
    if (!a) return [];
    const i = /* @__PURE__ */ new Map(), o = (c) => (i.has(c) || i.set(c, this.configOfImageHash({
      imageHash: c
    })), i.get(c));
    return a.result.forEach(async function(c) {
      const u = await o(c.nextImageHash);
      u && n.savePresignedConfiguration({
        wallet: e.wallet,
        nextConfig: u,
        signature: c.signature
      });
    }), a.result;
  }
  async savePresignedConfiguration(e) {
    await Promise.all(this.trackers.map((n) => n.savePresignedConfiguration(e)));
  }
  async getMigration(e, n, r, s) {
    return (await Promise.all(this.trackers.map((i) => i.getMigration(e, n, r, s)))).find((i) => !!i);
  }
  async saveMigration(e, n, r) {
    await Promise.all(this.trackers.map((s) => s.saveMigration(e, n, r)));
  }
}
class pJ {
  constructor(e, n, r) {
    this.tracker = e, this.cache = n, this.contexts = r;
  }
  async loadPresignedConfiguration(e) {
    var n = this;
    const r = [this.tracker.loadPresignedConfiguration(e), this.cache.loadPresignedConfiguration(e)];
    let s;
    const [a, i] = await Promise.all(r);
    if (a.length > 0 && i.length > 0 && a[a.length - 1].nextImageHash === i[i.length - 1].nextImageHash)
      s = e.longestPath === !0 ? a.length > i.length ? a : i : a.length < i.length ? a : i;
    else {
      var o, c;
      s = (o = (c = (await Promise.all(r.map(async function(l) {
        const d = await l, f = d[d.length - 1];
        if (!f) return;
        const h = await n.configOfImageHash({
          imageHash: f.nextImageHash
        });
        if (h)
          return {
            checkpoint: Ht.genericCoderFor(h.version).config.checkpointOf(h),
            result: d
          };
      }))).reduce((l, d) => d && (!l || d.checkpoint > l.checkpoint) ? d : l)) == null ? void 0 : c.result) != null ? o : [];
    }
    return s || [];
  }
  async savePresignedConfiguration(e) {
    await Promise.all([this.tracker.savePresignedConfiguration(e), this.cache.savePresignedConfiguration(e)]);
  }
  async configOfImageHash(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.configOfImageHash(e);
      if (r) return r;
    }
    const n = await this.tracker.configOfImageHash(e);
    return n && await this.cache.saveWalletConfig({
      config: n
    }), n;
  }
  async saveWalletConfig(e) {
    await Promise.all([this.tracker.saveWalletConfig(e), this.cache.saveWalletConfig(e)]);
  }
  async imageHashOfCounterfactualWallet(e) {
    if (e.noCache !== !0) {
      const r = await this.cache.imageHashOfCounterfactualWallet(e);
      if (r) return r;
    }
    const n = await this.tracker.imageHashOfCounterfactualWallet(e);
    if (n) {
      const r = await this.configOfImageHash({
        imageHash: n.imageHash
      });
      r && await this.cache.saveCounterfactualWallet({
        config: r,
        context: [n.context]
      });
    }
    return n;
  }
  async saveCounterfactualWallet(e) {
    await Promise.all([this.tracker.saveCounterfactualWallet(e), this.cache.saveCounterfactualWallet(e)]);
  }
  async walletsOfSigner(e) {
    if (e.noCache)
      return this.tracker.walletsOfSigner(e);
    const n = await Promise.all([this.tracker.walletsOfSigner(e), this.cache.walletsOfSigner(e)]), r = /* @__PURE__ */ new Map();
    for (const s of n)
      for (const a of s)
        r.set(a.wallet, a);
    return Array.from(r.values());
  }
  async saveWitnesses(e) {
    await Promise.all([this.tracker.saveWitnesses(e), this.cache.saveWitnesses(e)]);
  }
  async getMigration(e, n, r, s) {
    const a = await this.cache.getMigration(e, n, r, s);
    if (a) return a;
    const i = await this.tracker.getMigration(e, n, r, s);
    return i && await this.cache.saveMigration(e, i, this.contexts), i;
  }
  async saveMigration(e, n, r) {
    await Promise.all([this.tracker.saveMigration(e, n, r), this.cache.saveMigration(e, n, r)]);
  }
}
class SE {
  constructor() {
    this.cache = void 0, this.cache = /* @__PURE__ */ new Map();
  }
  do(e, n, r, ...s) {
    e = `${e}:${Tr(JSON.stringify(s, hJ))}`;
    let a = this.cache.get(e);
    if (a && a.expiration && /* @__PURE__ */ new Date() >= a.expiration && (a = void 0, this.cache.delete(e)), !a) {
      const i = {
        promise: r(...s)
      };
      n !== void 0 && (i.promise = i.promise.then((o) => (i.expiration = new Date(Date.now() + n), o))), a = i, this.cache.set(e, a);
    }
    return a.promise;
  }
}
function hJ(t, e) {
  return typeof e == "object" && e !== null && !Array.isArray(e) ? Object.fromEntries(Object.entries(e).sort()) : typeof e == "bigint" ? e.toString() : e;
}
function mJ(t) {
  return t instanceof L3;
}
class L3 {
  constructor(e, n = 50, r = !1) {
    this.tracker = e, this.window = n, this.verbose = r, this.cache = new SE();
  }
  invalidateCache() {
    this.cache = new SE();
  }
  configOfImageHash(e) {
    return this.cache.do("configOfImageHash", this.window, (n) => this.tracker.configOfImageHash(n), e);
  }
  getMigration(e, n, r, s) {
    return this.cache.do("getMigration", this.window, (...a) => this.tracker.getMigration(...a), e, n, r, s);
  }
  saveMigration(e, n, r) {
    return this.cache.do("saveMigration", void 0, (...s) => this.tracker.saveMigration(...s), e, n, r);
  }
  loadPresignedConfiguration(e) {
    return this.cache.do("loadPresignedConfiguration", this.window, (n) => this.tracker.loadPresignedConfiguration(n), e);
  }
  savePresignedConfiguration(e) {
    return this.cache.do("savePresignedConfiguration", void 0, (n) => this.tracker.savePresignedConfiguration(n), e);
  }
  saveWitnesses(e) {
    return this.cache.do("saveWitnesses", void 0, (n) => this.tracker.saveWitnesses(n), e);
  }
  saveWalletConfig(e) {
    return this.cache.do("saveWalletConfig", void 0, (n) => this.tracker.saveWalletConfig(n), e);
  }
  imageHashOfCounterfactualWallet(e) {
    return this.cache.do("imageHashOfCounterfactualWallet", void 0, (n) => this.tracker.imageHashOfCounterfactualWallet(n), e);
  }
  saveCounterfactualWallet(e) {
    return this.cache.do("saveCounterfactualWallet", void 0, (n) => this.tracker.saveCounterfactualWallet(n), e);
  }
  walletsOfSigner(e) {
    return this.cache.do("walletsOfSigner", this.window, (n) => this.tracker.walletsOfSigner(n), e);
  }
  updateProvider(e) {
    this.tracker instanceof yg && this.tracker.updateProvider(e);
  }
}
var bJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arweave: XQ,
  debug: eJ,
  local: rJ,
  remote: dJ,
  stores: nJ,
  raceUntil: Tb,
  allSafe: cl,
  MultipleTracker: fJ,
  CachedTracker: pJ,
  isDedupedTracker: mJ,
  DedupedTracker: L3
});
const Gd = new bJ.remote.RemoteConfigTracker(
  "https://sessions.sequence.app"
);
function H3(t) {
  return q9.map((e) => {
    try {
      const n = e8(t.relayerConfig, e.chainId);
      if (n) {
        const r = {
          provider: new hy(e.rpcUrl),
          url: n,
          projectAccessKey: t.sequenceProjectAccessKey
        };
        return {
          ...e,
          relayer: r
        };
      }
    } catch {
    }
    return e;
  });
}
async function yJ(t, e, n, r) {
  const s = await ah.new({
    config: {
      threshold: t,
      // By default a random checkpoint is generated every second
      checkpoint: Math.floor(Date.now() / 1e3),
      signers: e
    },
    tracker: Gd,
    contexts: re.context.defaultContexts,
    orchestrator: new sh([]),
    networks: H3({ relayerConfig: n, sequenceProjectAccessKey: r })
  }), a = await Gd.imageHashOfCounterfactualWallet({
    wallet: s.address
  });
  if (!a)
    throw new Error("Failed to fetch imageHash from the tracker");
  if (!await Gd.configOfImageHash({
    imageHash: a.imageHash
  }))
    throw new Error("Failed to fetch config from the tracker");
  return s;
}
function $3(t) {
  return t.map(gJ);
}
function gJ(t) {
  return {
    to: t.to,
    value: t.value ? BigInt(t.value) : void 0,
    data: t.data,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    delegateCall: t.delegateCall || !1,
    revertOnError: t.revertOnError || !1
  };
}
function wJ(t) {
  const e = [];
  if (t.signatures)
    for (const { signer: n, signature: r } of t.signatures) {
      const s = Sb(r);
      s.length === 66 && (s[64] === 0 || s[64] === 1) && (s[64] = s[64] + 27), e.push(new kJ(n, X3(s)));
    }
  return console.log("signers", e), new ah({
    address: t.address,
    tracker: Gd,
    contexts: re.context.defaultContexts,
    orchestrator: new sh(e),
    networks: H3({
      relayerConfig: t.relayerConfig,
      sequenceProjectAccessKey: t.sequenceProjectAccessKey
    })
  });
}
function EJ(t) {
  return re.transaction.digestOfTransactions(
    re.transaction.encodeNonce(t.space, t.nonce),
    $3(t.transactions)
  );
}
function xJ(t) {
  const e = EJ(t);
  return re.signature.subdigestOf({
    digest: e,
    chainId: t.chainId,
    address: t.wallet
  });
}
async function AJ(t, e, n) {
  const r = t.address;
  return (await yJ(
    1,
    [{ address: r, weight: 1 }],
    e,
    n
  )).address;
}
async function vJ(t, e, n, r, s, a, i) {
  var U, L;
  const o = s.id;
  if (!((U = e == null ? void 0 : e.account) != null && U.address) || !t)
    throw new Error("Privy signer or sequence wallet address not available");
  const c = r.map(($) => ({
    to: $.to,
    data: $.data,
    value: $.value || "0",
    revertOnError: !0
  })), u = {
    wallet: t,
    space: Math.floor(Date.now()).toString(),
    nonce: "0",
    chainId: o.toString(),
    transactions: c
  }, l = xJ(u), d = Sb(l), h = `${await e.signMessage({
    account: e.account,
    message: { raw: d }
  })}02`, y = wJ({
    address: t,
    signatures: [
      {
        signer: (L = e.account) == null ? void 0 : L.address,
        signature: h
      }
    ],
    relayerConfig: a,
    sequenceProjectAccessKey: i
  }), b = $3(c), g = await y.status(o), w = y.walletForStatus(o, g);
  if (console.log("sequence wallet1", w), console.log("sequence wallet", w), !(await (n == null ? void 0 : n.getCode({
    address: w.address
  })) !== void 0)) {
    console.log("deploying sequence wallet");
    const $ = await w.buildDeployTransaction();
    if (!w.relayer) throw new Error("Wallet deploy requires a relayer");
    console.log("deploy Tx", $), console.log("deployTx entrypoint:", $.entrypoint), console.log("deployTx transactions:", $.transactions), console.log("getting fee options 0");
    const _ = await w.relayer.getFeeOptions(
      w.address,
      ...$.transactions
    ), R = _ == null ? void 0 : _.quote;
    if (console.log("feeOptions", _), (_ == null ? void 0 : _.options.length) === 0) {
      console.log("Deployment is whitelisted - no fees required");
      const M = new Uint8Array(32);
      crypto.getRandomValues(M), w.relayer.relay(
        {
          entrypoint: $.entrypoint,
          transactions: $.transactions,
          chainId: w.chainId,
          intent: {
            id: Ys(M),
            wallet: w.address
          }
        },
        R
      ), console.log("Deployment relayed"), await new Promise((j) => setTimeout(j, 6e3));
    } else {
      const M = _ == null ? void 0 : _.options[0];
      if (!M)
        throw new Error("fee option not found");
      if (console.log("option", M), M) {
        console.log("Using native token for deployment fee");
        const j = OE(M);
        console.log("Fee transactions:", j);
        const G = [...$.transactions];
        console.log("All transactions (deployment + fees):", G);
        const Z = await y.predecorateTransactions(
          G,
          g,
          o
        ), Y = await y.signTransactions(
          Z,
          o
        );
        console.log("signed transactions with fees:", Y.transactions), console.log("signed entrypoint with fees:", Y.entrypoint);
        const X = new Uint8Array(32);
        crypto.getRandomValues(X), w.relayer.relay(
          {
            entrypoint: $.entrypoint,
            transactions: $.transactions,
            chainId: w.chainId,
            intent: {
              id: Ys(X),
              wallet: w.address
            }
          },
          R
        ), await new Promise((le) => setTimeout(le, 6e3)), console.log("sequence wallet deployed");
      } else
        throw new Error(
          "ERC20 fee payment for deployment is not supported yet. Please use native token or a relayer with free wallet deployments."
        );
    }
  }
  console.log("getting fee options 1");
  const P = await w.relayer.getFeeOptions(
    w.address,
    ...b
  ), x = P == null ? void 0 : P.options.find(
    ($) => $.token.symbol === "USDC"
  ), O = P == null ? void 0 : P.quote, I = OE(x);
  console.log("Fee transactions:", I);
  const T = await w.signTransactions(
    [...I, ...b],
    re.transaction.encodeNonce(u.space, u.nonce)
  ), N = await y.relayer(o).relay(T, O);
  return (N == null ? void 0 : N.hash) || null;
}
class kJ {
  constructor(e, n) {
    F(this, "signatureBytes");
    F(this, "savedSuffix");
    this.address = e, this.signature = n;
    const r = Sb(this.signature);
    this.savedSuffix = r.slice(-1), this.signatureBytes = r.slice(0, -1);
  }
  async buildDeployTransaction() {
  }
  async predecorateSignedTransactions() {
    return [];
  }
  async decorateTransactions(e) {
    return e;
  }
  async sign() {
    return this.signatureBytes;
  }
  notifyStatusChange() {
  }
  suffix() {
    return this.savedSuffix;
  }
  async getAddress() {
    return this.address;
  }
}
async function CJ(t, e, n, r) {
  return await t.feeOptions(
    e,
    BigInt(n),
    r
  );
}
function OE(t) {
  if (!t) return [];
  const e = BigInt(t.value);
  switch (t.token.type) {
    case "UNKNOWN":
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.to,
          value: e.toString(),
          data: "0x"
        }
      ];
    case "ERC20_TOKEN": {
      if (!t.token.contractAddress)
        throw new Error("No contract address for ERC-20 fee option");
      const [n] = p5([
        {
          inputs: [{ type: "address" }, { type: "uint256" }],
          name: "transfer",
          outputs: [{ type: "bool" }],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]);
      return [
        {
          delegateCall: !1,
          revertOnError: !0,
          gasLimit: t.gasLimit,
          to: t.token.contractAddress,
          value: 0,
          data: qx(n, [
            t.to,
            e
          ])
        }
      ];
    }
    default:
      throw new Error(`Unhandled fee token type ${t.token.type}`);
  }
}
async function TJ(t, e, n) {
  return Promise.race([
    t.request(...e),
    new Promise(
      (r, s) => setTimeout(() => s(new Error("Request timed out")), n)
    )
  ]);
}
function _3(t, e) {
  return (t == null ? void 0 : t.toString()) === (e == null ? void 0 : e.toString());
}
function G3(t, e) {
  return (t == null ? void 0 : t.toLowerCase()) === (e == null ? void 0 : e.toLowerCase());
}
function iX(t, e, n, r) {
  return _3(t, n) && G3(e, r);
}
function SJ() {
  return jj("testnet") === "true";
}
function OJ() {
  return "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
}
function BJ(t, e, n, r, s, a, i, o, c, u) {
  const l = u || (a === Ye ? "0x" : Dy(c, BigInt(i)));
  return {
    userAddress: t,
    originChainId: e,
    originTokenAddress: n,
    originTokenAmount: n === a ? i : r,
    // max amount
    destinationChainId: s,
    destinationToAddress: u || a === Ye ? c : a,
    destinationTokenAddress: a,
    destinationTokenAmount: i,
    destinationTokenSymbol: o,
    destinationCallData: l,
    destinationCallValue: a === Ye ? i : "0"
  };
}
async function oX(t) {
  const {
    account: e,
    originTokenAddress: n,
    originChainId: r,
    originTokenAmount: s,
    // account balance
    destinationChainId: a,
    recipient: i,
    destinationTokenAddress: o,
    destinationTokenAmount: c,
    destinationTokenSymbol: u,
    fee: l,
    client: d,
    dryMode: f = !1,
    apiClient: h,
    originRelayer: y,
    destinationRelayer: b,
    destinationCalldata: g,
    onTransactionStateChange: w,
    sourceTokenPriceUsd: v,
    destinationTokenPriceUsd: A,
    sourceTokenDecimals: P,
    destinationTokenDecimals: x,
    paymasterUrl: O,
    gasless: I = !1,
    relayerConfig: T,
    sequenceProjectAccessKey: C
  } = t;
  if (!d)
    throw new Error("Wallet client not provided");
  const N = uz(r);
  if (!N)
    throw new Error(`Chain ${r} not found`);
  const U = _3(r, a), L = G3(
    n,
    o
  );
  console.log("isToSameChain", U), console.log("isToSameToken", L);
  const $ = uu({
    chain: N,
    transport: Zt()
  }), _ = e.address, R = [];
  return R.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending"
  }), U || (R.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: r,
    state: "pending"
  }), R.push({
    transactionHash: "",
    explorerUrl: "",
    chainId: a,
    state: "pending"
  })), U && !L ? await UJ({
    originTokenAddress: n,
    destinationTokenAmount: c,
    destinationTokenAddress: o,
    destinationCalldata: g,
    recipient: i,
    originChainId: r,
    walletClient: d,
    publicClient: $
  }) : L && U ? await IJ({
    originTokenAddress: n,
    destinationTokenAmount: c,
    destinationCalldata: g,
    recipient: i,
    originChainId: r,
    walletClient: d,
    publicClient: $,
    onTransactionStateChange: w,
    dryMode: f,
    account: e,
    chain: N
  }) : await PJ({
    mainSignerAddress: _,
    originChainId: r,
    originTokenAddress: n,
    originTokenAmount: s,
    destinationChainId: a,
    destinationTokenAddress: o,
    destinationTokenAmount: c,
    destinationTokenSymbol: u,
    recipient: i,
    destinationCalldata: g,
    apiClient: h,
    sourceTokenPriceUsd: v,
    destinationTokenPriceUsd: A,
    sourceTokenDecimals: P,
    destinationTokenDecimals: x,
    gasless: I,
    paymasterUrl: O,
    originRelayer: y,
    destinationRelayer: b,
    sequenceProjectAccessKey: C,
    relayerConfig: T,
    walletClient: d,
    publicClient: $,
    chain: N,
    account: e,
    fee: l,
    dryMode: f,
    onTransactionStateChange: w,
    transactionStates: R
  });
}
async function PJ({
  mainSignerAddress: t,
  originChainId: e,
  originTokenAddress: n,
  originTokenAmount: r,
  destinationChainId: s,
  destinationTokenAddress: a,
  destinationTokenAmount: i,
  destinationTokenSymbol: o,
  recipient: c,
  destinationCalldata: u,
  apiClient: l,
  sourceTokenPriceUsd: d,
  destinationTokenPriceUsd: f,
  sourceTokenDecimals: h,
  destinationTokenDecimals: y,
  gasless: b,
  paymasterUrl: g,
  originRelayer: w,
  destinationRelayer: v,
  sequenceProjectAccessKey: A,
  relayerConfig: P,
  walletClient: x,
  publicClient: O,
  chain: I,
  account: T,
  fee: C,
  dryMode: N,
  onTransactionStateChange: U,
  transactionStates: L
}) {
  var Z, Y, X, le, J, ce, te;
  const $ = BJ(
    t,
    e,
    n,
    r,
    s,
    a,
    i,
    o,
    c,
    u
  );
  console.log("Creating intent with args:", $);
  const _ = await pz(l, $);
  if (console.log("Got intent:", _), !_)
    throw new Error("Invalid intent");
  if (!((Z = _.preconditions) != null && Z.length) || !((Y = _.calls) != null && Y.length) || !((X = _.anypayInfos) != null && X.length))
    throw new Error("Invalid intent");
  const R = Qv(
    t,
    _.calls,
    _.anypayInfos,
    (le = _.anypayFee) == null ? void 0 : le.quoteProvider
  );
  console.log("Calculated intent address:", R.toString()), await hz(
    l,
    t,
    _.calls,
    _.preconditions,
    _.anypayInfos,
    (J = _.anypayFee) == null ? void 0 : J.quoteProvider
  ), console.log("Committed intent config");
  const M = fz(
    _.preconditions,
    e
  );
  if (!M)
    throw new Error("No precondition found for origin chain");
  const j = (te = (ce = M == null ? void 0 : M.data) == null ? void 0 : ce.min) == null ? void 0 : te.toString(), G = j;
  return {
    intentAddress: R,
    originSendAmount: G,
    send: async (ae) => {
      console.log("sending origin transaction");
      const he = z3({
        originTokenAddress: n,
        destinationTokenAmount: i,
        destinationTokenDecimals: y,
        sourceTokenDecimals: h,
        sourceTokenPriceUsd: d ?? null,
        destinationTokenPriceUsd: f ?? null,
        depositAmount: G
      });
      console.log("needsNativeFee", he), console.log("sourceTokenPriceUsd", d), console.log("destinationTokenPriceUsd", f), console.log("sourceTokenDecimals", h), console.log("destinationTokenDecimals", y);
      let Oe = null, De = null, ze = null;
      const at = SJ(), mn = OJ();
      if (console.log("testnet", at), Oe = await FJ({
        originTokenAddress: at ? mn : n,
        gasless: b,
        paymasterUrl: g,
        chain: at ? Sv : I,
        account: T,
        relayerConfig: P,
        sequenceProjectAccessKey: A,
        originRelayer: w,
        firstPreconditionMin: j,
        intentAddress: R,
        onOriginSend: ae,
        publicClient: O,
        walletClient: x,
        destinationTokenDecimals: y,
        sourceTokenDecimals: h,
        fee: C,
        dryMode: N,
        sourceTokenPriceUsd: d ?? null,
        destinationTokenPriceUsd: f ?? null,
        destinationTokenAmount: i
      }), !Oe)
        throw new Error("Failed to send origin transaction");
      return L[0] = zd(
        Oe,
        e
      ), U(L), _.metaTxns[0] && _.preconditions[0] && (De = await BE({
        metaTx: _.metaTxns[0],
        relayer: w,
        precondition: _.preconditions[0]
      }), De && (L[1] = zd(
        De,
        e
      ), U(L))), _.metaTxns[1] && _.preconditions[1] && (ze = await BE({
        metaTx: _.metaTxns[1],
        relayer: v,
        precondition: _.preconditions[1]
      }), ze && (L[2] = zd(
        ze,
        s
      ), U(L))), {
        originUserTxReceipt: Oe,
        originMetaTxnReceipt: De,
        destinationMetaTxnReceipt: ze
      };
    }
  };
}
async function IJ({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationCalldata: n,
  recipient: r,
  originChainId: s,
  walletClient: a,
  publicClient: i,
  onTransactionStateChange: o,
  dryMode: c,
  account: u,
  chain: l
}) {
  return console.log("isToSameToken && isToSameChain"), {
    originSendAmount: e,
    send: async (d) => {
      const f = {
        to: n || t === Ye ? r : t,
        data: n || (t === Ye ? "0x" : Dy(r, BigInt(e))),
        value: t === Ye ? BigInt(e) : "0",
        chainId: s,
        chain: l
      };
      console.log("origin call params", f);
      let h = null;
      const y = null, b = null;
      if (await ku(a, s), !c) {
        o([
          {
            transactionHash: "",
            explorerUrl: "",
            chainId: s,
            state: "pending"
          }
        ]), console.log("origin call params", f);
        const g = await R0(
          u,
          a,
          f
        );
        console.log("origin tx", g), d && d();
        const w = await i.waitForTransactionReceipt({
          hash: g
        });
        console.log("receipt", w), h = w, o([
          zd(h, s)
        ]);
      }
      return {
        originUserTxReceipt: h,
        originMetaTxnReceipt: y,
        destinationMetaTxnReceipt: b
      };
    }
  };
}
async function UJ({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationTokenAddress: n,
  destinationCalldata: r,
  recipient: s,
  originChainId: a,
  walletClient: i,
  publicClient: o
}) {
  var d, f, h, y, b, g, w, v, A, P;
  const c = [];
  r && c.push({
    to: s,
    value: n === Ye ? e : "0",
    data: r
  });
  const u = await Xq({
    wallet: i,
    chainId: a,
    amount: e,
    currency: t,
    toCurrency: n,
    txs: c
  });
  console.log("relaysdk quote", u);
  let l = "0";
  try {
    if (l = (b = (y = (h = (f = (d = u.steps) == null ? void 0 : d[0]) == null ? void 0 : f.items) == null ? void 0 : h[0]) == null ? void 0 : y.data) == null ? void 0 : b.value, t !== Ye) {
      const x = rm({
        abi: Y3,
        data: (P = (A = (v = (w = (g = u.steps) == null ? void 0 : g[0]) == null ? void 0 : w.items) == null ? void 0 : v[0]) == null ? void 0 : A.data) == null ? void 0 : P.data
      });
      x.functionName === "approve" && (l = x.args[1].toString()), x.functionName === "transfer" && (l = x.args[1].toString());
    }
  } catch (x) {
    console.error("Error decoding function data:", x);
  }
  return {
    originSendAmount: l,
    send: async (x) => {
      await ku(i, a);
      const O = await eW(u, i);
      console.log("relaysdk result", O);
      const I = tW(O);
      return x && x(), {
        originUserTxReceipt: await o.waitForTransactionReceipt({
          hash: I
        }),
        originMetaTxnReceipt: null,
        destinationMetaTxnReceipt: null
      };
    }
  };
}
async function NJ({
  paymasterUrl: t,
  depositTokenAddress: e,
  depositTokenAmount: n,
  depositRecipient: r,
  onOriginSend: s,
  publicClient: a,
  walletClient: i,
  chain: o,
  account: c,
  relayerConfig: u,
  sequenceProjectAccessKey: l,
  originRelayer: d
}) {
  let f = null;
  const h = o.id;
  if (t) {
    console.log("doing gasless with paymaster");
    const y = await zj(
      i,
      o,
      e,
      BigInt(n),
      r,
      t
    );
    s && s();
    const b = await a.waitForTransactionReceipt({
      hash: y
    });
    console.log("receipt", b), f = b;
  } else {
    console.log("doing gasless with sequence wallet");
    const y = t8(), b = df(y), g = Df({
      account: b,
      chain: o,
      transport: Zt()
    });
    console.log("attempting to switch chain"), await ku(i, h), console.log("creating sequence wallet");
    const w = await AJ(
      b,
      u,
      l
    );
    console.log("sequenceWalletAddress", w);
    const v = uu({
      chain: o,
      transport: Zt()
    }), { signature: A, deadline: P } = await b8(
      v,
      i,
      c.address,
      w,
      e,
      BigInt(n),
      o
    ), x = oV(
      c.address,
      w,
      BigInt(n),
      P,
      A,
      r,
      e
    ), O = await CJ(
      d,
      w,
      h,
      x.map((C) => ({
        to: C.to,
        value: BigInt(C.value),
        data: C.data,
        gasLimit: BigInt(0),
        delegateCall: !1,
        onlyFallback: !1,
        behaviorOnError: "revert"
      }))
    );
    console.log("feeOptions", O);
    const I = await vJ(
      w,
      g,
      v,
      x,
      o,
      u,
      l
    );
    console.log("sequenceTxHash", I), s && s();
    const T = await a.waitForTransactionReceipt({
      hash: I
    });
    console.log("receipt", T), f = T;
  }
  return f;
}
async function RJ({
  originTokenAddress: t,
  firstPreconditionMin: e,
  onOriginSend: n,
  publicClient: r,
  walletClient: s,
  originChainId: a,
  chain: i,
  account: o,
  fee: c,
  dryMode: u,
  sourceTokenPriceUsd: l,
  destinationTokenPriceUsd: d,
  destinationTokenAmount: f,
  destinationTokenDecimals: h,
  sourceTokenDecimals: y,
  intentAddress: b
}) {
  var O, I;
  let g = null;
  const w = await z3({
    originTokenAddress: t,
    destinationTokenAmount: f,
    destinationTokenDecimals: h,
    sourceTokenDecimals: y,
    sourceTokenPriceUsd: l ?? null,
    destinationTokenPriceUsd: d ?? null,
    depositAmount: e
  });
  let v = Dg("0.00005", 18).toString();
  a === 137 && (v = Dg("1.5", 18).toString()), console.log("needsNativeFee", w);
  const A = {
    to: t === Ye ? b : t,
    data: t === Ye ? "0x" : Dy(
      b,
      BigInt(e) + BigInt(c)
    ),
    value: t === Ye ? BigInt(e) + BigInt(c) : "0",
    chain: i
  };
  await ku(s, a);
  let P = !1;
  if (w)
    try {
      const T = await TJ(
        s,
        [
          {
            method: "wallet_getCapabilities",
            params: [o.address]
          }
        ],
        1e4
      );
      console.log("capabilities", T);
      const C = `0x${a.toString(16)}`, N = T[C];
      P = ((O = N == null ? void 0 : N.atomic) == null ? void 0 : O.status) === "supported";
    } catch (T) {
      console.error("Error getting capabilities", T);
    }
  if (u && console.log("dry mode, skipping send calls"), console.log(P ? "using sendCalls" : "using sendTransaction"), P) {
    if (!u) {
      const T = [];
      w && T.push({
        to: b,
        data: "0x00",
        value: `0x${BigInt(v).toString(16)}`
      }), T.push({
        to: A.to,
        data: A.data,
        value: A.value ? `0x${BigInt(A.value).toString(16)}` : "0x0"
      });
      const C = await s.request({
        method: "wallet_sendCalls",
        params: [
          {
            version: "2.0.0",
            chainId: `0x${a.toString(16)}`,
            atomicRequired: !0,
            calls: T
          }
        ]
      });
      console.log("sendCalls result", C);
      const N = C.requestId || C.id;
      let U;
      for (; !U; ) {
        const $ = await s.request({
          method: "wallet_getCallsStatus",
          params: [N]
        });
        console.log("getCallsStatus result", $);
        const _ = (I = $ == null ? void 0 : $.receipts) == null ? void 0 : I[0];
        if ($.status === 200 && (_ != null && _.transactionHash)) {
          U = _.transactionHash;
          break;
        } else if ($.status === 500)
          throw new Error(`Transaction failed: ${$.error}`);
        await new Promise((R) => setTimeout(R, 2e3));
      }
      n && n();
      const L = await r.waitForTransactionReceipt({
        hash: U
      });
      console.log("receipt", L), g = L;
    }
  } else if (!u) {
    if (w) {
      const N = await R0(o, s, {
        to: b,
        data: "0x00",
        value: v,
        chain: i
      });
      console.log("origin tx", N);
      const U = await r.waitForTransactionReceipt({
        hash: N
      });
      console.log("nativeFeeReceipt", U);
    }
    const T = await R0(
      o,
      s,
      A
    );
    console.log("origin tx", T), n && n();
    const C = await r.waitForTransactionReceipt({
      hash: T
    });
    console.log("receipt", C), g = C;
  }
  return g;
}
async function FJ({
  originTokenAddress: t,
  gasless: e,
  paymasterUrl: n,
  chain: r,
  account: s,
  relayerConfig: a,
  sequenceProjectAccessKey: i,
  originRelayer: o,
  firstPreconditionMin: c,
  intentAddress: u,
  onOriginSend: l,
  publicClient: d,
  walletClient: f,
  destinationTokenDecimals: h,
  sourceTokenDecimals: y,
  fee: b,
  dryMode: g,
  sourceTokenPriceUsd: w,
  destinationTokenPriceUsd: v,
  destinationTokenAmount: A
}) {
  let P = null;
  const x = r.id, O = MJ(t, e, n);
  if (console.log("doGasless", O, n), O)
    try {
      P = await NJ({
        paymasterUrl: n,
        depositTokenAddress: t,
        depositTokenAmount: c,
        depositRecipient: u,
        onOriginSend: l,
        publicClient: d,
        walletClient: f,
        chain: r,
        account: s,
        relayerConfig: a,
        sequenceProjectAccessKey: i,
        originRelayer: o
      });
    } catch (I) {
      console.log("gassless attempt failed", I);
    }
  return P || (P = await RJ({
    originTokenAddress: t,
    firstPreconditionMin: c,
    intentAddress: u,
    onOriginSend: l,
    publicClient: d,
    walletClient: f,
    originChainId: x,
    chain: r,
    account: s,
    fee: b,
    dryMode: g,
    sourceTokenPriceUsd: w,
    destinationTokenPriceUsd: v,
    destinationTokenAmount: A,
    destinationTokenDecimals: h,
    sourceTokenDecimals: y
  })), P;
}
function MJ(t, e, n) {
  return t !== Ye && (e || n);
}
function zd(t, e) {
  let n = "", r = "pending";
  return "transactionHash" in t ? (n = t.transactionHash, r = t.status === "success" ? "confirmed" : "failed") : "txnHash" in t && (n = t.txnHash, r = t.status === "SUCCEEDED" ? "confirmed" : "failed"), {
    transactionHash: n,
    explorerUrl: rV(n, e),
    chainId: e,
    state: r
  };
}
async function BE({
  metaTx: t,
  relayer: e,
  precondition: n
}) {
  var a;
  let r = null;
  console.log("metaTx", t);
  const s = await Lz(e, t, [n]);
  for (console.log("opHash", s); ; ) {
    console.log(
      "polling status",
      t.id,
      BigInt(t.chainId)
    );
    const i = await Ez(
      e,
      t.id,
      Number(t.chainId)
    );
    if (console.log("status", i), i != null && i.transactionHash) {
      r = (a = i.data) == null ? void 0 : a.receipt;
      break;
    }
    await new Promise((o) => setTimeout(o, 1e3));
  }
  return r;
}
function z3({
  originTokenAddress: t,
  destinationTokenAmount: e,
  destinationTokenDecimals: n,
  sourceTokenDecimals: r,
  sourceTokenPriceUsd: s,
  destinationTokenPriceUsd: a,
  depositAmount: i
}) {
  let o = !1;
  if (t !== Ye && s && a && i && n !== void 0 && r !== void 0) {
    const c = Number(
      sm(BigInt(e), n)
    ), u = Number(
      sm(BigInt(i), n)
    );
    console.log("destinationAmount", c), console.log("depositAmountFormatted", u);
    const l = c * a, d = u * s, f = d - l;
    console.log(
      "destinationAmountUsd",
      l,
      "depositAmountUsd",
      d,
      "diff",
      f
    ), f >= 0 && f <= 0.02 && (o = !0);
  }
  return o;
}
const DJ = async (t, e) => {
  if (e.length === 0)
    return [];
  const n = await t.getCoinPrices({ tokens: e });
  return (n == null ? void 0 : n.tokenPrices) || [];
}, LJ = (t, e) => Sm({
  queryKey: ["coinPrices", t],
  queryFn: () => DJ(e, t),
  retry: !0,
  staleTime: 6e4,
  enabled: t.length > 0
}), HJ = { page: 1, pageSize: 10, more: !1 };
function ji(t) {
  return !("contractAddress" in t);
}
function $J(t, e) {
  const n = t.balanceUsd ?? 0, r = e.balanceUsd ?? 0;
  if (n !== r)
    return r - n;
  if (ji(t) && !ji(e)) return -1;
  if (!ji(t) && ji(e)) return 1;
  try {
    const s = BigInt(t.balance), a = BigInt(e.balance);
    if (s > a) return -1;
    if (s < a) return 1;
  } catch {
    return 0;
  }
  return 0;
}
function cX(t, e, n) {
  const r = e ?? Dz(), s = n ?? lz(), {
    data: a,
    isLoading: i,
    error: o
  } = Sm({
    queryKey: ["tokenBalances", t],
    queryFn: async () => {
      if (!t)
        return console.warn("No account address or indexer client"), {
          balances: [],
          nativeBalances: [],
          page: HJ
        };
      try {
        const f = await r.getTokenBalancesSummary({
          filter: {
            accountAddresses: [t],
            contractStatus: yS.VERIFIED,
            contractTypes: ["ERC20"],
            omitNativeBalances: !1
          }
        });
        return {
          page: f.page,
          balances: f.balances.flatMap((h) => h.results),
          nativeBalances: f.nativeBalances.flatMap(
            (h) => h.results
          )
        };
      } catch (f) {
        throw console.error("Failed to fetch token balances:", f), f;
      }
    },
    enabled: !!t,
    staleTime: 3e4,
    retry: 1
  }), { data: c, isLoading: u } = LJ(
    ((a == null ? void 0 : a.balances) ?? []).map((f) => {
      var h, y;
      return {
        tokenId: (h = f.contractInfo) == null ? void 0 : h.symbol,
        contractAddress: f.contractAddress,
        chainId: (y = f.contractInfo) == null ? void 0 : y.chainId
      };
    }).concat(
      ((a == null ? void 0 : a.nativeBalances) ?? []).map((f) => ({
        tokenId: f.symbol,
        contractAddress: Ye,
        chainId: f.chainId
      }))
    ) ?? [],
    s
  ), { data: l = [], isLoading: d } = Sm({
    queryKey: ["sortedTokens", a, c],
    queryFn: () => !a || !c ? [] : [
      ...a.nativeBalances,
      ...a.balances
    ].filter((y) => {
      try {
        return BigInt(y.balance) > 0n;
      } catch {
        return !1;
      }
    }).map((y) => {
      const b = ji(y), g = c.find(
        (w) => {
          var v;
          return w.token.contractAddress === (b ? Ye : y.contractAddress) && w.token.chainId === (b ? y.chainId : (v = y.contractInfo) == null ? void 0 : v.chainId);
        }
      );
      if (g != null && g.price) {
        const w = { ...y, price: g.price };
        return w.balanceUsd = V3(
          y,
          g.price
        ), w.balanceUsdFormatted = j3(
          y,
          g.price
        ), w;
      }
      return y;
    }).sort($J),
    enabled: !i && !u && !!a && !!c
  });
  return {
    tokenBalancesData: a,
    isLoadingBalances: i,
    isLoadingPrices: u,
    isLoadingSortedTokens: d || i || u,
    balanceError: o,
    sortedTokens: l
  };
}
async function _J() {
  return [
    "ETH",
    "WETH",
    "USDC",
    "USDT",
    "DAI",
    "OP",
    "ARB",
    "MATIC",
    "XDAI",
    "AVAX",
    "BNB",
    "OKB",
    "BAT",
    "ARB"
  ];
}
function lX() {
  const [t, e] = Lf([]);
  return Ob(() => {
    _J().then(e);
  }, []), t;
}
function GJ(t, e = 18) {
  try {
    const n = sm(BigInt(t), e), r = parseFloat(n);
    return r === 0 ? "0" : r < 1e-4 ? r.toExponential(2) : r < 1 ? r.toFixed(6) : r < 1e3 ? r.toFixed(4) : r.toLocaleString(void 0, { maximumFractionDigits: 2 });
  } catch (n) {
    return console.error("Error formatting balance:", n), t;
  }
}
function V3(t, e) {
  var a;
  const n = ji(t), r = GJ(
    t.balance,
    n ? 18 : (a = t.contractInfo) == null ? void 0 : a.decimals
  ), s = Number(e.value) ?? 0;
  return Number(r) * s;
}
function j3(t, e) {
  const n = V3(t, e);
  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD"
  }).format(n);
}
function uX(t, e) {
  const [n, r] = Lf("");
  return Ob(() => {
    const s = j3(t, e);
    r(s);
  }, [t, e]), n;
}
export {
  $J as $,
  IZ as A,
  RZ as B,
  FZ as C,
  iz as D,
  MZ as E,
  Mz as F,
  Dz as G,
  hz as H,
  R0 as I,
  DZ as J,
  mz as K,
  bz as L,
  yz as M,
  Ez as N,
  Lz as O,
  fz as P,
  _3 as Q,
  G3 as R,
  $f as S,
  iX as T,
  oX as U,
  RJ as V,
  MJ as W,
  DJ as X,
  LJ as Y,
  e8 as Z,
  Fz as _,
  nc as a,
  PZ as a$,
  cX as a0,
  _J as a1,
  lX as a2,
  GJ as a3,
  V3 as a4,
  j3 as a5,
  uX as a6,
  iC as a7,
  rZ as a8,
  YJ as a9,
  Rd as aA,
  o2 as aB,
  vu as aC,
  aZ as aD,
  EZ as aE,
  _l as aF,
  Py as aG,
  bc as aH,
  BZ as aI,
  Nv as aJ,
  D as aK,
  Dv as aL,
  Pi as aM,
  Ry as aN,
  OZ as aO,
  SZ as aP,
  Ws as aQ,
  Rn as aR,
  uf as aS,
  _M as aT,
  KM as aU,
  $Z as aV,
  NM as aW,
  Rv as aX,
  BV as aY,
  x8 as aZ,
  Ct as a_,
  sZ as aa,
  eZ as ab,
  cC as ac,
  nZ as ad,
  tZ as ae,
  GE as af,
  zE as ag,
  Qi as ah,
  XJ as ai,
  Bb as aj,
  dm as ak,
  aC as al,
  JJ as am,
  ZJ as an,
  Bl as ao,
  K5 as ap,
  Se as aq,
  TZ as ar,
  He as as,
  sa as at,
  _Z as au,
  rV as av,
  ml as aw,
  hl as ax,
  bl as ay,
  pl as az,
  lC as b,
  lz as c,
  HZ as d,
  Qv as e,
  Sm as f,
  bC as g,
  om as h,
  si as i,
  Dy as j,
  LZ as k,
  uz as l,
  ku as m,
  mi as n,
  Rz as o,
  dz as p,
  pz as q,
  cz as r,
  cm as s,
  sz as t,
  ZE as u,
  Wv as v,
  UZ as w,
  az as x,
  NZ as y,
  oz as z
};
